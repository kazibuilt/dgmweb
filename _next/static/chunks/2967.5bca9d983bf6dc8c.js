"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2967],{38047:(n,e,t)=>{t.d(e,{Z:()=>r});var o=t(15791);let r=function(n){(0,o.useEffect)(n,[])}},9897:(n,e,t)=>{t.d(e,{Z:()=>v});var o=t(15791),r=t(38047);let i=function(n){var e=(0,o.useRef)(n);e.current=n,(0,r.Z)(function(){return function(){return e.current()}})},a=function(n){var e=(0,o.useRef)(0),t=(0,o.useState)(n),r=t[0],a=t[1],c=(0,o.useCallback)(function(n){cancelAnimationFrame(e.current),e.current=requestAnimationFrame(function(){a(n)})},[]);return i(function(){cancelAnimationFrame(e.current)}),[r,c]};var c=t(40024);let v=function(n,e){void 0===n&&(n=1/0),void 0===e&&(e=1/0);var t=a({width:c.jU?window.innerWidth:n,height:c.jU?window.innerHeight:e}),r=t[0],i=t[1];return(0,o.useEffect)(function(){if(c.jU){var n=function(){i({width:window.innerWidth,height:window.innerHeight})};return(0,c.on)(window,"resize",n),function(){(0,c.S1)(window,"resize",n)}}},[]),r}},71993:(n,e,t)=>{t.d(e,{C2:()=>i,Lq:()=>u,Vw:()=>l,em:()=>c,r8:()=>s,ui:()=>a,xR:()=>v});var o=t(88384),r=t(84391);let i=document.createElement("canvas");i.width=0,i.height=0;let a=new o.T({antialias:!1,powerPreference:"high-performance",canvas:i,width:i.width,height:i.height}),c={x:0,y:0,get width(){return i.width*a.dpr},get height(){return i.height*a.dpr}};a.gl.scissor(c.x,c.y,c.width,c.height),a.gl.enable(a.gl.SCISSOR_TEST);let v=a.gl;v.clearColor(250/255,245/255,242/255,1);let s=new r.V(v,{fov:75,aspect:i.width/i.height,far:1e3}),l=new r.V(v,{fov:75,aspect:i.width/i.height,far:2e3}),u=700;l.position.set(0,0,u)},88957:(n,e,t)=>{t.d(e,{D:()=>o});let o="\nfloat valueRemap(float value, float inMin, float inMax, float outMin, float outMax) {\n  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n}\n"},92967:(n,e,t)=>{t.r(e),t.d(e,{default:()=>p});var o=t(69797),r=t(84241),i=t(77726),a=t(22550),c=t(15791),v=t(42983),s=t(26558),l=t(71993),u=t(88957),x=t(41199),f=t(98625),m=t(9897);let d=(0,c.forwardRef)((n,e)=>{let{scissorRef:t}=n,a=(0,v.Cp)(n=>n.size.width),s=(0,v.Cp)(n=>n.size.height),x=(0,v.Cp)(n=>n.renderer.dpr),f=(0,m.Z)(),d=(0,r.M4)("Footer Shader",{step1Min:{value:.25,min:0,max:1},step1Max:{value:.45,min:0,max:1},noise1XFactor:{value:.5,min:0,max:1},noise1YFactor:{value:1,min:0,max:1},noise2XFactor:{value:.5,min:0,max:1},noise2YFactor:{value:1,min:0,max:1},timeFactor:{value:.3,min:0,max:1}}),p=(0,c.useMemo)(()=>new i.$(l.xR,{vertex:"#version 300 es\n        precision highp float;\n\n        in vec4 position;\n        in vec2 uv;\n\n        uniform vec2 offset;\n        uniform float top;\n        out vec2 vUv;\n\n        void main() {\n          vUv = uv;\n          vUv.y += top;\n          gl_Position = position;\n        }\n      ",fragment:"#version 300 es\n        precision mediump float;\n\n        out vec4 fragColor;\n\n        uniform float time;\n        uniform float timeFactor;\n        uniform vec2 resolution;\n        uniform float step1Min;\n        uniform float step1Max;\n        uniform float step2Min;\n        uniform float step2Max;\n        uniform float noise1XFactor;\n        uniform float noise1YFactor;\n        uniform float noise2XFactor;\n        uniform float noise2YFactor;\n\n        in vec2 vUv;\n\n        float blendOverlay(float base, float blend) {\n          return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n        }\n\n        vec3 blendOverlay(vec3 base, vec3 blend) {\n          return vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n        }\n\n        vec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n          return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n        }\n\n        vec3 brightnessContrast(vec3 value, float brightness, float contrast) {\n          return (value - 0.5) * contrast + 0.5 + brightness;\n        }\n\n        float random(in vec2 st) {\n          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n        }\n\n        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\n        vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n        float snoise(vec3 v){ \n          const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n          // First corner\n            vec3 i  = floor(v + dot(v, C.yyy) );\n            vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n          // Other corners\n            vec3 g = step(x0.yzx, x0.xyz);\n            vec3 l = 1.0 - g;\n            vec3 i1 = min( g.xyz, l.zxy );\n            vec3 i2 = max( g.xyz, l.zxy );\n\n            //  x0 = x0 - 0. + 0.0 * C \n            vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n            vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n            vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n          // Permutations\n            i = mod(i, 289.0 ); \n            vec4 p = permute( permute( permute( \n                      i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n          // Gradients\n          // ( N*N points uniformly over a square, mapped onto an octahedron.)\n          float n_ = 1.0/7.0; // N=7\n          vec3  ns = n_ * D.wyz - D.xzx;\n\n          vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n          vec4 x_ = floor(j * ns.z);\n          vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n          vec4 x = x_ *ns.x + ns.yyyy;\n          vec4 y = y_ *ns.x + ns.yyyy;\n          vec4 h = 1.0 - abs(x) - abs(y);\n\n          vec4 b0 = vec4( x.xy, y.xy );\n          vec4 b1 = vec4( x.zw, y.zw );\n\n          vec4 s0 = floor(b0)*2.0 + 1.0;\n          vec4 s1 = floor(b1)*2.0 + 1.0;\n          vec4 sh = -step(h, vec4(0.0));\n\n          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n          vec3 p0 = vec3(a0.xy,h.x);\n          vec3 p1 = vec3(a0.zw,h.y);\n          vec3 p2 = vec3(a1.xy,h.z);\n          vec3 p3 = vec3(a1.zw,h.w);\n\n        //Normalise gradients\n          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n          p0 *= norm.x;\n          p1 *= norm.y;\n          p2 *= norm.z;\n          p3 *= norm.w;\n\n        // Mix final noise value\n          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n          m = m * m;\n          return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                        dot(p2,x2), dot(p3,x3) ) );\n        }\n\n        //  Function from I\xf1igo Quiles\n        //  https://www.shadertoy.com/view/MsS3Wc\n        vec3 hsb2rgb( in vec3 c ){\n            vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                                    6.0)-3.0)-1.0,\n                            0.0,\n                            1.0 );\n            rgb = rgb*rgb*(3.0-2.0*rgb);\n            return c.z * mix(vec3(1.0), rgb, c.y);\n        }\n\n        ".concat(u.D,"\n\n        void main() {\n          vec2 uv = vUv * 1.1;\n          float t = time * 0.25 * timeFactor;\n\n          float n =\n            valueRemap(snoise(\n              vec3(\n                uv.x * noise1XFactor + t * 0.75,\n                (uv.y + sin(uv.x + t) * 0.25) * noise1YFactor,\n                t\n              )\n            ), -1., 1., -0.25, 1.);\n\n          float n2 =\n            valueRemap(snoise(\n              vec3(\n                uv.x * noise2XFactor - t * 0.75,\n                (uv.y - sin(uv.x + t) * 0.25) * noise2YFactor,\n                t\n              )\n            ), -1., 1., 0.0, 1.);\n\n          vec3 color = vec3(25.0 / 360., 1.0, 1.0);\n          color = hsb2rgb(color);\n          vec3 bgColor = vec3(24., 25., 15.)/255.;\n\n          float blendFactor = clamp(n * smoothstep(step1Min, step1Max, n2), 0., 1.);\n          float gradient = valueRemap(vUv.y, 0.5, 1.0, 1., 0.);\n          gradient = clamp(gradient, 0., 1.);\n          color = mix(bgColor, color, blendFactor * gradient);\n\n          fragColor = vec4(color, 1.);\n        }\n      "),uniforms:{time:{value:0},resolution:{value:[a,s]},noise1XFactor:{value:.75},noise1YFactor:{value:0},noise2XFactor:{value:-.75},noise2YFactor:{value:0},step1Min:{value:.25},step1Max:{value:.8},top:{value:1e3}}}),[]);return(0,v.xQ)((n,e)=>{p.uniforms.time.value=e/1e3,p.uniforms.resolution.value[0]=a*x,p.uniforms.resolution.value[1]=s*x,p.uniforms.top.value=t.current.top/f.height}),(0,o.jsxs)("mesh",{visible:!1,ref:e,children:[(0,o.jsx)("plane",{args:[{width:2,height:2}]}),(0,o.jsx)("primitive",{dispose:null,object:p,uniforms:{timeFactor:{value:d.timeFactor},noise1XFactor:{value:d.noise1XFactor},noise1YFactor:{value:d.noise1YFactor},noise2XFactor:{value:d.noise2XFactor},noise2YFactor:{value:d.noise2YFactor},step1Min:{value:d.step1Min},step1Max:{value:d.step1Max}}})]})}),p=n=>{let{track:e}=n,t=(0,c.useRef)(!1),r=(0,v.Cp)(n=>n.renderer),i=(0,v.Cp)(n=>n.camera),l=(0,c.useRef)(null),u=(0,c.useRef)({top:0}),[m,{height:p,offsetTop:h,hasMeasured:b}]=(0,f.Z)({offsetCoords:!0}),y=(0,c.useMemo)(()=>new a.w,[]);return(0,c.useLayoutEffect)(()=>{m(e.current)},[e]),(0,x.LZ)(n=>{if(!n||!b||0===p)return;let e=n.scroll||0,o=h+(p-r.height)-e,i=o<p;u.current.top=o,t.current=i,l.current&&(l.current.visible=i)},[p,h,r.height,b]),(0,v.xQ)(()=>{t.current&&r.render({scene:y,clear:!1,camera:i})},1),(0,s.jz)((0,o.jsx)(d,{scissorRef:u,ref:l}),y)}}}]);