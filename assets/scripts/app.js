(() => {
	var b1 = Object.create;
	var Jh = Object.defineProperty,
		x1 = Object.defineProperties,
		w1 = Object.getOwnPropertyDescriptor,
		S1 = Object.getOwnPropertyDescriptors,
		E1 = Object.getOwnPropertyNames,
		Zh = Object.getOwnPropertySymbols,
		M1 = Object.getPrototypeOf,
		Qd = Object.prototype.hasOwnProperty,
		Zv = Object.prototype.propertyIsEnumerable;
	var tp = Math.pow,
		Kv = (i, t, e) => t in i ? Jh(i, t, {
			enumerable: !0,
			configurable: !0,
			writable: !0,
			value: e
		}) : i[t] = e,
		gn = (i, t) => {
			for (var e in t || (t = {})) Qd.call(t, e) && Kv(i, e, t[e]);
			if (Zh)
				for (var e of Zh(t)) Zv.call(t, e) && Kv(i, e, t[e]);
			return i
		},
		qa = (i, t) => x1(i, S1(t));
	var Jv = (i, t) => {
		var e = {};
		for (var n in i) Qd.call(i, n) && t.indexOf(n) < 0 && (e[n] = i[n]);
		if (i != null && Zh)
			for (var n of Zh(i)) t.indexOf(n) < 0 && Zv.call(i, n) && (e[n] = i[n]);
		return e
	};
	var C1 = (i, t) => () => (i && (t = i(i = 0)), t);
	var Qh = (i, t) => () => (t || i((t = {
			exports: {}
		}).exports, t), t.exports),
		Qv = (i, t) => {
			for (var e in t) Jh(i, e, {
				get: t[e],
				enumerable: !0
			})
		},
		T1 = (i, t, e, n) => {
			if (t && typeof t == "object" || typeof t == "function")
				for (let r of E1(t)) !Qd.call(i, r) && r !== e && Jh(i, r, {
					get: () => t[r],
					enumerable: !(n = w1(t, r)) || n.enumerable
				});
			return i
		};
	var yl = (i, t, e) => (e = i != null ? b1(M1(i)) : {}, T1(t || !i || !i.__esModule ? Jh(e, "default", {
		value: i,
		enumerable: !0
	}) : e, i));
	var Di = (i, t, e) => new Promise((n, r) => {
		var s = h => {
				try {
					o(e.next(h))
				} catch (c) {
					r(c)
				}
			},
			a = h => {
				try {
					o(e.throw(h))
				} catch (c) {
					r(c)
				}
			},
			o = h => h.done ? n(h.value) : Promise.resolve(h.value).then(s, a);
		o((e = e.apply(i, t)).next())
	});
	var mf = Qh((exports, module) => {
		typeof navigator != "undefined" && function (i, t) {
			typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (i = typeof globalThis != "undefined" ? globalThis : i || self, i.lottie = t())
		}(exports, function () {
			"use strict";
			var svgNS = "http://www.w3.org/2000/svg",
				locationHref = "",
				_useWebWorker = !1,
				initialDefaultFrame = -999999,
				setWebWorker = function (t) {
					_useWebWorker = !!t
				},
				getWebWorker = function () {
					return _useWebWorker
				},
				setLocationHref = function (t) {
					locationHref = t
				},
				getLocationHref = function () {
					return locationHref
				};

			function createTag(i) {
				return document.createElement(i)
			}

			function extendPrototype(i, t) {
				var e, n = i.length,
					r;
				for (e = 0; e < n; e += 1) {
					r = i[e].prototype;
					for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t.prototype[s] = r[s])
				}
			}

			function getDescriptor(i, t) {
				return Object.getOwnPropertyDescriptor(i, t)
			}

			function createProxyFunction(i) {
				function t() {}
				return t.prototype = i, t
			}
			var audioControllerFactory = function () {
					function i(t) {
						this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1
					}
					return i.prototype = {
							addAudio: function (e) {
								this.audios.push(e)
							},
							pause: function () {
								var e, n = this.audios.length;
								for (e = 0; e < n; e += 1) this.audios[e].pause()
							},
							resume: function () {
								var e, n = this.audios.length;
								for (e = 0; e < n; e += 1) this.audios[e].resume()
							},
							setRate: function (e) {
								var n, r = this.audios.length;
								for (n = 0; n < r; n += 1) this.audios[n].setRate(e)
							},
							createAudio: function (e) {
								return this.audioFactory ? this.audioFactory(e) : window.Howl ? new window.Howl({
									src: [e]
								}) : {
									isPlaying: !1,
									play: function () {
										this.isPlaying = !0
									},
									seek: function () {
										this.isPlaying = !1
									},
									playing: function () {},
									rate: function () {},
									setVolume: function () {}
								}
							},
							setAudioFactory: function (e) {
								this.audioFactory = e
							},
							setVolume: function (e) {
								this._volume = e, this._updateVolume()
							},
							mute: function () {
								this._isMuted = !0, this._updateVolume()
							},
							unmute: function () {
								this._isMuted = !1, this._updateVolume()
							},
							getVolume: function () {
								return this._volume
							},
							_updateVolume: function () {
								var e, n = this.audios.length;
								for (e = 0; e < n; e += 1) this.audios[e].volume(this._volume * (this._isMuted ? 0 : 1))
							}
						},
						function () {
							return new i
						}
				}(),
				createTypedArray = function () {
					function i(e, n) {
						var r = 0,
							s = [],
							a;
						switch (e) {
							case "int16":
							case "uint8c":
								a = 1;
								break;
							default:
								a = 1.1;
								break
						}
						for (r = 0; r < n; r += 1) s.push(a);
						return s
					}

					function t(e, n) {
						return e === "float32" ? new Float32Array(n) : e === "int16" ? new Int16Array(n) : e === "uint8c" ? new Uint8ClampedArray(n) : i(e, n)
					}
					return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? t : i
				}();

			function createSizedArray(i) {
				return Array.apply(null, {
					length: i
				})
			}

			function _typeof$6(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function (e) {
					return typeof e
				} : _typeof$6 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$6(i)
			}
			var subframeEnabled = !0,
				expressionsPlugin = null,
				expressionsInterfaces = null,
				idPrefix$1 = "",
				isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
				_shouldRoundValues = !1,
				bmPow = Math.pow,
				bmSqrt = Math.sqrt,
				bmFloor = Math.floor,
				bmMax = Math.max,
				bmMin = Math.min,
				BMMath = {};
			(function () {
				var i = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
					t, e = i.length;
				for (t = 0; t < e; t += 1) BMMath[i[t]] = Math[i[t]]
			})();

			function ProjectInterface$1() {
				return {}
			}
			BMMath.random = Math.random, BMMath.abs = function (i) {
				var t = _typeof$6(i);
				if (t === "object" && i.length) {
					var e = createSizedArray(i.length),
						n, r = i.length;
					for (n = 0; n < r; n += 1) e[n] = Math.abs(i[n]);
					return e
				}
				return Math.abs(i)
			};
			var defaultCurveSegments = 150,
				degToRads = Math.PI / 180,
				roundCorner = .5519;

			function roundValues(i) {
				_shouldRoundValues = !!i
			}

			function bmRnd(i) {
				return _shouldRoundValues ? Math.round(i) : i
			}

			function styleDiv(i) {
				i.style.position = "absolute", i.style.top = 0, i.style.left = 0, i.style.display = "block", i.style.transformOrigin = "0 0", i.style.webkitTransformOrigin = "0 0", i.style.backfaceVisibility = "visible", i.style.webkitBackfaceVisibility = "visible", i.style.transformStyle = "preserve-3d", i.style.webkitTransformStyle = "preserve-3d", i.style.mozTransformStyle = "preserve-3d"
			}

			function BMEnterFrameEvent(i, t, e, n) {
				this.type = i, this.currentTime = t, this.totalTime = e, this.direction = n < 0 ? -1 : 1
			}

			function BMCompleteEvent(i, t) {
				this.type = i, this.direction = t < 0 ? -1 : 1
			}

			function BMCompleteLoopEvent(i, t, e, n) {
				this.type = i, this.currentLoop = e, this.totalLoops = t, this.direction = n < 0 ? -1 : 1
			}

			function BMSegmentStartEvent(i, t, e) {
				this.type = i, this.firstFrame = t, this.totalFrames = e
			}

			function BMDestroyEvent(i, t) {
				this.type = i, this.target = t
			}

			function BMRenderFrameErrorEvent(i, t) {
				this.type = "renderFrameError", this.nativeError = i, this.currentTime = t
			}

			function BMConfigErrorEvent(i) {
				this.type = "configError", this.nativeError = i
			}

			function BMAnimationConfigErrorEvent(i, t) {
				this.type = i, this.nativeError = t
			}
			var createElementID = function () {
				var i = 0;
				return function () {
					return i += 1, idPrefix$1 + "__lottie_element_" + i
				}
			}();

			function HSVtoRGB(i, t, e) {
				var n, r, s, a, o, h, c, u;
				switch (a = Math.floor(i * 6), o = i * 6 - a, h = e * (1 - t), c = e * (1 - o * t), u = e * (1 - (1 - o) * t), a % 6) {
					case 0:
						n = e, r = u, s = h;
						break;
					case 1:
						n = c, r = e, s = h;
						break;
					case 2:
						n = h, r = e, s = u;
						break;
					case 3:
						n = h, r = c, s = e;
						break;
					case 4:
						n = u, r = h, s = e;
						break;
					case 5:
						n = e, r = h, s = c;
						break;
					default:
						break
				}
				return [n, r, s]
			}

			function RGBtoHSV(i, t, e) {
				var n = Math.max(i, t, e),
					r = Math.min(i, t, e),
					s = n - r,
					a, o = n === 0 ? 0 : s / n,
					h = n / 255;
				switch (n) {
					case r:
						a = 0;
						break;
					case i:
						a = t - e + s * (t < e ? 6 : 0), a /= 6 * s;
						break;
					case t:
						a = e - i + s * 2, a /= 6 * s;
						break;
					case e:
						a = i - t + s * 4, a /= 6 * s;
						break;
					default:
						break
				}
				return [a, o, h]
			}

			function addSaturationToRGB(i, t) {
				var e = RGBtoHSV(i[0] * 255, i[1] * 255, i[2] * 255);
				return e[1] += t, e[1] > 1 ? e[1] = 1 : e[1] <= 0 && (e[1] = 0), HSVtoRGB(e[0], e[1], e[2])
			}

			function addBrightnessToRGB(i, t) {
				var e = RGBtoHSV(i[0] * 255, i[1] * 255, i[2] * 255);
				return e[2] += t, e[2] > 1 ? e[2] = 1 : e[2] < 0 && (e[2] = 0), HSVtoRGB(e[0], e[1], e[2])
			}

			function addHueToRGB(i, t) {
				var e = RGBtoHSV(i[0] * 255, i[1] * 255, i[2] * 255);
				return e[0] += t / 360, e[0] > 1 ? e[0] -= 1 : e[0] < 0 && (e[0] += 1), HSVtoRGB(e[0], e[1], e[2])
			}
			var rgbToHex = function () {
					var i = [],
						t, e;
					for (t = 0; t < 256; t += 1) e = t.toString(16), i[t] = e.length === 1 ? "0" + e : e;
					return function (n, r, s) {
						return n < 0 && (n = 0), r < 0 && (r = 0), s < 0 && (s = 0), "#" + i[n] + i[r] + i[s]
					}
				}(),
				setSubframeEnabled = function (t) {
					subframeEnabled = !!t
				},
				getSubframeEnabled = function () {
					return subframeEnabled
				},
				setExpressionsPlugin = function (t) {
					expressionsPlugin = t
				},
				getExpressionsPlugin = function () {
					return expressionsPlugin
				},
				setExpressionInterfaces = function (t) {
					expressionsInterfaces = t
				},
				getExpressionInterfaces = function () {
					return expressionsInterfaces
				},
				setDefaultCurveSegments = function (t) {
					defaultCurveSegments = t
				},
				getDefaultCurveSegments = function () {
					return defaultCurveSegments
				},
				setIdPrefix = function (t) {
					idPrefix$1 = t
				},
				getIdPrefix = function () {
					return idPrefix$1
				};

			function createNS(i) {
				return document.createElementNS(svgNS, i)
			}

			function _typeof$5(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function (e) {
					return typeof e
				} : _typeof$5 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$5(i)
			}
			var dataManager = function () {
					var i = 1,
						t = [],
						e, n, r = {
							onmessage: function () {},
							postMessage: function (_) {
								e({
									data: _
								})
							}
						},
						s = {
							postMessage: function (_) {
								r.onmessage({
									data: _
								})
							}
						};

					function a(p) {
						if (window.Worker && window.Blob && getWebWorker()) {
							var _ = new Blob(["var _workerSelf = self; self.onmessage = ", p.toString()], {
									type: "text/javascript"
								}),
								b = URL.createObjectURL(_);
							return new Worker(b)
						}
						return e = p, r
					}

					function o() {
						n || (n = a(function (_) {
							function b() {
								function w(W, O) {
									var B, A, D = W.length,
										H, q, Q, tt;
									for (A = 0; A < D; A += 1)
										if (B = W[A], "ks" in B && !B.completed) {
											if (B.completed = !0, B.hasMask) {
												var nt = B.masksProperties;
												for (q = nt.length, H = 0; H < q; H += 1)
													if (nt[H].pt.k.i) T(nt[H].pt.k);
													else
														for (tt = nt[H].pt.k.length, Q = 0; Q < tt; Q += 1) nt[H].pt.k[Q].s && T(nt[H].pt.k[Q].s[0]), nt[H].pt.k[Q].e && T(nt[H].pt.k[Q].e[0])
											}
											B.ty === 0 ? (B.layers = x(B.refId, O), w(B.layers, O)) : B.ty === 4 ? M(B.shapes) : B.ty === 5 && z(B)
										}
								}

								function f(W, O) {
									if (W) {
										var B = 0,
											A = W.length;
										for (B = 0; B < A; B += 1) W[B].t === 1 && (W[B].data.layers = x(W[B].data.refId, O), w(W[B].data.layers, O))
									}
								}

								function S(W, O) {
									for (var B = 0, A = O.length; B < A;) {
										if (O[B].id === W) return O[B];
										B += 1
									}
									return null
								}

								function x(W, O) {
									var B = S(W, O);
									return B ? B.layers.__used ? JSON.parse(JSON.stringify(B.layers)) : (B.layers.__used = !0, B.layers) : null
								}

								function M(W) {
									var O, B = W.length,
										A, D;
									for (O = B - 1; O >= 0; O -= 1)
										if (W[O].ty === "sh")
											if (W[O].ks.k.i) T(W[O].ks.k);
											else
												for (D = W[O].ks.k.length, A = 0; A < D; A += 1) W[O].ks.k[A].s && T(W[O].ks.k[A].s[0]), W[O].ks.k[A].e && T(W[O].ks.k[A].e[0]);
									else W[O].ty === "gr" && M(W[O].it)
								}

								function T(W) {
									var O, B = W.i.length;
									for (O = 0; O < B; O += 1) W.i[O][0] += W.v[O][0], W.i[O][1] += W.v[O][1], W.o[O][0] += W.v[O][0], W.o[O][1] += W.v[O][1]
								}

								function I(W, O) {
									var B = O ? O.split(".") : [100, 100, 100];
									return W[0] > B[0] ? !0 : B[0] > W[0] ? !1 : W[1] > B[1] ? !0 : B[1] > W[1] ? !1 : W[2] > B[2] ? !0 : B[2] > W[2] ? !1 : null
								}
								var L = function () {
										var W = [4, 4, 14];

										function O(A) {
											var D = A.t.d;
											A.t.d = {
												k: [{
													s: D,
													t: 0
												}]
											}
										}

										function B(A) {
											var D, H = A.length;
											for (D = 0; D < H; D += 1) A[D].ty === 5 && O(A[D])
										}
										return function (A) {
											if (I(W, A.v) && (B(A.layers), A.assets)) {
												var D, H = A.assets.length;
												for (D = 0; D < H; D += 1) A.assets[D].layers && B(A.assets[D].layers)
											}
										}
									}(),
									F = function () {
										var W = [4, 7, 99];
										return function (O) {
											if (O.chars && !I(W, O.v)) {
												var B, A = O.chars.length;
												for (B = 0; B < A; B += 1) {
													var D = O.chars[B];
													D.data && D.data.shapes && (M(D.data.shapes), D.data.ip = 0, D.data.op = 99999, D.data.st = 0, D.data.sr = 1, D.data.ks = {
														p: {
															k: [0, 0],
															a: 0
														},
														s: {
															k: [100, 100],
															a: 0
														},
														a: {
															k: [0, 0],
															a: 0
														},
														r: {
															k: 0,
															a: 0
														},
														o: {
															k: 100,
															a: 0
														}
													}, O.chars[B].t || (D.data.shapes.push({
														ty: "no"
													}), D.data.shapes[0].it.push({
														p: {
															k: [0, 0],
															a: 0
														},
														s: {
															k: [100, 100],
															a: 0
														},
														a: {
															k: [0, 0],
															a: 0
														},
														r: {
															k: 0,
															a: 0
														},
														o: {
															k: 100,
															a: 0
														},
														sk: {
															k: 0,
															a: 0
														},
														sa: {
															k: 0,
															a: 0
														},
														ty: "tr"
													})))
												}
											}
										}
									}(),
									k = function () {
										var W = [5, 7, 15];

										function O(A) {
											var D = A.t.p;
											typeof D.a == "number" && (D.a = {
												a: 0,
												k: D.a
											}), typeof D.p == "number" && (D.p = {
												a: 0,
												k: D.p
											}), typeof D.r == "number" && (D.r = {
												a: 0,
												k: D.r
											})
										}

										function B(A) {
											var D, H = A.length;
											for (D = 0; D < H; D += 1) A[D].ty === 5 && O(A[D])
										}
										return function (A) {
											if (I(W, A.v) && (B(A.layers), A.assets)) {
												var D, H = A.assets.length;
												for (D = 0; D < H; D += 1) A.assets[D].layers && B(A.assets[D].layers)
											}
										}
									}(),
									G = function () {
										var W = [4, 1, 9];

										function O(A) {
											var D, H = A.length,
												q, Q;
											for (D = 0; D < H; D += 1)
												if (A[D].ty === "gr") O(A[D].it);
												else if (A[D].ty === "fl" || A[D].ty === "st")
												if (A[D].c.k && A[D].c.k[0].i)
													for (Q = A[D].c.k.length, q = 0; q < Q; q += 1) A[D].c.k[q].s && (A[D].c.k[q].s[0] /= 255, A[D].c.k[q].s[1] /= 255, A[D].c.k[q].s[2] /= 255, A[D].c.k[q].s[3] /= 255), A[D].c.k[q].e && (A[D].c.k[q].e[0] /= 255, A[D].c.k[q].e[1] /= 255, A[D].c.k[q].e[2] /= 255, A[D].c.k[q].e[3] /= 255);
												else A[D].c.k[0] /= 255, A[D].c.k[1] /= 255, A[D].c.k[2] /= 255, A[D].c.k[3] /= 255
										}

										function B(A) {
											var D, H = A.length;
											for (D = 0; D < H; D += 1) A[D].ty === 4 && O(A[D].shapes)
										}
										return function (A) {
											if (I(W, A.v) && (B(A.layers), A.assets)) {
												var D, H = A.assets.length;
												for (D = 0; D < H; D += 1) A.assets[D].layers && B(A.assets[D].layers)
											}
										}
									}(),
									j = function () {
										var W = [4, 4, 18];

										function O(A) {
											var D, H = A.length,
												q, Q;
											for (D = H - 1; D >= 0; D -= 1)
												if (A[D].ty === "sh")
													if (A[D].ks.k.i) A[D].ks.k.c = A[D].closed;
													else
														for (Q = A[D].ks.k.length, q = 0; q < Q; q += 1) A[D].ks.k[q].s && (A[D].ks.k[q].s[0].c = A[D].closed), A[D].ks.k[q].e && (A[D].ks.k[q].e[0].c = A[D].closed);
											else A[D].ty === "gr" && O(A[D].it)
										}

										function B(A) {
											var D, H, q = A.length,
												Q, tt, nt, ut;
											for (H = 0; H < q; H += 1) {
												if (D = A[H], D.hasMask) {
													var et = D.masksProperties;
													for (tt = et.length, Q = 0; Q < tt; Q += 1)
														if (et[Q].pt.k.i) et[Q].pt.k.c = et[Q].cl;
														else
															for (ut = et[Q].pt.k.length, nt = 0; nt < ut; nt += 1) et[Q].pt.k[nt].s && (et[Q].pt.k[nt].s[0].c = et[Q].cl), et[Q].pt.k[nt].e && (et[Q].pt.k[nt].e[0].c = et[Q].cl)
												}
												D.ty === 4 && O(D.shapes)
											}
										}
										return function (A) {
											if (I(W, A.v) && (B(A.layers), A.assets)) {
												var D, H = A.assets.length;
												for (D = 0; D < H; D += 1) A.assets[D].layers && B(A.assets[D].layers)
											}
										}
									}();

								function U(W) {
									W.__complete || (G(W), L(W), F(W), k(W), j(W), w(W.layers, W.assets), f(W.chars, W.assets), W.__complete = !0)
								}

								function z(W) {
									W.t.a.length === 0 && "m" in W.t.p
								}
								var $ = {};
								return $.completeData = U, $.checkColors = G, $.checkChars = F, $.checkPathProperties = k, $.checkShapes = j, $.completeLayers = w, $
							}
							if (s.dataManager || (s.dataManager = b()), s.assetLoader || (s.assetLoader = function () {
									function w(S) {
										var x = S.getResponseHeader("content-type");
										return x && S.responseType === "json" && x.indexOf("json") !== -1 || S.response && _typeof$5(S.response) === "object" ? S.response : S.response && typeof S.response == "string" ? JSON.parse(S.response) : S.responseText ? JSON.parse(S.responseText) : null
									}

									function f(S, x, M, T) {
										var I, L = new XMLHttpRequest;
										try {
											L.responseType = "json"
										} catch (F) {}
										L.onreadystatechange = function () {
											if (L.readyState === 4)
												if (L.status === 200) I = w(L), M(I);
												else try {
													I = w(L), M(I)
												} catch (F) {
													T && T(F)
												}
										};
										try {
											L.open(["G", "E", "T"].join(""), S, !0)
										} catch (F) {
											L.open(["G", "E", "T"].join(""), x + "/" + S, !0)
										}
										L.send()
									}
									return {
										load: f
									}
								}()), _.data.type === "loadAnimation") s.assetLoader.load(_.data.path, _.data.fullPath, function (w) {
								s.dataManager.completeData(w), s.postMessage({
									id: _.data.id,
									payload: w,
									status: "success"
								})
							}, function () {
								s.postMessage({
									id: _.data.id,
									status: "error"
								})
							});
							else if (_.data.type === "complete") {
								var y = _.data.animation;
								s.dataManager.completeData(y), s.postMessage({
									id: _.data.id,
									payload: y,
									status: "success"
								})
							} else _.data.type === "loadData" && s.assetLoader.load(_.data.path, _.data.fullPath, function (w) {
								s.postMessage({
									id: _.data.id,
									payload: w,
									status: "success"
								})
							}, function () {
								s.postMessage({
									id: _.data.id,
									status: "error"
								})
							})
						}), n.onmessage = function (p) {
							var _ = p.data,
								b = _.id,
								y = t[b];
							t[b] = null, _.status === "success" ? y.onComplete(_.payload) : y.onError && y.onError()
						})
					}

					function h(p, _) {
						i += 1;
						var b = "processId_" + i;
						return t[b] = {
							onComplete: p,
							onError: _
						}, b
					}

					function c(p, _, b) {
						o();
						var y = h(_, b);
						n.postMessage({
							type: "loadAnimation",
							path: p,
							fullPath: window.location.origin + window.location.pathname,
							id: y
						})
					}

					function u(p, _, b) {
						o();
						var y = h(_, b);
						n.postMessage({
							type: "loadData",
							path: p,
							fullPath: window.location.origin + window.location.pathname,
							id: y
						})
					}

					function g(p, _, b) {
						o();
						var y = h(_, b);
						n.postMessage({
							type: "complete",
							animation: p,
							id: y
						})
					}
					return {
						loadAnimation: c,
						loadData: u,
						completeAnimation: g
					}
				}(),
				ImagePreloader = function () {
					var i = function () {
						var f = createTag("canvas");
						f.width = 1, f.height = 1;
						var S = f.getContext("2d");
						return S.fillStyle = "rgba(0,0,0,0)", S.fillRect(0, 0, 1, 1), f
					}();

					function t() {
						this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
					}

					function e() {
						this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
					}

					function n(f, S, x) {
						var M = "";
						if (f.e) M = f.p;
						else if (S) {
							var T = f.p;
							T.indexOf("images/") !== -1 && (T = T.split("/")[1]), M = S + T
						} else M = x, M += f.u ? f.u : "", M += f.p;
						return M
					}

					function r(f) {
						var S = 0,
							x = setInterval(function () {
								var M = f.getBBox();
								(M.width || S > 500) && (this._imageLoaded(), clearInterval(x)), S += 1
							}.bind(this), 50)
					}

					function s(f) {
						var S = n(f, this.assetsPath, this.path),
							x = createNS("image");
						isSafari ? this.testImageLoaded(x) : x.addEventListener("load", this._imageLoaded, !1), x.addEventListener("error", function () {
							M.img = i, this._imageLoaded()
						}.bind(this), !1), x.setAttributeNS("http://www.w3.org/1999/xlink", "href", S), this._elementHelper.append ? this._elementHelper.append(x) : this._elementHelper.appendChild(x);
						var M = {
							img: x,
							assetData: f
						};
						return M
					}

					function a(f) {
						var S = n(f, this.assetsPath, this.path),
							x = createTag("img");
						x.crossOrigin = "anonymous", x.addEventListener("load", this._imageLoaded, !1), x.addEventListener("error", function () {
							M.img = i, this._imageLoaded()
						}.bind(this), !1), x.src = S;
						var M = {
							img: x,
							assetData: f
						};
						return M
					}

					function o(f) {
						var S = {
								assetData: f
							},
							x = n(f, this.assetsPath, this.path);
						return dataManager.loadData(x, function (M) {
							S.img = M, this._footageLoaded()
						}.bind(this), function () {
							S.img = {}, this._footageLoaded()
						}.bind(this)), S
					}

					function h(f, S) {
						this.imagesLoadedCb = S;
						var x, M = f.length;
						for (x = 0; x < M; x += 1) f[x].layers || (!f[x].t || f[x].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(f[x]))) : f[x].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(f[x]))))
					}

					function c(f) {
						this.path = f || ""
					}

					function u(f) {
						this.assetsPath = f || ""
					}

					function g(f) {
						for (var S = 0, x = this.images.length; S < x;) {
							if (this.images[S].assetData === f) return this.images[S].img;
							S += 1
						}
						return null
					}

					function p() {
						this.imagesLoadedCb = null, this.images.length = 0
					}

					function _() {
						return this.totalImages === this.loadedAssets
					}

					function b() {
						return this.totalFootages === this.loadedFootagesCount
					}

					function y(f, S) {
						f === "svg" ? (this._elementHelper = S, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
					}

					function w() {
						this._imageLoaded = t.bind(this), this._footageLoaded = e.bind(this), this.testImageLoaded = r.bind(this), this.createFootageData = o.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
					}
					return w.prototype = {
						loadAssets: h,
						setAssetsPath: u,
						setPath: c,
						loadedImages: _,
						loadedFootages: b,
						destroy: p,
						getAsset: g,
						createImgData: a,
						createImageData: s,
						imageLoaded: t,
						footageLoaded: e,
						setCacheType: y
					}, w
				}();

			function BaseEvent() {}
			BaseEvent.prototype = {
				triggerEvent: function (t, e) {
					if (this._cbs[t])
						for (var n = this._cbs[t], r = 0; r < n.length; r += 1) n[r](e)
				},
				addEventListener: function (t, e) {
					return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e),
						function () {
							this.removeEventListener(t, e)
						}.bind(this)
				},
				removeEventListener: function (t, e) {
					if (!e) this._cbs[t] = null;
					else if (this._cbs[t]) {
						for (var n = 0, r = this._cbs[t].length; n < r;) this._cbs[t][n] === e && (this._cbs[t].splice(n, 1), n -= 1, r -= 1), n += 1;
						this._cbs[t].length || (this._cbs[t] = null)
					}
				}
			};
			var markerParser = function () {
					function i(t) {
						for (var e = t.split(`\r
`), n = {}, r, s = 0, a = 0; a < e.length; a += 1) r = e[a].split(":"), r.length === 2 && (n[r[0]] = r[1].trim(), s += 1);
						if (s === 0) throw new Error;
						return n
					}
					return function (t) {
						for (var e = [], n = 0; n < t.length; n += 1) {
							var r = t[n],
								s = {
									time: r.tm,
									duration: r.dr
								};
							try {
								s.payload = JSON.parse(t[n].cm)
							} catch (a) {
								try {
									s.payload = i(t[n].cm)
								} catch (o) {
									s.payload = {
										name: t[n].cm
									}
								}
							}
							e.push(s)
						}
						return e
					}
				}(),
				ProjectInterface = function () {
					function i(t) {
						this.compositions.push(t)
					}
					return function () {
						function t(e) {
							for (var n = 0, r = this.compositions.length; n < r;) {
								if (this.compositions[n].data && this.compositions[n].data.nm === e) return this.compositions[n].prepareFrame && this.compositions[n].data.xt && this.compositions[n].prepareFrame(this.currentFrame), this.compositions[n].compInterface;
								n += 1
							}
							return null
						}
						return t.compositions = [], t.currentFrame = 0, t.registerComposition = i, t
					}
				}(),
				renderers = {},
				registerRenderer = function (t, e) {
					renderers[t] = e
				};

			function getRenderer(i) {
				return renderers[i]
			}

			function getRegisteredRenderer() {
				if (renderers.canvas) return "canvas";
				for (var i in renderers)
					if (renderers[i]) return i;
				return ""
			}

			function _typeof$4(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function (e) {
					return typeof e
				} : _typeof$4 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$4(i)
			}
			var AnimationItem = function () {
				this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin()
			};
			extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (i) {
				(i.wrapper || i.container) && (this.wrapper = i.wrapper || i.container);
				var t = "svg";
				i.animType ? t = i.animType : i.renderer && (t = i.renderer);
				var e = getRenderer(t);
				this.renderer = new e(this, i.rendererSettings), this.imagePreloader.setCacheType(t, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = t, i.loop === "" || i.loop === null || i.loop === void 0 || i.loop === !0 ? this.loop = !0 : i.loop === !1 ? this.loop = !1 : this.loop = parseInt(i.loop, 10), this.autoplay = "autoplay" in i ? i.autoplay : !0, this.name = i.name ? i.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(i, "autoloadSegments") ? i.autoloadSegments : !0, this.assetsPath = i.assetsPath, this.initialSegment = i.initialSegment, i.audioFactory && this.audioController.setAudioFactory(i.audioFactory), i.animationData ? this.setupAnimation(i.animationData) : i.path && (i.path.lastIndexOf("\\") !== -1 ? this.path = i.path.substr(0, i.path.lastIndexOf("\\") + 1) : this.path = i.path.substr(0, i.path.lastIndexOf("/") + 1), this.fileName = i.path.substr(i.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(i.path, this.configAnimation, this.onSetupError))
			}, AnimationItem.prototype.onSetupError = function () {
				this.trigger("data_failed")
			}, AnimationItem.prototype.setupAnimation = function (i) {
				dataManager.completeAnimation(i, this.configAnimation)
			}, AnimationItem.prototype.setData = function (i, t) {
				t && _typeof$4(t) !== "object" && (t = JSON.parse(t));
				var e = {
						wrapper: i,
						animationData: t
					},
					n = i.attributes;
				e.path = n.getNamedItem("data-animation-path") ? n.getNamedItem("data-animation-path").value : n.getNamedItem("data-bm-path") ? n.getNamedItem("data-bm-path").value : n.getNamedItem("bm-path") ? n.getNamedItem("bm-path").value : "", e.animType = n.getNamedItem("data-anim-type") ? n.getNamedItem("data-anim-type").value : n.getNamedItem("data-bm-type") ? n.getNamedItem("data-bm-type").value : n.getNamedItem("bm-type") ? n.getNamedItem("bm-type").value : n.getNamedItem("data-bm-renderer") ? n.getNamedItem("data-bm-renderer").value : n.getNamedItem("bm-renderer") ? n.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
				var r = n.getNamedItem("data-anim-loop") ? n.getNamedItem("data-anim-loop").value : n.getNamedItem("data-bm-loop") ? n.getNamedItem("data-bm-loop").value : n.getNamedItem("bm-loop") ? n.getNamedItem("bm-loop").value : "";
				r === "false" ? e.loop = !1 : r === "true" ? e.loop = !0 : r !== "" && (e.loop = parseInt(r, 10));
				var s = n.getNamedItem("data-anim-autoplay") ? n.getNamedItem("data-anim-autoplay").value : n.getNamedItem("data-bm-autoplay") ? n.getNamedItem("data-bm-autoplay").value : n.getNamedItem("bm-autoplay") ? n.getNamedItem("bm-autoplay").value : !0;
				e.autoplay = s !== "false", e.name = n.getNamedItem("data-name") ? n.getNamedItem("data-name").value : n.getNamedItem("data-bm-name") ? n.getNamedItem("data-bm-name").value : n.getNamedItem("bm-name") ? n.getNamedItem("bm-name").value : "";
				var a = n.getNamedItem("data-anim-prerender") ? n.getNamedItem("data-anim-prerender").value : n.getNamedItem("data-bm-prerender") ? n.getNamedItem("data-bm-prerender").value : n.getNamedItem("bm-prerender") ? n.getNamedItem("bm-prerender").value : "";
				a === "false" && (e.prerender = !1), e.path ? this.setParams(e) : this.trigger("destroy")
			}, AnimationItem.prototype.includeLayers = function (i) {
				i.op > this.animationData.op && (this.animationData.op = i.op, this.totalFrames = Math.floor(i.op - this.animationData.ip));
				var t = this.animationData.layers,
					e, n = t.length,
					r = i.layers,
					s, a = r.length;
				for (s = 0; s < a; s += 1)
					for (e = 0; e < n;) {
						if (t[e].id === r[s].id) {
							t[e] = r[s];
							break
						}
						e += 1
					}
				if ((i.chars || i.fonts) && (this.renderer.globalData.fontManager.addChars(i.chars), this.renderer.globalData.fontManager.addFonts(i.fonts, this.renderer.globalData.defs)), i.assets)
					for (n = i.assets.length, e = 0; e < n; e += 1) this.animationData.assets.push(i.assets[e]);
				this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
			}, AnimationItem.prototype.onSegmentComplete = function (i) {
				this.animationData = i;
				var t = getExpressionsPlugin();
				t && t.initExpressions(this), this.loadNextSegment()
			}, AnimationItem.prototype.loadNextSegment = function () {
				var i = this.animationData.segments;
				if (!i || i.length === 0 || !this.autoloadSegments) {
					this.trigger("data_ready"), this.timeCompleted = this.totalFrames;
					return
				}
				var t = i.shift();
				this.timeCompleted = t.time * this.frameRate;
				var e = this.path + this.fileName + "_" + this.segmentPos + ".json";
				this.segmentPos += 1, dataManager.loadData(e, this.includeLayers.bind(this), function () {
					this.trigger("data_failed")
				}.bind(this))
			}, AnimationItem.prototype.loadSegments = function () {
				var i = this.animationData.segments;
				i || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
			}, AnimationItem.prototype.imagesLoaded = function () {
				this.trigger("loaded_images"), this.checkLoaded()
			}, AnimationItem.prototype.preloadImages = function () {
				this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
			}, AnimationItem.prototype.configAnimation = function (i) {
				if (this.renderer) try {
					this.animationData = i, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(i), i.assets || (i.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(i.assets), this.markers = markerParser(i.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
				} catch (t) {
					this.triggerConfigError(t)
				}
			}, AnimationItem.prototype.waitForFontsLoaded = function () {
				this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
			}, AnimationItem.prototype.checkLoaded = function () {
				if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
					this.isLoaded = !0;
					var i = getExpressionsPlugin();
					i && i.initExpressions(this), this.renderer.initItems(), setTimeout(function () {
						this.trigger("DOMLoaded")
					}.bind(this), 0), this.gotoFrame(), this.autoplay && this.play()
				}
			}, AnimationItem.prototype.resize = function (i, t) {
				var e = typeof i == "number" ? i : void 0,
					n = typeof t == "number" ? t : void 0;
				this.renderer.updateContainerSize(e, n)
			}, AnimationItem.prototype.setSubframe = function (i) {
				this.isSubframeEnabled = !!i
			}, AnimationItem.prototype.gotoFrame = function () {
				this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame")
			}, AnimationItem.prototype.renderFrame = function () {
				if (!(this.isLoaded === !1 || !this.renderer)) try {
					this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame)
				} catch (i) {
					this.triggerRenderFrameError(i)
				}
			}, AnimationItem.prototype.play = function (i) {
				i && this.name !== i || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
			}, AnimationItem.prototype.pause = function (i) {
				i && this.name !== i || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause())
			}, AnimationItem.prototype.togglePause = function (i) {
				i && this.name !== i || (this.isPaused === !0 ? this.play() : this.pause())
			}, AnimationItem.prototype.stop = function (i) {
				i && this.name !== i || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
			}, AnimationItem.prototype.getMarkerData = function (i) {
				for (var t, e = 0; e < this.markers.length; e += 1)
					if (t = this.markers[e], t.payload && t.payload.name === i) return t;
				return null
			}, AnimationItem.prototype.goToAndStop = function (i, t, e) {
				if (!(e && this.name !== e)) {
					var n = Number(i);
					if (isNaN(n)) {
						var r = this.getMarkerData(i);
						r && this.goToAndStop(r.time, !0)
					} else t ? this.setCurrentRawFrameValue(i) : this.setCurrentRawFrameValue(i * this.frameModifier);
					this.pause()
				}
			}, AnimationItem.prototype.goToAndPlay = function (i, t, e) {
				if (!(e && this.name !== e)) {
					var n = Number(i);
					if (isNaN(n)) {
						var r = this.getMarkerData(i);
						r && (r.duration ? this.playSegments([r.time, r.time + r.duration], !0) : this.goToAndStop(r.time, !0))
					} else this.goToAndStop(n, t, e);
					this.play()
				}
			}, AnimationItem.prototype.advanceTime = function (i) {
				if (!(this.isPaused === !0 || this.isLoaded === !1)) {
					var t = this.currentRawFrame + i * this.frameModifier,
						e = !1;
					t >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(t > this.totalFrames ? t % this.totalFrames : 0) || (e = !0, t = this.totalFrames - 1) : t >= this.totalFrames ? (this.playCount += 1, this.checkSegments(t % this.totalFrames) || (this.setCurrentRawFrameValue(t % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(t) : t < 0 ? this.checkSegments(t % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + t % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (e = !0, t = 0)) : this.setCurrentRawFrameValue(t), e && (this.setCurrentRawFrameValue(t), this.pause(), this.trigger("complete"))
				}
			}, AnimationItem.prototype.adjustSegment = function (i, t) {
				this.playCount = 0, i[1] < i[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = i[0] - i[1], this.timeCompleted = this.totalFrames, this.firstFrame = i[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - t)) : i[1] > i[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = i[1] - i[0], this.timeCompleted = this.totalFrames, this.firstFrame = i[0], this.setCurrentRawFrameValue(.001 + t)), this.trigger("segmentStart")
			}, AnimationItem.prototype.setSegment = function (i, t) {
				var e = -1;
				this.isPaused && (this.currentRawFrame + this.firstFrame < i ? e = i : this.currentRawFrame + this.firstFrame > t && (e = t - i)), this.firstFrame = i, this.totalFrames = t - i, this.timeCompleted = this.totalFrames, e !== -1 && this.goToAndStop(e, !0)
			}, AnimationItem.prototype.playSegments = function (i, t) {
				if (t && (this.segments.length = 0), _typeof$4(i[0]) === "object") {
					var e, n = i.length;
					for (e = 0; e < n; e += 1) this.segments.push(i[e])
				} else this.segments.push(i);
				this.segments.length && t && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
			}, AnimationItem.prototype.resetSegments = function (i) {
				this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), i && this.checkSegments(0)
			}, AnimationItem.prototype.checkSegments = function (i) {
				return this.segments.length ? (this.adjustSegment(this.segments.shift(), i), !0) : !1
			}, AnimationItem.prototype.destroy = function (i) {
				i && this.name !== i || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null)
			}, AnimationItem.prototype.setCurrentRawFrameValue = function (i) {
				this.currentRawFrame = i, this.gotoFrame()
			}, AnimationItem.prototype.setSpeed = function (i) {
				this.playSpeed = i, this.updaFrameModifier()
			}, AnimationItem.prototype.setDirection = function (i) {
				this.playDirection = i < 0 ? -1 : 1, this.updaFrameModifier()
			}, AnimationItem.prototype.setLoop = function (i) {
				this.loop = i
			}, AnimationItem.prototype.setVolume = function (i, t) {
				t && this.name !== t || this.audioController.setVolume(i)
			}, AnimationItem.prototype.getVolume = function () {
				return this.audioController.getVolume()
			}, AnimationItem.prototype.mute = function (i) {
				i && this.name !== i || this.audioController.mute()
			}, AnimationItem.prototype.unmute = function (i) {
				i && this.name !== i || this.audioController.unmute()
			}, AnimationItem.prototype.updaFrameModifier = function () {
				this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
			}, AnimationItem.prototype.getPath = function () {
				return this.path
			}, AnimationItem.prototype.getAssetsPath = function (i) {
				var t = "";
				if (i.e) t = i.p;
				else if (this.assetsPath) {
					var e = i.p;
					e.indexOf("images/") !== -1 && (e = e.split("/")[1]), t = this.assetsPath + e
				} else t = this.path, t += i.u ? i.u : "", t += i.p;
				return t
			}, AnimationItem.prototype.getAssetData = function (i) {
				for (var t = 0, e = this.assets.length; t < e;) {
					if (i === this.assets[t].id) return this.assets[t];
					t += 1
				}
				return null
			}, AnimationItem.prototype.hide = function () {
				this.renderer.hide()
			}, AnimationItem.prototype.show = function () {
				this.renderer.show()
			}, AnimationItem.prototype.getDuration = function (i) {
				return i ? this.totalFrames : this.totalFrames / this.frameRate
			}, AnimationItem.prototype.updateDocumentData = function (i, t, e) {
				try {
					var n = this.renderer.getElementByPath(i);
					n.updateDocumentData(t, e)
				} catch (r) {}
			}, AnimationItem.prototype.trigger = function (i) {
				if (this._cbs && this._cbs[i]) switch (i) {
					case "enterFrame":
						this.triggerEvent(i, new BMEnterFrameEvent(i, this.currentFrame, this.totalFrames, this.frameModifier));
						break;
					case "drawnFrame":
						this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(i, this.drawnFrameEvent);
						break;
					case "loopComplete":
						this.triggerEvent(i, new BMCompleteLoopEvent(i, this.loop, this.playCount, this.frameMult));
						break;
					case "complete":
						this.triggerEvent(i, new BMCompleteEvent(i, this.frameMult));
						break;
					case "segmentStart":
						this.triggerEvent(i, new BMSegmentStartEvent(i, this.firstFrame, this.totalFrames));
						break;
					case "destroy":
						this.triggerEvent(i, new BMDestroyEvent(i, this));
						break;
					default:
						this.triggerEvent(i)
				}
				i === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(i, this.currentFrame, this.totalFrames, this.frameMult)), i === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(i, this.loop, this.playCount, this.frameMult)), i === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(i, this.frameMult)), i === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(i, this.firstFrame, this.totalFrames)), i === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(i, this))
			}, AnimationItem.prototype.triggerRenderFrameError = function (i) {
				var t = new BMRenderFrameErrorEvent(i, this.currentFrame);
				this.triggerEvent("error", t), this.onError && this.onError.call(this, t)
			}, AnimationItem.prototype.triggerConfigError = function (i) {
				var t = new BMConfigErrorEvent(i, this.currentFrame);
				this.triggerEvent("error", t), this.onError && this.onError.call(this, t)
			};
			var animationManager = function () {
					var i = {},
						t = [],
						e = 0,
						n = 0,
						r = 0,
						s = !0,
						a = !1;

					function o(O) {
						for (var B = 0, A = O.target; B < n;) t[B].animation === A && (t.splice(B, 1), B -= 1, n -= 1, A.isPaused || g()), B += 1
					}

					function h(O, B) {
						if (!O) return null;
						for (var A = 0; A < n;) {
							if (t[A].elem === O && t[A].elem !== null) return t[A].animation;
							A += 1
						}
						var D = new AnimationItem;
						return p(D, O), D.setData(O, B), D
					}

					function c() {
						var O, B = t.length,
							A = [];
						for (O = 0; O < B; O += 1) A.push(t[O].animation);
						return A
					}

					function u() {
						r += 1, G()
					}

					function g() {
						r -= 1
					}

					function p(O, B) {
						O.addEventListener("destroy", o), O.addEventListener("_active", u), O.addEventListener("_idle", g), t.push({
							elem: B,
							animation: O
						}), n += 1
					}

					function _(O) {
						var B = new AnimationItem;
						return p(B, null), B.setParams(O), B
					}

					function b(O, B) {
						var A;
						for (A = 0; A < n; A += 1) t[A].animation.setSpeed(O, B)
					}

					function y(O, B) {
						var A;
						for (A = 0; A < n; A += 1) t[A].animation.setDirection(O, B)
					}

					function w(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.play(O)
					}

					function f(O) {
						var B = O - e,
							A;
						for (A = 0; A < n; A += 1) t[A].animation.advanceTime(B);
						e = O, r && !a ? window.requestAnimationFrame(f) : s = !0
					}

					function S(O) {
						e = O, window.requestAnimationFrame(f)
					}

					function x(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.pause(O)
					}

					function M(O, B, A) {
						var D;
						for (D = 0; D < n; D += 1) t[D].animation.goToAndStop(O, B, A)
					}

					function T(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.stop(O)
					}

					function I(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.togglePause(O)
					}

					function L(O) {
						var B;
						for (B = n - 1; B >= 0; B -= 1) t[B].animation.destroy(O)
					}

					function F(O, B, A) {
						var D = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
							H, q = D.length;
						for (H = 0; H < q; H += 1) A && D[H].setAttribute("data-bm-type", A), h(D[H], O);
						if (B && q === 0) {
							A || (A = "svg");
							var Q = document.getElementsByTagName("body")[0];
							Q.innerText = "";
							var tt = createTag("div");
							tt.style.width = "100%", tt.style.height = "100%", tt.setAttribute("data-bm-type", A), Q.appendChild(tt), h(tt, O)
						}
					}

					function k() {
						var O;
						for (O = 0; O < n; O += 1) t[O].animation.resize()
					}

					function G() {
						!a && r && s && (window.requestAnimationFrame(S), s = !1)
					}

					function j() {
						a = !0
					}

					function U() {
						a = !1, G()
					}

					function z(O, B) {
						var A;
						for (A = 0; A < n; A += 1) t[A].animation.setVolume(O, B)
					}

					function $(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.mute(O)
					}

					function W(O) {
						var B;
						for (B = 0; B < n; B += 1) t[B].animation.unmute(O)
					}
					return i.registerAnimation = h, i.loadAnimation = _, i.setSpeed = b, i.setDirection = y, i.play = w, i.pause = x, i.stop = T, i.togglePause = I, i.searchAnimations = F, i.resize = k, i.goToAndStop = M, i.destroy = L, i.freeze = j, i.unfreeze = U, i.setVolume = z, i.mute = $, i.unmute = W, i.getRegisteredAnimations = c, i
				}(),
				BezierFactory = function () {
					var i = {};
					i.getBezierEasing = e;
					var t = {};

					function e(S, x, M, T, I) {
						var L = I || ("bez_" + S + "_" + x + "_" + M + "_" + T).replace(/\./g, "p");
						if (t[L]) return t[L];
						var F = new f([S, x, M, T]);
						return t[L] = F, F
					}
					var n = 4,
						r = .001,
						s = 1e-7,
						a = 10,
						o = 11,
						h = 1 / (o - 1),
						c = typeof Float32Array == "function";

					function u(S, x) {
						return 1 - 3 * x + 3 * S
					}

					function g(S, x) {
						return 3 * x - 6 * S
					}

					function p(S) {
						return 3 * S
					}

					function _(S, x, M) {
						return ((u(x, M) * S + g(x, M)) * S + p(x)) * S
					}

					function b(S, x, M) {
						return 3 * u(x, M) * S * S + 2 * g(x, M) * S + p(x)
					}

					function y(S, x, M, T, I) {
						var L, F, k = 0;
						do F = x + (M - x) / 2, L = _(F, T, I) - S, L > 0 ? M = F : x = F; while (Math.abs(L) > s && ++k < a);
						return F
					}

					function w(S, x, M, T) {
						for (var I = 0; I < n; ++I) {
							var L = b(x, M, T);
							if (L === 0) return x;
							var F = _(x, M, T) - S;
							x -= F / L
						}
						return x
					}

					function f(S) {
						this._p = S, this._mSampleValues = c ? new Float32Array(o) : new Array(o), this._precomputed = !1, this.get = this.get.bind(this)
					}
					return f.prototype = {
						get: function (x) {
							var M = this._p[0],
								T = this._p[1],
								I = this._p[2],
								L = this._p[3];
							return this._precomputed || this._precompute(), M === T && I === L ? x : x === 0 ? 0 : x === 1 ? 1 : _(this._getTForX(x), T, L)
						},
						_precompute: function () {
							var x = this._p[0],
								M = this._p[1],
								T = this._p[2],
								I = this._p[3];
							this._precomputed = !0, (x !== M || T !== I) && this._calcSampleValues()
						},
						_calcSampleValues: function () {
							for (var x = this._p[0], M = this._p[2], T = 0; T < o; ++T) this._mSampleValues[T] = _(T * h, x, M)
						},
						_getTForX: function (x) {
							for (var M = this._p[0], T = this._p[2], I = this._mSampleValues, L = 0, F = 1, k = o - 1; F !== k && I[F] <= x; ++F) L += h;
							--F;
							var G = (x - I[F]) / (I[F + 1] - I[F]),
								j = L + G * h,
								U = b(j, M, T);
							return U >= r ? w(x, j, M, T) : U === 0 ? j : y(x, L, L + h, M, T)
						}
					}, i
				}(),
				pooling = function () {
					function i(t) {
						return t.concat(createSizedArray(t.length))
					}
					return {
						double: i
					}
				}(),
				poolFactory = function () {
					return function (i, t, e) {
						var n = 0,
							r = i,
							s = createSizedArray(r),
							a = {
								newElement: o,
								release: h
							};

						function o() {
							var c;
							return n ? (n -= 1, c = s[n]) : c = t(), c
						}

						function h(c) {
							n === r && (s = pooling.double(s), r *= 2), e && e(c), s[n] = c, n += 1
						}
						return a
					}
				}(),
				bezierLengthPool = function () {
					function i() {
						return {
							addedLength: 0,
							percents: createTypedArray("float32", getDefaultCurveSegments()),
							lengths: createTypedArray("float32", getDefaultCurveSegments())
						}
					}
					return poolFactory(8, i)
				}(),
				segmentsLengthPool = function () {
					function i() {
						return {
							lengths: [],
							totalLength: 0
						}
					}

					function t(e) {
						var n, r = e.lengths.length;
						for (n = 0; n < r; n += 1) bezierLengthPool.release(e.lengths[n]);
						e.lengths.length = 0
					}
					return poolFactory(8, i, t)
				}();

			function bezFunction() {
				var i = Math;

				function t(p, _, b, y, w, f) {
					var S = p * y + _ * w + b * f - w * y - f * p - b * _;
					return S > -.001 && S < .001
				}

				function e(p, _, b, y, w, f, S, x, M) {
					if (b === 0 && f === 0 && M === 0) return t(p, _, y, w, S, x);
					var T = i.sqrt(i.pow(y - p, 2) + i.pow(w - _, 2) + i.pow(f - b, 2)),
						I = i.sqrt(i.pow(S - p, 2) + i.pow(x - _, 2) + i.pow(M - b, 2)),
						L = i.sqrt(i.pow(S - y, 2) + i.pow(x - w, 2) + i.pow(M - f, 2)),
						F;
					return T > I ? T > L ? F = T - I - L : F = L - I - T : L > I ? F = L - I - T : F = I - T - L, F > -1e-4 && F < 1e-4
				}
				var n = function () {
					return function (p, _, b, y) {
						var w = getDefaultCurveSegments(),
							f, S, x, M, T, I = 0,
							L, F = [],
							k = [],
							G = bezierLengthPool.newElement();
						for (x = b.length, f = 0; f < w; f += 1) {
							for (T = f / (w - 1), L = 0, S = 0; S < x; S += 1) M = bmPow(1 - T, 3) * p[S] + 3 * bmPow(1 - T, 2) * T * b[S] + 3 * (1 - T) * bmPow(T, 2) * y[S] + bmPow(T, 3) * _[S], F[S] = M, k[S] !== null && (L += bmPow(F[S] - k[S], 2)), k[S] = F[S];
							L && (L = bmSqrt(L), I += L), G.percents[f] = T, G.lengths[f] = I
						}
						return G.addedLength = I, G
					}
				}();

				function r(p) {
					var _ = segmentsLengthPool.newElement(),
						b = p.c,
						y = p.v,
						w = p.o,
						f = p.i,
						S, x = p._length,
						M = _.lengths,
						T = 0;
					for (S = 0; S < x - 1; S += 1) M[S] = n(y[S], y[S + 1], w[S], f[S + 1]), T += M[S].addedLength;
					return b && x && (M[S] = n(y[S], y[0], w[S], f[0]), T += M[S].addedLength), _.totalLength = T, _
				}

				function s(p) {
					this.segmentLength = 0, this.points = new Array(p)
				}

				function a(p, _) {
					this.partialLength = p, this.point = _
				}
				var o = function () {
					var p = {};
					return function (_, b, y, w) {
						var f = (_[0] + "_" + _[1] + "_" + b[0] + "_" + b[1] + "_" + y[0] + "_" + y[1] + "_" + w[0] + "_" + w[1]).replace(/\./g, "p");
						if (!p[f]) {
							var S = getDefaultCurveSegments(),
								x, M, T, I, L, F = 0,
								k, G, j = null;
							_.length === 2 && (_[0] !== b[0] || _[1] !== b[1]) && t(_[0], _[1], b[0], b[1], _[0] + y[0], _[1] + y[1]) && t(_[0], _[1], b[0], b[1], b[0] + w[0], b[1] + w[1]) && (S = 2);
							var U = new s(S);
							for (T = y.length, x = 0; x < S; x += 1) {
								for (G = createSizedArray(T), L = x / (S - 1), k = 0, M = 0; M < T; M += 1) I = bmPow(1 - L, 3) * _[M] + 3 * bmPow(1 - L, 2) * L * (_[M] + y[M]) + 3 * (1 - L) * bmPow(L, 2) * (b[M] + w[M]) + bmPow(L, 3) * b[M], G[M] = I, j !== null && (k += bmPow(G[M] - j[M], 2));
								k = bmSqrt(k), F += k, U.points[x] = new a(k, G), j = G
							}
							U.segmentLength = F, p[f] = U
						}
						return p[f]
					}
				}();

				function h(p, _) {
					var b = _.percents,
						y = _.lengths,
						w = b.length,
						f = bmFloor((w - 1) * p),
						S = p * _.addedLength,
						x = 0;
					if (f === w - 1 || f === 0 || S === y[f]) return b[f];
					for (var M = y[f] > S ? -1 : 1, T = !0; T;)
						if (y[f] <= S && y[f + 1] > S ? (x = (S - y[f]) / (y[f + 1] - y[f]), T = !1) : f += M, f < 0 || f >= w - 1) {
							if (f === w - 1) return b[f];
							T = !1
						} return b[f] + (b[f + 1] - b[f]) * x
				}

				function c(p, _, b, y, w, f) {
					var S = h(w, f),
						x = 1 - S,
						M = i.round((x * x * x * p[0] + (S * x * x + x * S * x + x * x * S) * b[0] + (S * S * x + x * S * S + S * x * S) * y[0] + S * S * S * _[0]) * 1e3) / 1e3,
						T = i.round((x * x * x * p[1] + (S * x * x + x * S * x + x * x * S) * b[1] + (S * S * x + x * S * S + S * x * S) * y[1] + S * S * S * _[1]) * 1e3) / 1e3;
					return [M, T]
				}
				var u = createTypedArray("float32", 8);

				function g(p, _, b, y, w, f, S) {
					w < 0 ? w = 0 : w > 1 && (w = 1);
					var x = h(w, S);
					f = f > 1 ? 1 : f;
					var M = h(f, S),
						T, I = p.length,
						L = 1 - x,
						F = 1 - M,
						k = L * L * L,
						G = x * L * L * 3,
						j = x * x * L * 3,
						U = x * x * x,
						z = L * L * F,
						$ = x * L * F + L * x * F + L * L * M,
						W = x * x * F + L * x * M + x * L * M,
						O = x * x * M,
						B = L * F * F,
						A = x * F * F + L * M * F + L * F * M,
						D = x * M * F + L * M * M + x * F * M,
						H = x * M * M,
						q = F * F * F,
						Q = M * F * F + F * M * F + F * F * M,
						tt = M * M * F + F * M * M + M * F * M,
						nt = M * M * M;
					for (T = 0; T < I; T += 1) u[T * 4] = i.round((k * p[T] + G * b[T] + j * y[T] + U * _[T]) * 1e3) / 1e3, u[T * 4 + 1] = i.round((z * p[T] + $ * b[T] + W * y[T] + O * _[T]) * 1e3) / 1e3, u[T * 4 + 2] = i.round((B * p[T] + A * b[T] + D * y[T] + H * _[T]) * 1e3) / 1e3, u[T * 4 + 3] = i.round((q * p[T] + Q * b[T] + tt * y[T] + nt * _[T]) * 1e3) / 1e3;
					return u
				}
				return {
					getSegmentsLength: r,
					getNewSegment: g,
					getPointInSegment: c,
					buildBezierData: o,
					pointOnLine2D: t,
					pointOnLine3D: e
				}
			}
			var bez = bezFunction(),
				initFrame = initialDefaultFrame,
				mathAbs = Math.abs;

			function interpolateValue(i, t) {
				var e = this.offsetTime,
					n;
				this.propType === "multidimensional" && (n = createTypedArray("float32", this.pv.length));
				for (var r = t.lastIndex, s = r, a = this.keyframes.length - 1, o = !0, h, c, u; o;) {
					if (h = this.keyframes[s], c = this.keyframes[s + 1], s === a - 1 && i >= c.t - e) {
						h.h && (h = c), r = 0;
						break
					}
					if (c.t - e > i) {
						r = s;
						break
					}
					s < a - 1 ? s += 1 : (r = 0, o = !1)
				}
				u = this.keyframesMetadata[s] || {};
				var g, p, _, b, y, w, f = c.t - e,
					S = h.t - e,
					x;
				if (h.to) {
					u.bezierData || (u.bezierData = bez.buildBezierData(h.s, c.s || h.e, h.to, h.ti));
					var M = u.bezierData;
					if (i >= f || i < S) {
						var T = i >= f ? M.points.length - 1 : 0;
						for (p = M.points[T].point.length, g = 0; g < p; g += 1) n[g] = M.points[T].point[g]
					} else {
						u.__fnct ? w = u.__fnct : (w = BezierFactory.getBezierEasing(h.o.x, h.o.y, h.i.x, h.i.y, h.n).get, u.__fnct = w), _ = w((i - S) / (f - S));
						var I = M.segmentLength * _,
							L, F = t.lastFrame < i && t._lastKeyframeIndex === s ? t._lastAddedLength : 0;
						for (y = t.lastFrame < i && t._lastKeyframeIndex === s ? t._lastPoint : 0, o = !0, b = M.points.length; o;) {
							if (F += M.points[y].partialLength, I === 0 || _ === 0 || y === M.points.length - 1) {
								for (p = M.points[y].point.length, g = 0; g < p; g += 1) n[g] = M.points[y].point[g];
								break
							} else if (I >= F && I < F + M.points[y + 1].partialLength) {
								for (L = (I - F) / M.points[y + 1].partialLength, p = M.points[y].point.length, g = 0; g < p; g += 1) n[g] = M.points[y].point[g] + (M.points[y + 1].point[g] - M.points[y].point[g]) * L;
								break
							}
							y < b - 1 ? y += 1 : o = !1
						}
						t._lastPoint = y, t._lastAddedLength = F - M.points[y].partialLength, t._lastKeyframeIndex = s
					}
				} else {
					var k, G, j, U, z;
					if (a = h.s.length, x = c.s || h.e, this.sh && h.h !== 1)
						if (i >= f) n[0] = x[0], n[1] = x[1], n[2] = x[2];
						else if (i <= S) n[0] = h.s[0], n[1] = h.s[1], n[2] = h.s[2];
					else {
						var $ = createQuaternion(h.s),
							W = createQuaternion(x),
							O = (i - S) / (f - S);
						quaternionToEuler(n, slerp($, W, O))
					} else
						for (s = 0; s < a; s += 1) h.h !== 1 && (i >= f ? _ = 1 : i < S ? _ = 0 : (h.o.x.constructor === Array ? (u.__fnct || (u.__fnct = []), u.__fnct[s] ? w = u.__fnct[s] : (k = h.o.x[s] === void 0 ? h.o.x[0] : h.o.x[s], G = h.o.y[s] === void 0 ? h.o.y[0] : h.o.y[s], j = h.i.x[s] === void 0 ? h.i.x[0] : h.i.x[s], U = h.i.y[s] === void 0 ? h.i.y[0] : h.i.y[s], w = BezierFactory.getBezierEasing(k, G, j, U).get, u.__fnct[s] = w)) : u.__fnct ? w = u.__fnct : (k = h.o.x, G = h.o.y, j = h.i.x, U = h.i.y, w = BezierFactory.getBezierEasing(k, G, j, U).get, h.keyframeMetadata = w), _ = w((i - S) / (f - S)))), x = c.s || h.e, z = h.h === 1 ? h.s[s] : h.s[s] + (x[s] - h.s[s]) * _, this.propType === "multidimensional" ? n[s] = z : n = z
				}
				return t.lastIndex = r, n
			}

			function slerp(i, t, e) {
				var n = [],
					r = i[0],
					s = i[1],
					a = i[2],
					o = i[3],
					h = t[0],
					c = t[1],
					u = t[2],
					g = t[3],
					p, _, b, y, w;
				return _ = r * h + s * c + a * u + o * g, _ < 0 && (_ = -_, h = -h, c = -c, u = -u, g = -g), 1 - _ > 1e-6 ? (p = Math.acos(_), b = Math.sin(p), y = Math.sin((1 - e) * p) / b, w = Math.sin(e * p) / b) : (y = 1 - e, w = e), n[0] = y * r + w * h, n[1] = y * s + w * c, n[2] = y * a + w * u, n[3] = y * o + w * g, n
			}

			function quaternionToEuler(i, t) {
				var e = t[0],
					n = t[1],
					r = t[2],
					s = t[3],
					a = Math.atan2(2 * n * s - 2 * e * r, 1 - 2 * n * n - 2 * r * r),
					o = Math.asin(2 * e * n + 2 * r * s),
					h = Math.atan2(2 * e * s - 2 * n * r, 1 - 2 * e * e - 2 * r * r);
				i[0] = a / degToRads, i[1] = o / degToRads, i[2] = h / degToRads
			}

			function createQuaternion(i) {
				var t = i[0] * degToRads,
					e = i[1] * degToRads,
					n = i[2] * degToRads,
					r = Math.cos(t / 2),
					s = Math.cos(e / 2),
					a = Math.cos(n / 2),
					o = Math.sin(t / 2),
					h = Math.sin(e / 2),
					c = Math.sin(n / 2),
					u = r * s * a - o * h * c,
					g = o * h * a + r * s * c,
					p = o * s * a + r * h * c,
					_ = r * h * a - o * s * c;
				return [g, p, _, u]
			}

			function getValueAtCurrentTime() {
				var i = this.comp.renderedFrame - this.offsetTime,
					t = this.keyframes[0].t - this.offsetTime,
					e = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
				if (!(i === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= e && i >= e || this._caching.lastFrame < t && i < t))) {
					this._caching.lastFrame >= i && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
					var n = this.interpolateValue(i, this._caching);
					this.pv = n
				}
				return this._caching.lastFrame = i, this.pv
			}

			function setVValue(i) {
				var t;
				if (this.propType === "unidimensional") t = i * this.mult, mathAbs(this.v - t) > 1e-5 && (this.v = t, this._mdf = !0);
				else
					for (var e = 0, n = this.v.length; e < n;) t = i[e] * this.mult, mathAbs(this.v[e] - t) > 1e-5 && (this.v[e] = t, this._mdf = !0), e += 1
			}

			function processEffectsSequence() {
				if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
					if (this.lock) {
						this.setVValue(this.pv);
						return
					}
					this.lock = !0, this._mdf = this._isFirstFrame;
					var i, t = this.effectsSequence.length,
						e = this.kf ? this.pv : this.data.k;
					for (i = 0; i < t; i += 1) e = this.effectsSequence[i](e);
					this.setVValue(e), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
				}
			}

			function addEffect(i) {
				this.effectsSequence.push(i), this.container.addDynamicProperty(this)
			}

			function ValueProperty(i, t, e, n) {
				this.propType = "unidimensional", this.mult = e || 1, this.data = t, this.v = e ? t.k * e : t.k, this.pv = t.k, this._mdf = !1, this.elem = i, this.container = n, this.comp = i.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
			}

			function MultiDimensionalProperty(i, t, e, n) {
				this.propType = "multidimensional", this.mult = e || 1, this.data = t, this._mdf = !1, this.elem = i, this.container = n, this.comp = i.comp, this.k = !1, this.kf = !1, this.frameId = -1;
				var r, s = t.k.length;
				for (this.v = createTypedArray("float32", s), this.pv = createTypedArray("float32", s), this.vel = createTypedArray("float32", s), r = 0; r < s; r += 1) this.v[r] = t.k[r] * this.mult, this.pv[r] = t.k[r];
				this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
			}

			function KeyframedValueProperty(i, t, e, n) {
				this.propType = "unidimensional", this.keyframes = t.k, this.keyframesMetadata = [], this.offsetTime = i.data.st, this.frameId = -1, this._caching = {
					lastFrame: initFrame,
					lastIndex: 0,
					value: 0,
					_lastKeyframeIndex: -1
				}, this.k = !0, this.kf = !0, this.data = t, this.mult = e || 1, this.elem = i, this.container = n, this.comp = i.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect
			}

			function KeyframedMultidimensionalProperty(i, t, e, n) {
				this.propType = "multidimensional";
				var r, s = t.k.length,
					a, o, h, c;
				for (r = 0; r < s - 1; r += 1) t.k[r].to && t.k[r].s && t.k[r + 1] && t.k[r + 1].s && (a = t.k[r].s, o = t.k[r + 1].s, h = t.k[r].to, c = t.k[r].ti, (a.length === 2 && !(a[0] === o[0] && a[1] === o[1]) && bez.pointOnLine2D(a[0], a[1], o[0], o[1], a[0] + h[0], a[1] + h[1]) && bez.pointOnLine2D(a[0], a[1], o[0], o[1], o[0] + c[0], o[1] + c[1]) || a.length === 3 && !(a[0] === o[0] && a[1] === o[1] && a[2] === o[2]) && bez.pointOnLine3D(a[0], a[1], a[2], o[0], o[1], o[2], a[0] + h[0], a[1] + h[1], a[2] + h[2]) && bez.pointOnLine3D(a[0], a[1], a[2], o[0], o[1], o[2], o[0] + c[0], o[1] + c[1], o[2] + c[2])) && (t.k[r].to = null, t.k[r].ti = null), a[0] === o[0] && a[1] === o[1] && h[0] === 0 && h[1] === 0 && c[0] === 0 && c[1] === 0 && (a.length === 2 || a[2] === o[2] && h[2] === 0 && c[2] === 0) && (t.k[r].to = null, t.k[r].ti = null));
				this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = t, this.keyframes = t.k, this.keyframesMetadata = [], this.offsetTime = i.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = e || 1, this.elem = i, this.container = n, this.comp = i.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
				var u = t.k[0].s.length;
				for (this.v = createTypedArray("float32", u), this.pv = createTypedArray("float32", u), r = 0; r < u; r += 1) this.v[r] = initFrame, this.pv[r] = initFrame;
				this._caching = {
					lastFrame: initFrame,
					lastIndex: 0,
					value: createTypedArray("float32", u)
				}, this.addEffect = addEffect
			}
			var PropertyFactory = function () {
				function i(e, n, r, s, a) {
					n.sid && (n = e.globalData.slotManager.getProp(n));
					var o;
					if (!n.k.length) o = new ValueProperty(e, n, s, a);
					else if (typeof n.k[0] == "number") o = new MultiDimensionalProperty(e, n, s, a);
					else switch (r) {
						case 0:
							o = new KeyframedValueProperty(e, n, s, a);
							break;
						case 1:
							o = new KeyframedMultidimensionalProperty(e, n, s, a);
							break;
						default:
							break
					}
					return o.effectsSequence.length && a.addDynamicProperty(o), o
				}
				var t = {
					getProp: i
				};
				return t
			}();

			function DynamicPropertyContainer() {}
			DynamicPropertyContainer.prototype = {
				addDynamicProperty: function (t) {
					this.dynamicProperties.indexOf(t) === -1 && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
				},
				iterateDynamicProperties: function () {
					this._mdf = !1;
					var t, e = this.dynamicProperties.length;
					for (t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0)
				},
				initDynamicPropertyContainer: function (t) {
					this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
				}
			};
			var pointPool = function () {
				function i() {
					return createTypedArray("float32", 2)
				}
				return poolFactory(8, i)
			}();

			function ShapePath() {
				this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
			}
			ShapePath.prototype.setPathData = function (i, t) {
				this.c = i, this.setLength(t);
				for (var e = 0; e < t;) this.v[e] = pointPool.newElement(), this.o[e] = pointPool.newElement(), this.i[e] = pointPool.newElement(), e += 1
			}, ShapePath.prototype.setLength = function (i) {
				for (; this._maxLength < i;) this.doubleArrayLength();
				this._length = i
			}, ShapePath.prototype.doubleArrayLength = function () {
				this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
			}, ShapePath.prototype.setXYAt = function (i, t, e, n, r) {
				var s;
				switch (this._length = Math.max(this._length, n + 1), this._length >= this._maxLength && this.doubleArrayLength(), e) {
					case "v":
						s = this.v;
						break;
					case "i":
						s = this.i;
						break;
					case "o":
						s = this.o;
						break;
					default:
						s = [];
						break
				}(!s[n] || s[n] && !r) && (s[n] = pointPool.newElement()), s[n][0] = i, s[n][1] = t
			}, ShapePath.prototype.setTripleAt = function (i, t, e, n, r, s, a, o) {
				this.setXYAt(i, t, "v", a, o), this.setXYAt(e, n, "o", a, o), this.setXYAt(r, s, "i", a, o)
			}, ShapePath.prototype.reverse = function () {
				var i = new ShapePath;
				i.setPathData(this.c, this._length);
				var t = this.v,
					e = this.o,
					n = this.i,
					r = 0;
				this.c && (i.setTripleAt(t[0][0], t[0][1], n[0][0], n[0][1], e[0][0], e[0][1], 0, !1), r = 1);
				var s = this._length - 1,
					a = this._length,
					o;
				for (o = r; o < a; o += 1) i.setTripleAt(t[s][0], t[s][1], n[s][0], n[s][1], e[s][0], e[s][1], o, !1), s -= 1;
				return i
			}, ShapePath.prototype.length = function () {
				return this._length
			};
			var shapePool = function () {
				function i() {
					return new ShapePath
				}

				function t(r) {
					var s = r._length,
						a;
					for (a = 0; a < s; a += 1) pointPool.release(r.v[a]), pointPool.release(r.i[a]), pointPool.release(r.o[a]), r.v[a] = null, r.i[a] = null, r.o[a] = null;
					r._length = 0, r.c = !1
				}

				function e(r) {
					var s = n.newElement(),
						a, o = r._length === void 0 ? r.v.length : r._length;
					for (s.setLength(o), s.c = r.c, a = 0; a < o; a += 1) s.setTripleAt(r.v[a][0], r.v[a][1], r.o[a][0], r.o[a][1], r.i[a][0], r.i[a][1], a);
					return s
				}
				var n = poolFactory(4, i, t);
				return n.clone = e, n
			}();

			function ShapeCollection() {
				this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
			}
			ShapeCollection.prototype.addShape = function (i) {
				this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = i, this._length += 1
			}, ShapeCollection.prototype.releaseShapes = function () {
				var i;
				for (i = 0; i < this._length; i += 1) shapePool.release(this.shapes[i]);
				this._length = 0
			};
			var shapeCollectionPool = function () {
					var i = {
							newShapeCollection: r,
							release: s
						},
						t = 0,
						e = 4,
						n = createSizedArray(e);

					function r() {
						var a;
						return t ? (t -= 1, a = n[t]) : a = new ShapeCollection, a
					}

					function s(a) {
						var o, h = a._length;
						for (o = 0; o < h; o += 1) shapePool.release(a.shapes[o]);
						a._length = 0, t === e && (n = pooling.double(n), e *= 2), n[t] = a, t += 1
					}
					return i
				}(),
				ShapePropertyFactory = function () {
					var i = -999999;

					function t(f, S, x) {
						var M = x.lastIndex,
							T, I, L, F, k, G, j, U, z, $ = this.keyframes;
						if (f < $[0].t - this.offsetTime) T = $[0].s[0], L = !0, M = 0;
						else if (f >= $[$.length - 1].t - this.offsetTime) T = $[$.length - 1].s ? $[$.length - 1].s[0] : $[$.length - 2].e[0], L = !0;
						else {
							for (var W = M, O = $.length - 1, B = !0, A, D, H; B && (A = $[W], D = $[W + 1], !(D.t - this.offsetTime > f));) W < O - 1 ? W += 1 : B = !1;
							if (H = this.keyframesMetadata[W] || {}, L = A.h === 1, M = W, !L) {
								if (f >= D.t - this.offsetTime) U = 1;
								else if (f < A.t - this.offsetTime) U = 0;
								else {
									var q;
									H.__fnct ? q = H.__fnct : (q = BezierFactory.getBezierEasing(A.o.x, A.o.y, A.i.x, A.i.y).get, H.__fnct = q), U = q((f - (A.t - this.offsetTime)) / (D.t - this.offsetTime - (A.t - this.offsetTime)))
								}
								I = D.s ? D.s[0] : A.e[0]
							}
							T = A.s[0]
						}
						for (G = S._length, j = T.i[0].length, x.lastIndex = M, F = 0; F < G; F += 1)
							for (k = 0; k < j; k += 1) z = L ? T.i[F][k] : T.i[F][k] + (I.i[F][k] - T.i[F][k]) * U, S.i[F][k] = z, z = L ? T.o[F][k] : T.o[F][k] + (I.o[F][k] - T.o[F][k]) * U, S.o[F][k] = z, z = L ? T.v[F][k] : T.v[F][k] + (I.v[F][k] - T.v[F][k]) * U, S.v[F][k] = z
					}

					function e() {
						var f = this.comp.renderedFrame - this.offsetTime,
							S = this.keyframes[0].t - this.offsetTime,
							x = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
							M = this._caching.lastFrame;
						return M !== i && (M < S && f < S || M > x && f > x) || (this._caching.lastIndex = M < f ? this._caching.lastIndex : 0, this.interpolateShape(f, this.pv, this._caching)), this._caching.lastFrame = f, this.pv
					}

					function n() {
						this.paths = this.localShapeCollection
					}

					function r(f, S) {
						if (f._length !== S._length || f.c !== S.c) return !1;
						var x, M = f._length;
						for (x = 0; x < M; x += 1)
							if (f.v[x][0] !== S.v[x][0] || f.v[x][1] !== S.v[x][1] || f.o[x][0] !== S.o[x][0] || f.o[x][1] !== S.o[x][1] || f.i[x][0] !== S.i[x][0] || f.i[x][1] !== S.i[x][1]) return !1;
						return !0
					}

					function s(f) {
						r(this.v, f) || (this.v = shapePool.clone(f), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
					}

					function a() {
						if (this.elem.globalData.frameId !== this.frameId) {
							if (!this.effectsSequence.length) {
								this._mdf = !1;
								return
							}
							if (this.lock) {
								this.setVValue(this.pv);
								return
							}
							this.lock = !0, this._mdf = !1;
							var f;
							this.kf ? f = this.pv : this.data.ks ? f = this.data.ks.k : f = this.data.pt.k;
							var S, x = this.effectsSequence.length;
							for (S = 0; S < x; S += 1) f = this.effectsSequence[S](f);
							this.setVValue(f), this.lock = !1, this.frameId = this.elem.globalData.frameId
						}
					}

					function o(f, S, x) {
						this.propType = "shape", this.comp = f.comp, this.container = f, this.elem = f, this.data = S, this.k = !1, this.kf = !1, this._mdf = !1;
						var M = x === 3 ? S.pt.k : S.ks.k;
						this.v = shapePool.clone(M), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = n, this.effectsSequence = []
					}

					function h(f) {
						this.effectsSequence.push(f), this.container.addDynamicProperty(this)
					}
					o.prototype.interpolateShape = t, o.prototype.getValue = a, o.prototype.setVValue = s, o.prototype.addEffect = h;

					function c(f, S, x) {
						this.propType = "shape", this.comp = f.comp, this.elem = f, this.container = f, this.offsetTime = f.data.st, this.keyframes = x === 3 ? S.pt.k : S.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
						var M = this.keyframes[0].s[0].i.length;
						this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, M), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = i, this.reset = n, this._caching = {
							lastFrame: i,
							lastIndex: 0
						}, this.effectsSequence = [e.bind(this)]
					}
					c.prototype.getValue = a, c.prototype.interpolateShape = t, c.prototype.setVValue = s, c.prototype.addEffect = h;
					var u = function () {
							var f = roundCorner;

							function S(x, M) {
								this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = M.d, this.elem = x, this.comp = x.comp, this.frameId = -1, this.initDynamicPropertyContainer(x), this.p = PropertyFactory.getProp(x, M.p, 1, 0, this), this.s = PropertyFactory.getProp(x, M.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
							}
							return S.prototype = {
								reset: n,
								getValue: function () {
									this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
								},
								convertEllToPath: function () {
									var M = this.p.v[0],
										T = this.p.v[1],
										I = this.s.v[0] / 2,
										L = this.s.v[1] / 2,
										F = this.d !== 3,
										k = this.v;
									k.v[0][0] = M, k.v[0][1] = T - L, k.v[1][0] = F ? M + I : M - I, k.v[1][1] = T, k.v[2][0] = M, k.v[2][1] = T + L, k.v[3][0] = F ? M - I : M + I, k.v[3][1] = T, k.i[0][0] = F ? M - I * f : M + I * f, k.i[0][1] = T - L, k.i[1][0] = F ? M + I : M - I, k.i[1][1] = T - L * f, k.i[2][0] = F ? M + I * f : M - I * f, k.i[2][1] = T + L, k.i[3][0] = F ? M - I : M + I, k.i[3][1] = T + L * f, k.o[0][0] = F ? M + I * f : M - I * f, k.o[0][1] = T - L, k.o[1][0] = F ? M + I : M - I, k.o[1][1] = T + L * f, k.o[2][0] = F ? M - I * f : M + I * f, k.o[2][1] = T + L, k.o[3][0] = F ? M - I : M + I, k.o[3][1] = T - L * f
								}
							}, extendPrototype([DynamicPropertyContainer], S), S
						}(),
						g = function () {
							function f(S, x) {
								this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = S, this.comp = S.comp, this.data = x, this.frameId = -1, this.d = x.d, this.initDynamicPropertyContainer(S), x.sy === 1 ? (this.ir = PropertyFactory.getProp(S, x.ir, 0, 0, this), this.is = PropertyFactory.getProp(S, x.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(S, x.pt, 0, 0, this), this.p = PropertyFactory.getProp(S, x.p, 1, 0, this), this.r = PropertyFactory.getProp(S, x.r, 0, degToRads, this), this.or = PropertyFactory.getProp(S, x.or, 0, 0, this), this.os = PropertyFactory.getProp(S, x.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
							}
							return f.prototype = {
								reset: n,
								getValue: function () {
									this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
								},
								convertStarToPath: function () {
									var x = Math.floor(this.pt.v) * 2,
										M = Math.PI * 2 / x,
										T = !0,
										I = this.or.v,
										L = this.ir.v,
										F = this.os.v,
										k = this.is.v,
										G = 2 * Math.PI * I / (x * 2),
										j = 2 * Math.PI * L / (x * 2),
										U, z, $, W, O = -Math.PI / 2;
									O += this.r.v;
									var B = this.data.d === 3 ? -1 : 1;
									for (this.v._length = 0, U = 0; U < x; U += 1) {
										z = T ? I : L, $ = T ? F : k, W = T ? G : j;
										var A = z * Math.cos(O),
											D = z * Math.sin(O),
											H = A === 0 && D === 0 ? 0 : D / Math.sqrt(A * A + D * D),
											q = A === 0 && D === 0 ? 0 : -A / Math.sqrt(A * A + D * D);
										A += +this.p.v[0], D += +this.p.v[1], this.v.setTripleAt(A, D, A - H * W * $ * B, D - q * W * $ * B, A + H * W * $ * B, D + q * W * $ * B, U, !0), T = !T, O += M * B
									}
								},
								convertPolygonToPath: function () {
									var x = Math.floor(this.pt.v),
										M = Math.PI * 2 / x,
										T = this.or.v,
										I = this.os.v,
										L = 2 * Math.PI * T / (x * 4),
										F, k = -Math.PI * .5,
										G = this.data.d === 3 ? -1 : 1;
									for (k += this.r.v, this.v._length = 0, F = 0; F < x; F += 1) {
										var j = T * Math.cos(k),
											U = T * Math.sin(k),
											z = j === 0 && U === 0 ? 0 : U / Math.sqrt(j * j + U * U),
											$ = j === 0 && U === 0 ? 0 : -j / Math.sqrt(j * j + U * U);
										j += +this.p.v[0], U += +this.p.v[1], this.v.setTripleAt(j, U, j - z * L * I * G, U - $ * L * I * G, j + z * L * I * G, U + $ * L * I * G, F, !0), k += M * G
									}
									this.paths.length = 0, this.paths[0] = this.v
								}
							}, extendPrototype([DynamicPropertyContainer], f), f
						}(),
						p = function () {
							function f(S, x) {
								this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = S, this.comp = S.comp, this.frameId = -1, this.d = x.d, this.initDynamicPropertyContainer(S), this.p = PropertyFactory.getProp(S, x.p, 1, 0, this), this.s = PropertyFactory.getProp(S, x.s, 1, 0, this), this.r = PropertyFactory.getProp(S, x.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
							}
							return f.prototype = {
								convertRectToPath: function () {
									var x = this.p.v[0],
										M = this.p.v[1],
										T = this.s.v[0] / 2,
										I = this.s.v[1] / 2,
										L = bmMin(T, I, this.r.v),
										F = L * (1 - roundCorner);
									this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(x + T, M - I + L, x + T, M - I + L, x + T, M - I + F, 0, !0), this.v.setTripleAt(x + T, M + I - L, x + T, M + I - F, x + T, M + I - L, 1, !0), L !== 0 ? (this.v.setTripleAt(x + T - L, M + I, x + T - L, M + I, x + T - F, M + I, 2, !0), this.v.setTripleAt(x - T + L, M + I, x - T + F, M + I, x - T + L, M + I, 3, !0), this.v.setTripleAt(x - T, M + I - L, x - T, M + I - L, x - T, M + I - F, 4, !0), this.v.setTripleAt(x - T, M - I + L, x - T, M - I + F, x - T, M - I + L, 5, !0), this.v.setTripleAt(x - T + L, M - I, x - T + L, M - I, x - T + F, M - I, 6, !0), this.v.setTripleAt(x + T - L, M - I, x + T - F, M - I, x + T - L, M - I, 7, !0)) : (this.v.setTripleAt(x - T, M + I, x - T + F, M + I, x - T, M + I, 2), this.v.setTripleAt(x - T, M - I, x - T, M - I + F, x - T, M - I, 3))) : (this.v.setTripleAt(x + T, M - I + L, x + T, M - I + F, x + T, M - I + L, 0, !0), L !== 0 ? (this.v.setTripleAt(x + T - L, M - I, x + T - L, M - I, x + T - F, M - I, 1, !0), this.v.setTripleAt(x - T + L, M - I, x - T + F, M - I, x - T + L, M - I, 2, !0), this.v.setTripleAt(x - T, M - I + L, x - T, M - I + L, x - T, M - I + F, 3, !0), this.v.setTripleAt(x - T, M + I - L, x - T, M + I - F, x - T, M + I - L, 4, !0), this.v.setTripleAt(x - T + L, M + I, x - T + L, M + I, x - T + F, M + I, 5, !0), this.v.setTripleAt(x + T - L, M + I, x + T - F, M + I, x + T - L, M + I, 6, !0), this.v.setTripleAt(x + T, M + I - L, x + T, M + I - L, x + T, M + I - F, 7, !0)) : (this.v.setTripleAt(x - T, M - I, x - T + F, M - I, x - T, M - I, 1, !0), this.v.setTripleAt(x - T, M + I, x - T, M + I - F, x - T, M + I, 2, !0), this.v.setTripleAt(x + T, M + I, x + T - F, M + I, x + T, M + I, 3, !0)))
								},
								getValue: function () {
									this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
								},
								reset: n
							}, extendPrototype([DynamicPropertyContainer], f), f
						}();

					function _(f, S, x) {
						var M;
						if (x === 3 || x === 4) {
							var T = x === 3 ? S.pt : S.ks,
								I = T.k;
							I.length ? M = new c(f, S, x) : M = new o(f, S, x)
						} else x === 5 ? M = new p(f, S) : x === 6 ? M = new u(f, S) : x === 7 && (M = new g(f, S));
						return M.k && f.addDynamicProperty(M), M
					}

					function b() {
						return o
					}

					function y() {
						return c
					}
					var w = {};
					return w.getShapeProp = _, w.getConstructorFunction = b, w.getKeyframedConstructorFunction = y, w
				}();
			var Matrix = function () {
				var i = Math.cos,
					t = Math.sin,
					e = Math.tan,
					n = Math.round;

				function r() {
					return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
				}

				function s(A) {
					if (A === 0) return this;
					var D = i(A),
						H = t(A);
					return this._t(D, -H, 0, 0, H, D, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
				}

				function a(A) {
					if (A === 0) return this;
					var D = i(A),
						H = t(A);
					return this._t(1, 0, 0, 0, 0, D, -H, 0, 0, H, D, 0, 0, 0, 0, 1)
				}

				function o(A) {
					if (A === 0) return this;
					var D = i(A),
						H = t(A);
					return this._t(D, 0, H, 0, 0, 1, 0, 0, -H, 0, D, 0, 0, 0, 0, 1)
				}

				function h(A) {
					if (A === 0) return this;
					var D = i(A),
						H = t(A);
					return this._t(D, -H, 0, 0, H, D, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
				}

				function c(A, D) {
					return this._t(1, D, A, 1, 0, 0)
				}

				function u(A, D) {
					return this.shear(e(A), e(D))
				}

				function g(A, D) {
					var H = i(D),
						q = t(D);
					return this._t(H, q, 0, 0, -q, H, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, e(A), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(H, -q, 0, 0, q, H, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
				}

				function p(A, D, H) {
					return !H && H !== 0 && (H = 1), A === 1 && D === 1 && H === 1 ? this : this._t(A, 0, 0, 0, 0, D, 0, 0, 0, 0, H, 0, 0, 0, 0, 1)
				}

				function _(A, D, H, q, Q, tt, nt, ut, et, it, Et, wt, yt, At, Vt, lt) {
					return this.props[0] = A, this.props[1] = D, this.props[2] = H, this.props[3] = q, this.props[4] = Q, this.props[5] = tt, this.props[6] = nt, this.props[7] = ut, this.props[8] = et, this.props[9] = it, this.props[10] = Et, this.props[11] = wt, this.props[12] = yt, this.props[13] = At, this.props[14] = Vt, this.props[15] = lt, this
				}

				function b(A, D, H) {
					return H = H || 0, A !== 0 || D !== 0 || H !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, A, D, H, 1) : this
				}

				function y(A, D, H, q, Q, tt, nt, ut, et, it, Et, wt, yt, At, Vt, lt) {
					var dt = this.props;
					if (A === 1 && D === 0 && H === 0 && q === 0 && Q === 0 && tt === 1 && nt === 0 && ut === 0 && et === 0 && it === 0 && Et === 1 && wt === 0) return dt[12] = dt[12] * A + dt[15] * yt, dt[13] = dt[13] * tt + dt[15] * At, dt[14] = dt[14] * Et + dt[15] * Vt, dt[15] *= lt, this._identityCalculated = !1, this;
					var qt = dt[0],
						Zt = dt[1],
						re = dt[2],
						de = dt[3],
						Xt = dt[4],
						le = dt[5],
						ye = dt[6],
						Z = dt[7],
						X = dt[8],
						pt = dt[9],
						xt = dt[10],
						St = dt[11],
						Pt = dt[12],
						Bt = dt[13],
						It = dt[14],
						mt = dt[15];
					return dt[0] = qt * A + Zt * Q + re * et + de * yt, dt[1] = qt * D + Zt * tt + re * it + de * At, dt[2] = qt * H + Zt * nt + re * Et + de * Vt, dt[3] = qt * q + Zt * ut + re * wt + de * lt, dt[4] = Xt * A + le * Q + ye * et + Z * yt, dt[5] = Xt * D + le * tt + ye * it + Z * At, dt[6] = Xt * H + le * nt + ye * Et + Z * Vt, dt[7] = Xt * q + le * ut + ye * wt + Z * lt, dt[8] = X * A + pt * Q + xt * et + St * yt, dt[9] = X * D + pt * tt + xt * it + St * At, dt[10] = X * H + pt * nt + xt * Et + St * Vt, dt[11] = X * q + pt * ut + xt * wt + St * lt, dt[12] = Pt * A + Bt * Q + It * et + mt * yt, dt[13] = Pt * D + Bt * tt + It * it + mt * At, dt[14] = Pt * H + Bt * nt + It * Et + mt * Vt, dt[15] = Pt * q + Bt * ut + It * wt + mt * lt, this._identityCalculated = !1, this
				}

				function w(A) {
					var D = A.props;
					return this.transform(D[0], D[1], D[2], D[3], D[4], D[5], D[6], D[7], D[8], D[9], D[10], D[11], D[12], D[13], D[14], D[15])
				}

				function f() {
					return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity
				}

				function S(A) {
					for (var D = 0; D < 16;) {
						if (A.props[D] !== this.props[D]) return !1;
						D += 1
					}
					return !0
				}

				function x(A) {
					var D;
					for (D = 0; D < 16; D += 1) A.props[D] = this.props[D];
					return A
				}

				function M(A) {
					var D;
					for (D = 0; D < 16; D += 1) this.props[D] = A[D]
				}

				function T(A, D, H) {
					return {
						x: A * this.props[0] + D * this.props[4] + H * this.props[8] + this.props[12],
						y: A * this.props[1] + D * this.props[5] + H * this.props[9] + this.props[13],
						z: A * this.props[2] + D * this.props[6] + H * this.props[10] + this.props[14]
					}
				}

				function I(A, D, H) {
					return A * this.props[0] + D * this.props[4] + H * this.props[8] + this.props[12]
				}

				function L(A, D, H) {
					return A * this.props[1] + D * this.props[5] + H * this.props[9] + this.props[13]
				}

				function F(A, D, H) {
					return A * this.props[2] + D * this.props[6] + H * this.props[10] + this.props[14]
				}

				function k() {
					var A = this.props[0] * this.props[5] - this.props[1] * this.props[4],
						D = this.props[5] / A,
						H = -this.props[1] / A,
						q = -this.props[4] / A,
						Q = this.props[0] / A,
						tt = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / A,
						nt = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / A,
						ut = new Matrix;
					return ut.props[0] = D, ut.props[1] = H, ut.props[4] = q, ut.props[5] = Q, ut.props[12] = tt, ut.props[13] = nt, ut
				}

				function G(A) {
					var D = this.getInverseMatrix();
					return D.applyToPointArray(A[0], A[1], A[2] || 0)
				}

				function j(A) {
					var D, H = A.length,
						q = [];
					for (D = 0; D < H; D += 1) q[D] = G(A[D]);
					return q
				}

				function U(A, D, H) {
					var q = createTypedArray("float32", 6);
					if (this.isIdentity()) q[0] = A[0], q[1] = A[1], q[2] = D[0], q[3] = D[1], q[4] = H[0], q[5] = H[1];
					else {
						var Q = this.props[0],
							tt = this.props[1],
							nt = this.props[4],
							ut = this.props[5],
							et = this.props[12],
							it = this.props[13];
						q[0] = A[0] * Q + A[1] * nt + et, q[1] = A[0] * tt + A[1] * ut + it, q[2] = D[0] * Q + D[1] * nt + et, q[3] = D[0] * tt + D[1] * ut + it, q[4] = H[0] * Q + H[1] * nt + et, q[5] = H[0] * tt + H[1] * ut + it
					}
					return q
				}

				function z(A, D, H) {
					var q;
					return this.isIdentity() ? q = [A, D, H] : q = [A * this.props[0] + D * this.props[4] + H * this.props[8] + this.props[12], A * this.props[1] + D * this.props[5] + H * this.props[9] + this.props[13], A * this.props[2] + D * this.props[6] + H * this.props[10] + this.props[14]], q
				}

				function $(A, D) {
					if (this.isIdentity()) return A + "," + D;
					var H = this.props;
					return Math.round((A * H[0] + D * H[4] + H[12]) * 100) / 100 + "," + Math.round((A * H[1] + D * H[5] + H[13]) * 100) / 100
				}

				function W() {
					for (var A = 0, D = this.props, H = "matrix3d(", q = 1e4; A < 16;) H += n(D[A] * q) / q, H += A === 15 ? ")" : ",", A += 1;
					return H
				}

				function O(A) {
					var D = 1e4;
					return A < 1e-6 && A > 0 || A > -1e-6 && A < 0 ? n(A * D) / D : A
				}

				function B() {
					var A = this.props,
						D = O(A[0]),
						H = O(A[1]),
						q = O(A[4]),
						Q = O(A[5]),
						tt = O(A[12]),
						nt = O(A[13]);
					return "matrix(" + D + "," + H + "," + q + "," + Q + "," + tt + "," + nt + ")"
				}
				return function () {
					this.reset = r, this.rotate = s, this.rotateX = a, this.rotateY = o, this.rotateZ = h, this.skew = u, this.skewFromAxis = g, this.shear = c, this.scale = p, this.setTransform = _, this.translate = b, this.transform = y, this.multiply = w, this.applyToPoint = T, this.applyToX = I, this.applyToY = L, this.applyToZ = F, this.applyToPointArray = z, this.applyToTriplePoints = U, this.applyToPointStringified = $, this.toCSS = W, this.to2dCSS = B, this.clone = x, this.cloneFromProps = M, this.equals = S, this.inversePoints = j, this.inversePoint = G, this.getInverseMatrix = k, this._t = this.transform, this.isIdentity = f, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
				}
			}();

			function _typeof$3(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function (e) {
					return typeof e
				} : _typeof$3 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$3(i)
			}
			var lottie = {},
				standalone = "__[STANDALONE]__",
				animationData = "__[ANIMATIONDATA]__",
				renderer = "";

			function setLocation(i) {
				setLocationHref(i)
			}

			function searchAnimations() {
				standalone === !0 ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
			}

			function setSubframeRendering(i) {
				setSubframeEnabled(i)
			}

			function setPrefix(i) {
				setIdPrefix(i)
			}

			function loadAnimation(i) {
				return standalone === !0 && (i.animationData = JSON.parse(animationData)), animationManager.loadAnimation(i)
			}

			function setQuality(i) {
				if (typeof i == "string") switch (i) {
					case "high":
						setDefaultCurveSegments(200);
						break;
					default:
					case "medium":
						setDefaultCurveSegments(50);
						break;
					case "low":
						setDefaultCurveSegments(10);
						break
				} else !isNaN(i) && i > 1 && setDefaultCurveSegments(i);
				getDefaultCurveSegments() >= 50 ? roundValues(!1) : roundValues(!0)
			}

			function inBrowser() {
				return typeof navigator != "undefined"
			}

			function installPlugin(i, t) {
				i === "expressions" && setExpressionsPlugin(t)
			}

			function getFactory(i) {
				switch (i) {
					case "propertyFactory":
						return PropertyFactory;
					case "shapePropertyFactory":
						return ShapePropertyFactory;
					case "matrix":
						return Matrix;
					default:
						return null
				}
			}
			lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2";

			function checkReady() {
				document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations())
			}

			function getQueryVariable(i) {
				for (var t = queryString.split("&"), e = 0; e < t.length; e += 1) {
					var n = t[e].split("=");
					if (decodeURIComponent(n[0]) == i) return decodeURIComponent(n[1])
				}
				return null
			}
			var queryString = "";
			if (standalone) {
				var scripts = document.getElementsByTagName("script"),
					index = scripts.length - 1,
					myScript = scripts[index] || {
						src: ""
					};
				queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", renderer = getQueryVariable("renderer")
			}
			var readyStateCheckInterval = setInterval(checkReady, 100);
			try {
				!((typeof exports == "undefined" ? "undefined" : _typeof$3(exports)) === "object" && typeof module != "undefined") && !(typeof define == "function" && define.amd) && (window.bodymovin = lottie)
			} catch (i) {}
			var ShapeModifiers = function () {
				var i = {},
					t = {};
				i.registerModifier = e, i.getModifier = n;

				function e(r, s) {
					t[r] || (t[r] = s)
				}

				function n(r, s, a) {
					return new t[r](s, a)
				}
				return i
			}();

			function ShapeModifier() {}
			ShapeModifier.prototype.initModifierProperties = function () {}, ShapeModifier.prototype.addShapeToModifier = function () {}, ShapeModifier.prototype.addShape = function (i) {
				if (!this.closed) {
					i.sh.container.addDynamicProperty(i.sh);
					var t = {
						shape: i.sh,
						data: i,
						localShapeCollection: shapeCollectionPool.newShapeCollection()
					};
					this.shapes.push(t), this.addShapeToModifier(t), this._isAnimated && i.setAsAnimated()
				}
			}, ShapeModifier.prototype.init = function (i, t) {
				this.shapes = [], this.elem = i, this.initDynamicPropertyContainer(i), this.initModifierProperties(i, t), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
			}, ShapeModifier.prototype.processKeys = function () {
				this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
			}, extendPrototype([DynamicPropertyContainer], ShapeModifier);

			function TrimModifier() {}
			extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (i, t) {
				this.s = PropertyFactory.getProp(i, t.s, 0, .01, this), this.e = PropertyFactory.getProp(i, t.e, 0, .01, this), this.o = PropertyFactory.getProp(i, t.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = t.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
			}, TrimModifier.prototype.addShapeToModifier = function (i) {
				i.pathsData = []
			}, TrimModifier.prototype.calculateShapeEdges = function (i, t, e, n, r) {
				var s = [];
				t <= 1 ? s.push({
					s: i,
					e: t
				}) : i >= 1 ? s.push({
					s: i - 1,
					e: t - 1
				}) : (s.push({
					s: i,
					e: 1
				}), s.push({
					s: 0,
					e: t - 1
				}));
				var a = [],
					o, h = s.length,
					c;
				for (o = 0; o < h; o += 1)
					if (c = s[o], !(c.e * r < n || c.s * r > n + e)) {
						var u, g;
						c.s * r <= n ? u = 0 : u = (c.s * r - n) / e, c.e * r >= n + e ? g = 1 : g = (c.e * r - n) / e, a.push([u, g])
					} return a.length || a.push([0, 0]), a
			}, TrimModifier.prototype.releasePathsData = function (i) {
				var t, e = i.length;
				for (t = 0; t < e; t += 1) segmentsLengthPool.release(i[t]);
				return i.length = 0, i
			}, TrimModifier.prototype.processShapes = function (i) {
				var t, e;
				if (this._mdf || i) {
					var n = this.o.v % 360 / 360;
					if (n < 0 && (n += 1), this.s.v > 1 ? t = 1 + n : this.s.v < 0 ? t = 0 + n : t = this.s.v + n, this.e.v > 1 ? e = 1 + n : this.e.v < 0 ? e = 0 + n : e = this.e.v + n, t > e) {
						var r = t;
						t = e, e = r
					}
					t = Math.round(t * 1e4) * 1e-4, e = Math.round(e * 1e4) * 1e-4, this.sValue = t, this.eValue = e
				} else t = this.sValue, e = this.eValue;
				var s, a, o = this.shapes.length,
					h, c, u, g, p, _ = 0;
				if (e === t)
					for (a = 0; a < o; a += 1) this.shapes[a].localShapeCollection.releaseShapes(), this.shapes[a].shape._mdf = !0, this.shapes[a].shape.paths = this.shapes[a].localShapeCollection, this._mdf && (this.shapes[a].pathsData.length = 0);
				else if (e === 1 && t === 0 || e === 0 && t === 1) {
					if (this._mdf)
						for (a = 0; a < o; a += 1) this.shapes[a].pathsData.length = 0, this.shapes[a].shape._mdf = !0
				} else {
					var b = [],
						y, w;
					for (a = 0; a < o; a += 1)
						if (y = this.shapes[a], !y.shape._mdf && !this._mdf && !i && this.m !== 2) y.shape.paths = y.localShapeCollection;
						else {
							if (s = y.shape.paths, c = s._length, p = 0, !y.shape._mdf && y.pathsData.length) p = y.totalShapeLength;
							else {
								for (u = this.releasePathsData(y.pathsData), h = 0; h < c; h += 1) g = bez.getSegmentsLength(s.shapes[h]), u.push(g), p += g.totalLength;
								y.totalShapeLength = p, y.pathsData = u
							}
							_ += p, y.shape._mdf = !0
						} var f = t,
						S = e,
						x = 0,
						M;
					for (a = o - 1; a >= 0; a -= 1)
						if (y = this.shapes[a], y.shape._mdf) {
							for (w = y.localShapeCollection, w.releaseShapes(), this.m === 2 && o > 1 ? (M = this.calculateShapeEdges(t, e, y.totalShapeLength, x, _), x += y.totalShapeLength) : M = [
									[f, S]
								], c = M.length, h = 0; h < c; h += 1) {
								f = M[h][0], S = M[h][1], b.length = 0, S <= 1 ? b.push({
									s: y.totalShapeLength * f,
									e: y.totalShapeLength * S
								}) : f >= 1 ? b.push({
									s: y.totalShapeLength * (f - 1),
									e: y.totalShapeLength * (S - 1)
								}) : (b.push({
									s: y.totalShapeLength * f,
									e: y.totalShapeLength
								}), b.push({
									s: 0,
									e: y.totalShapeLength * (S - 1)
								}));
								var T = this.addShapes(y, b[0]);
								if (b[0].s !== b[0].e) {
									if (b.length > 1) {
										var I = y.shape.paths.shapes[y.shape.paths._length - 1];
										if (I.c) {
											var L = T.pop();
											this.addPaths(T, w), T = this.addShapes(y, b[1], L)
										} else this.addPaths(T, w), T = this.addShapes(y, b[1])
									}
									this.addPaths(T, w)
								}
							}
							y.shape.paths = w
						}
				}
			}, TrimModifier.prototype.addPaths = function (i, t) {
				var e, n = i.length;
				for (e = 0; e < n; e += 1) t.addShape(i[e])
			}, TrimModifier.prototype.addSegment = function (i, t, e, n, r, s, a) {
				r.setXYAt(t[0], t[1], "o", s), r.setXYAt(e[0], e[1], "i", s + 1), a && r.setXYAt(i[0], i[1], "v", s), r.setXYAt(n[0], n[1], "v", s + 1)
			}, TrimModifier.prototype.addSegmentFromArray = function (i, t, e, n) {
				t.setXYAt(i[1], i[5], "o", e), t.setXYAt(i[2], i[6], "i", e + 1), n && t.setXYAt(i[0], i[4], "v", e), t.setXYAt(i[3], i[7], "v", e + 1)
			}, TrimModifier.prototype.addShapes = function (i, t, e) {
				var n = i.pathsData,
					r = i.shape.paths.shapes,
					s, a = i.shape.paths._length,
					o, h, c = 0,
					u, g, p, _, b = [],
					y, w = !0;
				for (e ? (g = e._length, y = e._length) : (e = shapePool.newElement(), g = 0, y = 0), b.push(e), s = 0; s < a; s += 1) {
					for (p = n[s].lengths, e.c = r[s].c, h = r[s].c ? p.length : p.length + 1, o = 1; o < h; o += 1)
						if (u = p[o - 1], c + u.addedLength < t.s) c += u.addedLength, e.c = !1;
						else if (c > t.e) {
						e.c = !1;
						break
					} else t.s <= c && t.e >= c + u.addedLength ? (this.addSegment(r[s].v[o - 1], r[s].o[o - 1], r[s].i[o], r[s].v[o], e, g, w), w = !1) : (_ = bez.getNewSegment(r[s].v[o - 1], r[s].v[o], r[s].o[o - 1], r[s].i[o], (t.s - c) / u.addedLength, (t.e - c) / u.addedLength, p[o - 1]), this.addSegmentFromArray(_, e, g, w), w = !1, e.c = !1), c += u.addedLength, g += 1;
					if (r[s].c && p.length) {
						if (u = p[o - 1], c <= t.e) {
							var f = p[o - 1].addedLength;
							t.s <= c && t.e >= c + f ? (this.addSegment(r[s].v[o - 1], r[s].o[o - 1], r[s].i[0], r[s].v[0], e, g, w), w = !1) : (_ = bez.getNewSegment(r[s].v[o - 1], r[s].v[0], r[s].o[o - 1], r[s].i[0], (t.s - c) / f, (t.e - c) / f, p[o - 1]), this.addSegmentFromArray(_, e, g, w), w = !1, e.c = !1)
						} else e.c = !1;
						c += u.addedLength, g += 1
					}
					if (e._length && (e.setXYAt(e.v[y][0], e.v[y][1], "i", y), e.setXYAt(e.v[e._length - 1][0], e.v[e._length - 1][1], "o", e._length - 1)), c > t.e) break;
					s < a - 1 && (e = shapePool.newElement(), w = !0, b.push(e), g = 0)
				}
				return b
			};

			function PuckerAndBloatModifier() {}
			extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (i, t) {
				this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(i, t.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
			}, PuckerAndBloatModifier.prototype.processPath = function (i, t) {
				var e = t / 100,
					n = [0, 0],
					r = i._length,
					s = 0;
				for (s = 0; s < r; s += 1) n[0] += i.v[s][0], n[1] += i.v[s][1];
				n[0] /= r, n[1] /= r;
				var a = shapePool.newElement();
				a.c = i.c;
				var o, h, c, u, g, p;
				for (s = 0; s < r; s += 1) o = i.v[s][0] + (n[0] - i.v[s][0]) * e, h = i.v[s][1] + (n[1] - i.v[s][1]) * e, c = i.o[s][0] + (n[0] - i.o[s][0]) * -e, u = i.o[s][1] + (n[1] - i.o[s][1]) * -e, g = i.i[s][0] + (n[0] - i.i[s][0]) * -e, p = i.i[s][1] + (n[1] - i.i[s][1]) * -e, a.setTripleAt(o, h, c, u, g, p, s);
				return a
			}, PuckerAndBloatModifier.prototype.processShapes = function (i) {
				var t, e, n = this.shapes.length,
					r, s, a = this.amount.v;
				if (a !== 0) {
					var o, h;
					for (e = 0; e < n; e += 1) {
						if (o = this.shapes[e], h = o.localShapeCollection, !(!o.shape._mdf && !this._mdf && !i))
							for (h.releaseShapes(), o.shape._mdf = !0, t = o.shape.paths.shapes, s = o.shape.paths._length, r = 0; r < s; r += 1) h.addShape(this.processPath(t[r], a));
						o.shape.paths = o.localShapeCollection
					}
				}
				this.dynamicProperties.length || (this._mdf = !1)
			};
			var TransformPropertyFactory = function () {
				var i = [0, 0];

				function t(h) {
					var c = this._mdf;
					this.iterateDynamicProperties(), this._mdf = this._mdf || c, this.a && h.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && h.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && h.skewFromAxis(-this.sk.v, this.sa.v), this.r ? h.rotate(-this.r.v) : h.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? h.translate(this.px.v, this.py.v, -this.pz.v) : h.translate(this.px.v, this.py.v, 0) : h.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
				}

				function e(h) {
					if (this.elem.globalData.frameId !== this.frameId) {
						if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || h) {
							var c;
							if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
								var u, g;
								if (c = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (u = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / c, 0), g = this.p.getValueAtTime(this.p.keyframes[0].t / c, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (u = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / c, 0), g = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / c, 0)) : (u = this.p.pv, g = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / c, this.p.offsetTime));
								else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
									u = [], g = [];
									var p = this.px,
										_ = this.py;
									p._caching.lastFrame + p.offsetTime <= p.keyframes[0].t ? (u[0] = p.getValueAtTime((p.keyframes[0].t + .01) / c, 0), u[1] = _.getValueAtTime((_.keyframes[0].t + .01) / c, 0), g[0] = p.getValueAtTime(p.keyframes[0].t / c, 0), g[1] = _.getValueAtTime(_.keyframes[0].t / c, 0)) : p._caching.lastFrame + p.offsetTime >= p.keyframes[p.keyframes.length - 1].t ? (u[0] = p.getValueAtTime(p.keyframes[p.keyframes.length - 1].t / c, 0), u[1] = _.getValueAtTime(_.keyframes[_.keyframes.length - 1].t / c, 0), g[0] = p.getValueAtTime((p.keyframes[p.keyframes.length - 1].t - .01) / c, 0), g[1] = _.getValueAtTime((_.keyframes[_.keyframes.length - 1].t - .01) / c, 0)) : (u = [p.pv, _.pv], g[0] = p.getValueAtTime((p._caching.lastFrame + p.offsetTime - .01) / c, p.offsetTime), g[1] = _.getValueAtTime((_._caching.lastFrame + _.offsetTime - .01) / c, _.offsetTime))
								} else g = i, u = g;
								this.v.rotate(-Math.atan2(u[1] - g[1], u[0] - g[0]))
							}
							this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
						}
						this.frameId = this.elem.globalData.frameId
					}
				}

				function n() {
					if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length) this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1;
					else return;
					if (!this.s.effectsSequence.length) this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2;
					else return;
					if (this.sk)
						if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3;
						else return;
					this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
				}

				function r() {}

				function s(h) {
					this._addDynamicProperty(h), this.elem.addDynamicProperty(h), this._isDirty = !0
				}

				function a(h, c, u) {
					if (this.elem = h, this.frameId = -1, this.propType = "transform", this.data = c, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(u || h), c.p && c.p.s ? (this.px = PropertyFactory.getProp(h, c.p.x, 0, 0, this), this.py = PropertyFactory.getProp(h, c.p.y, 0, 0, this), c.p.z && (this.pz = PropertyFactory.getProp(h, c.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(h, c.p || {
							k: [0, 0, 0]
						}, 1, 0, this), c.rx) {
						if (this.rx = PropertyFactory.getProp(h, c.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(h, c.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(h, c.rz, 0, degToRads, this), c.or.k[0].ti) {
							var g, p = c.or.k.length;
							for (g = 0; g < p; g += 1) c.or.k[g].to = null, c.or.k[g].ti = null
						}
						this.or = PropertyFactory.getProp(h, c.or, 1, degToRads, this), this.or.sh = !0
					} else this.r = PropertyFactory.getProp(h, c.r || {
						k: 0
					}, 0, degToRads, this);
					c.sk && (this.sk = PropertyFactory.getProp(h, c.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(h, c.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(h, c.a || {
						k: [0, 0, 0]
					}, 1, 0, this), this.s = PropertyFactory.getProp(h, c.s || {
						k: [100, 100, 100]
					}, 1, .01, this), c.o ? this.o = PropertyFactory.getProp(h, c.o, 0, .01, h) : this.o = {
						_mdf: !1,
						v: 1
					}, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
				}
				a.prototype = {
					applyToMatrix: t,
					getValue: e,
					precalculateMatrix: n,
					autoOrient: r
				}, extendPrototype([DynamicPropertyContainer], a), a.prototype.addDynamicProperty = s, a.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

				function o(h, c, u) {
					return new a(h, c, u)
				}
				return {
					getTransformProperty: o
				}
			}();

			function RepeaterModifier() {}
			extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (i, t) {
				this.getValue = this.processKeys, this.c = PropertyFactory.getProp(i, t.c, 0, null, this), this.o = PropertyFactory.getProp(i, t.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(i, t.tr, this), this.so = PropertyFactory.getProp(i, t.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(i, t.tr.eo, 0, .01, this), this.data = t, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
			}, RepeaterModifier.prototype.applyTransforms = function (i, t, e, n, r, s) {
				var a = s ? -1 : 1,
					o = n.s.v[0] + (1 - n.s.v[0]) * (1 - r),
					h = n.s.v[1] + (1 - n.s.v[1]) * (1 - r);
				i.translate(n.p.v[0] * a * r, n.p.v[1] * a * r, n.p.v[2]), t.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), t.rotate(-n.r.v * a * r), t.translate(n.a.v[0], n.a.v[1], n.a.v[2]), e.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), e.scale(s ? 1 / o : o, s ? 1 / h : h), e.translate(n.a.v[0], n.a.v[1], n.a.v[2])
			}, RepeaterModifier.prototype.init = function (i, t, e, n) {
				for (this.elem = i, this.arr = t, this.pos = e, this.elemsData = n, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(i), this.initModifierProperties(i, t[e]); e > 0;) e -= 1, this._elements.unshift(t[e]);
				this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
			}, RepeaterModifier.prototype.resetElements = function (i) {
				var t, e = i.length;
				for (t = 0; t < e; t += 1) i[t]._processed = !1, i[t].ty === "gr" && this.resetElements(i[t].it)
			}, RepeaterModifier.prototype.cloneElements = function (i) {
				var t = JSON.parse(JSON.stringify(i));
				return this.resetElements(t), t
			}, RepeaterModifier.prototype.changeGroupRender = function (i, t) {
				var e, n = i.length;
				for (e = 0; e < n; e += 1) i[e]._render = t, i[e].ty === "gr" && this.changeGroupRender(i[e].it, t)
			}, RepeaterModifier.prototype.processShapes = function (i) {
				var t, e, n, r, s, a = !1;
				if (this._mdf || i) {
					var o = Math.ceil(this.c.v);
					if (this._groups.length < o) {
						for (; this._groups.length < o;) {
							var h = {
								it: this.cloneElements(this._elements),
								ty: "gr"
							};
							h.it.push({
								a: {
									a: 0,
									ix: 1,
									k: [0, 0]
								},
								nm: "Transform",
								o: {
									a: 0,
									ix: 7,
									k: 100
								},
								p: {
									a: 0,
									ix: 2,
									k: [0, 0]
								},
								r: {
									a: 1,
									ix: 6,
									k: [{
										s: 0,
										e: 0,
										t: 0
									}, {
										s: 0,
										e: 0,
										t: 1
									}]
								},
								s: {
									a: 0,
									ix: 3,
									k: [100, 100]
								},
								sa: {
									a: 0,
									ix: 5,
									k: 0
								},
								sk: {
									a: 0,
									ix: 4,
									k: 0
								},
								ty: "tr"
							}), this.arr.splice(0, 0, h), this._groups.splice(0, 0, h), this._currentCopies += 1
						}
						this.elem.reloadShapes(), a = !0
					}
					s = 0;
					var c;
					for (n = 0; n <= this._groups.length - 1; n += 1) {
						if (c = s < o, this._groups[n]._render = c, this.changeGroupRender(this._groups[n].it, c), !c) {
							var u = this.elemsData[n].it,
								g = u[u.length - 1];
							g.transform.op.v !== 0 ? (g.transform.op._mdf = !0, g.transform.op.v = 0) : g.transform.op._mdf = !1
						}
						s += 1
					}
					this._currentCopies = o;
					var p = this.o.v,
						_ = p % 1,
						b = p > 0 ? Math.floor(p) : Math.ceil(p),
						y = this.pMatrix.props,
						w = this.rMatrix.props,
						f = this.sMatrix.props;
					this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
					var S = 0;
					if (p > 0) {
						for (; S < b;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), S += 1;
						_ && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, _, !1), S += _)
					} else if (p < 0) {
						for (; S > b;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), S -= 1;
						_ && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -_, !0), S -= _)
					}
					n = this.data.m === 1 ? 0 : this._currentCopies - 1, r = this.data.m === 1 ? 1 : -1, s = this._currentCopies;
					for (var x, M; s;) {
						if (t = this.elemsData[n].it, e = t[t.length - 1].transform.mProps.v.props, M = e.length, t[t.length - 1].transform.mProps._mdf = !0, t[t.length - 1].transform.op._mdf = !0, t[t.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (n / (this._currentCopies - 1)), S !== 0) {
							for ((n !== 0 && r === 1 || n !== this._currentCopies - 1 && r === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(w[0], w[1], w[2], w[3], w[4], w[5], w[6], w[7], w[8], w[9], w[10], w[11], w[12], w[13], w[14], w[15]), this.matrix.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), this.matrix.transform(y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7], y[8], y[9], y[10], y[11], y[12], y[13], y[14], y[15]), x = 0; x < M; x += 1) e[x] = this.matrix.props[x];
							this.matrix.reset()
						} else
							for (this.matrix.reset(), x = 0; x < M; x += 1) e[x] = this.matrix.props[x];
						S += 1, s -= 1, n += r
					}
				} else
					for (s = this._currentCopies, n = 0, r = 1; s;) t = this.elemsData[n].it, e = t[t.length - 1].transform.mProps.v.props, t[t.length - 1].transform.mProps._mdf = !1, t[t.length - 1].transform.op._mdf = !1, s -= 1, n += r;
				return a
			}, RepeaterModifier.prototype.addShape = function () {};

			function RoundCornersModifier() {}
			extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (i, t) {
				this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(i, t.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
			}, RoundCornersModifier.prototype.processPath = function (i, t) {
				var e = shapePool.newElement();
				e.c = i.c;
				var n, r = i._length,
					s, a, o, h, c, u, g = 0,
					p, _, b, y, w, f;
				for (n = 0; n < r; n += 1) s = i.v[n], o = i.o[n], a = i.i[n], s[0] === o[0] && s[1] === o[1] && s[0] === a[0] && s[1] === a[1] ? (n === 0 || n === r - 1) && !i.c ? (e.setTripleAt(s[0], s[1], o[0], o[1], a[0], a[1], g), g += 1) : (n === 0 ? h = i.v[r - 1] : h = i.v[n - 1], c = Math.sqrt(Math.pow(s[0] - h[0], 2) + Math.pow(s[1] - h[1], 2)), u = c ? Math.min(c / 2, t) / c : 0, w = s[0] + (h[0] - s[0]) * u, p = w, f = s[1] - (s[1] - h[1]) * u, _ = f, b = p - (p - s[0]) * roundCorner, y = _ - (_ - s[1]) * roundCorner, e.setTripleAt(p, _, b, y, w, f, g), g += 1, n === r - 1 ? h = i.v[0] : h = i.v[n + 1], c = Math.sqrt(Math.pow(s[0] - h[0], 2) + Math.pow(s[1] - h[1], 2)), u = c ? Math.min(c / 2, t) / c : 0, b = s[0] + (h[0] - s[0]) * u, p = b, y = s[1] + (h[1] - s[1]) * u, _ = y, w = p - (p - s[0]) * roundCorner, f = _ - (_ - s[1]) * roundCorner, e.setTripleAt(p, _, b, y, w, f, g), g += 1) : (e.setTripleAt(i.v[n][0], i.v[n][1], i.o[n][0], i.o[n][1], i.i[n][0], i.i[n][1], g), g += 1);
				return e
			}, RoundCornersModifier.prototype.processShapes = function (i) {
				var t, e, n = this.shapes.length,
					r, s, a = this.rd.v;
				if (a !== 0) {
					var o, h;
					for (e = 0; e < n; e += 1) {
						if (o = this.shapes[e], h = o.localShapeCollection, !(!o.shape._mdf && !this._mdf && !i))
							for (h.releaseShapes(), o.shape._mdf = !0, t = o.shape.paths.shapes, s = o.shape.paths._length, r = 0; r < s; r += 1) h.addShape(this.processPath(t[r], a));
						o.shape.paths = o.localShapeCollection
					}
				}
				this.dynamicProperties.length || (this._mdf = !1)
			};

			function floatEqual(i, t) {
				return Math.abs(i - t) * 1e5 <= Math.min(Math.abs(i), Math.abs(t))
			}

			function floatZero(i) {
				return Math.abs(i) <= 1e-5
			}

			function lerp(i, t, e) {
				return i * (1 - e) + t * e
			}

			function lerpPoint(i, t, e) {
				return [lerp(i[0], t[0], e), lerp(i[1], t[1], e)]
			}

			function quadRoots(i, t, e) {
				if (i === 0) return [];
				var n = t * t - 4 * i * e;
				if (n < 0) return [];
				var r = -t / (2 * i);
				if (n === 0) return [r];
				var s = Math.sqrt(n) / (2 * i);
				return [r - s, r + s]
			}

			function polynomialCoefficients(i, t, e, n) {
				return [-i + 3 * t - 3 * e + n, 3 * i - 6 * t + 3 * e, -3 * i + 3 * t, i]
			}

			function singlePoint(i) {
				return new PolynomialBezier(i, i, i, i, !1)
			}

			function PolynomialBezier(i, t, e, n, r) {
				r && pointEqual(i, t) && (t = lerpPoint(i, n, 1 / 3)), r && pointEqual(e, n) && (e = lerpPoint(i, n, 2 / 3));
				var s = polynomialCoefficients(i[0], t[0], e[0], n[0]),
					a = polynomialCoefficients(i[1], t[1], e[1], n[1]);
				this.a = [s[0], a[0]], this.b = [s[1], a[1]], this.c = [s[2], a[2]], this.d = [s[3], a[3]], this.points = [i, t, e, n]
			}
			PolynomialBezier.prototype.point = function (i) {
				return [((this.a[0] * i + this.b[0]) * i + this.c[0]) * i + this.d[0], ((this.a[1] * i + this.b[1]) * i + this.c[1]) * i + this.d[1]]
			}, PolynomialBezier.prototype.derivative = function (i) {
				return [(3 * i * this.a[0] + 2 * this.b[0]) * i + this.c[0], (3 * i * this.a[1] + 2 * this.b[1]) * i + this.c[1]]
			}, PolynomialBezier.prototype.tangentAngle = function (i) {
				var t = this.derivative(i);
				return Math.atan2(t[1], t[0])
			}, PolynomialBezier.prototype.normalAngle = function (i) {
				var t = this.derivative(i);
				return Math.atan2(t[0], t[1])
			}, PolynomialBezier.prototype.inflectionPoints = function () {
				var i = this.a[1] * this.b[0] - this.a[0] * this.b[1];
				if (floatZero(i)) return [];
				var t = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / i,
					e = t * t - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / i;
				if (e < 0) return [];
				var n = Math.sqrt(e);
				return floatZero(n) ? n > 0 && n < 1 ? [t] : [] : [t - n, t + n].filter(function (r) {
					return r > 0 && r < 1
				})
			}, PolynomialBezier.prototype.split = function (i) {
				if (i <= 0) return [singlePoint(this.points[0]), this];
				if (i >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
				var t = lerpPoint(this.points[0], this.points[1], i),
					e = lerpPoint(this.points[1], this.points[2], i),
					n = lerpPoint(this.points[2], this.points[3], i),
					r = lerpPoint(t, e, i),
					s = lerpPoint(e, n, i),
					a = lerpPoint(r, s, i);
				return [new PolynomialBezier(this.points[0], t, r, a, !0), new PolynomialBezier(a, s, n, this.points[3], !0)]
			};

			function extrema(i, t) {
				var e = i.points[0][t],
					n = i.points[i.points.length - 1][t];
				if (e > n) {
					var r = n;
					n = e, e = r
				}
				for (var s = quadRoots(3 * i.a[t], 2 * i.b[t], i.c[t]), a = 0; a < s.length; a += 1)
					if (s[a] > 0 && s[a] < 1) {
						var o = i.point(s[a])[t];
						o < e ? e = o : o > n && (n = o)
					} return {
					min: e,
					max: n
				}
			}
			PolynomialBezier.prototype.bounds = function () {
				return {
					x: extrema(this, 0),
					y: extrema(this, 1)
				}
			}, PolynomialBezier.prototype.boundingBox = function () {
				var i = this.bounds();
				return {
					left: i.x.min,
					right: i.x.max,
					top: i.y.min,
					bottom: i.y.max,
					width: i.x.max - i.x.min,
					height: i.y.max - i.y.min,
					cx: (i.x.max + i.x.min) / 2,
					cy: (i.y.max + i.y.min) / 2
				}
			};

			function intersectData(i, t, e) {
				var n = i.boundingBox();
				return {
					cx: n.cx,
					cy: n.cy,
					width: n.width,
					height: n.height,
					bez: i,
					t: (t + e) / 2,
					t1: t,
					t2: e
				}
			}

			function splitData(i) {
				var t = i.bez.split(.5);
				return [intersectData(t[0], i.t1, i.t), intersectData(t[1], i.t, i.t2)]
			}

			function boxIntersect(i, t) {
				return Math.abs(i.cx - t.cx) * 2 < i.width + t.width && Math.abs(i.cy - t.cy) * 2 < i.height + t.height
			}

			function intersectsImpl(i, t, e, n, r, s) {
				if (boxIntersect(i, t)) {
					if (e >= s || i.width <= n && i.height <= n && t.width <= n && t.height <= n) {
						r.push([i.t, t.t]);
						return
					}
					var a = splitData(i),
						o = splitData(t);
					intersectsImpl(a[0], o[0], e + 1, n, r, s), intersectsImpl(a[0], o[1], e + 1, n, r, s), intersectsImpl(a[1], o[0], e + 1, n, r, s), intersectsImpl(a[1], o[1], e + 1, n, r, s)
				}
			}
			PolynomialBezier.prototype.intersections = function (i, t, e) {
				t === void 0 && (t = 2), e === void 0 && (e = 7);
				var n = [];
				return intersectsImpl(intersectData(this, 0, 1), intersectData(i, 0, 1), 0, t, n, e), n
			}, PolynomialBezier.shapeSegment = function (i, t) {
				var e = (t + 1) % i.length();
				return new PolynomialBezier(i.v[t], i.o[t], i.i[e], i.v[e], !0)
			}, PolynomialBezier.shapeSegmentInverted = function (i, t) {
				var e = (t + 1) % i.length();
				return new PolynomialBezier(i.v[e], i.i[e], i.o[t], i.v[t], !0)
			};

			function crossProduct(i, t) {
				return [i[1] * t[2] - i[2] * t[1], i[2] * t[0] - i[0] * t[2], i[0] * t[1] - i[1] * t[0]]
			}

			function lineIntersection(i, t, e, n) {
				var r = [i[0], i[1], 1],
					s = [t[0], t[1], 1],
					a = [e[0], e[1], 1],
					o = [n[0], n[1], 1],
					h = crossProduct(crossProduct(r, s), crossProduct(a, o));
				return floatZero(h[2]) ? null : [h[0] / h[2], h[1] / h[2]]
			}

			function polarOffset(i, t, e) {
				return [i[0] + Math.cos(t) * e, i[1] - Math.sin(t) * e]
			}

			function pointDistance(i, t) {
				return Math.hypot(i[0] - t[0], i[1] - t[1])
			}

			function pointEqual(i, t) {
				return floatEqual(i[0], t[0]) && floatEqual(i[1], t[1])
			}

			function ZigZagModifier() {}
			extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function (i, t) {
				this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(i, t.s, 0, null, this), this.frequency = PropertyFactory.getProp(i, t.r, 0, null, this), this.pointsType = PropertyFactory.getProp(i, t.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
			};

			function setPoint(i, t, e, n, r, s, a) {
				var o = e - Math.PI / 2,
					h = e + Math.PI / 2,
					c = t[0] + Math.cos(e) * n * r,
					u = t[1] - Math.sin(e) * n * r;
				i.setTripleAt(c, u, c + Math.cos(o) * s, u - Math.sin(o) * s, c + Math.cos(h) * a, u - Math.sin(h) * a, i.length())
			}

			function getPerpendicularVector(i, t) {
				var e = [t[0] - i[0], t[1] - i[1]],
					n = -Math.PI * .5,
					r = [Math.cos(n) * e[0] - Math.sin(n) * e[1], Math.sin(n) * e[0] + Math.cos(n) * e[1]];
				return r
			}

			function getProjectingAngle(i, t) {
				var e = t === 0 ? i.length() - 1 : t - 1,
					n = (t + 1) % i.length(),
					r = i.v[e],
					s = i.v[n],
					a = getPerpendicularVector(r, s);
				return Math.atan2(0, 1) - Math.atan2(a[1], a[0])
			}

			function zigZagCorner(i, t, e, n, r, s, a) {
				var o = getProjectingAngle(t, e),
					h = t.v[e % t._length],
					c = t.v[e === 0 ? t._length - 1 : e - 1],
					u = t.v[(e + 1) % t._length],
					g = s === 2 ? Math.sqrt(Math.pow(h[0] - c[0], 2) + Math.pow(h[1] - c[1], 2)) : 0,
					p = s === 2 ? Math.sqrt(Math.pow(h[0] - u[0], 2) + Math.pow(h[1] - u[1], 2)) : 0;
				setPoint(i, t.v[e % t._length], o, a, n, p / ((r + 1) * 2), g / ((r + 1) * 2), s)
			}

			function zigZagSegment(i, t, e, n, r, s) {
				for (var a = 0; a < n; a += 1) {
					var o = (a + 1) / (n + 1),
						h = r === 2 ? Math.sqrt(Math.pow(t.points[3][0] - t.points[0][0], 2) + Math.pow(t.points[3][1] - t.points[0][1], 2)) : 0,
						c = t.normalAngle(o),
						u = t.point(o);
					setPoint(i, u, c, s, e, h / ((n + 1) * 2), h / ((n + 1) * 2), r), s = -s
				}
				return s
			}
			ZigZagModifier.prototype.processPath = function (i, t, e, n) {
				var r = i._length,
					s = shapePool.newElement();
				if (s.c = i.c, i.c || (r -= 1), r === 0) return s;
				var a = -1,
					o = PolynomialBezier.shapeSegment(i, 0);
				zigZagCorner(s, i, 0, t, e, n, a);
				for (var h = 0; h < r; h += 1) a = zigZagSegment(s, o, t, e, n, -a), h === r - 1 && !i.c ? o = null : o = PolynomialBezier.shapeSegment(i, (h + 1) % r), zigZagCorner(s, i, h + 1, t, e, n, a);
				return s
			}, ZigZagModifier.prototype.processShapes = function (i) {
				var t, e, n = this.shapes.length,
					r, s, a = this.amplitude.v,
					o = Math.max(0, Math.round(this.frequency.v)),
					h = this.pointsType.v;
				if (a !== 0) {
					var c, u;
					for (e = 0; e < n; e += 1) {
						if (c = this.shapes[e], u = c.localShapeCollection, !(!c.shape._mdf && !this._mdf && !i))
							for (u.releaseShapes(), c.shape._mdf = !0, t = c.shape.paths.shapes, s = c.shape.paths._length, r = 0; r < s; r += 1) u.addShape(this.processPath(t[r], a, o, h));
						c.shape.paths = c.localShapeCollection
					}
				}
				this.dynamicProperties.length || (this._mdf = !1)
			};

			function linearOffset(i, t, e) {
				var n = Math.atan2(t[0] - i[0], t[1] - i[1]);
				return [polarOffset(i, n, e), polarOffset(t, n, e)]
			}

			function offsetSegment(i, t) {
				var e, n, r, s, a, o, h;
				h = linearOffset(i.points[0], i.points[1], t), e = h[0], n = h[1], h = linearOffset(i.points[1], i.points[2], t), r = h[0], s = h[1], h = linearOffset(i.points[2], i.points[3], t), a = h[0], o = h[1];
				var c = lineIntersection(e, n, r, s);
				c === null && (c = n);
				var u = lineIntersection(a, o, r, s);
				return u === null && (u = a), new PolynomialBezier(e, c, u, o)
			}

			function joinLines(i, t, e, n, r) {
				var s = t.points[3],
					a = e.points[0];
				if (n === 3 || pointEqual(s, a)) return s;
				if (n === 2) {
					var o = -t.tangentAngle(1),
						h = -e.tangentAngle(0) + Math.PI,
						c = lineIntersection(s, polarOffset(s, o + Math.PI / 2, 100), a, polarOffset(a, o + Math.PI / 2, 100)),
						u = c ? pointDistance(c, s) : pointDistance(s, a) / 2,
						g = polarOffset(s, o, 2 * u * roundCorner);
					return i.setXYAt(g[0], g[1], "o", i.length() - 1), g = polarOffset(a, h, 2 * u * roundCorner), i.setTripleAt(a[0], a[1], a[0], a[1], g[0], g[1], i.length()), a
				}
				var p = pointEqual(s, t.points[2]) ? t.points[0] : t.points[2],
					_ = pointEqual(a, e.points[1]) ? e.points[3] : e.points[1],
					b = lineIntersection(p, s, a, _);
				return b && pointDistance(b, s) < r ? (i.setTripleAt(b[0], b[1], b[0], b[1], b[0], b[1], i.length()), b) : s
			}

			function getIntersection(i, t) {
				var e = i.intersections(t);
				return e.length && floatEqual(e[0][0], 1) && e.shift(), e.length ? e[0] : null
			}

			function pruneSegmentIntersection(i, t) {
				var e = i.slice(),
					n = t.slice(),
					r = getIntersection(i[i.length - 1], t[0]);
				return r && (e[i.length - 1] = i[i.length - 1].split(r[0])[0], n[0] = t[0].split(r[1])[1]), i.length > 1 && t.length > 1 && (r = getIntersection(i[0], t[t.length - 1]), r) ? [
					[i[0].split(r[0])[0]],
					[t[t.length - 1].split(r[1])[1]]
				] : [e, n]
			}

			function pruneIntersections(i) {
				for (var t, e = 1; e < i.length; e += 1) t = pruneSegmentIntersection(i[e - 1], i[e]), i[e - 1] = t[0], i[e] = t[1];
				return i.length > 1 && (t = pruneSegmentIntersection(i[i.length - 1], i[0]), i[i.length - 1] = t[0], i[0] = t[1]), i
			}

			function offsetSegmentSplit(i, t) {
				var e = i.inflectionPoints(),
					n, r, s, a;
				if (e.length === 0) return [offsetSegment(i, t)];
				if (e.length === 1 || floatEqual(e[1], 1)) return s = i.split(e[0]), n = s[0], r = s[1], [offsetSegment(n, t), offsetSegment(r, t)];
				s = i.split(e[0]), n = s[0];
				var o = (e[1] - e[0]) / (1 - e[0]);
				return s = s[1].split(o), a = s[0], r = s[1], [offsetSegment(n, t), offsetSegment(a, t), offsetSegment(r, t)]
			}

			function OffsetPathModifier() {}
			extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function (i, t) {
				this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(i, t.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(i, t.ml, 0, null, this), this.lineJoin = t.lj, this._isAnimated = this.amount.effectsSequence.length !== 0
			}, OffsetPathModifier.prototype.processPath = function (i, t, e, n) {
				var r = shapePool.newElement();
				r.c = i.c;
				var s = i.length();
				i.c || (s -= 1);
				var a, o, h, c = [];
				for (a = 0; a < s; a += 1) h = PolynomialBezier.shapeSegment(i, a), c.push(offsetSegmentSplit(h, t));
				if (!i.c)
					for (a = s - 1; a >= 0; a -= 1) h = PolynomialBezier.shapeSegmentInverted(i, a), c.push(offsetSegmentSplit(h, t));
				c = pruneIntersections(c);
				var u = null,
					g = null;
				for (a = 0; a < c.length; a += 1) {
					var p = c[a];
					for (g && (u = joinLines(r, g, p[0], e, n)), g = p[p.length - 1], o = 0; o < p.length; o += 1) h = p[o], u && pointEqual(h.points[0], u) ? r.setXYAt(h.points[1][0], h.points[1][1], "o", r.length() - 1) : r.setTripleAt(h.points[0][0], h.points[0][1], h.points[1][0], h.points[1][1], h.points[0][0], h.points[0][1], r.length()), r.setTripleAt(h.points[3][0], h.points[3][1], h.points[3][0], h.points[3][1], h.points[2][0], h.points[2][1], r.length()), u = h.points[3]
				}
				return c.length && joinLines(r, g, c[0][0], e, n), r
			}, OffsetPathModifier.prototype.processShapes = function (i) {
				var t, e, n = this.shapes.length,
					r, s, a = this.amount.v,
					o = this.miterLimit.v,
					h = this.lineJoin;
				if (a !== 0) {
					var c, u;
					for (e = 0; e < n; e += 1) {
						if (c = this.shapes[e], u = c.localShapeCollection, !(!c.shape._mdf && !this._mdf && !i))
							for (u.releaseShapes(), c.shape._mdf = !0, t = c.shape.paths.shapes, s = c.shape.paths._length, r = 0; r < s; r += 1) u.addShape(this.processPath(t[r], a, h, o));
						c.shape.paths = c.localShapeCollection
					}
				}
				this.dynamicProperties.length || (this._mdf = !1)
			};

			function getFontProperties(i) {
				for (var t = i.fStyle ? i.fStyle.split(" ") : [], e = "normal", n = "normal", r = t.length, s, a = 0; a < r; a += 1) switch (s = t[a].toLowerCase(), s) {
					case "italic":
						n = "italic";
						break;
					case "bold":
						e = "700";
						break;
					case "black":
						e = "900";
						break;
					case "medium":
						e = "500";
						break;
					case "regular":
					case "normal":
						e = "400";
						break;
					case "light":
					case "thin":
						e = "200";
						break;
					default:
						break
				}
				return {
					style: n,
					weight: i.fWeight || e
				}
			}
			var FontManager = function () {
				var i = 5e3,
					t = {
						w: 0,
						size: 0,
						shapes: [],
						data: {
							shapes: []
						}
					},
					e = [];
				e = e.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
				var n = 127988,
					r = 917631,
					s = 917601,
					a = 917626,
					o = 65039,
					h = 8205,
					c = 127462,
					u = 127487,
					g = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];

				function p(O) {
					var B = O.split(","),
						A, D = B.length,
						H = [];
					for (A = 0; A < D; A += 1) B[A] !== "sans-serif" && B[A] !== "monospace" && H.push(B[A]);
					return H.join(",")
				}

				function _(O, B) {
					var A = createTag("span");
					A.setAttribute("aria-hidden", !0), A.style.fontFamily = B;
					var D = createTag("span");
					D.innerText = "giItT1WQy@!-/#", A.style.position = "absolute", A.style.left = "-10000px", A.style.top = "-10000px", A.style.fontSize = "300px", A.style.fontVariant = "normal", A.style.fontStyle = "normal", A.style.fontWeight = "normal", A.style.letterSpacing = "0", A.appendChild(D), document.body.appendChild(A);
					var H = D.offsetWidth;
					return D.style.fontFamily = p(O) + ", " + B, {
						node: D,
						w: H,
						parent: A
					}
				}

				function b() {
					var O, B = this.fonts.length,
						A, D, H = B;
					for (O = 0; O < B; O += 1) this.fonts[O].loaded ? H -= 1 : this.fonts[O].fOrigin === "n" || this.fonts[O].origin === 0 ? this.fonts[O].loaded = !0 : (A = this.fonts[O].monoCase.node, D = this.fonts[O].monoCase.w, A.offsetWidth !== D ? (H -= 1, this.fonts[O].loaded = !0) : (A = this.fonts[O].sansCase.node, D = this.fonts[O].sansCase.w, A.offsetWidth !== D && (H -= 1, this.fonts[O].loaded = !0)), this.fonts[O].loaded && (this.fonts[O].sansCase.parent.parentNode.removeChild(this.fonts[O].sansCase.parent), this.fonts[O].monoCase.parent.parentNode.removeChild(this.fonts[O].monoCase.parent)));
					H !== 0 && Date.now() - this.initTime < i ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
				}

				function y(O, B) {
					var A = document.body && B ? "svg" : "canvas",
						D, H = getFontProperties(O);
					if (A === "svg") {
						var q = createNS("text");
						q.style.fontSize = "100px", q.setAttribute("font-family", O.fFamily), q.setAttribute("font-style", H.style), q.setAttribute("font-weight", H.weight), q.textContent = "1", O.fClass ? (q.style.fontFamily = "inherit", q.setAttribute("class", O.fClass)) : q.style.fontFamily = O.fFamily, B.appendChild(q), D = q
					} else {
						var Q = new OffscreenCanvas(500, 500).getContext("2d");
						Q.font = H.style + " " + H.weight + " 100px " + O.fFamily, D = Q
					}

					function tt(nt) {
						return A === "svg" ? (D.textContent = nt, D.getComputedTextLength()) : D.measureText(nt).width
					}
					return {
						measureText: tt
					}
				}

				function w(O, B) {
					if (!O) {
						this.isLoaded = !0;
						return
					}
					if (this.chars) {
						this.isLoaded = !0, this.fonts = O.list;
						return
					}
					if (!document.body) {
						this.isLoaded = !0, O.list.forEach(function (Et) {
							Et.helper = y(Et), Et.cache = {}
						}), this.fonts = O.list;
						return
					}
					var A = O.list,
						D, H = A.length,
						q = H;
					for (D = 0; D < H; D += 1) {
						var Q = !0,
							tt, nt;
						if (A[D].loaded = !1, A[D].monoCase = _(A[D].fFamily, "monospace"), A[D].sansCase = _(A[D].fFamily, "sans-serif"), !A[D].fPath) A[D].loaded = !0, q -= 1;
						else if (A[D].fOrigin === "p" || A[D].origin === 3) {
							if (tt = document.querySelectorAll('style[f-forigin="p"][f-family="' + A[D].fFamily + '"], style[f-origin="3"][f-family="' + A[D].fFamily + '"]'), tt.length > 0 && (Q = !1), Q) {
								var ut = createTag("style");
								ut.setAttribute("f-forigin", A[D].fOrigin), ut.setAttribute("f-origin", A[D].origin), ut.setAttribute("f-family", A[D].fFamily), ut.type = "text/css", ut.innerText = "@font-face {font-family: " + A[D].fFamily + "; font-style: normal; src: url('" + A[D].fPath + "');}", B.appendChild(ut)
							}
						} else if (A[D].fOrigin === "g" || A[D].origin === 1) {
							for (tt = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), nt = 0; nt < tt.length; nt += 1) tt[nt].href.indexOf(A[D].fPath) !== -1 && (Q = !1);
							if (Q) {
								var et = createTag("link");
								et.setAttribute("f-forigin", A[D].fOrigin), et.setAttribute("f-origin", A[D].origin), et.type = "text/css", et.rel = "stylesheet", et.href = A[D].fPath, document.body.appendChild(et)
							}
						} else if (A[D].fOrigin === "t" || A[D].origin === 2) {
							for (tt = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), nt = 0; nt < tt.length; nt += 1) A[D].fPath === tt[nt].src && (Q = !1);
							if (Q) {
								var it = createTag("link");
								it.setAttribute("f-forigin", A[D].fOrigin), it.setAttribute("f-origin", A[D].origin), it.setAttribute("rel", "stylesheet"), it.setAttribute("href", A[D].fPath), B.appendChild(it)
							}
						}
						A[D].helper = y(A[D], B), A[D].cache = {}, this.fonts.push(A[D])
					}
					q === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
				}

				function f(O) {
					if (O) {
						this.chars || (this.chars = []);
						var B, A = O.length,
							D, H = this.chars.length,
							q;
						for (B = 0; B < A; B += 1) {
							for (D = 0, q = !1; D < H;) this.chars[D].style === O[B].style && this.chars[D].fFamily === O[B].fFamily && this.chars[D].ch === O[B].ch && (q = !0), D += 1;
							q || (this.chars.push(O[B]), H += 1)
						}
					}
				}

				function S(O, B, A) {
					for (var D = 0, H = this.chars.length; D < H;) {
						if (this.chars[D].ch === O && this.chars[D].style === B && this.chars[D].fFamily === A) return this.chars[D];
						D += 1
					}
					return (typeof O == "string" && O.charCodeAt(0) !== 13 || !O) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", O, B, A)), t
				}

				function x(O, B, A) {
					var D = this.getFontByName(B),
						H = O;
					if (!D.cache[H]) {
						var q = D.helper;
						if (O === " ") {
							var Q = q.measureText("|" + O + "|"),
								tt = q.measureText("||");
							D.cache[H] = (Q - tt) / 100
						} else D.cache[H] = q.measureText(O) / 100
					}
					return D.cache[H] * A
				}

				function M(O) {
					for (var B = 0, A = this.fonts.length; B < A;) {
						if (this.fonts[B].fName === O) return this.fonts[B];
						B += 1
					}
					return this.fonts[0]
				}

				function T(O) {
					var B = 0,
						A = O.charCodeAt(0);
					if (A >= 55296 && A <= 56319) {
						var D = O.charCodeAt(1);
						D >= 56320 && D <= 57343 && (B = (A - 55296) * 1024 + D - 56320 + 65536)
					}
					return B
				}

				function I(O, B) {
					var A = O.toString(16) + B.toString(16);
					return g.indexOf(A) !== -1
				}

				function L(O) {
					return O === h
				}

				function F(O) {
					return O === o
				}

				function k(O) {
					var B = T(O);
					return B >= c && B <= u
				}

				function G(O) {
					return k(O.substr(0, 2)) && k(O.substr(2, 2))
				}

				function j(O) {
					return e.indexOf(O) !== -1
				}

				function U(O, B) {
					var A = T(O.substr(B, 2));
					if (A !== n) return !1;
					var D = 0;
					for (B += 2; D < 5;) {
						if (A = T(O.substr(B, 2)), A < s || A > a) return !1;
						D += 1, B += 2
					}
					return T(O.substr(B, 2)) === r
				}

				function z() {
					this.isLoaded = !0
				}
				var $ = function () {
					this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
				};
				$.isModifier = I, $.isZeroWidthJoiner = L, $.isFlagEmoji = G, $.isRegionalCode = k, $.isCombinedCharacter = j, $.isRegionalFlag = U, $.isVariationSelector = F, $.BLACK_FLAG_CODE_POINT = n;
				var W = {
					addChars: f,
					addFonts: w,
					getCharData: S,
					getFontByName: M,
					measureText: x,
					checkLoadedFonts: b,
					setIsLoaded: z
				};
				return $.prototype = W, $
			}();

			function SlotManager(i) {
				this.animationData = i
			}
			SlotManager.prototype.getProp = function (i) {
				return this.animationData.slots && this.animationData.slots[i.sid] ? Object.assign(i, this.animationData.slots[i.sid].p) : i
			};

			function slotFactory(i) {
				return new SlotManager(i)
			}

			function RenderableElement() {}
			RenderableElement.prototype = {
				initRenderable: function () {
					this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
				},
				addRenderableComponent: function (t) {
					this.renderableComponents.indexOf(t) === -1 && this.renderableComponents.push(t)
				},
				removeRenderableComponent: function (t) {
					this.renderableComponents.indexOf(t) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
				},
				prepareRenderableFrame: function (t) {
					this.checkLayerLimits(t)
				},
				checkTransparency: function () {
					this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
				},
				checkLayerLimits: function (t) {
					this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
				},
				renderRenderable: function () {
					var t, e = this.renderableComponents.length;
					for (t = 0; t < e; t += 1) this.renderableComponents[t].renderFrame(this._isFirstFrame)
				},
				sourceRectAtTime: function () {
					return {
						top: 0,
						left: 0,
						width: 100,
						height: 100
					}
				},
				getLayerSize: function () {
					return this.data.ty === 5 ? {
						w: this.data.textData.width,
						h: this.data.textData.height
					} : {
						w: this.data.width,
						h: this.data.height
					}
				}
			};
			var getBlendMode = function () {
				var i = {
					0: "source-over",
					1: "multiply",
					2: "screen",
					3: "overlay",
					4: "darken",
					5: "lighten",
					6: "color-dodge",
					7: "color-burn",
					8: "hard-light",
					9: "soft-light",
					10: "difference",
					11: "exclusion",
					12: "hue",
					13: "saturation",
					14: "color",
					15: "luminosity"
				};
				return function (t) {
					return i[t] || ""
				}
			}();

			function SliderEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 0, 0, e)
			}

			function AngleEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 0, 0, e)
			}

			function ColorEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 1, 0, e)
			}

			function PointEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 1, 0, e)
			}

			function LayerIndexEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 0, 0, e)
			}

			function MaskIndexEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 0, 0, e)
			}

			function CheckboxEffect(i, t, e) {
				this.p = PropertyFactory.getProp(t, i.v, 0, 0, e)
			}

			function NoValueEffect() {
				this.p = {}
			}

			function EffectsManager(i, t) {
				var e = i.ef || [];
				this.effectElements = [];
				var n, r = e.length,
					s;
				for (n = 0; n < r; n += 1) s = new GroupEffect(e[n], t), this.effectElements.push(s)
			}

			function GroupEffect(i, t) {
				this.init(i, t)
			}
			extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (i, t) {
				this.data = i, this.effectElements = [], this.initDynamicPropertyContainer(t);
				var e, n = this.data.ef.length,
					r, s = this.data.ef;
				for (e = 0; e < n; e += 1) {
					switch (r = null, s[e].ty) {
						case 0:
							r = new SliderEffect(s[e], t, this);
							break;
						case 1:
							r = new AngleEffect(s[e], t, this);
							break;
						case 2:
							r = new ColorEffect(s[e], t, this);
							break;
						case 3:
							r = new PointEffect(s[e], t, this);
							break;
						case 4:
						case 7:
							r = new CheckboxEffect(s[e], t, this);
							break;
						case 10:
							r = new LayerIndexEffect(s[e], t, this);
							break;
						case 11:
							r = new MaskIndexEffect(s[e], t, this);
							break;
						case 5:
							r = new EffectsManager(s[e], t, this);
							break;
						default:
							r = new NoValueEffect(s[e], t, this);
							break
					}
					r && this.effectElements.push(r)
				}
			};

			function BaseElement() {}
			BaseElement.prototype = {
				checkMasks: function () {
					if (!this.data.hasMask) return !1;
					for (var t = 0, e = this.data.masksProperties.length; t < e;) {
						if (this.data.masksProperties[t].mode !== "n" && this.data.masksProperties[t].cl !== !1) return !0;
						t += 1
					}
					return !1
				},
				initExpressions: function () {
					var t = getExpressionInterfaces();
					if (t) {
						var e = t("layer"),
							n = t("effects"),
							r = t("shape"),
							s = t("text"),
							a = t("comp");
						this.layerInterface = e(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
						var o = n.createEffectsInterface(this, this.layerInterface);
						this.layerInterface.registerEffectsInterface(o), this.data.ty === 0 || this.data.xt ? this.compInterface = a(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = r(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = s(this), this.layerInterface.text = this.layerInterface.textInterface)
					}
				},
				setBlendMode: function () {
					var t = getBlendMode(this.data.bm),
						e = this.baseElement || this.layerElement;
					e.style["mix-blend-mode"] = t
				},
				initBaseData: function (t, e, n) {
					this.globalData = e, this.comp = n, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
				},
				getType: function () {
					return this.type
				},
				sourceRectAtTime: function () {}
			};

			function FrameElement() {}
			FrameElement.prototype = {
				initFrame: function () {
					this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
				},
				prepareProperties: function (t, e) {
					var n, r = this.dynamicProperties.length;
					for (n = 0; n < r; n += 1)(e || this._isParent && this.dynamicProperties[n].propType === "transform") && (this.dynamicProperties[n].getValue(), this.dynamicProperties[n]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
				},
				addDynamicProperty: function (t) {
					this.dynamicProperties.indexOf(t) === -1 && this.dynamicProperties.push(t)
				}
			};

			function FootageElement(i, t, e) {
				this.initFrame(), this.initRenderable(), this.assetData = t.getAssetData(i.refId), this.footageData = t.imageLoader.getAsset(this.assetData), this.initBaseData(i, t, e)
			}
			FootageElement.prototype.prepareFrame = function () {}, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () {
				return null
			}, FootageElement.prototype.renderFrame = function () {}, FootageElement.prototype.destroy = function () {}, FootageElement.prototype.initExpressions = function () {
				var i = getExpressionInterfaces();
				if (i) {
					var t = i("footage");
					this.layerInterface = t(this)
				}
			}, FootageElement.prototype.getFootageData = function () {
				return this.footageData
			};

			function AudioElement(i, t, e) {
				this.initFrame(), this.initRenderable(), this.assetData = t.getAssetData(i.refId), this.initBaseData(i, t, e), this._isPlaying = !1, this._canPlay = !1;
				var n = this.globalData.getAssetsPath(this.assetData);
				this.audio = this.globalData.audioController.createAudio(n), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = i.tm ? PropertyFactory.getProp(this, i.tm, 0, t.frameRate, this) : {
					_placeholder: !0
				}, this.lv = PropertyFactory.getProp(this, i.au && i.au.lv ? i.au.lv : {
					k: [100]
				}, 1, .01, this)
			}
			AudioElement.prototype.prepareFrame = function (i) {
				if (this.prepareRenderableFrame(i, !0), this.prepareProperties(i, !0), this.tm._placeholder) this._currentTime = i / this.data.sr;
				else {
					var t = this.tm.v;
					this._currentTime = t
				}
				this._volume = this.lv.v[0];
				var e = this._volume * this._volumeMultiplier;
				this._previousVolume !== e && (this._previousVolume = e, this.audio.volume(e))
			}, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () {
				this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
			}, AudioElement.prototype.show = function () {}, AudioElement.prototype.hide = function () {
				this.audio.pause(), this._isPlaying = !1
			}, AudioElement.prototype.pause = function () {
				this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
			}, AudioElement.prototype.resume = function () {
				this._canPlay = !0
			}, AudioElement.prototype.setRate = function (i) {
				this.audio.rate(i)
			}, AudioElement.prototype.volume = function (i) {
				this._volumeMultiplier = i, this._previousVolume = i * this._volume, this.audio.volume(this._previousVolume)
			}, AudioElement.prototype.getBaseElement = function () {
				return null
			}, AudioElement.prototype.destroy = function () {}, AudioElement.prototype.sourceRectAtTime = function () {}, AudioElement.prototype.initExpressions = function () {};

			function BaseRenderer() {}
			BaseRenderer.prototype.checkLayers = function (i) {
				var t, e = this.layers.length,
					n;
				for (this.completeLayers = !0, t = e - 1; t >= 0; t -= 1) this.elements[t] || (n = this.layers[t], n.ip - n.st <= i - this.layers[t].st && n.op - n.st > i - this.layers[t].st && this.buildItem(t)), this.completeLayers = this.elements[t] ? this.completeLayers : !1;
				this.checkPendingElements()
			}, BaseRenderer.prototype.createItem = function (i) {
				switch (i.ty) {
					case 2:
						return this.createImage(i);
					case 0:
						return this.createComp(i);
					case 1:
						return this.createSolid(i);
					case 3:
						return this.createNull(i);
					case 4:
						return this.createShape(i);
					case 5:
						return this.createText(i);
					case 6:
						return this.createAudio(i);
					case 13:
						return this.createCamera(i);
					case 15:
						return this.createFootage(i);
					default:
						return this.createNull(i)
				}
			}, BaseRenderer.prototype.createCamera = function () {
				throw new Error("You're using a 3d camera. Try the html renderer.")
			}, BaseRenderer.prototype.createAudio = function (i) {
				return new AudioElement(i, this.globalData, this)
			}, BaseRenderer.prototype.createFootage = function (i) {
				return new FootageElement(i, this.globalData, this)
			}, BaseRenderer.prototype.buildAllItems = function () {
				var i, t = this.layers.length;
				for (i = 0; i < t; i += 1) this.buildItem(i);
				this.checkPendingElements()
			}, BaseRenderer.prototype.includeLayers = function (i) {
				this.completeLayers = !1;
				var t, e = i.length,
					n, r = this.layers.length;
				for (t = 0; t < e; t += 1)
					for (n = 0; n < r;) {
						if (this.layers[n].id === i[t].id) {
							this.layers[n] = i[t];
							break
						}
						n += 1
					}
			}, BaseRenderer.prototype.setProjectInterface = function (i) {
				this.globalData.projectInterface = i
			}, BaseRenderer.prototype.initItems = function () {
				this.globalData.progressiveLoad || this.buildAllItems()
			}, BaseRenderer.prototype.buildElementParenting = function (i, t, e) {
				for (var n = this.elements, r = this.layers, s = 0, a = r.length; s < a;) r[s].ind == t && (!n[s] || n[s] === !0 ? (this.buildItem(s), this.addPendingElement(i)) : (e.push(n[s]), n[s].setAsParent(), r[s].parent !== void 0 ? this.buildElementParenting(i, r[s].parent, e) : i.setHierarchy(e))), s += 1
			}, BaseRenderer.prototype.addPendingElement = function (i) {
				this.pendingElements.push(i)
			}, BaseRenderer.prototype.searchExtraCompositions = function (i) {
				var t, e = i.length;
				for (t = 0; t < e; t += 1)
					if (i[t].xt) {
						var n = this.createComp(i[t]);
						n.initExpressions(), this.globalData.projectInterface.registerComposition(n)
					}
			}, BaseRenderer.prototype.getElementById = function (i) {
				var t, e = this.elements.length;
				for (t = 0; t < e; t += 1)
					if (this.elements[t].data.ind === i) return this.elements[t];
				return null
			}, BaseRenderer.prototype.getElementByPath = function (i) {
				var t = i.shift(),
					e;
				if (typeof t == "number") e = this.elements[t];
				else {
					var n, r = this.elements.length;
					for (n = 0; n < r; n += 1)
						if (this.elements[n].data.nm === t) {
							e = this.elements[n];
							break
						}
				}
				return i.length === 0 ? e : e.getElementByPath(i)
			}, BaseRenderer.prototype.setupGlobalData = function (i, t) {
				this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(i), this.globalData.fontManager.addChars(i.chars), this.globalData.fontManager.addFonts(i.fonts, t), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = i.fr, this.globalData.nm = i.nm, this.globalData.compSize = {
					w: i.w,
					h: i.h
				}
			};
			var effectTypes = {
				TRANSFORM_EFFECT: "transformEFfect"
			};

			function TransformElement() {}
			TransformElement.prototype = {
				initTransform: function () {
					var t = new Matrix;
					this.finalTransform = {
						mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
							o: 0
						},
						_matMdf: !1,
						_localMatMdf: !1,
						_opMdf: !1,
						mat: t,
						localMat: t,
						localOpacity: 1
					}, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
				},
				renderTransform: function () {
					if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
						var t, e = this.finalTransform.mat,
							n = 0,
							r = this.hierarchy.length;
						if (!this.finalTransform._matMdf)
							for (; n < r;) {
								if (this.hierarchy[n].finalTransform.mProp._mdf) {
									this.finalTransform._matMdf = !0;
									break
								}
								n += 1
							}
						if (this.finalTransform._matMdf)
							for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), n = 0; n < r; n += 1) e.multiply(this.hierarchy[n].finalTransform.mProp.v)
					}
					this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
				},
				renderLocalTransform: function () {
					if (this.localTransforms) {
						var t = 0,
							e = this.localTransforms.length;
						if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
							for (; t < e;) this.localTransforms[t]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[t]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), t += 1;
						if (this.finalTransform._localMatMdf) {
							var n = this.finalTransform.localMat;
							for (this.localTransforms[0].matrix.clone(n), t = 1; t < e; t += 1) {
								var r = this.localTransforms[t].matrix;
								n.multiply(r)
							}
							n.multiply(this.finalTransform.mat)
						}
						if (this.finalTransform._opMdf) {
							var s = this.finalTransform.localOpacity;
							for (t = 0; t < e; t += 1) s *= this.localTransforms[t].opacity * .01;
							this.finalTransform.localOpacity = s
						}
					}
				},
				searchEffectTransforms: function () {
					if (this.renderableEffectsManager) {
						var t = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
						if (t.length) {
							this.localTransforms = [], this.finalTransform.localMat = new Matrix;
							var e = 0,
								n = t.length;
							for (e = 0; e < n; e += 1) this.localTransforms.push(t[e])
						}
					}
				},
				globalToLocal: function (t) {
					var e = [];
					e.push(this.finalTransform);
					for (var n = !0, r = this.comp; n;) r.finalTransform ? (r.data.hasMask && e.splice(0, 0, r.finalTransform), r = r.comp) : n = !1;
					var s, a = e.length,
						o;
					for (s = 0; s < a; s += 1) o = e[s].mat.applyToPointArray(0, 0, 0), t = [t[0] - o[0], t[1] - o[1], 0];
					return t
				},
				mHelper: new Matrix
			};

			function MaskElement(i, t, e) {
				this.data = i, this.element = t, this.globalData = e, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
				var n = this.globalData.defs,
					r, s = this.masksProperties ? this.masksProperties.length : 0;
				this.viewData = createSizedArray(s), this.solidPath = "";
				var a, o = this.masksProperties,
					h = 0,
					c = [],
					u, g, p = createElementID(),
					_, b, y, w, f = "clipPath",
					S = "clip-path";
				for (r = 0; r < s; r += 1)
					if ((o[r].mode !== "a" && o[r].mode !== "n" || o[r].inv || o[r].o.k !== 100 || o[r].o.x) && (f = "mask", S = "mask"), (o[r].mode === "s" || o[r].mode === "i") && h === 0 ? (_ = createNS("rect"), _.setAttribute("fill", "#ffffff"), _.setAttribute("width", this.element.comp.data.w || 0), _.setAttribute("height", this.element.comp.data.h || 0), c.push(_)) : _ = null, a = createNS("path"), o[r].mode === "n") this.viewData[r] = {
						op: PropertyFactory.getProp(this.element, o[r].o, 0, .01, this.element),
						prop: ShapePropertyFactory.getShapeProp(this.element, o[r], 3),
						elem: a,
						lastPath: ""
					}, n.appendChild(a);
					else {
						h += 1, a.setAttribute("fill", o[r].mode === "s" ? "#FF8500" : "#ffffff"), a.setAttribute("clip-rule", "nonzero");
						var x;
						if (o[r].x.k !== 0 ? (f = "mask", S = "mask", w = PropertyFactory.getProp(this.element, o[r].x, 0, null, this.element), x = createElementID(), b = createNS("filter"), b.setAttribute("id", x), y = createNS("feMorphology"), y.setAttribute("operator", "erode"), y.setAttribute("in", "SourceGraphic"), y.setAttribute("radius", "0"), b.appendChild(y), n.appendChild(b), a.setAttribute("stroke", o[r].mode === "s" ? "#FF8500" : "#ffffff")) : (y = null, w = null), this.storedData[r] = {
								elem: a,
								x: w,
								expan: y,
								lastPath: "",
								lastOperator: "",
								filterId: x,
								lastRadius: 0
							}, o[r].mode === "i") {
							g = c.length;
							var M = createNS("g");
							for (u = 0; u < g; u += 1) M.appendChild(c[u]);
							var T = createNS("mask");
							T.setAttribute("mask-type", "alpha"), T.setAttribute("id", p + "_" + h), T.appendChild(a), n.appendChild(T), M.setAttribute("mask", "url(" + getLocationHref() + "#" + p + "_" + h + ")"), c.length = 0, c.push(M)
						} else c.push(a);
						o[r].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[r] = {
							elem: a,
							lastPath: "",
							op: PropertyFactory.getProp(this.element, o[r].o, 0, .01, this.element),
							prop: ShapePropertyFactory.getShapeProp(this.element, o[r], 3),
							invRect: _
						}, this.viewData[r].prop.k || this.drawPath(o[r], this.viewData[r].prop.v, this.viewData[r])
					} for (this.maskElement = createNS(f), s = c.length, r = 0; r < s; r += 1) this.maskElement.appendChild(c[r]);
				h > 0 && (this.maskElement.setAttribute("id", p), this.element.maskedElement.setAttribute(S, "url(" + getLocationHref() + "#" + p + ")"), n.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
			}
			MaskElement.prototype.getMaskProperty = function (i) {
				return this.viewData[i].prop
			}, MaskElement.prototype.renderFrame = function (i) {
				var t = this.element.finalTransform.mat,
					e, n = this.masksProperties.length;
				for (e = 0; e < n; e += 1)
					if ((this.viewData[e].prop._mdf || i) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || i) && this.viewData[e].elem.setAttribute("fill-opacity", this.viewData[e].op.v), this.masksProperties[e].mode !== "n" && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || i) && this.viewData[e].invRect.setAttribute("transform", t.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || i))) {
						var r = this.storedData[e].expan;
						this.storedData[e].x.v < 0 ? (this.storedData[e].lastOperator !== "erode" && (this.storedData[e].lastOperator = "erode", this.storedData[e].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[e].filterId + ")")), r.setAttribute("radius", -this.storedData[e].x.v)) : (this.storedData[e].lastOperator !== "dilate" && (this.storedData[e].lastOperator = "dilate", this.storedData[e].elem.setAttribute("filter", null)), this.storedData[e].elem.setAttribute("stroke-width", this.storedData[e].x.v * 2))
					}
			}, MaskElement.prototype.getMaskelement = function () {
				return this.maskElement
			}, MaskElement.prototype.createLayerSolidPath = function () {
				var i = "M0,0 ";
				return i += " h" + this.globalData.compSize.w, i += " v" + this.globalData.compSize.h, i += " h-" + this.globalData.compSize.w, i += " v-" + this.globalData.compSize.h + " ", i
			}, MaskElement.prototype.drawPath = function (i, t, e) {
				var n = " M" + t.v[0][0] + "," + t.v[0][1],
					r, s;
				for (s = t._length, r = 1; r < s; r += 1) n += " C" + t.o[r - 1][0] + "," + t.o[r - 1][1] + " " + t.i[r][0] + "," + t.i[r][1] + " " + t.v[r][0] + "," + t.v[r][1];
				if (t.c && s > 1 && (n += " C" + t.o[r - 1][0] + "," + t.o[r - 1][1] + " " + t.i[0][0] + "," + t.i[0][1] + " " + t.v[0][0] + "," + t.v[0][1]), e.lastPath !== n) {
					var a = "";
					e.elem && (t.c && (a = i.inv ? this.solidPath + n : n), e.elem.setAttribute("d", a)), e.lastPath = n
				}
			}, MaskElement.prototype.destroy = function () {
				this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
			};
			var filtersFactory = function () {
					var i = {};
					i.createFilter = t, i.createAlphaToLuminanceFilter = e;

					function t(n, r) {
						var s = createNS("filter");
						return s.setAttribute("id", n), r !== !0 && (s.setAttribute("filterUnits", "objectBoundingBox"), s.setAttribute("x", "0%"), s.setAttribute("y", "0%"), s.setAttribute("width", "100%"), s.setAttribute("height", "100%")), s
					}

					function e() {
						var n = createNS("feColorMatrix");
						return n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "sRGB"), n.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), n
					}
					return i
				}(),
				featureSupport = function () {
					var i = {
						maskType: !0,
						svgLumaHidden: !0,
						offscreenCanvas: typeof OffscreenCanvas != "undefined"
					};
					return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (i.maskType = !1), /firefox/i.test(navigator.userAgent) && (i.svgLumaHidden = !1), i
				}(),
				registeredEffects$1 = {},
				idPrefix = "filter_result_";

			function SVGEffects(i) {
				var t, e = "SourceGraphic",
					n = i.data.ef ? i.data.ef.length : 0,
					r = createElementID(),
					s = filtersFactory.createFilter(r, !0),
					a = 0;
				this.filters = [];
				var o;
				for (t = 0; t < n; t += 1) {
					o = null;
					var h = i.data.ef[t].ty;
					if (registeredEffects$1[h]) {
						var c = registeredEffects$1[h].effect;
						o = new c(s, i.effectsManager.effectElements[t], i, idPrefix + a, e), e = idPrefix + a, registeredEffects$1[h].countsAsEffect && (a += 1)
					}
					o && this.filters.push(o)
				}
				a && (i.globalData.defs.appendChild(s), i.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + r + ")")), this.filters.length && i.addRenderableComponent(this)
			}
			SVGEffects.prototype.renderFrame = function (i) {
				var t, e = this.filters.length;
				for (t = 0; t < e; t += 1) this.filters[t].renderFrame(i)
			}, SVGEffects.prototype.getEffects = function (i) {
				var t, e = this.filters.length,
					n = [];
				for (t = 0; t < e; t += 1) this.filters[t].type === i && n.push(this.filters[t]);
				return n
			};

			function registerEffect$1(i, t, e) {
				registeredEffects$1[i] = {
					effect: t,
					countsAsEffect: e
				}
			}

			function SVGBaseElement() {}
			SVGBaseElement.prototype = {
				initRendererElement: function () {
					this.layerElement = createNS("g")
				},
				createContainerElements: function () {
					this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
					var t = null;
					if (this.data.td) {
						this.matteMasks = {};
						var e = createNS("g");
						e.setAttribute("id", this.layerId), e.appendChild(this.layerElement), t = e, this.globalData.defs.appendChild(e)
					} else this.data.tt ? (this.matteElement.appendChild(this.layerElement), t = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
					if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) {
						var n = createNS("clipPath"),
							r = createNS("path");
						r.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
						var s = createElementID();
						if (n.setAttribute("id", s), n.appendChild(r), this.globalData.defs.appendChild(n), this.checkMasks()) {
							var a = createNS("g");
							a.setAttribute("clip-path", "url(" + getLocationHref() + "#" + s + ")"), a.appendChild(this.layerElement), this.transformedElement = a, t ? t.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
						} else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + s + ")")
					}
					this.data.bm !== 0 && this.setBlendMode()
				},
				renderElement: function () {
					this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
				},
				destroyBaseElement: function () {
					this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
				},
				getBaseElement: function () {
					return this.data.hd ? null : this.baseElement
				},
				createRenderableComponents: function () {
					this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms()
				},
				getMatte: function (t) {
					if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[t]) {
						var e = this.layerId + "_" + t,
							n, r, s, a;
						if (t === 1 || t === 3) {
							var o = createNS("mask");
							o.setAttribute("id", e), o.setAttribute("mask-type", t === 3 ? "luminance" : "alpha"), s = createNS("use"), s.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), o.appendChild(s), this.globalData.defs.appendChild(o), !featureSupport.maskType && t === 1 && (o.setAttribute("mask-type", "luminance"), n = createElementID(), r = filtersFactory.createFilter(n), this.globalData.defs.appendChild(r), r.appendChild(filtersFactory.createAlphaToLuminanceFilter()), a = createNS("g"), a.appendChild(s), o.appendChild(a), a.setAttribute("filter", "url(" + getLocationHref() + "#" + n + ")"))
						} else if (t === 2) {
							var h = createNS("mask");
							h.setAttribute("id", e), h.setAttribute("mask-type", "alpha");
							var c = createNS("g");
							h.appendChild(c), n = createElementID(), r = filtersFactory.createFilter(n);
							var u = createNS("feComponentTransfer");
							u.setAttribute("in", "SourceGraphic"), r.appendChild(u);
							var g = createNS("feFuncA");
							g.setAttribute("type", "table"), g.setAttribute("tableValues", "1.0 0.0"), u.appendChild(g), this.globalData.defs.appendChild(r);
							var p = createNS("rect");
							p.setAttribute("width", this.comp.data.w), p.setAttribute("height", this.comp.data.h), p.setAttribute("x", "0"), p.setAttribute("y", "0"), p.setAttribute("fill", "#ffffff"), p.setAttribute("opacity", "0"), c.setAttribute("filter", "url(" + getLocationHref() + "#" + n + ")"), c.appendChild(p), s = createNS("use"), s.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), c.appendChild(s), featureSupport.maskType || (h.setAttribute("mask-type", "luminance"), r.appendChild(filtersFactory.createAlphaToLuminanceFilter()), a = createNS("g"), c.appendChild(p), a.appendChild(this.layerElement), c.appendChild(a)), this.globalData.defs.appendChild(h)
						}
						this.matteMasks[t] = e
					}
					return this.matteMasks[t]
				},
				setMatte: function (t) {
					this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + t + ")")
				}
			};

			function HierarchyElement() {}
			HierarchyElement.prototype = {
				initHierarchy: function () {
					this.hierarchy = [], this._isParent = !1, this.checkParenting()
				},
				setHierarchy: function (t) {
					this.hierarchy = t
				},
				setAsParent: function () {
					this._isParent = !0
				},
				checkParenting: function () {
					this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
				}
			};

			function RenderableDOMElement() {}(function () {
				var i = {
					initElement: function (e, n, r) {
						this.initFrame(), this.initBaseData(e, n, r), this.initTransform(e, n, r), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
					},
					hide: function () {
						if (!this.hidden && (!this.isInRange || this.isTransparent)) {
							var e = this.baseElement || this.layerElement;
							e.style.display = "none", this.hidden = !0
						}
					},
					show: function () {
						if (this.isInRange && !this.isTransparent) {
							if (!this.data.hd) {
								var e = this.baseElement || this.layerElement;
								e.style.display = "block"
							}
							this.hidden = !1, this._isFirstFrame = !0
						}
					},
					renderFrame: function () {
						this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
					},
					renderInnerContent: function () {},
					prepareFrame: function (e) {
						this._mdf = !1, this.prepareRenderableFrame(e), this.prepareProperties(e, this.isInRange), this.checkTransparency()
					},
					destroy: function () {
						this.innerElem = null, this.destroyBaseElement()
					}
				};
				extendPrototype([RenderableElement, createProxyFunction(i)], RenderableDOMElement)
			})();

			function IImageElement(i, t, e) {
				this.assetData = t.getAssetData(i.refId), this.assetData && this.assetData.sid && (this.assetData = t.slotManager.getProp(this.assetData)), this.initElement(i, t, e), this.sourceRect = {
					top: 0,
					left: 0,
					width: this.assetData.w,
					height: this.assetData.h
				}
			}
			extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () {
				var i = this.globalData.getAssetsPath(this.assetData);
				this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", i), this.layerElement.appendChild(this.innerElem)
			}, IImageElement.prototype.sourceRectAtTime = function () {
				return this.sourceRect
			};

			function ProcessedElement(i, t) {
				this.elem = i, this.pos = t
			}

			function IShapeElement() {}
			IShapeElement.prototype = {
				addShapeToModifiers: function (t) {
					var e, n = this.shapeModifiers.length;
					for (e = 0; e < n; e += 1) this.shapeModifiers[e].addShape(t)
				},
				isShapeInAnimatedModifiers: function (t) {
					for (var e = 0, n = this.shapeModifiers.length; e < n;)
						if (this.shapeModifiers[e].isAnimatedWithShape(t)) return !0;
					return !1
				},
				renderModifiers: function () {
					if (this.shapeModifiers.length) {
						var t, e = this.shapes.length;
						for (t = 0; t < e; t += 1) this.shapes[t].sh.reset();
						e = this.shapeModifiers.length;
						var n;
						for (t = e - 1; t >= 0 && (n = this.shapeModifiers[t].processShapes(this._isFirstFrame), !n); t -= 1);
					}
				},
				searchProcessedElement: function (t) {
					for (var e = this.processedElements, n = 0, r = e.length; n < r;) {
						if (e[n].elem === t) return e[n].pos;
						n += 1
					}
					return 0
				},
				addProcessedElement: function (t, e) {
					for (var n = this.processedElements, r = n.length; r;)
						if (r -= 1, n[r].elem === t) {
							n[r].pos = e;
							return
						} n.push(new ProcessedElement(t, e))
				},
				prepareFrame: function (t) {
					this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
				}
			};
			var lineCapEnum = {
					1: "butt",
					2: "round",
					3: "square"
				},
				lineJoinEnum = {
					1: "miter",
					2: "round",
					3: "bevel"
				};

			function SVGShapeData(i, t, e) {
				this.caches = [], this.styles = [], this.transformers = i, this.lStr = "", this.sh = e, this.lvl = t, this._isAnimated = !!e.k;
				for (var n = 0, r = i.length; n < r;) {
					if (i[n].mProps.dynamicProperties.length) {
						this._isAnimated = !0;
						break
					}
					n += 1
				}
			}
			SVGShapeData.prototype.setAsAnimated = function () {
				this._isAnimated = !0
			};

			function SVGStyleData(i, t) {
				this.data = i, this.type = i.ty, this.d = "", this.lvl = t, this._mdf = !1, this.closed = i.hd === !0, this.pElem = createNS("path"), this.msElem = null
			}
			SVGStyleData.prototype.reset = function () {
				this.d = "", this._mdf = !1
			};

			function DashProperty(i, t, e, n) {
				this.elem = i, this.frameId = -1, this.dataProps = createSizedArray(t.length), this.renderer = e, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", t.length ? t.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(n);
				var r, s = t.length || 0,
					a;
				for (r = 0; r < s; r += 1) a = PropertyFactory.getProp(i, t[r].v, 0, 0, this), this.k = a.k || this.k, this.dataProps[r] = {
					n: t[r].n,
					p: a
				};
				this.k || this.getValue(!0), this._isAnimated = this.k
			}
			DashProperty.prototype.getValue = function (i) {
				if (!(this.elem.globalData.frameId === this.frameId && !i) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || i, this._mdf)) {
					var t = 0,
						e = this.dataProps.length;
					for (this.renderer === "svg" && (this.dashStr = ""), t = 0; t < e; t += 1) this.dataProps[t].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[t].p.v : this.dashArray[t] = this.dataProps[t].p.v : this.dashoffset[0] = this.dataProps[t].p.v
				}
			}, extendPrototype([DynamicPropertyContainer], DashProperty);

			function SVGStrokeStyleData(i, t, e) {
				this.initDynamicPropertyContainer(i), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(i, t.o, 0, .01, this), this.w = PropertyFactory.getProp(i, t.w, 0, null, this), this.d = new DashProperty(i, t.d || {}, "svg", this), this.c = PropertyFactory.getProp(i, t.c, 1, 255, this), this.style = e, this._isAnimated = !!this._isAnimated
			}
			extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

			function SVGFillStyleData(i, t, e) {
				this.initDynamicPropertyContainer(i), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(i, t.o, 0, .01, this), this.c = PropertyFactory.getProp(i, t.c, 1, 255, this), this.style = e
			}
			extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

			function SVGNoStyleData(i, t, e) {
				this.initDynamicPropertyContainer(i), this.getValue = this.iterateDynamicProperties, this.style = e
			}
			extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

			function GradientProperty(i, t, e) {
				this.data = t, this.c = createTypedArray("uint8c", t.p * 4);
				var n = t.k.k[0].s ? t.k.k[0].s.length - t.p * 4 : t.k.k.length - t.p * 4;
				this.o = createTypedArray("float32", n), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = n, this.initDynamicPropertyContainer(e), this.prop = PropertyFactory.getProp(i, t.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
			}
			GradientProperty.prototype.comparePoints = function (i, t) {
				for (var e = 0, n = this.o.length / 2, r; e < n;) {
					if (r = Math.abs(i[e * 4] - i[t * 4 + e * 2]), r > .01) return !1;
					e += 1
				}
				return !0
			}, GradientProperty.prototype.checkCollapsable = function () {
				if (this.o.length / 2 !== this.c.length / 4) return !1;
				if (this.data.k.k[0].s)
					for (var i = 0, t = this.data.k.k.length; i < t;) {
						if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) return !1;
						i += 1
					} else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
				return !0
			}, GradientProperty.prototype.getValue = function (i) {
				if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || i) {
					var t, e = this.data.p * 4,
						n, r;
					for (t = 0; t < e; t += 1) n = t % 4 === 0 ? 100 : 255, r = Math.round(this.prop.v[t] * n), this.c[t] !== r && (this.c[t] = r, this._cmdf = !i);
					if (this.o.length)
						for (e = this.prop.v.length, t = this.data.p * 4; t < e; t += 1) n = t % 2 === 0 ? 100 : 1, r = t % 2 === 0 ? Math.round(this.prop.v[t] * 100) : this.prop.v[t], this.o[t - this.data.p * 4] !== r && (this.o[t - this.data.p * 4] = r, this._omdf = !i);
					this._mdf = !i
				}
			}, extendPrototype([DynamicPropertyContainer], GradientProperty);

			function SVGGradientFillStyleData(i, t, e) {
				this.initDynamicPropertyContainer(i), this.getValue = this.iterateDynamicProperties, this.initGradientData(i, t, e)
			}
			SVGGradientFillStyleData.prototype.initGradientData = function (i, t, e) {
				this.o = PropertyFactory.getProp(i, t.o, 0, .01, this), this.s = PropertyFactory.getProp(i, t.s, 1, null, this), this.e = PropertyFactory.getProp(i, t.e, 1, null, this), this.h = PropertyFactory.getProp(i, t.h || {
					k: 0
				}, 0, .01, this), this.a = PropertyFactory.getProp(i, t.a || {
					k: 0
				}, 0, degToRads, this), this.g = new GradientProperty(i, t.g, this), this.style = e, this.stops = [], this.setGradientData(e.pElem, t), this.setGradientOpacity(t, e), this._isAnimated = !!this._isAnimated
			}, SVGGradientFillStyleData.prototype.setGradientData = function (i, t) {
				var e = createElementID(),
					n = createNS(t.t === 1 ? "linearGradient" : "radialGradient");
				n.setAttribute("id", e), n.setAttribute("spreadMethod", "pad"), n.setAttribute("gradientUnits", "userSpaceOnUse");
				var r = [],
					s, a, o;
				for (o = t.g.p * 4, a = 0; a < o; a += 4) s = createNS("stop"), n.appendChild(s), r.push(s);
				i.setAttribute(t.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + e + ")"), this.gf = n, this.cst = r
			}, SVGGradientFillStyleData.prototype.setGradientOpacity = function (i, t) {
				if (this.g._hasOpacity && !this.g._collapsable) {
					var e, n, r, s = createNS("mask"),
						a = createNS("path");
					s.appendChild(a);
					var o = createElementID(),
						h = createElementID();
					s.setAttribute("id", h);
					var c = createNS(i.t === 1 ? "linearGradient" : "radialGradient");
					c.setAttribute("id", o), c.setAttribute("spreadMethod", "pad"), c.setAttribute("gradientUnits", "userSpaceOnUse"), r = i.g.k.k[0].s ? i.g.k.k[0].s.length : i.g.k.k.length;
					var u = this.stops;
					for (n = i.g.p * 4; n < r; n += 2) e = createNS("stop"), e.setAttribute("stop-color", "rgb(255,255,255)"), c.appendChild(e), u.push(e);
					a.setAttribute(i.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + o + ")"), i.ty === "gs" && (a.setAttribute("stroke-linecap", lineCapEnum[i.lc || 2]), a.setAttribute("stroke-linejoin", lineJoinEnum[i.lj || 2]), i.lj === 1 && a.setAttribute("stroke-miterlimit", i.ml)), this.of = c, this.ms = s, this.ost = u, this.maskId = h, t.msElem = a
				}
			}, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

			function SVGGradientStrokeStyleData(i, t, e) {
				this.initDynamicPropertyContainer(i), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(i, t.w, 0, null, this), this.d = new DashProperty(i, t.d || {}, "svg", this), this.initGradientData(i, t, e), this._isAnimated = !!this._isAnimated
			}
			extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

			function ShapeGroupData() {
				this.it = [], this.prevViewData = [], this.gr = createNS("g")
			}

			function SVGTransformData(i, t, e) {
				this.transform = {
					mProps: i,
					op: t,
					container: e
				}, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
			}
			var buildShapeString = function (t, e, n, r) {
					if (e === 0) return "";
					var s = t.o,
						a = t.i,
						o = t.v,
						h, c = " M" + r.applyToPointStringified(o[0][0], o[0][1]);
					for (h = 1; h < e; h += 1) c += " C" + r.applyToPointStringified(s[h - 1][0], s[h - 1][1]) + " " + r.applyToPointStringified(a[h][0], a[h][1]) + " " + r.applyToPointStringified(o[h][0], o[h][1]);
					return n && e && (c += " C" + r.applyToPointStringified(s[h - 1][0], s[h - 1][1]) + " " + r.applyToPointStringified(a[0][0], a[0][1]) + " " + r.applyToPointStringified(o[0][0], o[0][1]), c += "z"), c
				},
				SVGElementsRenderer = function () {
					var i = new Matrix,
						t = new Matrix,
						e = {
							createRenderFunction: n
						};

					function n(g) {
						switch (g.ty) {
							case "fl":
								return o;
							case "gf":
								return c;
							case "gs":
								return h;
							case "st":
								return u;
							case "sh":
							case "el":
							case "rc":
							case "sr":
								return a;
							case "tr":
								return r;
							case "no":
								return s;
							default:
								return null
						}
					}

					function r(g, p, _) {
						(_ || p.transform.op._mdf) && p.transform.container.setAttribute("opacity", p.transform.op.v), (_ || p.transform.mProps._mdf) && p.transform.container.setAttribute("transform", p.transform.mProps.v.to2dCSS())
					}

					function s() {}

					function a(g, p, _) {
						var b, y, w, f, S, x, M = p.styles.length,
							T = p.lvl,
							I, L, F, k;
						for (x = 0; x < M; x += 1) {
							if (f = p.sh._mdf || _, p.styles[x].lvl < T) {
								for (L = t.reset(), F = T - p.styles[x].lvl, k = p.transformers.length - 1; !f && F > 0;) f = p.transformers[k].mProps._mdf || f, F -= 1, k -= 1;
								if (f)
									for (F = T - p.styles[x].lvl, k = p.transformers.length - 1; F > 0;) L.multiply(p.transformers[k].mProps.v), F -= 1, k -= 1
							} else L = i;
							if (I = p.sh.paths, y = I._length, f) {
								for (w = "", b = 0; b < y; b += 1) S = I.shapes[b], S && S._length && (w += buildShapeString(S, S._length, S.c, L));
								p.caches[x] = w
							} else w = p.caches[x];
							p.styles[x].d += g.hd === !0 ? "" : w, p.styles[x]._mdf = f || p.styles[x]._mdf
						}
					}

					function o(g, p, _) {
						var b = p.style;
						(p.c._mdf || _) && b.pElem.setAttribute("fill", "rgb(" + bmFloor(p.c.v[0]) + "," + bmFloor(p.c.v[1]) + "," + bmFloor(p.c.v[2]) + ")"), (p.o._mdf || _) && b.pElem.setAttribute("fill-opacity", p.o.v)
					}

					function h(g, p, _) {
						c(g, p, _), u(g, p, _)
					}

					function c(g, p, _) {
						var b = p.gf,
							y = p.g._hasOpacity,
							w = p.s.v,
							f = p.e.v;
						if (p.o._mdf || _) {
							var S = g.ty === "gf" ? "fill-opacity" : "stroke-opacity";
							p.style.pElem.setAttribute(S, p.o.v)
						}
						if (p.s._mdf || _) {
							var x = g.t === 1 ? "x1" : "cx",
								M = x === "x1" ? "y1" : "cy";
							b.setAttribute(x, w[0]), b.setAttribute(M, w[1]), y && !p.g._collapsable && (p.of.setAttribute(x, w[0]), p.of.setAttribute(M, w[1]))
						}
						var T, I, L, F;
						if (p.g._cmdf || _) {
							T = p.cst;
							var k = p.g.c;
							for (L = T.length, I = 0; I < L; I += 1) F = T[I], F.setAttribute("offset", k[I * 4] + "%"), F.setAttribute("stop-color", "rgb(" + k[I * 4 + 1] + "," + k[I * 4 + 2] + "," + k[I * 4 + 3] + ")")
						}
						if (y && (p.g._omdf || _)) {
							var G = p.g.o;
							for (p.g._collapsable ? T = p.cst : T = p.ost, L = T.length, I = 0; I < L; I += 1) F = T[I], p.g._collapsable || F.setAttribute("offset", G[I * 2] + "%"), F.setAttribute("stop-opacity", G[I * 2 + 1])
						}
						if (g.t === 1)(p.e._mdf || _) && (b.setAttribute("x2", f[0]), b.setAttribute("y2", f[1]), y && !p.g._collapsable && (p.of.setAttribute("x2", f[0]), p.of.setAttribute("y2", f[1])));
						else {
							var j;
							if ((p.s._mdf || p.e._mdf || _) && (j = Math.sqrt(Math.pow(w[0] - f[0], 2) + Math.pow(w[1] - f[1], 2)), b.setAttribute("r", j), y && !p.g._collapsable && p.of.setAttribute("r", j)), p.e._mdf || p.h._mdf || p.a._mdf || _) {
								j || (j = Math.sqrt(Math.pow(w[0] - f[0], 2) + Math.pow(w[1] - f[1], 2)));
								var U = Math.atan2(f[1] - w[1], f[0] - w[0]),
									z = p.h.v;
								z >= 1 ? z = .99 : z <= -1 && (z = -.99);
								var $ = j * z,
									W = Math.cos(U + p.a.v) * $ + w[0],
									O = Math.sin(U + p.a.v) * $ + w[1];
								b.setAttribute("fx", W), b.setAttribute("fy", O), y && !p.g._collapsable && (p.of.setAttribute("fx", W), p.of.setAttribute("fy", O))
							}
						}
					}

					function u(g, p, _) {
						var b = p.style,
							y = p.d;
						y && (y._mdf || _) && y.dashStr && (b.pElem.setAttribute("stroke-dasharray", y.dashStr), b.pElem.setAttribute("stroke-dashoffset", y.dashoffset[0])), p.c && (p.c._mdf || _) && b.pElem.setAttribute("stroke", "rgb(" + bmFloor(p.c.v[0]) + "," + bmFloor(p.c.v[1]) + "," + bmFloor(p.c.v[2]) + ")"), (p.o._mdf || _) && b.pElem.setAttribute("stroke-opacity", p.o.v), (p.w._mdf || _) && (b.pElem.setAttribute("stroke-width", p.w.v), b.msElem && b.msElem.setAttribute("stroke-width", p.w.v))
					}
					return e
				}();

			function SVGShapeElement(i, t, e) {
				this.shapes = [], this.shapesData = i.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(i, t, e), this.prevViewData = []
			}
			extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () {}, SVGShapeElement.prototype.createContent = function () {
				this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
			}, SVGShapeElement.prototype.filterUniqueShapes = function () {
				var i, t = this.shapes.length,
					e, n, r = this.stylesList.length,
					s, a = [],
					o = !1;
				for (n = 0; n < r; n += 1) {
					for (s = this.stylesList[n], o = !1, a.length = 0, i = 0; i < t; i += 1) e = this.shapes[i], e.styles.indexOf(s) !== -1 && (a.push(e), o = e._isAnimated || o);
					a.length > 1 && o && this.setShapesAsAnimated(a)
				}
			}, SVGShapeElement.prototype.setShapesAsAnimated = function (i) {
				var t, e = i.length;
				for (t = 0; t < e; t += 1) i[t].setAsAnimated()
			}, SVGShapeElement.prototype.createStyleElement = function (i, t) {
				var e, n = new SVGStyleData(i, t),
					r = n.pElem;
				if (i.ty === "st") e = new SVGStrokeStyleData(this, i, n);
				else if (i.ty === "fl") e = new SVGFillStyleData(this, i, n);
				else if (i.ty === "gf" || i.ty === "gs") {
					var s = i.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
					e = new s(this, i, n), this.globalData.defs.appendChild(e.gf), e.maskId && (this.globalData.defs.appendChild(e.ms), this.globalData.defs.appendChild(e.of), r.setAttribute("mask", "url(" + getLocationHref() + "#" + e.maskId + ")"))
				} else i.ty === "no" && (e = new SVGNoStyleData(this, i, n));
				return (i.ty === "st" || i.ty === "gs") && (r.setAttribute("stroke-linecap", lineCapEnum[i.lc || 2]), r.setAttribute("stroke-linejoin", lineJoinEnum[i.lj || 2]), r.setAttribute("fill-opacity", "0"), i.lj === 1 && r.setAttribute("stroke-miterlimit", i.ml)), i.r === 2 && r.setAttribute("fill-rule", "evenodd"), i.ln && r.setAttribute("id", i.ln), i.cl && r.setAttribute("class", i.cl), i.bm && (r.style["mix-blend-mode"] = getBlendMode(i.bm)), this.stylesList.push(n), this.addToAnimatedContents(i, e), e
			}, SVGShapeElement.prototype.createGroupElement = function (i) {
				var t = new ShapeGroupData;
				return i.ln && t.gr.setAttribute("id", i.ln), i.cl && t.gr.setAttribute("class", i.cl), i.bm && (t.gr.style["mix-blend-mode"] = getBlendMode(i.bm)), t
			}, SVGShapeElement.prototype.createTransformElement = function (i, t) {
				var e = TransformPropertyFactory.getTransformProperty(this, i, this),
					n = new SVGTransformData(e, e.o, t);
				return this.addToAnimatedContents(i, n), n
			}, SVGShapeElement.prototype.createShapeElement = function (i, t, e) {
				var n = 4;
				i.ty === "rc" ? n = 5 : i.ty === "el" ? n = 6 : i.ty === "sr" && (n = 7);
				var r = ShapePropertyFactory.getShapeProp(this, i, n, this),
					s = new SVGShapeData(t, e, r);
				return this.shapes.push(s), this.addShapeToModifiers(s), this.addToAnimatedContents(i, s), s
			}, SVGShapeElement.prototype.addToAnimatedContents = function (i, t) {
				for (var e = 0, n = this.animatedContents.length; e < n;) {
					if (this.animatedContents[e].element === t) return;
					e += 1
				}
				this.animatedContents.push({
					fn: SVGElementsRenderer.createRenderFunction(i),
					element: t,
					data: i
				})
			}, SVGShapeElement.prototype.setElementStyles = function (i) {
				var t = i.styles,
					e, n = this.stylesList.length;
				for (e = 0; e < n; e += 1) this.stylesList[e].closed || t.push(this.stylesList[e])
			}, SVGShapeElement.prototype.reloadShapes = function () {
				this._isFirstFrame = !0;
				var i, t = this.itemsData.length;
				for (i = 0; i < t; i += 1) this.prevViewData[i] = this.itemsData[i];
				for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), t = this.dynamicProperties.length, i = 0; i < t; i += 1) this.dynamicProperties[i].getValue();
				this.renderModifiers()
			}, SVGShapeElement.prototype.searchShapes = function (i, t, e, n, r, s, a) {
				var o = [].concat(s),
					h, c = i.length - 1,
					u, g, p = [],
					_ = [],
					b, y, w;
				for (h = c; h >= 0; h -= 1) {
					if (w = this.searchProcessedElement(i[h]), w ? t[h] = e[w - 1] : i[h]._render = a, i[h].ty === "fl" || i[h].ty === "st" || i[h].ty === "gf" || i[h].ty === "gs" || i[h].ty === "no") w ? t[h].style.closed = !1 : t[h] = this.createStyleElement(i[h], r), i[h]._render && t[h].style.pElem.parentNode !== n && n.appendChild(t[h].style.pElem), p.push(t[h].style);
					else if (i[h].ty === "gr") {
						if (!w) t[h] = this.createGroupElement(i[h]);
						else
							for (g = t[h].it.length, u = 0; u < g; u += 1) t[h].prevViewData[u] = t[h].it[u];
						this.searchShapes(i[h].it, t[h].it, t[h].prevViewData, t[h].gr, r + 1, o, a), i[h]._render && t[h].gr.parentNode !== n && n.appendChild(t[h].gr)
					} else i[h].ty === "tr" ? (w || (t[h] = this.createTransformElement(i[h], n)), b = t[h].transform, o.push(b)) : i[h].ty === "sh" || i[h].ty === "rc" || i[h].ty === "el" || i[h].ty === "sr" ? (w || (t[h] = this.createShapeElement(i[h], o, r)), this.setElementStyles(t[h])) : i[h].ty === "tm" || i[h].ty === "rd" || i[h].ty === "ms" || i[h].ty === "pb" || i[h].ty === "zz" || i[h].ty === "op" ? (w ? (y = t[h], y.closed = !1) : (y = ShapeModifiers.getModifier(i[h].ty), y.init(this, i[h]), t[h] = y, this.shapeModifiers.push(y)), _.push(y)) : i[h].ty === "rp" && (w ? (y = t[h], y.closed = !0) : (y = ShapeModifiers.getModifier(i[h].ty), t[h] = y, y.init(this, i, h, t), this.shapeModifiers.push(y), a = !1), _.push(y));
					this.addProcessedElement(i[h], h + 1)
				}
				for (c = p.length, h = 0; h < c; h += 1) p[h].closed = !0;
				for (c = _.length, h = 0; h < c; h += 1) _[h].closed = !0
			}, SVGShapeElement.prototype.renderInnerContent = function () {
				this.renderModifiers();
				var i, t = this.stylesList.length;
				for (i = 0; i < t; i += 1) this.stylesList[i].reset();
				for (this.renderShape(), i = 0; i < t; i += 1)(this.stylesList[i]._mdf || this._isFirstFrame) && (this.stylesList[i].msElem && (this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d), this.stylesList[i].d = "M0 0" + this.stylesList[i].d), this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0"))
			}, SVGShapeElement.prototype.renderShape = function () {
				var i, t = this.animatedContents.length,
					e;
				for (i = 0; i < t; i += 1) e = this.animatedContents[i], (this._isFirstFrame || e.element._isAnimated) && e.data !== !0 && e.fn(e.data, e.element, this._isFirstFrame)
			}, SVGShapeElement.prototype.destroy = function () {
				this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
			};

			function LetterProps(i, t, e, n, r, s) {
				this.o = i, this.sw = t, this.sc = e, this.fc = n, this.m = r, this.p = s, this._mdf = {
					o: !0,
					sw: !!t,
					sc: !!e,
					fc: !!n,
					m: !0,
					p: !0
				}
			}
			LetterProps.prototype.update = function (i, t, e, n, r, s) {
				this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
				var a = !1;
				return this.o !== i && (this.o = i, this._mdf.o = !0, a = !0), this.sw !== t && (this.sw = t, this._mdf.sw = !0, a = !0), this.sc !== e && (this.sc = e, this._mdf.sc = !0, a = !0), this.fc !== n && (this.fc = n, this._mdf.fc = !0, a = !0), this.m !== r && (this.m = r, this._mdf.m = !0, a = !0), s.length && (this.p[0] !== s[0] || this.p[1] !== s[1] || this.p[4] !== s[4] || this.p[5] !== s[5] || this.p[12] !== s[12] || this.p[13] !== s[13]) && (this.p = s, this._mdf.p = !0, a = !0), a
			};

			function TextProperty(i, t) {
				this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, t.d && t.d.sid && (t.d = i.globalData.slotManager.getProp(t.d)), this.data = t, this.elem = i, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
					ascent: 0,
					boxWidth: this.defaultBoxWidth,
					f: "",
					fStyle: "",
					fWeight: "",
					fc: "",
					j: "",
					justifyOffset: "",
					l: [],
					lh: 0,
					lineWidths: [],
					ls: "",
					of: "",
					s: "",
					sc: "",
					sw: 0,
					t: 0,
					tr: 0,
					sz: 0,
					ps: null,
					fillColorAnim: !1,
					strokeColorAnim: !1,
					strokeWidthAnim: !1,
					yOffset: 0,
					finalSize: 0,
					finalText: [],
					finalLineHeight: 0,
					__complete: !1
				}, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
			}
			TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (i, t) {
				for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && (i[e] = t[e]);
				return i
			}, TextProperty.prototype.setCurrentData = function (i) {
				i.__complete || this.completeTextData(i), this.currentData = i, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
			}, TextProperty.prototype.searchProperty = function () {
				return this.searchKeyframes()
			}, TextProperty.prototype.searchKeyframes = function () {
				return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
			}, TextProperty.prototype.addEffect = function (i) {
				this.effectsSequence.push(i), this.elem.addDynamicProperty(this)
			}, TextProperty.prototype.getValue = function (i) {
				if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !i)) {
					this.currentData.t = this.data.d.k[this.keysIndex].s.t;
					var t = this.currentData,
						e = this.keysIndex;
					if (this.lock) {
						this.setCurrentData(this.currentData);
						return
					}
					this.lock = !0, this._mdf = !1;
					var n, r = this.effectsSequence.length,
						s = i || this.data.d.k[this.keysIndex].s;
					for (n = 0; n < r; n += 1) e !== this.keysIndex ? s = this.effectsSequence[n](s, s.t) : s = this.effectsSequence[n](this.currentData, s.t);
					t !== s && this.setCurrentData(s), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
				}
			}, TextProperty.prototype.getKeyframeValue = function () {
				for (var i = this.data.d.k, t = this.elem.comp.renderedFrame, e = 0, n = i.length; e <= n - 1 && !(e === n - 1 || i[e + 1].t > t);) e += 1;
				return this.keysIndex !== e && (this.keysIndex = e), this.data.d.k[this.keysIndex].s
			}, TextProperty.prototype.buildFinalText = function (i) {
				for (var t = [], e = 0, n = i.length, r, s, a = !1, o = !1, h = ""; e < n;) a = o, o = !1, r = i.charCodeAt(e), h = i.charAt(e), FontManager.isCombinedCharacter(r) ? a = !0 : r >= 55296 && r <= 56319 ? FontManager.isRegionalFlag(i, e) ? h = i.substr(e, 14) : (s = i.charCodeAt(e + 1), s >= 56320 && s <= 57343 && (FontManager.isModifier(r, s) ? (h = i.substr(e, 2), a = !0) : FontManager.isFlagEmoji(i.substr(e, 4)) ? h = i.substr(e, 4) : h = i.substr(e, 2))) : r > 56319 ? (s = i.charCodeAt(e + 1), FontManager.isVariationSelector(r) && (a = !0)) : FontManager.isZeroWidthJoiner(r) && (a = !0, o = !0), a ? (t[t.length - 1] += h, a = !1) : t.push(h), e += h.length;
				return t
			}, TextProperty.prototype.completeTextData = function (i) {
				i.__complete = !0;
				var t = this.elem.globalData.fontManager,
					e = this.data,
					n = [],
					r, s, a, o = 0,
					h, c = e.m.g,
					u = 0,
					g = 0,
					p = 0,
					_ = [],
					b = 0,
					y = 0,
					w, f, S = t.getFontByName(i.f),
					x, M = 0,
					T = getFontProperties(S);
				i.fWeight = T.weight, i.fStyle = T.style, i.finalSize = i.s, i.finalText = this.buildFinalText(i.t), s = i.finalText.length, i.finalLineHeight = i.lh;
				var I = i.tr / 1e3 * i.finalSize,
					L;
				if (i.sz)
					for (var F = !0, k = i.sz[0], G = i.sz[1], j, U; F;) {
						U = this.buildFinalText(i.t), j = 0, b = 0, s = U.length, I = i.tr / 1e3 * i.finalSize;
						var z = -1;
						for (r = 0; r < s; r += 1) L = U[r].charCodeAt(0), a = !1, U[r] === " " ? z = r : (L === 13 || L === 3) && (b = 0, a = !0, j += i.finalLineHeight || i.finalSize * 1.2), t.chars ? (x = t.getCharData(U[r], S.fStyle, S.fFamily), M = a ? 0 : x.w * i.finalSize / 100) : M = t.measureText(U[r], i.f, i.finalSize), b + M > k && U[r] !== " " ? (z === -1 ? s += 1 : r = z, j += i.finalLineHeight || i.finalSize * 1.2, U.splice(r, z === r ? 1 : 0, "\r"), z = -1, b = 0) : (b += M, b += I);
						j += S.ascent * i.finalSize / 100, this.canResize && i.finalSize > this.minimumFontSize && G < j ? (i.finalSize -= 1, i.finalLineHeight = i.finalSize * i.lh / i.s) : (i.finalText = U, s = i.finalText.length, F = !1)
					}
				b = -I, M = 0;
				var $ = 0,
					W;
				for (r = 0; r < s; r += 1)
					if (a = !1, W = i.finalText[r], L = W.charCodeAt(0), L === 13 || L === 3 ? ($ = 0, _.push(b), y = b > y ? b : y, b = -2 * I, h = "", a = !0, p += 1) : h = W, t.chars ? (x = t.getCharData(W, S.fStyle, t.getFontByName(i.f).fFamily), M = a ? 0 : x.w * i.finalSize / 100) : M = t.measureText(h, i.f, i.finalSize), W === " " ? $ += M + I : (b += M + I + $, $ = 0), n.push({
							l: M,
							an: M,
							add: u,
							n: a,
							anIndexes: [],
							val: h,
							line: p,
							animatorJustifyOffset: 0
						}), c == 2) {
						if (u += M, h === "" || h === " " || r === s - 1) {
							for ((h === "" || h === " ") && (u -= M); g <= r;) n[g].an = u, n[g].ind = o, n[g].extra = M, g += 1;
							o += 1, u = 0
						}
					} else if (c == 3) {
					if (u += M, h === "" || r === s - 1) {
						for (h === "" && (u -= M); g <= r;) n[g].an = u, n[g].ind = o, n[g].extra = M, g += 1;
						u = 0, o += 1
					}
				} else n[o].ind = o, n[o].extra = 0, o += 1;
				if (i.l = n, y = b > y ? b : y, _.push(b), i.sz) i.boxWidth = i.sz[0], i.justifyOffset = 0;
				else switch (i.boxWidth = y, i.j) {
					case 1:
						i.justifyOffset = -i.boxWidth;
						break;
					case 2:
						i.justifyOffset = -i.boxWidth / 2;
						break;
					default:
						i.justifyOffset = 0
				}
				i.lineWidths = _;
				var O = e.a,
					B, A;
				f = O.length;
				var D, H, q = [];
				for (w = 0; w < f; w += 1) {
					for (B = O[w], B.a.sc && (i.strokeColorAnim = !0), B.a.sw && (i.strokeWidthAnim = !0), (B.a.fc || B.a.fh || B.a.fs || B.a.fb) && (i.fillColorAnim = !0), H = 0, D = B.s.b, r = 0; r < s; r += 1) A = n[r], A.anIndexes[w] = H, (D == 1 && A.val !== "" || D == 2 && A.val !== "" && A.val !== " " || D == 3 && (A.n || A.val == " " || r == s - 1) || D == 4 && (A.n || r == s - 1)) && (B.s.rn === 1 && q.push(H), H += 1);
					e.a[w].s.totalChars = H;
					var Q = -1,
						tt;
					if (B.s.rn === 1)
						for (r = 0; r < s; r += 1) A = n[r], Q != A.anIndexes[w] && (Q = A.anIndexes[w], tt = q.splice(Math.floor(Math.random() * q.length), 1)[0]), A.anIndexes[w] = tt
				}
				i.yOffset = i.finalLineHeight || i.finalSize * 1.2, i.ls = i.ls || 0, i.ascent = S.ascent * i.finalSize / 100
			}, TextProperty.prototype.updateDocumentData = function (i, t) {
				t = t === void 0 ? this.keysIndex : t;
				var e = this.copyData({}, this.data.d.k[t].s);
				e = this.copyData(e, i), this.data.d.k[t].s = e, this.recalculate(t), this.setCurrentData(e), this.elem.addDynamicProperty(this)
			}, TextProperty.prototype.recalculate = function (i) {
				var t = this.data.d.k[i].s;
				t.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(t)
			}, TextProperty.prototype.canResizeFont = function (i) {
				this.canResize = i, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
			}, TextProperty.prototype.setMinimumFontSize = function (i) {
				this.minimumFontSize = Math.floor(i) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
			};
			var TextSelectorProp = function () {
				var i = Math.max,
					t = Math.min,
					e = Math.floor;

				function n(s, a) {
					this._currentTextLength = -1, this.k = !1, this.data = a, this.elem = s, this.comp = s.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(s), this.s = PropertyFactory.getProp(s, a.s || {
						k: 0
					}, 0, 0, this), "e" in a ? this.e = PropertyFactory.getProp(s, a.e, 0, 0, this) : this.e = {
						v: 100
					}, this.o = PropertyFactory.getProp(s, a.o || {
						k: 0
					}, 0, 0, this), this.xe = PropertyFactory.getProp(s, a.xe || {
						k: 0
					}, 0, 0, this), this.ne = PropertyFactory.getProp(s, a.ne || {
						k: 0
					}, 0, 0, this), this.sm = PropertyFactory.getProp(s, a.sm || {
						k: 100
					}, 0, 0, this), this.a = PropertyFactory.getProp(s, a.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
				}
				n.prototype = {
					getMult: function (a) {
						this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
						var o = 0,
							h = 0,
							c = 1,
							u = 1;
						this.ne.v > 0 ? o = this.ne.v / 100 : h = -this.ne.v / 100, this.xe.v > 0 ? c = 1 - this.xe.v / 100 : u = 1 + this.xe.v / 100;
						var g = BezierFactory.getBezierEasing(o, h, c, u).get,
							p = 0,
							_ = this.finalS,
							b = this.finalE,
							y = this.data.sh;
						if (y === 2) b === _ ? p = a >= b ? 1 : 0 : p = i(0, t(.5 / (b - _) + (a - _) / (b - _), 1)), p = g(p);
						else if (y === 3) b === _ ? p = a >= b ? 0 : 1 : p = 1 - i(0, t(.5 / (b - _) + (a - _) / (b - _), 1)), p = g(p);
						else if (y === 4) b === _ ? p = 0 : (p = i(0, t(.5 / (b - _) + (a - _) / (b - _), 1)), p < .5 ? p *= 2 : p = 1 - 2 * (p - .5)), p = g(p);
						else if (y === 5) {
							if (b === _) p = 0;
							else {
								var w = b - _;
								a = t(i(0, a + .5 - _), b - _);
								var f = -w / 2 + a,
									S = w / 2;
								p = Math.sqrt(1 - f * f / (S * S))
							}
							p = g(p)
						} else y === 6 ? (b === _ ? p = 0 : (a = t(i(0, a + .5 - _), b - _), p = (1 + Math.cos(Math.PI + Math.PI * 2 * a / (b - _))) / 2), p = g(p)) : (a >= e(_) && (a - _ < 0 ? p = i(0, t(t(b, 1) - (_ - a), 1)) : p = i(0, t(b - a, 1))), p = g(p));
						if (this.sm.v !== 100) {
							var x = this.sm.v * .01;
							x === 0 && (x = 1e-8);
							var M = .5 - x * .5;
							p < M ? p = 0 : (p = (p - M) / x, p > 1 && (p = 1))
						}
						return p * this.a.v
					},
					getValue: function (a) {
						this.iterateDynamicProperties(), this._mdf = a || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, a && this.data.r === 2 && (this.e.v = this._currentTextLength);
						var o = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
							h = this.o.v / o,
							c = this.s.v / o + h,
							u = this.e.v / o + h;
						if (c > u) {
							var g = c;
							c = u, u = g
						}
						this.finalS = c, this.finalE = u
					}
				}, extendPrototype([DynamicPropertyContainer], n);

				function r(s, a, o) {
					return new n(s, a, o)
				}
				return {
					getTextSelectorProp: r
				}
			}();

			function TextAnimatorDataProperty(i, t, e) {
				var n = {
						propType: !1
					},
					r = PropertyFactory.getProp,
					s = t.a;
				this.a = {
					r: s.r ? r(i, s.r, 0, degToRads, e) : n,
					rx: s.rx ? r(i, s.rx, 0, degToRads, e) : n,
					ry: s.ry ? r(i, s.ry, 0, degToRads, e) : n,
					sk: s.sk ? r(i, s.sk, 0, degToRads, e) : n,
					sa: s.sa ? r(i, s.sa, 0, degToRads, e) : n,
					s: s.s ? r(i, s.s, 1, .01, e) : n,
					a: s.a ? r(i, s.a, 1, 0, e) : n,
					o: s.o ? r(i, s.o, 0, .01, e) : n,
					p: s.p ? r(i, s.p, 1, 0, e) : n,
					sw: s.sw ? r(i, s.sw, 0, 0, e) : n,
					sc: s.sc ? r(i, s.sc, 1, 0, e) : n,
					fc: s.fc ? r(i, s.fc, 1, 0, e) : n,
					fh: s.fh ? r(i, s.fh, 0, 0, e) : n,
					fs: s.fs ? r(i, s.fs, 0, .01, e) : n,
					fb: s.fb ? r(i, s.fb, 0, .01, e) : n,
					t: s.t ? r(i, s.t, 0, 0, e) : n
				}, this.s = TextSelectorProp.getTextSelectorProp(i, t.s, e), this.s.t = t.s.t
			}

			function TextAnimatorProperty(i, t, e) {
				this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = i, this._renderType = t, this._elem = e, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
					alignment: {}
				}, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(e)
			}
			TextAnimatorProperty.prototype.searchProperties = function () {
				var i, t = this._textData.a.length,
					e, n = PropertyFactory.getProp;
				for (i = 0; i < t; i += 1) e = this._textData.a[i], this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, e, this);
				this._textData.p && "m" in this._textData.p ? (this._pathData = {
					a: n(this._elem, this._textData.p.a, 0, 0, this),
					f: n(this._elem, this._textData.p.f, 0, 0, this),
					l: n(this._elem, this._textData.p.l, 0, 0, this),
					r: n(this._elem, this._textData.p.r, 0, 0, this),
					p: n(this._elem, this._textData.p.p, 0, 0, this),
					m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
				}, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = n(this._elem, this._textData.m.a, 1, 0, this)
			}, TextAnimatorProperty.prototype.getMeasures = function (i, t) {
				if (this.lettersChangedFlag = t, !(!this._mdf && !this._isFirstFrame && !t && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
					this._isFirstFrame = !1;
					var e = this._moreOptions.alignment.v,
						n = this._animatorsData,
						r = this._textData,
						s = this.mHelper,
						a = this._renderType,
						o = this.renderedLetters.length,
						h, c, u, g, p = i.l,
						_, b, y, w, f, S, x, M, T, I, L, F, k, G, j;
					if (this._hasMaskedPath) {
						if (j = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
							var U = j.v;
							this._pathData.r.v && (U = U.reverse()), _ = {
								tLength: 0,
								segments: []
							}, g = U._length - 1;
							var z;
							for (F = 0, u = 0; u < g; u += 1) z = bez.buildBezierData(U.v[u], U.v[u + 1], [U.o[u][0] - U.v[u][0], U.o[u][1] - U.v[u][1]], [U.i[u + 1][0] - U.v[u + 1][0], U.i[u + 1][1] - U.v[u + 1][1]]), _.tLength += z.segmentLength, _.segments.push(z), F += z.segmentLength;
							u = g, j.v.c && (z = bez.buildBezierData(U.v[u], U.v[0], [U.o[u][0] - U.v[u][0], U.o[u][1] - U.v[u][1]], [U.i[0][0] - U.v[0][0], U.i[0][1] - U.v[0][1]]), _.tLength += z.segmentLength, _.segments.push(z), F += z.segmentLength), this._pathData.pi = _
						}
						if (_ = this._pathData.pi, b = this._pathData.f.v, x = 0, S = 1, w = 0, f = !0, I = _.segments, b < 0 && j.v.c)
							for (_.tLength < Math.abs(b) && (b = -Math.abs(b) % _.tLength), x = I.length - 1, T = I[x].points, S = T.length - 1; b < 0;) b += T[S].partialLength, S -= 1, S < 0 && (x -= 1, T = I[x].points, S = T.length - 1);
						T = I[x].points, M = T[S - 1], y = T[S], L = y.partialLength
					}
					g = p.length, h = 0, c = 0;
					var $ = i.finalSize * 1.2 * .714,
						W = !0,
						O, B, A, D, H;
					D = n.length;
					var q, Q = -1,
						tt, nt, ut, et = b,
						it = x,
						Et = S,
						wt = -1,
						yt, At, Vt, lt, dt, qt, Zt, re, de = "",
						Xt = this.defaultPropsArray,
						le;
					if (i.j === 2 || i.j === 1) {
						var ye = 0,
							Z = 0,
							X = i.j === 2 ? -.5 : -1,
							pt = 0,
							xt = !0;
						for (u = 0; u < g; u += 1)
							if (p[u].n) {
								for (ye && (ye += Z); pt < u;) p[pt].animatorJustifyOffset = ye, pt += 1;
								ye = 0, xt = !0
							} else {
								for (A = 0; A < D; A += 1) O = n[A].a, O.t.propType && (xt && i.j === 2 && (Z += O.t.v * X), B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), q.length ? ye += O.t.v * q[0] * X : ye += O.t.v * q * X);
								xt = !1
							} for (ye && (ye += Z); pt < u;) p[pt].animatorJustifyOffset = ye, pt += 1
					}
					for (u = 0; u < g; u += 1) {
						if (s.reset(), yt = 1, p[u].n) h = 0, c += i.yOffset, c += W ? 1 : 0, b = et, W = !1, this._hasMaskedPath && (x = it, S = Et, T = I[x].points, M = T[S - 1], y = T[S], L = y.partialLength, w = 0), de = "", re = "", qt = "", le = "", Xt = this.defaultPropsArray;
						else {
							if (this._hasMaskedPath) {
								if (wt !== p[u].line) {
									switch (i.j) {
										case 1:
											b += F - i.lineWidths[p[u].line];
											break;
										case 2:
											b += (F - i.lineWidths[p[u].line]) / 2;
											break;
										default:
											break
									}
									wt = p[u].line
								}
								Q !== p[u].ind && (p[Q] && (b += p[Q].extra), b += p[u].an / 2, Q = p[u].ind), b += e[0] * p[u].an * .005;
								var St = 0;
								for (A = 0; A < D; A += 1) O = n[A].a, O.p.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), q.length ? St += O.p.v[0] * q[0] : St += O.p.v[0] * q), O.a.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), q.length ? St += O.a.v[0] * q[0] : St += O.a.v[0] * q);
								for (f = !0, this._pathData.a.v && (b = p[0].an * .5 + (F - this._pathData.f.v - p[0].an * .5 - p[p.length - 1].an * .5) * Q / (g - 1), b += this._pathData.f.v); f;) w + L >= b + St || !T ? (k = (b + St - w) / y.partialLength, nt = M.point[0] + (y.point[0] - M.point[0]) * k, ut = M.point[1] + (y.point[1] - M.point[1]) * k, s.translate(-e[0] * p[u].an * .005, -(e[1] * $) * .01), f = !1) : T && (w += y.partialLength, S += 1, S >= T.length && (S = 0, x += 1, I[x] ? T = I[x].points : j.v.c ? (S = 0, x = 0, T = I[x].points) : (w -= y.partialLength, T = null)), T && (M = y, y = T[S], L = y.partialLength));
								tt = p[u].an / 2 - p[u].add, s.translate(-tt, 0, 0)
							} else tt = p[u].an / 2 - p[u].add, s.translate(-tt, 0, 0), s.translate(-e[0] * p[u].an * .005, -e[1] * $ * .01, 0);
							for (A = 0; A < D; A += 1) O = n[A].a, O.t.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), (h !== 0 || i.j !== 0) && (this._hasMaskedPath ? q.length ? b += O.t.v * q[0] : b += O.t.v * q : q.length ? h += O.t.v * q[0] : h += O.t.v * q));
							for (i.strokeWidthAnim && (Vt = i.sw || 0), i.strokeColorAnim && (i.sc ? At = [i.sc[0], i.sc[1], i.sc[2]] : At = [0, 0, 0]), i.fillColorAnim && i.fc && (lt = [i.fc[0], i.fc[1], i.fc[2]]), A = 0; A < D; A += 1) O = n[A].a, O.a.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), q.length ? s.translate(-O.a.v[0] * q[0], -O.a.v[1] * q[1], O.a.v[2] * q[2]) : s.translate(-O.a.v[0] * q, -O.a.v[1] * q, O.a.v[2] * q));
							for (A = 0; A < D; A += 1) O = n[A].a, O.s.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), q.length ? s.scale(1 + (O.s.v[0] - 1) * q[0], 1 + (O.s.v[1] - 1) * q[1], 1) : s.scale(1 + (O.s.v[0] - 1) * q, 1 + (O.s.v[1] - 1) * q, 1));
							for (A = 0; A < D; A += 1) {
								if (O = n[A].a, B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), O.sk.propType && (q.length ? s.skewFromAxis(-O.sk.v * q[0], O.sa.v * q[1]) : s.skewFromAxis(-O.sk.v * q, O.sa.v * q)), O.r.propType && (q.length ? s.rotateZ(-O.r.v * q[2]) : s.rotateZ(-O.r.v * q)), O.ry.propType && (q.length ? s.rotateY(O.ry.v * q[1]) : s.rotateY(O.ry.v * q)), O.rx.propType && (q.length ? s.rotateX(O.rx.v * q[0]) : s.rotateX(O.rx.v * q)), O.o.propType && (q.length ? yt += (O.o.v * q[0] - yt) * q[0] : yt += (O.o.v * q - yt) * q), i.strokeWidthAnim && O.sw.propType && (q.length ? Vt += O.sw.v * q[0] : Vt += O.sw.v * q), i.strokeColorAnim && O.sc.propType)
									for (dt = 0; dt < 3; dt += 1) q.length ? At[dt] += (O.sc.v[dt] - At[dt]) * q[0] : At[dt] += (O.sc.v[dt] - At[dt]) * q;
								if (i.fillColorAnim && i.fc) {
									if (O.fc.propType)
										for (dt = 0; dt < 3; dt += 1) q.length ? lt[dt] += (O.fc.v[dt] - lt[dt]) * q[0] : lt[dt] += (O.fc.v[dt] - lt[dt]) * q;
									O.fh.propType && (q.length ? lt = addHueToRGB(lt, O.fh.v * q[0]) : lt = addHueToRGB(lt, O.fh.v * q)), O.fs.propType && (q.length ? lt = addSaturationToRGB(lt, O.fs.v * q[0]) : lt = addSaturationToRGB(lt, O.fs.v * q)), O.fb.propType && (q.length ? lt = addBrightnessToRGB(lt, O.fb.v * q[0]) : lt = addBrightnessToRGB(lt, O.fb.v * q))
								}
							}
							for (A = 0; A < D; A += 1) O = n[A].a, O.p.propType && (B = n[A].s, q = B.getMult(p[u].anIndexes[A], r.a[A].s.totalChars), this._hasMaskedPath ? q.length ? s.translate(0, O.p.v[1] * q[0], -O.p.v[2] * q[1]) : s.translate(0, O.p.v[1] * q, -O.p.v[2] * q) : q.length ? s.translate(O.p.v[0] * q[0], O.p.v[1] * q[1], -O.p.v[2] * q[2]) : s.translate(O.p.v[0] * q, O.p.v[1] * q, -O.p.v[2] * q));
							if (i.strokeWidthAnim && (qt = Vt < 0 ? 0 : Vt), i.strokeColorAnim && (Zt = "rgb(" + Math.round(At[0] * 255) + "," + Math.round(At[1] * 255) + "," + Math.round(At[2] * 255) + ")"), i.fillColorAnim && i.fc && (re = "rgb(" + Math.round(lt[0] * 255) + "," + Math.round(lt[1] * 255) + "," + Math.round(lt[2] * 255) + ")"), this._hasMaskedPath) {
								if (s.translate(0, -i.ls), s.translate(0, e[1] * $ * .01 + c, 0), this._pathData.p.v) {
									G = (y.point[1] - M.point[1]) / (y.point[0] - M.point[0]);
									var Pt = Math.atan(G) * 180 / Math.PI;
									y.point[0] < M.point[0] && (Pt += 180), s.rotate(-Pt * Math.PI / 180)
								}
								s.translate(nt, ut, 0), b -= e[0] * p[u].an * .005, p[u + 1] && Q !== p[u + 1].ind && (b += p[u].an / 2, b += i.tr * .001 * i.finalSize)
							} else {
								switch (s.translate(h, c, 0), i.ps && s.translate(i.ps[0], i.ps[1] + i.ascent, 0), i.j) {
									case 1:
										s.translate(p[u].animatorJustifyOffset + i.justifyOffset + (i.boxWidth - i.lineWidths[p[u].line]), 0, 0);
										break;
									case 2:
										s.translate(p[u].animatorJustifyOffset + i.justifyOffset + (i.boxWidth - i.lineWidths[p[u].line]) / 2, 0, 0);
										break;
									default:
										break
								}
								s.translate(0, -i.ls), s.translate(tt, 0, 0), s.translate(e[0] * p[u].an * .005, e[1] * $ * .01, 0), h += p[u].l + i.tr * .001 * i.finalSize
							}
							a === "html" ? de = s.toCSS() : a === "svg" ? de = s.to2dCSS() : Xt = [s.props[0], s.props[1], s.props[2], s.props[3], s.props[4], s.props[5], s.props[6], s.props[7], s.props[8], s.props[9], s.props[10], s.props[11], s.props[12], s.props[13], s.props[14], s.props[15]], le = yt
						}
						o <= u ? (H = new LetterProps(le, qt, Zt, re, de, Xt), this.renderedLetters.push(H), o += 1, this.lettersChangedFlag = !0) : (H = this.renderedLetters[u], this.lettersChangedFlag = H.update(le, qt, Zt, re, de, Xt) || this.lettersChangedFlag)
					}
				}
			}, TextAnimatorProperty.prototype.getValue = function () {
				this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
			}, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

			function ITextElement() {}
			ITextElement.prototype.initElement = function (i, t, e) {
				this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(i, t, e), this.textProperty = new TextProperty(this, i.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(i.t, this.renderType, this), this.initTransform(i, t, e), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
			}, ITextElement.prototype.prepareFrame = function (i) {
				this._mdf = !1, this.prepareRenderableFrame(i), this.prepareProperties(i, this.isInRange)
			}, ITextElement.prototype.createPathShape = function (i, t) {
				var e, n = t.length,
					r, s = "";
				for (e = 0; e < n; e += 1) t[e].ty === "sh" && (r = t[e].ks.k, s += buildShapeString(r, r.i.length, !0, i));
				return s
			}, ITextElement.prototype.updateDocumentData = function (i, t) {
				this.textProperty.updateDocumentData(i, t)
			}, ITextElement.prototype.canResizeFont = function (i) {
				this.textProperty.canResizeFont(i)
			}, ITextElement.prototype.setMinimumFontSize = function (i) {
				this.textProperty.setMinimumFontSize(i)
			}, ITextElement.prototype.applyTextPropertiesToMatrix = function (i, t, e, n, r) {
				switch (i.ps && t.translate(i.ps[0], i.ps[1] + i.ascent, 0), t.translate(0, -i.ls, 0), i.j) {
					case 1:
						t.translate(i.justifyOffset + (i.boxWidth - i.lineWidths[e]), 0, 0);
						break;
					case 2:
						t.translate(i.justifyOffset + (i.boxWidth - i.lineWidths[e]) / 2, 0, 0);
						break;
					default:
						break
				}
				t.translate(n, r, 0)
			}, ITextElement.prototype.buildColor = function (i) {
				return "rgb(" + Math.round(i[0] * 255) + "," + Math.round(i[1] * 255) + "," + Math.round(i[2] * 255) + ")"
			}, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () {}, ITextElement.prototype.validateText = function () {
				(this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
			};
			var emptyShapeData = {
				shapes: []
			};

			function SVGTextLottieElement(i, t, e) {
				this.textSpans = [], this.renderType = "svg", this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () {
				this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
			}, SVGTextLottieElement.prototype.buildTextContents = function (i) {
				for (var t = 0, e = i.length, n = [], r = ""; t < e;) i[t] === String.fromCharCode(13) || i[t] === String.fromCharCode(3) ? (n.push(r), r = "") : r += i[t], t += 1;
				return n.push(r), n
			}, SVGTextLottieElement.prototype.buildShapeData = function (i, t) {
				if (i.shapes && i.shapes.length) {
					var e = i.shapes[0];
					if (e.it) {
						var n = e.it[e.it.length - 1];
						n.s && (n.s.k[0] = t, n.s.k[1] = t)
					}
				}
				return i
			}, SVGTextLottieElement.prototype.buildNewText = function () {
				this.addDynamicProperty(this);
				var i, t, e = this.textProperty.currentData;
				this.renderedLetters = createSizedArray(e ? e.l.length : 0), e.fc ? this.layerElement.setAttribute("fill", this.buildColor(e.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), e.sc && (this.layerElement.setAttribute("stroke", this.buildColor(e.sc)), this.layerElement.setAttribute("stroke-width", e.sw)), this.layerElement.setAttribute("font-size", e.finalSize);
				var n = this.globalData.fontManager.getFontByName(e.f);
				if (n.fClass) this.layerElement.setAttribute("class", n.fClass);
				else {
					this.layerElement.setAttribute("font-family", n.fFamily);
					var r = e.fWeight,
						s = e.fStyle;
					this.layerElement.setAttribute("font-style", s), this.layerElement.setAttribute("font-weight", r)
				}
				this.layerElement.setAttribute("aria-label", e.t);
				var a = e.l || [],
					o = !!this.globalData.fontManager.chars;
				t = a.length;
				var h, c = this.mHelper,
					u = "",
					g = this.data.singleShape,
					p = 0,
					_ = 0,
					b = !0,
					y = e.tr * .001 * e.finalSize;
				if (g && !o && !e.sz) {
					var w = this.textContainer,
						f = "start";
					switch (e.j) {
						case 1:
							f = "end";
							break;
						case 2:
							f = "middle";
							break;
						default:
							f = "start";
							break
					}
					w.setAttribute("text-anchor", f), w.setAttribute("letter-spacing", y);
					var S = this.buildTextContents(e.finalText);
					for (t = S.length, _ = e.ps ? e.ps[1] + e.ascent : 0, i = 0; i < t; i += 1) h = this.textSpans[i].span || createNS("tspan"), h.textContent = S[i], h.setAttribute("x", 0), h.setAttribute("y", _), h.style.display = "inherit", w.appendChild(h), this.textSpans[i] || (this.textSpans[i] = {
						span: null,
						glyph: null
					}), this.textSpans[i].span = h, _ += e.finalLineHeight;
					this.layerElement.appendChild(w)
				} else {
					var x = this.textSpans.length,
						M;
					for (i = 0; i < t; i += 1) {
						if (this.textSpans[i] || (this.textSpans[i] = {
								span: null,
								childSpan: null,
								glyph: null
							}), !o || !g || i === 0) {
							if (h = x > i ? this.textSpans[i].span : createNS(o ? "g" : "text"), x <= i) {
								if (h.setAttribute("stroke-linecap", "butt"), h.setAttribute("stroke-linejoin", "round"), h.setAttribute("stroke-miterlimit", "4"), this.textSpans[i].span = h, o) {
									var T = createNS("g");
									h.appendChild(T), this.textSpans[i].childSpan = T
								}
								this.textSpans[i].span = h, this.layerElement.appendChild(h)
							}
							h.style.display = "inherit"
						}
						if (c.reset(), g && (a[i].n && (p = -y, _ += e.yOffset, _ += b ? 1 : 0, b = !1), this.applyTextPropertiesToMatrix(e, c, a[i].line, p, _), p += a[i].l || 0, p += y), o) {
							M = this.globalData.fontManager.getCharData(e.finalText[i], n.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily);
							var I;
							if (M.t === 1) I = new SVGCompElement(M.data, this.globalData, this);
							else {
								var L = emptyShapeData;
								M.data && M.data.shapes && (L = this.buildShapeData(M.data, e.finalSize)), I = new SVGShapeElement(L, this.globalData, this)
							}
							if (this.textSpans[i].glyph) {
								var F = this.textSpans[i].glyph;
								this.textSpans[i].childSpan.removeChild(F.layerElement), F.destroy()
							}
							this.textSpans[i].glyph = I, I._debug = !0, I.prepareFrame(0), I.renderFrame(), this.textSpans[i].childSpan.appendChild(I.layerElement), M.t === 1 && this.textSpans[i].childSpan.setAttribute("transform", "scale(" + e.finalSize / 100 + "," + e.finalSize / 100 + ")")
						} else g && h.setAttribute("transform", "translate(" + c.props[12] + "," + c.props[13] + ")"), h.textContent = a[i].val, h.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
					}
					g && h && h.setAttribute("d", u)
				}
				for (; i < this.textSpans.length;) this.textSpans[i].span.style.display = "none", i += 1;
				this._sizeChanged = !0
			}, SVGTextLottieElement.prototype.sourceRectAtTime = function () {
				if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
					this._sizeChanged = !1;
					var i = this.layerElement.getBBox();
					this.bbox = {
						top: i.y,
						left: i.x,
						width: i.width,
						height: i.height
					}
				}
				return this.bbox
			}, SVGTextLottieElement.prototype.getValue = function () {
				var i, t = this.textSpans.length,
					e;
				for (this.renderedFrame = this.comp.renderedFrame, i = 0; i < t; i += 1) e = this.textSpans[i].glyph, e && (e.prepareFrame(this.comp.renderedFrame - this.data.st), e._mdf && (this._mdf = !0))
			}, SVGTextLottieElement.prototype.renderInnerContent = function () {
				if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
					this._sizeChanged = !0;
					var i, t, e = this.textAnimator.renderedLetters,
						n = this.textProperty.currentData.l;
					t = n.length;
					var r, s, a;
					for (i = 0; i < t; i += 1) n[i].n || (r = e[i], s = this.textSpans[i].span, a = this.textSpans[i].glyph, a && a.renderFrame(), r._mdf.m && s.setAttribute("transform", r.m), r._mdf.o && s.setAttribute("opacity", r.o), r._mdf.sw && s.setAttribute("stroke-width", r.sw), r._mdf.sc && s.setAttribute("stroke", r.sc), r._mdf.fc && s.setAttribute("fill", r.fc))
				}
			};

			function ISolidElement(i, t, e) {
				this.initElement(i, t, e)
			}
			extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () {
				var i = createNS("rect");
				i.setAttribute("width", this.data.sw), i.setAttribute("height", this.data.sh), i.setAttribute("fill", this.data.sc), this.layerElement.appendChild(i)
			};

			function NullElement(i, t, e) {
				this.initFrame(), this.initBaseData(i, t, e), this.initFrame(), this.initTransform(i, t, e), this.initHierarchy()
			}
			NullElement.prototype.prepareFrame = function (i) {
				this.prepareProperties(i, !0)
			}, NullElement.prototype.renderFrame = function () {}, NullElement.prototype.getBaseElement = function () {
				return null
			}, NullElement.prototype.destroy = function () {}, NullElement.prototype.sourceRectAtTime = function () {}, NullElement.prototype.hide = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

			function SVGRendererBase() {}
			extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function (i) {
				return new NullElement(i, this.globalData, this)
			}, SVGRendererBase.prototype.createShape = function (i) {
				return new SVGShapeElement(i, this.globalData, this)
			}, SVGRendererBase.prototype.createText = function (i) {
				return new SVGTextLottieElement(i, this.globalData, this)
			}, SVGRendererBase.prototype.createImage = function (i) {
				return new IImageElement(i, this.globalData, this)
			}, SVGRendererBase.prototype.createSolid = function (i) {
				return new ISolidElement(i, this.globalData, this)
			}, SVGRendererBase.prototype.configAnimation = function (i) {
				this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + i.w + " " + i.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", i.w), this.svgElement.setAttribute("height", i.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
				var t = this.globalData.defs;
				this.setupGlobalData(i, t), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = i;
				var e = createNS("clipPath"),
					n = createNS("rect");
				n.setAttribute("width", i.w), n.setAttribute("height", i.h), n.setAttribute("x", 0), n.setAttribute("y", 0);
				var r = createElementID();
				e.setAttribute("id", r), e.appendChild(n), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + r + ")"), t.appendChild(e), this.layers = i.layers, this.elements = createSizedArray(i.layers.length)
			}, SVGRendererBase.prototype.destroy = function () {
				this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
				var i, t = this.layers ? this.layers.length : 0;
				for (i = 0; i < t; i += 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
				this.elements.length = 0, this.destroyed = !0, this.animationItem = null
			}, SVGRendererBase.prototype.updateContainerSize = function () {}, SVGRendererBase.prototype.findIndexByInd = function (i) {
				var t = 0,
					e = this.layers.length;
				for (t = 0; t < e; t += 1)
					if (this.layers[t].ind === i) return t;
				return -1
			}, SVGRendererBase.prototype.buildItem = function (i) {
				var t = this.elements;
				if (!(t[i] || this.layers[i].ty === 99)) {
					t[i] = !0;
					var e = this.createItem(this.layers[i]);
					if (t[i] = e, getExpressionsPlugin() && (this.layers[i].ty === 0 && this.globalData.projectInterface.registerComposition(e), e.initExpressions()), this.appendElementInPos(e, i), this.layers[i].tt) {
						var n = "tp" in this.layers[i] ? this.findIndexByInd(this.layers[i].tp) : i - 1;
						if (n === -1) return;
						if (!this.elements[n] || this.elements[n] === !0) this.buildItem(n), this.addPendingElement(e);
						else {
							var r = t[n],
								s = r.getMatte(this.layers[i].tt);
							e.setMatte(s)
						}
					}
				}
			}, SVGRendererBase.prototype.checkPendingElements = function () {
				for (; this.pendingElements.length;) {
					var i = this.pendingElements.pop();
					if (i.checkParenting(), i.data.tt)
						for (var t = 0, e = this.elements.length; t < e;) {
							if (this.elements[t] === i) {
								var n = "tp" in i.data ? this.findIndexByInd(i.data.tp) : t - 1,
									r = this.elements[n],
									s = r.getMatte(this.layers[t].tt);
								i.setMatte(s);
								break
							}
							t += 1
						}
				}
			}, SVGRendererBase.prototype.renderFrame = function (i) {
				if (!(this.renderedFrame === i || this.destroyed)) {
					i === null ? i = this.renderedFrame : this.renderedFrame = i, this.globalData.frameNum = i, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = i, this.globalData._mdf = !1;
					var t, e = this.layers.length;
					for (this.completeLayers || this.checkLayers(i), t = e - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].prepareFrame(i - this.layers[t].st);
					if (this.globalData._mdf)
						for (t = 0; t < e; t += 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
				}
			}, SVGRendererBase.prototype.appendElementInPos = function (i, t) {
				var e = i.getBaseElement();
				if (e) {
					for (var n = 0, r; n < t;) this.elements[n] && this.elements[n] !== !0 && this.elements[n].getBaseElement() && (r = this.elements[n].getBaseElement()), n += 1;
					r ? this.layerElement.insertBefore(e, r) : this.layerElement.appendChild(e)
				}
			}, SVGRendererBase.prototype.hide = function () {
				this.layerElement.style.display = "none"
			}, SVGRendererBase.prototype.show = function () {
				this.layerElement.style.display = "block"
			};

			function ICompElement() {}
			extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (i, t, e) {
				this.initFrame(), this.initBaseData(i, t, e), this.initTransform(i, t, e), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !t.progressiveLoad) && this.buildAllItems(), this.hide()
			}, ICompElement.prototype.prepareFrame = function (i) {
				if (this._mdf = !1, this.prepareRenderableFrame(i), this.prepareProperties(i, this.isInRange), !(!this.isInRange && !this.data.xt)) {
					if (this.tm._placeholder) this.renderedFrame = i / this.data.sr;
					else {
						var t = this.tm.v;
						t === this.data.op && (t = this.data.op - 1), this.renderedFrame = t
					}
					var e, n = this.elements.length;
					for (this.completeLayers || this.checkLayers(this.renderedFrame), e = n - 1; e >= 0; e -= 1)(this.completeLayers || this.elements[e]) && (this.elements[e].prepareFrame(this.renderedFrame - this.layers[e].st), this.elements[e]._mdf && (this._mdf = !0))
				}
			}, ICompElement.prototype.renderInnerContent = function () {
				var i, t = this.layers.length;
				for (i = 0; i < t; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
			}, ICompElement.prototype.setElements = function (i) {
				this.elements = i
			}, ICompElement.prototype.getElements = function () {
				return this.elements
			}, ICompElement.prototype.destroyElements = function () {
				var i, t = this.layers.length;
				for (i = 0; i < t; i += 1) this.elements[i] && this.elements[i].destroy()
			}, ICompElement.prototype.destroy = function () {
				this.destroyElements(), this.destroyBaseElement()
			};

			function SVGCompElement(i, t, e) {
				this.layers = i.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(i, t, e), this.tm = i.tm ? PropertyFactory.getProp(this, i.tm, 0, t.frameRate, this) : {
					_placeholder: !0
				}
			}
			extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function (i) {
				return new SVGCompElement(i, this.globalData, this)
			};

			function SVGRenderer(i, t) {
				this.animationItem = i, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
				var e = "";
				if (t && t.title) {
					var n = createNS("title"),
						r = createElementID();
					n.setAttribute("id", r), n.textContent = t.title, this.svgElement.appendChild(n), e += r
				}
				if (t && t.description) {
					var s = createNS("desc"),
						a = createElementID();
					s.setAttribute("id", a), s.textContent = t.description, this.svgElement.appendChild(s), e += " " + a
				}
				e && this.svgElement.setAttribute("aria-labelledby", e);
				var o = createNS("defs");
				this.svgElement.appendChild(o);
				var h = createNS("g");
				this.svgElement.appendChild(h), this.layerElement = h, this.renderConfig = {
					preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
					imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
					contentVisibility: t && t.contentVisibility || "visible",
					progressiveLoad: t && t.progressiveLoad || !1,
					hideOnTransparent: !(t && t.hideOnTransparent === !1),
					viewBoxOnly: t && t.viewBoxOnly || !1,
					viewBoxSize: t && t.viewBoxSize || !1,
					className: t && t.className || "",
					id: t && t.id || "",
					focusable: t && t.focusable,
					filterSize: {
						width: t && t.filterSize && t.filterSize.width || "100%",
						height: t && t.filterSize && t.filterSize.height || "100%",
						x: t && t.filterSize && t.filterSize.x || "0%",
						y: t && t.filterSize && t.filterSize.y || "0%"
					},
					width: t && t.width,
					height: t && t.height,
					runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
				}, this.globalData = {
					_mdf: !1,
					frameNum: -1,
					defs: o,
					renderConfig: this.renderConfig
				}, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
			}
			extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function (i) {
				return new SVGCompElement(i, this.globalData, this)
			};

			function ShapeTransformManager() {
				this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
			}
			ShapeTransformManager.prototype = {
				addTransformSequence: function (t) {
					var e, n = t.length,
						r = "_";
					for (e = 0; e < n; e += 1) r += t[e].transform.key + "_";
					var s = this.sequences[r];
					return s || (s = {
						transforms: [].concat(t),
						finalTransform: new Matrix,
						_mdf: !1
					}, this.sequences[r] = s, this.sequenceList.push(s)), s
				},
				processSequence: function (t, e) {
					for (var n = 0, r = t.transforms.length, s = e; n < r && !e;) {
						if (t.transforms[n].transform.mProps._mdf) {
							s = !0;
							break
						}
						n += 1
					}
					if (s)
						for (t.finalTransform.reset(), n = r - 1; n >= 0; n -= 1) t.finalTransform.multiply(t.transforms[n].transform.mProps.v);
					t._mdf = s
				},
				processSequences: function (t) {
					var e, n = this.sequenceList.length;
					for (e = 0; e < n; e += 1) this.processSequence(this.sequenceList[e], t)
				},
				getNewKey: function () {
					return this.transform_key_count += 1, "_" + this.transform_key_count
				}
			};
			var lumaLoader = function () {
				var t = "__lottie_element_luma_buffer",
					e = null,
					n = null,
					r = null;

				function s() {
					var h = createNS("svg"),
						c = createNS("filter"),
						u = createNS("feColorMatrix");
					return c.setAttribute("id", t), u.setAttribute("type", "matrix"), u.setAttribute("color-interpolation-filters", "sRGB"), u.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), c.appendChild(u), h.appendChild(c), h.setAttribute("id", t + "_svg"), featureSupport.svgLumaHidden && (h.style.display = "none"), h
				}

				function a() {
					e || (r = s(), document.body.appendChild(r), e = createTag("canvas"), n = e.getContext("2d"), n.filter = "url(#" + t + ")", n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1))
				}

				function o(h) {
					return e || a(), e.width = h.width, e.height = h.height, n.filter = "url(#" + t + ")", e
				}
				return {
					load: a,
					get: o
				}
			};

			function createCanvas(i, t) {
				if (featureSupport.offscreenCanvas) return new OffscreenCanvas(i, t);
				var e = createTag("canvas");
				return e.width = i, e.height = t, e
			}
			var assetLoader = function () {
					return {
						loadLumaCanvas: lumaLoader.load,
						getLumaCanvas: lumaLoader.get,
						createCanvas
					}
				}(),
				registeredEffects = {};

			function CVEffects(i) {
				var t, e = i.data.ef ? i.data.ef.length : 0;
				this.filters = [];
				var n;
				for (t = 0; t < e; t += 1) {
					n = null;
					var r = i.data.ef[t].ty;
					if (registeredEffects[r]) {
						var s = registeredEffects[r].effect;
						n = new s(i.effectsManager.effectElements[t], i)
					}
					n && this.filters.push(n)
				}
				this.filters.length && i.addRenderableComponent(this)
			}
			CVEffects.prototype.renderFrame = function (i) {
				var t, e = this.filters.length;
				for (t = 0; t < e; t += 1) this.filters[t].renderFrame(i)
			}, CVEffects.prototype.getEffects = function (i) {
				var t, e = this.filters.length,
					n = [];
				for (t = 0; t < e; t += 1) this.filters[t].type === i && n.push(this.filters[t]);
				return n
			};

			function registerEffect(i, t) {
				registeredEffects[i] = {
					effect: t
				}
			}

			function CVMaskElement(i, t) {
				this.data = i, this.element = t, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
				var e, n = this.masksProperties.length,
					r = !1;
				for (e = 0; e < n; e += 1) this.masksProperties[e].mode !== "n" && (r = !0), this.viewData[e] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[e], 3);
				this.hasMasks = r, r && this.element.addRenderableComponent(this)
			}
			CVMaskElement.prototype.renderFrame = function () {
				if (this.hasMasks) {
					var i = this.element.finalTransform.mat,
						t = this.element.canvasContext,
						e, n = this.masksProperties.length,
						r, s, a;
					for (t.beginPath(), e = 0; e < n; e += 1)
						if (this.masksProperties[e].mode !== "n") {
							this.masksProperties[e].inv && (t.moveTo(0, 0), t.lineTo(this.element.globalData.compSize.w, 0), t.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), t.lineTo(0, this.element.globalData.compSize.h), t.lineTo(0, 0)), a = this.viewData[e].v, r = i.applyToPointArray(a.v[0][0], a.v[0][1], 0), t.moveTo(r[0], r[1]);
							var o, h = a._length;
							for (o = 1; o < h; o += 1) s = i.applyToTriplePoints(a.o[o - 1], a.i[o], a.v[o]), t.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
							s = i.applyToTriplePoints(a.o[o - 1], a.i[0], a.v[0]), t.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5])
						} this.element.globalData.renderer.save(!0), t.clip()
				}
			}, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () {
				this.element = null
			};

			function CVBaseElement() {}
			var operationsMap = {
				1: "source-in",
				2: "source-out",
				3: "source-in",
				4: "source-out"
			};
			CVBaseElement.prototype = {
				createElements: function () {},
				initRendererElement: function () {},
				createContainerElements: function () {
					if (this.data.tt >= 1) {
						this.buffers = [];
						var t = this.globalData.canvasContext,
							e = assetLoader.createCanvas(t.canvas.width, t.canvas.height);
						this.buffers.push(e);
						var n = assetLoader.createCanvas(t.canvas.width, t.canvas.height);
						this.buffers.push(n), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
					}
					this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms()
				},
				createContent: function () {},
				setBlendMode: function () {
					var t = this.globalData;
					if (t.blendMode !== this.data.bm) {
						t.blendMode = this.data.bm;
						var e = getBlendMode(this.data.bm);
						t.canvasContext.globalCompositeOperation = e
					}
				},
				createRenderableComponents: function () {
					this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
				},
				hideElement: function () {
					!this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
				},
				showElement: function () {
					this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
				},
				clearCanvas: function (t) {
					t.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
				},
				prepareLayer: function () {
					if (this.data.tt >= 1) {
						var t = this.buffers[0],
							e = t.getContext("2d");
						this.clearCanvas(e), e.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform)
					}
				},
				exitLayer: function () {
					if (this.data.tt >= 1) {
						var t = this.buffers[1],
							e = t.getContext("2d");
						this.clearCanvas(e), e.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
						var n = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
						if (n.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
							var r = assetLoader.getLumaCanvas(this.canvasContext.canvas),
								s = r.getContext("2d");
							s.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(r, 0, 0)
						}
						this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(t, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over"
					}
				},
				renderFrame: function (t) {
					if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !t)) {
						this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
						var e = this.data.ty === 0;
						this.prepareLayer(), this.globalData.renderer.save(e), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(e), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
					}
				},
				destroy: function () {
					this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
				},
				mHelper: new Matrix
			}, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

			function CVShapeData(i, t, e, n) {
				this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
				var r = 4;
				t.ty === "rc" ? r = 5 : t.ty === "el" ? r = 6 : t.ty === "sr" && (r = 7), this.sh = ShapePropertyFactory.getShapeProp(i, t, r, i);
				var s, a = e.length,
					o;
				for (s = 0; s < a; s += 1) e[s].closed || (o = {
					transforms: n.addTransformSequence(e[s].transforms),
					trNodes: []
				}, this.styledShapes.push(o), e[s].elements.push(o))
			}
			CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

			function CVShapeElement(i, t, e) {
				this.shapes = [], this.shapesData = i.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
				opacity: 1,
				_opMdf: !1
			}, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () {
				this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
			}, CVShapeElement.prototype.createStyleElement = function (i, t) {
				var e = {
						data: i,
						type: i.ty,
						preTransforms: this.transformsManager.addTransformSequence(t),
						transforms: [],
						elements: [],
						closed: i.hd === !0
					},
					n = {};
				if (i.ty === "fl" || i.ty === "st" ? (n.c = PropertyFactory.getProp(this, i.c, 1, 255, this), n.c.k || (e.co = "rgb(" + bmFloor(n.c.v[0]) + "," + bmFloor(n.c.v[1]) + "," + bmFloor(n.c.v[2]) + ")")) : (i.ty === "gf" || i.ty === "gs") && (n.s = PropertyFactory.getProp(this, i.s, 1, null, this), n.e = PropertyFactory.getProp(this, i.e, 1, null, this), n.h = PropertyFactory.getProp(this, i.h || {
						k: 0
					}, 0, .01, this), n.a = PropertyFactory.getProp(this, i.a || {
						k: 0
					}, 0, degToRads, this), n.g = new GradientProperty(this, i.g, this)), n.o = PropertyFactory.getProp(this, i.o, 0, .01, this), i.ty === "st" || i.ty === "gs") {
					if (e.lc = lineCapEnum[i.lc || 2], e.lj = lineJoinEnum[i.lj || 2], i.lj == 1 && (e.ml = i.ml), n.w = PropertyFactory.getProp(this, i.w, 0, null, this), n.w.k || (e.wi = n.w.v), i.d) {
						var r = new DashProperty(this, i.d, "canvas", this);
						n.d = r, n.d.k || (e.da = n.d.dashArray, e.do = n.d.dashoffset[0])
					}
				} else e.r = i.r === 2 ? "evenodd" : "nonzero";
				return this.stylesList.push(e), n.style = e, n
			}, CVShapeElement.prototype.createGroupElement = function () {
				var i = {
					it: [],
					prevViewData: []
				};
				return i
			}, CVShapeElement.prototype.createTransformElement = function (i) {
				var t = {
					transform: {
						opacity: 1,
						_opMdf: !1,
						key: this.transformsManager.getNewKey(),
						op: PropertyFactory.getProp(this, i.o, 0, .01, this),
						mProps: TransformPropertyFactory.getTransformProperty(this, i, this)
					}
				};
				return t
			}, CVShapeElement.prototype.createShapeElement = function (i) {
				var t = new CVShapeData(this, i, this.stylesList, this.transformsManager);
				return this.shapes.push(t), this.addShapeToModifiers(t), t
			}, CVShapeElement.prototype.reloadShapes = function () {
				this._isFirstFrame = !0;
				var i, t = this.itemsData.length;
				for (i = 0; i < t; i += 1) this.prevViewData[i] = this.itemsData[i];
				for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), t = this.dynamicProperties.length, i = 0; i < t; i += 1) this.dynamicProperties[i].getValue();
				this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
			}, CVShapeElement.prototype.addTransformToStyleList = function (i) {
				var t, e = this.stylesList.length;
				for (t = 0; t < e; t += 1) this.stylesList[t].closed || this.stylesList[t].transforms.push(i)
			}, CVShapeElement.prototype.removeTransformFromStyleList = function () {
				var i, t = this.stylesList.length;
				for (i = 0; i < t; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.pop()
			}, CVShapeElement.prototype.closeStyles = function (i) {
				var t, e = i.length;
				for (t = 0; t < e; t += 1) i[t].closed = !0
			}, CVShapeElement.prototype.searchShapes = function (i, t, e, n, r) {
				var s, a = i.length - 1,
					o, h, c = [],
					u = [],
					g, p, _, b = [].concat(r);
				for (s = a; s >= 0; s -= 1) {
					if (g = this.searchProcessedElement(i[s]), g ? t[s] = e[g - 1] : i[s]._shouldRender = n, i[s].ty === "fl" || i[s].ty === "st" || i[s].ty === "gf" || i[s].ty === "gs") g ? t[s].style.closed = !1 : t[s] = this.createStyleElement(i[s], b), c.push(t[s].style);
					else if (i[s].ty === "gr") {
						if (!g) t[s] = this.createGroupElement(i[s]);
						else
							for (h = t[s].it.length, o = 0; o < h; o += 1) t[s].prevViewData[o] = t[s].it[o];
						this.searchShapes(i[s].it, t[s].it, t[s].prevViewData, n, b)
					} else i[s].ty === "tr" ? (g || (_ = this.createTransformElement(i[s]), t[s] = _), b.push(t[s]), this.addTransformToStyleList(t[s])) : i[s].ty === "sh" || i[s].ty === "rc" || i[s].ty === "el" || i[s].ty === "sr" ? g || (t[s] = this.createShapeElement(i[s])) : i[s].ty === "tm" || i[s].ty === "rd" || i[s].ty === "pb" || i[s].ty === "zz" || i[s].ty === "op" ? (g ? (p = t[s], p.closed = !1) : (p = ShapeModifiers.getModifier(i[s].ty), p.init(this, i[s]), t[s] = p, this.shapeModifiers.push(p)), u.push(p)) : i[s].ty === "rp" && (g ? (p = t[s], p.closed = !0) : (p = ShapeModifiers.getModifier(i[s].ty), t[s] = p, p.init(this, i, s, t), this.shapeModifiers.push(p), n = !1), u.push(p));
					this.addProcessedElement(i[s], s + 1)
				}
				for (this.removeTransformFromStyleList(), this.closeStyles(c), a = u.length, s = 0; s < a; s += 1) u[s].closed = !0
			}, CVShapeElement.prototype.renderInnerContent = function () {
				this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
			}, CVShapeElement.prototype.renderShapeTransform = function (i, t) {
				(i._opMdf || t.op._mdf || this._isFirstFrame) && (t.opacity = i.opacity, t.opacity *= t.op.v, t._opMdf = !0)
			}, CVShapeElement.prototype.drawLayer = function () {
				var i, t = this.stylesList.length,
					e, n, r, s, a, o, h = this.globalData.renderer,
					c = this.globalData.canvasContext,
					u, g;
				for (i = 0; i < t; i += 1)
					if (g = this.stylesList[i], u = g.type, !((u === "st" || u === "gs") && g.wi === 0 || !g.data._shouldRender || g.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
						for (h.save(), a = g.elements, u === "st" || u === "gs" ? (h.ctxStrokeStyle(u === "st" ? g.co : g.grd), h.ctxLineWidth(g.wi), h.ctxLineCap(g.lc), h.ctxLineJoin(g.lj), h.ctxMiterLimit(g.ml || 0)) : h.ctxFillStyle(u === "fl" ? g.co : g.grd), h.ctxOpacity(g.coOp), u !== "st" && u !== "gs" && c.beginPath(), h.ctxTransform(g.preTransforms.finalTransform.props), n = a.length, e = 0; e < n; e += 1) {
							for ((u === "st" || u === "gs") && (c.beginPath(), g.da && (c.setLineDash(g.da), c.lineDashOffset = g.do)), o = a[e].trNodes, s = o.length, r = 0; r < s; r += 1) o[r].t === "m" ? c.moveTo(o[r].p[0], o[r].p[1]) : o[r].t === "c" ? c.bezierCurveTo(o[r].pts[0], o[r].pts[1], o[r].pts[2], o[r].pts[3], o[r].pts[4], o[r].pts[5]) : c.closePath();
							(u === "st" || u === "gs") && (h.ctxStroke(), g.da && c.setLineDash(this.dashResetter))
						}
						u !== "st" && u !== "gs" && this.globalData.renderer.ctxFill(g.r), h.restore()
					}
			}, CVShapeElement.prototype.renderShape = function (i, t, e, n) {
				var r, s = t.length - 1,
					a;
				for (a = i, r = s; r >= 0; r -= 1) t[r].ty === "tr" ? (a = e[r].transform, this.renderShapeTransform(i, a)) : t[r].ty === "sh" || t[r].ty === "el" || t[r].ty === "rc" || t[r].ty === "sr" ? this.renderPath(t[r], e[r]) : t[r].ty === "fl" ? this.renderFill(t[r], e[r], a) : t[r].ty === "st" ? this.renderStroke(t[r], e[r], a) : t[r].ty === "gf" || t[r].ty === "gs" ? this.renderGradientFill(t[r], e[r], a) : t[r].ty === "gr" ? this.renderShape(a, t[r].it, e[r].it) : t[r].ty;
				n && this.drawLayer()
			}, CVShapeElement.prototype.renderStyledShape = function (i, t) {
				if (this._isFirstFrame || t._mdf || i.transforms._mdf) {
					var e = i.trNodes,
						n = t.paths,
						r, s, a, o = n._length;
					e.length = 0;
					var h = i.transforms.finalTransform;
					for (a = 0; a < o; a += 1) {
						var c = n.shapes[a];
						if (c && c.v) {
							for (s = c._length, r = 1; r < s; r += 1) r === 1 && e.push({
								t: "m",
								p: h.applyToPointArray(c.v[0][0], c.v[0][1], 0)
							}), e.push({
								t: "c",
								pts: h.applyToTriplePoints(c.o[r - 1], c.i[r], c.v[r])
							});
							s === 1 && e.push({
								t: "m",
								p: h.applyToPointArray(c.v[0][0], c.v[0][1], 0)
							}), c.c && s && (e.push({
								t: "c",
								pts: h.applyToTriplePoints(c.o[r - 1], c.i[0], c.v[0])
							}), e.push({
								t: "z"
							}))
						}
					}
					i.trNodes = e
				}
			}, CVShapeElement.prototype.renderPath = function (i, t) {
				if (i.hd !== !0 && i._shouldRender) {
					var e, n = t.styledShapes.length;
					for (e = 0; e < n; e += 1) this.renderStyledShape(t.styledShapes[e], t.sh)
				}
			}, CVShapeElement.prototype.renderFill = function (i, t, e) {
				var n = t.style;
				(t.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"), (t.o._mdf || e._opMdf || this._isFirstFrame) && (n.coOp = t.o.v * e.opacity)
			}, CVShapeElement.prototype.renderGradientFill = function (i, t, e) {
				var n = t.style,
					r;
				if (!n.grd || t.g._mdf || t.s._mdf || t.e._mdf || i.t !== 1 && (t.h._mdf || t.a._mdf)) {
					var s = this.globalData.canvasContext,
						a = t.s.v,
						o = t.e.v;
					if (i.t === 1) r = s.createLinearGradient(a[0], a[1], o[0], o[1]);
					else {
						var h = Math.sqrt(Math.pow(a[0] - o[0], 2) + Math.pow(a[1] - o[1], 2)),
							c = Math.atan2(o[1] - a[1], o[0] - a[0]),
							u = t.h.v;
						u >= 1 ? u = .99 : u <= -1 && (u = -.99);
						var g = h * u,
							p = Math.cos(c + t.a.v) * g + a[0],
							_ = Math.sin(c + t.a.v) * g + a[1];
						r = s.createRadialGradient(p, _, 0, a[0], a[1], h)
					}
					var b, y = i.g.p,
						w = t.g.c,
						f = 1;
					for (b = 0; b < y; b += 1) t.g._hasOpacity && t.g._collapsable && (f = t.g.o[b * 2 + 1]), r.addColorStop(w[b * 4] / 100, "rgba(" + w[b * 4 + 1] + "," + w[b * 4 + 2] + "," + w[b * 4 + 3] + "," + f + ")");
					n.grd = r
				}
				n.coOp = t.o.v * e.opacity
			}, CVShapeElement.prototype.renderStroke = function (i, t, e) {
				var n = t.style,
					r = t.d;
				r && (r._mdf || this._isFirstFrame) && (n.da = r.dashArray, n.do = r.dashoffset[0]), (t.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"), (t.o._mdf || e._opMdf || this._isFirstFrame) && (n.coOp = t.o.v * e.opacity), (t.w._mdf || this._isFirstFrame) && (n.wi = t.w.v)
			}, CVShapeElement.prototype.destroy = function () {
				this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
			};

			function CVTextElement(i, t, e) {
				this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
					fill: "rgba(0,0,0,0)",
					stroke: "rgba(0,0,0,0)",
					sWidth: 0,
					fValue: ""
				}, this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () {
				var i = this.textProperty.currentData;
				this.renderedLetters = createSizedArray(i.l ? i.l.length : 0);
				var t = !1;
				i.fc ? (t = !0, this.values.fill = this.buildColor(i.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = t;
				var e = !1;
				i.sc && (e = !0, this.values.stroke = this.buildColor(i.sc), this.values.sWidth = i.sw);
				var n = this.globalData.fontManager.getFontByName(i.f),
					r, s, a = i.l,
					o = this.mHelper;
				this.stroke = e, this.values.fValue = i.finalSize + "px " + this.globalData.fontManager.getFontByName(i.f).fFamily, s = i.finalText.length;
				var h, c, u, g, p, _, b, y, w, f, S = this.data.singleShape,
					x = i.tr * .001 * i.finalSize,
					M = 0,
					T = 0,
					I = !0,
					L = 0;
				for (r = 0; r < s; r += 1) {
					h = this.globalData.fontManager.getCharData(i.finalText[r], n.fStyle, this.globalData.fontManager.getFontByName(i.f).fFamily), c = h && h.data || {}, o.reset(), S && a[r].n && (M = -x, T += i.yOffset, T += I ? 1 : 0, I = !1), p = c.shapes ? c.shapes[0].it : [], b = p.length, o.scale(i.finalSize / 100, i.finalSize / 100), S && this.applyTextPropertiesToMatrix(i, o, a[r].line, M, T), w = createSizedArray(b - 1);
					var F = 0;
					for (_ = 0; _ < b; _ += 1)
						if (p[_].ty === "sh") {
							for (g = p[_].ks.k.i.length, y = p[_].ks.k, f = [], u = 1; u < g; u += 1) u === 1 && f.push(o.applyToX(y.v[0][0], y.v[0][1], 0), o.applyToY(y.v[0][0], y.v[0][1], 0)), f.push(o.applyToX(y.o[u - 1][0], y.o[u - 1][1], 0), o.applyToY(y.o[u - 1][0], y.o[u - 1][1], 0), o.applyToX(y.i[u][0], y.i[u][1], 0), o.applyToY(y.i[u][0], y.i[u][1], 0), o.applyToX(y.v[u][0], y.v[u][1], 0), o.applyToY(y.v[u][0], y.v[u][1], 0));
							f.push(o.applyToX(y.o[u - 1][0], y.o[u - 1][1], 0), o.applyToY(y.o[u - 1][0], y.o[u - 1][1], 0), o.applyToX(y.i[0][0], y.i[0][1], 0), o.applyToY(y.i[0][0], y.i[0][1], 0), o.applyToX(y.v[0][0], y.v[0][1], 0), o.applyToY(y.v[0][0], y.v[0][1], 0)), w[F] = f, F += 1
						} S && (M += a[r].l, M += x), this.textSpans[L] ? this.textSpans[L].elem = w : this.textSpans[L] = {
						elem: w
					}, L += 1
				}
			}, CVTextElement.prototype.renderInnerContent = function () {
				this.validateText();
				var i = this.canvasContext;
				i.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
				var t, e, n, r, s, a, o = this.textAnimator.renderedLetters,
					h = this.textProperty.currentData.l;
				e = h.length;
				var c, u = null,
					g = null,
					p = null,
					_, b, y = this.globalData.renderer;
				for (t = 0; t < e; t += 1)
					if (!h[t].n) {
						if (c = o[t], c && (y.save(), y.ctxTransform(c.p), y.ctxOpacity(c.o)), this.fill) {
							for (c && c.fc ? u !== c.fc && (y.ctxFillStyle(c.fc), u = c.fc) : u !== this.values.fill && (u = this.values.fill, y.ctxFillStyle(this.values.fill)), _ = this.textSpans[t].elem, r = _.length, this.globalData.canvasContext.beginPath(), n = 0; n < r; n += 1)
								for (b = _[n], a = b.length, this.globalData.canvasContext.moveTo(b[0], b[1]), s = 2; s < a; s += 6) this.globalData.canvasContext.bezierCurveTo(b[s], b[s + 1], b[s + 2], b[s + 3], b[s + 4], b[s + 5]);
							this.globalData.canvasContext.closePath(), y.ctxFill()
						}
						if (this.stroke) {
							for (c && c.sw ? p !== c.sw && (p = c.sw, y.ctxLineWidth(c.sw)) : p !== this.values.sWidth && (p = this.values.sWidth, y.ctxLineWidth(this.values.sWidth)), c && c.sc ? g !== c.sc && (g = c.sc, y.ctxStrokeStyle(c.sc)) : g !== this.values.stroke && (g = this.values.stroke, y.ctxStrokeStyle(this.values.stroke)), _ = this.textSpans[t].elem, r = _.length, this.globalData.canvasContext.beginPath(), n = 0; n < r; n += 1)
								for (b = _[n], a = b.length, this.globalData.canvasContext.moveTo(b[0], b[1]), s = 2; s < a; s += 6) this.globalData.canvasContext.bezierCurveTo(b[s], b[s + 1], b[s + 2], b[s + 3], b[s + 4], b[s + 5]);
							this.globalData.canvasContext.closePath(), y.ctxStroke()
						}
						c && this.globalData.renderer.restore()
					}
			};

			function CVImageElement(i, t, e) {
				this.assetData = t.getAssetData(i.refId), this.img = t.imageLoader.getAsset(this.assetData), this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () {
				if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
					var i = createTag("canvas");
					i.width = this.assetData.w, i.height = this.assetData.h;
					var t = i.getContext("2d"),
						e = this.img.width,
						n = this.img.height,
						r = e / n,
						s = this.assetData.w / this.assetData.h,
						a, o, h = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
					r > s && h === "xMidYMid slice" || r < s && h !== "xMidYMid slice" ? (o = n, a = o * s) : (a = e, o = a / s), t.drawImage(this.img, (e - a) / 2, (n - o) / 2, a, o, 0, 0, this.assetData.w, this.assetData.h), this.img = i
				}
			}, CVImageElement.prototype.renderInnerContent = function () {
				this.canvasContext.drawImage(this.img, 0, 0)
			}, CVImageElement.prototype.destroy = function () {
				this.img = null
			};

			function CVSolidElement(i, t, e) {
				this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () {
				this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
			};

			function CanvasRendererBase() {}
			extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function (i) {
				return new CVShapeElement(i, this.globalData, this)
			}, CanvasRendererBase.prototype.createText = function (i) {
				return new CVTextElement(i, this.globalData, this)
			}, CanvasRendererBase.prototype.createImage = function (i) {
				return new CVImageElement(i, this.globalData, this)
			}, CanvasRendererBase.prototype.createSolid = function (i) {
				return new CVSolidElement(i, this.globalData, this)
			}, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function (i) {
				i[0] === 1 && i[1] === 0 && i[4] === 0 && i[5] === 1 && i[12] === 0 && i[13] === 0 || this.canvasContext.transform(i[0], i[1], i[4], i[5], i[12], i[13])
			}, CanvasRendererBase.prototype.ctxOpacity = function (i) {
				this.canvasContext.globalAlpha *= i < 0 ? 0 : i
			}, CanvasRendererBase.prototype.ctxFillStyle = function (i) {
				this.canvasContext.fillStyle = i
			}, CanvasRendererBase.prototype.ctxStrokeStyle = function (i) {
				this.canvasContext.strokeStyle = i
			}, CanvasRendererBase.prototype.ctxLineWidth = function (i) {
				this.canvasContext.lineWidth = i
			}, CanvasRendererBase.prototype.ctxLineCap = function (i) {
				this.canvasContext.lineCap = i
			}, CanvasRendererBase.prototype.ctxLineJoin = function (i) {
				this.canvasContext.lineJoin = i
			}, CanvasRendererBase.prototype.ctxMiterLimit = function (i) {
				this.canvasContext.miterLimit = i
			}, CanvasRendererBase.prototype.ctxFill = function (i) {
				this.canvasContext.fill(i)
			}, CanvasRendererBase.prototype.ctxFillRect = function (i, t, e, n) {
				this.canvasContext.fillRect(i, t, e, n)
			}, CanvasRendererBase.prototype.ctxStroke = function () {
				this.canvasContext.stroke()
			}, CanvasRendererBase.prototype.reset = function () {
				if (!this.renderConfig.clearCanvas) {
					this.canvasContext.restore();
					return
				}
				this.contextData.reset()
			}, CanvasRendererBase.prototype.save = function () {
				this.canvasContext.save()
			}, CanvasRendererBase.prototype.restore = function (i) {
				if (!this.renderConfig.clearCanvas) {
					this.canvasContext.restore();
					return
				}
				i && (this.globalData.blendMode = "source-over"), this.contextData.restore(i)
			}, CanvasRendererBase.prototype.configAnimation = function (i) {
				if (this.animationItem.wrapper) {
					this.animationItem.container = createTag("canvas");
					var t = this.animationItem.container.style;
					t.width = "100%", t.height = "100%";
					var e = "0px 0px 0px";
					t.transformOrigin = e, t.mozTransformOrigin = e, t.webkitTransformOrigin = e, t["-webkit-transform"] = e, t.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
				} else this.canvasContext = this.renderConfig.context;
				this.contextData.setContext(this.canvasContext), this.data = i, this.layers = i.layers, this.transformCanvas = {
					w: i.w,
					h: i.h,
					sx: 0,
					sy: 0,
					tx: 0,
					ty: 0
				}, this.setupGlobalData(i, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(i.layers.length), this.updateContainerSize()
			}, CanvasRendererBase.prototype.updateContainerSize = function (i, t) {
				this.reset();
				var e, n;
				i ? (e = i, n = t, this.canvasContext.canvas.width = e, this.canvasContext.canvas.height = n) : (this.animationItem.wrapper && this.animationItem.container ? (e = this.animationItem.wrapper.offsetWidth, n = this.animationItem.wrapper.offsetHeight) : (e = this.canvasContext.canvas.width, n = this.canvasContext.canvas.height), this.canvasContext.canvas.width = e * this.renderConfig.dpr, this.canvasContext.canvas.height = n * this.renderConfig.dpr);
				var r, s;
				if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
					var a = this.renderConfig.preserveAspectRatio.split(" "),
						o = a[1] || "meet",
						h = a[0] || "xMidYMid",
						c = h.substr(0, 4),
						u = h.substr(4);
					r = e / n, s = this.transformCanvas.w / this.transformCanvas.h, s > r && o === "meet" || s < r && o === "slice" ? (this.transformCanvas.sx = e / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = n / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = n / (this.transformCanvas.h / this.renderConfig.dpr)), c === "xMid" && (s < r && o === "meet" || s > r && o === "slice") ? this.transformCanvas.tx = (e - this.transformCanvas.w * (n / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : c === "xMax" && (s < r && o === "meet" || s > r && o === "slice") ? this.transformCanvas.tx = (e - this.transformCanvas.w * (n / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, u === "YMid" && (s > r && o === "meet" || s < r && o === "slice") ? this.transformCanvas.ty = (n - this.transformCanvas.h * (e / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : u === "YMax" && (s > r && o === "meet" || s < r && o === "slice") ? this.transformCanvas.ty = (n - this.transformCanvas.h * (e / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
				} else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = e / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = n / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
				this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
			}, CanvasRendererBase.prototype.destroy = function () {
				this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
				var i, t = this.layers ? this.layers.length : 0;
				for (i = t - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
				this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
			}, CanvasRendererBase.prototype.renderFrame = function (i, t) {
				if (!(this.renderedFrame === i && this.renderConfig.clearCanvas === !0 && !t || this.destroyed || i === -1)) {
					this.renderedFrame = i, this.globalData.frameNum = i - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || t, this.globalData.projectInterface.currentFrame = i;
					var e, n = this.layers.length;
					for (this.completeLayers || this.checkLayers(i), e = n - 1; e >= 0; e -= 1)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(i - this.layers[e].st);
					if (this.globalData._mdf) {
						for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), e = n - 1; e >= 0; e -= 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame();
						this.renderConfig.clearCanvas !== !0 && this.restore()
					}
				}
			}, CanvasRendererBase.prototype.buildItem = function (i) {
				var t = this.elements;
				if (!(t[i] || this.layers[i].ty === 99)) {
					var e = this.createItem(this.layers[i], this, this.globalData);
					t[i] = e, e.initExpressions()
				}
			}, CanvasRendererBase.prototype.checkPendingElements = function () {
				for (; this.pendingElements.length;) {
					var i = this.pendingElements.pop();
					i.checkParenting()
				}
			}, CanvasRendererBase.prototype.hide = function () {
				this.animationItem.container.style.display = "none"
			}, CanvasRendererBase.prototype.show = function () {
				this.animationItem.container.style.display = "block"
			};

			function CanvasContext() {
				this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random()
			}

			function CVContextData() {
				this.stack = [], this.cArrPos = 0, this.cTr = new Matrix;
				var i, t = 15;
				for (i = 0; i < t; i += 1) {
					var e = new CanvasContext;
					this.stack[i] = e
				}
				this._length = t, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = ""
			}
			CVContextData.prototype.duplicate = function () {
				var i = this._length * 2,
					t = 0;
				for (t = this._length; t < i; t += 1) this.stack[t] = new CanvasContext;
				this._length = i
			}, CVContextData.prototype.reset = function () {
				this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1
			}, CVContextData.prototype.restore = function (i) {
				this.cArrPos -= 1;
				var t = this.stack[this.cArrPos],
					e = t.transform,
					n, r = this.cTr.props;
				for (n = 0; n < 16; n += 1) r[n] = e[n];
				if (i) {
					this.nativeContext.restore();
					var s = this.stack[this.cArrPos + 1];
					this.appliedFillStyle = s.fillStyle, this.appliedStrokeStyle = s.strokeStyle, this.appliedLineWidth = s.lineWidth, this.appliedLineCap = s.lineCap, this.appliedLineJoin = s.lineJoin, this.appliedMiterLimit = s.miterLimit
				}
				this.nativeContext.setTransform(e[0], e[1], e[4], e[5], e[12], e[13]), (i || t.opacity !== -1 && this.currentOpacity !== t.opacity) && (this.nativeContext.globalAlpha = t.opacity, this.currentOpacity = t.opacity), this.currentFillStyle = t.fillStyle, this.currentStrokeStyle = t.strokeStyle, this.currentLineWidth = t.lineWidth, this.currentLineCap = t.lineCap, this.currentLineJoin = t.lineJoin, this.currentMiterLimit = t.miterLimit
			}, CVContextData.prototype.save = function (i) {
				i && this.nativeContext.save();
				var t = this.cTr.props;
				this._length <= this.cArrPos && this.duplicate();
				var e = this.stack[this.cArrPos],
					n;
				for (n = 0; n < 16; n += 1) e.transform[n] = t[n];
				this.cArrPos += 1;
				var r = this.stack[this.cArrPos];
				r.opacity = e.opacity, r.fillStyle = e.fillStyle, r.strokeStyle = e.strokeStyle, r.lineWidth = e.lineWidth, r.lineCap = e.lineCap, r.lineJoin = e.lineJoin, r.miterLimit = e.miterLimit
			}, CVContextData.prototype.setOpacity = function (i) {
				this.stack[this.cArrPos].opacity = i
			}, CVContextData.prototype.setContext = function (i) {
				this.nativeContext = i
			}, CVContextData.prototype.fillStyle = function (i) {
				this.stack[this.cArrPos].fillStyle !== i && (this.currentFillStyle = i, this.stack[this.cArrPos].fillStyle = i)
			}, CVContextData.prototype.strokeStyle = function (i) {
				this.stack[this.cArrPos].strokeStyle !== i && (this.currentStrokeStyle = i, this.stack[this.cArrPos].strokeStyle = i)
			}, CVContextData.prototype.lineWidth = function (i) {
				this.stack[this.cArrPos].lineWidth !== i && (this.currentLineWidth = i, this.stack[this.cArrPos].lineWidth = i)
			}, CVContextData.prototype.lineCap = function (i) {
				this.stack[this.cArrPos].lineCap !== i && (this.currentLineCap = i, this.stack[this.cArrPos].lineCap = i)
			}, CVContextData.prototype.lineJoin = function (i) {
				this.stack[this.cArrPos].lineJoin !== i && (this.currentLineJoin = i, this.stack[this.cArrPos].lineJoin = i)
			}, CVContextData.prototype.miterLimit = function (i) {
				this.stack[this.cArrPos].miterLimit !== i && (this.currentMiterLimit = i, this.stack[this.cArrPos].miterLimit = i)
			}, CVContextData.prototype.transform = function (i) {
				this.transformMat.cloneFromProps(i);
				var t = this.cTr;
				this.transformMat.multiply(t), t.cloneFromProps(this.transformMat.props);
				var e = t.props;
				this.nativeContext.setTransform(e[0], e[1], e[4], e[5], e[12], e[13])
			}, CVContextData.prototype.opacity = function (i) {
				var t = this.stack[this.cArrPos].opacity;
				t *= i < 0 ? 0 : i, this.stack[this.cArrPos].opacity !== t && (this.currentOpacity !== i && (this.nativeContext.globalAlpha = i, this.currentOpacity = i), this.stack[this.cArrPos].opacity = t)
			}, CVContextData.prototype.fill = function (i) {
				this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(i)
			}, CVContextData.prototype.fillRect = function (i, t, e, n) {
				this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(i, t, e, n)
			}, CVContextData.prototype.stroke = function () {
				this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke()
			};

			function CVCompElement(i, t, e) {
				this.completeLayers = !1, this.layers = i.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(i, t, e), this.tm = i.tm ? PropertyFactory.getProp(this, i.tm, 0, t.frameRate, this) : {
					_placeholder: !0
				}
			}
			extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () {
				var i = this.canvasContext;
				i.beginPath(), i.moveTo(0, 0), i.lineTo(this.data.w, 0), i.lineTo(this.data.w, this.data.h), i.lineTo(0, this.data.h), i.lineTo(0, 0), i.clip();
				var t, e = this.layers.length;
				for (t = e - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
			}, CVCompElement.prototype.destroy = function () {
				var i, t = this.layers.length;
				for (i = t - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy();
				this.layers = null, this.elements = null
			}, CVCompElement.prototype.createComp = function (i) {
				return new CVCompElement(i, this.globalData, this)
			};

			function CanvasRenderer(i, t) {
				this.animationItem = i, this.renderConfig = {
					clearCanvas: t && t.clearCanvas !== void 0 ? t.clearCanvas : !0,
					context: t && t.context || null,
					progressiveLoad: t && t.progressiveLoad || !1,
					preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
					imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
					contentVisibility: t && t.contentVisibility || "visible",
					className: t && t.className || "",
					id: t && t.id || "",
					runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
				}, this.renderConfig.dpr = t && t.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = t && t.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
					frameNum: -1,
					_mdf: !1,
					renderConfig: this.renderConfig,
					currentGlobalAlpha: -1
				}, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData))
			}
			extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function (i) {
				return new CVCompElement(i, this.globalData, this)
			};

			function HBaseElement() {}
			HBaseElement.prototype = {
				checkBlendMode: function () {},
				initRendererElement: function () {
					this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
				},
				createContainerElements: function () {
					this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode()
				},
				renderElement: function () {
					var t = this.transformedElement ? this.transformedElement.style : {};
					if (this.finalTransform._matMdf) {
						var e = this.finalTransform.mat.toCSS();
						t.transform = e, t.webkitTransform = e
					}
					this.finalTransform._opMdf && (t.opacity = this.finalTransform.mProp.o.v)
				},
				renderFrame: function () {
					this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
				},
				destroy: function () {
					this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
				},
				createRenderableComponents: function () {
					this.maskManager = new MaskElement(this.data, this, this.globalData)
				},
				addEffects: function () {},
				setMatte: function () {}
			}, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;

			function HSolidElement(i, t, e) {
				this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () {
				var i;
				this.data.hasMask ? (i = createNS("rect"), i.setAttribute("width", this.data.sw), i.setAttribute("height", this.data.sh), i.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (i = createTag("div"), i.style.width = this.data.sw + "px", i.style.height = this.data.sh + "px", i.style.backgroundColor = this.data.sc), this.layerElement.appendChild(i)
			};

			function HShapeElement(i, t, e) {
				this.shapes = [], this.shapesData = i.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(i, t, e), this.prevViewData = [], this.currentBBox = {
					x: 999999,
					y: -999999,
					h: 0,
					w: 0
				}
			}
			extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () {
				var i;
				if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), i = this.svgElement;
				else {
					i = createNS("svg");
					var t = this.comp.data ? this.comp.data : this.globalData.compSize;
					i.setAttribute("width", t.w), i.setAttribute("height", t.h), i.appendChild(this.shapesContainer), this.layerElement.appendChild(i)
				}
				this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = i
			}, HShapeElement.prototype.getTransformedPoint = function (i, t) {
				var e, n = i.length;
				for (e = 0; e < n; e += 1) t = i[e].mProps.v.applyToPointArray(t[0], t[1], 0);
				return t
			}, HShapeElement.prototype.calculateShapeBoundingBox = function (i, t) {
				var e = i.sh.v,
					n = i.transformers,
					r, s = e._length,
					a, o, h, c;
				if (!(s <= 1)) {
					for (r = 0; r < s - 1; r += 1) a = this.getTransformedPoint(n, e.v[r]), o = this.getTransformedPoint(n, e.o[r]), h = this.getTransformedPoint(n, e.i[r + 1]), c = this.getTransformedPoint(n, e.v[r + 1]), this.checkBounds(a, o, h, c, t);
					e.c && (a = this.getTransformedPoint(n, e.v[r]), o = this.getTransformedPoint(n, e.o[r]), h = this.getTransformedPoint(n, e.i[0]), c = this.getTransformedPoint(n, e.v[0]), this.checkBounds(a, o, h, c, t))
				}
			}, HShapeElement.prototype.checkBounds = function (i, t, e, n, r) {
				this.getBoundsOfCurve(i, t, e, n);
				var s = this.shapeBoundingBox;
				r.x = bmMin(s.left, r.x), r.xMax = bmMax(s.right, r.xMax), r.y = bmMin(s.top, r.y), r.yMax = bmMax(s.bottom, r.yMax)
			}, HShapeElement.prototype.shapeBoundingBox = {
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, HShapeElement.prototype.tempBoundingBox = {
				x: 0,
				xMax: 0,
				y: 0,
				yMax: 0,
				width: 0,
				height: 0
			}, HShapeElement.prototype.getBoundsOfCurve = function (i, t, e, n) {
				for (var r = [
						[i[0], n[0]],
						[i[1], n[1]]
					], s, a, o, h, c, u, g, p = 0; p < 2; ++p) a = 6 * i[p] - 12 * t[p] + 6 * e[p], s = -3 * i[p] + 9 * t[p] - 9 * e[p] + 3 * n[p], o = 3 * t[p] - 3 * i[p], a |= 0, s |= 0, o |= 0, s === 0 && a === 0 || (s === 0 ? (h = -o / a, h > 0 && h < 1 && r[p].push(this.calculateF(h, i, t, e, n, p))) : (c = a * a - 4 * o * s, c >= 0 && (u = (-a + bmSqrt(c)) / (2 * s), u > 0 && u < 1 && r[p].push(this.calculateF(u, i, t, e, n, p)), g = (-a - bmSqrt(c)) / (2 * s), g > 0 && g < 1 && r[p].push(this.calculateF(g, i, t, e, n, p)))));
				this.shapeBoundingBox.left = bmMin.apply(null, r[0]), this.shapeBoundingBox.top = bmMin.apply(null, r[1]), this.shapeBoundingBox.right = bmMax.apply(null, r[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, r[1])
			}, HShapeElement.prototype.calculateF = function (i, t, e, n, r, s) {
				return bmPow(1 - i, 3) * t[s] + 3 * bmPow(1 - i, 2) * i * e[s] + 3 * (1 - i) * bmPow(i, 2) * n[s] + bmPow(i, 3) * r[s]
			}, HShapeElement.prototype.calculateBoundingBox = function (i, t) {
				var e, n = i.length;
				for (e = 0; e < n; e += 1) i[e] && i[e].sh ? this.calculateShapeBoundingBox(i[e], t) : i[e] && i[e].it ? this.calculateBoundingBox(i[e].it, t) : i[e] && i[e].style && i[e].w && this.expandStrokeBoundingBox(i[e].w, t)
			}, HShapeElement.prototype.expandStrokeBoundingBox = function (i, t) {
				var e = 0;
				if (i.keyframes) {
					for (var n = 0; n < i.keyframes.length; n += 1) {
						var r = i.keyframes[n].s;
						r > e && (e = r)
					}
					e *= i.mult
				} else e = i.v * i.mult;
				t.x -= e, t.xMax += e, t.y -= e, t.yMax += e
			}, HShapeElement.prototype.currentBoxContains = function (i) {
				return this.currentBBox.x <= i.x && this.currentBBox.y <= i.y && this.currentBBox.width + this.currentBBox.x >= i.x + i.width && this.currentBBox.height + this.currentBBox.y >= i.y + i.height
			}, HShapeElement.prototype.renderInnerContent = function () {
				if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
					var i = this.tempBoundingBox,
						t = 999999;
					if (i.x = t, i.xMax = -t, i.y = t, i.yMax = -t, this.calculateBoundingBox(this.itemsData, i), i.width = i.xMax < i.x ? 0 : i.xMax - i.x, i.height = i.yMax < i.y ? 0 : i.yMax - i.y, this.currentBoxContains(i)) return;
					var e = !1;
					if (this.currentBBox.w !== i.width && (this.currentBBox.w = i.width, this.shapeCont.setAttribute("width", i.width), e = !0), this.currentBBox.h !== i.height && (this.currentBBox.h = i.height, this.shapeCont.setAttribute("height", i.height), e = !0), e || this.currentBBox.x !== i.x || this.currentBBox.y !== i.y) {
						this.currentBBox.w = i.width, this.currentBBox.h = i.height, this.currentBBox.x = i.x, this.currentBBox.y = i.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
						var n = this.shapeCont.style,
							r = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
						n.transform = r, n.webkitTransform = r
					}
				}
			};

			function HTextElement(i, t, e) {
				this.textSpans = [], this.textPaths = [], this.currentBBox = {
					x: 999999,
					y: -999999,
					h: 0,
					w: 0
				}, this.renderType = "svg", this.isMasked = !1, this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () {
				if (this.isMasked = this.checkMasks(), this.isMasked) {
					this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
					var i = createNS("g");
					this.maskedElement.appendChild(i), this.innerElem = i
				} else this.renderType = "html", this.innerElem = this.layerElement;
				this.checkParenting()
			}, HTextElement.prototype.buildNewText = function () {
				var i = this.textProperty.currentData;
				this.renderedLetters = createSizedArray(i.l ? i.l.length : 0);
				var t = this.innerElem.style,
					e = i.fc ? this.buildColor(i.fc) : "rgba(0,0,0,0)";
				t.fill = e, t.color = e, i.sc && (t.stroke = this.buildColor(i.sc), t.strokeWidth = i.sw + "px");
				var n = this.globalData.fontManager.getFontByName(i.f);
				if (!this.globalData.fontManager.chars)
					if (t.fontSize = i.finalSize + "px", t.lineHeight = i.finalSize + "px", n.fClass) this.innerElem.className = n.fClass;
					else {
						t.fontFamily = n.fFamily;
						var r = i.fWeight,
							s = i.fStyle;
						t.fontStyle = s, t.fontWeight = r
					} var a, o, h = i.l;
				o = h.length;
				var c, u, g, p = this.mHelper,
					_, b = "",
					y = 0;
				for (a = 0; a < o; a += 1) {
					if (this.globalData.fontManager.chars ? (this.textPaths[y] ? c = this.textPaths[y] : (c = createNS("path"), c.setAttribute("stroke-linecap", lineCapEnum[1]), c.setAttribute("stroke-linejoin", lineJoinEnum[2]), c.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[y] ? (u = this.textSpans[y], g = u.children[0]) : (u = createTag("div"), u.style.lineHeight = 0, g = createNS("svg"), g.appendChild(c), styleDiv(u)))) : this.isMasked ? c = this.textPaths[y] ? this.textPaths[y] : createNS("text") : this.textSpans[y] ? (u = this.textSpans[y], c = this.textPaths[y]) : (u = createTag("span"), styleDiv(u), c = createTag("span"), styleDiv(c), u.appendChild(c)), this.globalData.fontManager.chars) {
						var w = this.globalData.fontManager.getCharData(i.finalText[a], n.fStyle, this.globalData.fontManager.getFontByName(i.f).fFamily),
							f;
						if (w ? f = w.data : f = null, p.reset(), f && f.shapes && f.shapes.length && (_ = f.shapes[0].it, p.scale(i.finalSize / 100, i.finalSize / 100), b = this.createPathShape(p, _), c.setAttribute("d", b)), this.isMasked) this.innerElem.appendChild(c);
						else {
							if (this.innerElem.appendChild(u), f && f.shapes) {
								document.body.appendChild(g);
								var S = g.getBBox();
								g.setAttribute("width", S.width + 2), g.setAttribute("height", S.height + 2), g.setAttribute("viewBox", S.x - 1 + " " + (S.y - 1) + " " + (S.width + 2) + " " + (S.height + 2));
								var x = g.style,
									M = "translate(" + (S.x - 1) + "px," + (S.y - 1) + "px)";
								x.transform = M, x.webkitTransform = M, h[a].yOffset = S.y - 1
							} else g.setAttribute("width", 1), g.setAttribute("height", 1);
							u.appendChild(g)
						}
					} else if (c.textContent = h[a].val, c.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(c);
					else {
						this.innerElem.appendChild(u);
						var T = c.style,
							I = "translate3d(0," + -i.finalSize / 1.2 + "px,0)";
						T.transform = I, T.webkitTransform = I
					}
					this.isMasked ? this.textSpans[y] = c : this.textSpans[y] = u, this.textSpans[y].style.display = "block", this.textPaths[y] = c, y += 1
				}
				for (; y < this.textSpans.length;) this.textSpans[y].style.display = "none", y += 1
			}, HTextElement.prototype.renderInnerContent = function () {
				this.validateText();
				var i;
				if (this.data.singleShape) {
					if (!this._isFirstFrame && !this.lettersChangedFlag) return;
					if (this.isMasked && this.finalTransform._matMdf) {
						this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), i = this.svgElement.style;
						var t = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
						i.transform = t, i.webkitTransform = t
					}
				}
				if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
					var e, n, r = 0,
						s = this.textAnimator.renderedLetters,
						a = this.textProperty.currentData.l;
					n = a.length;
					var o, h, c;
					for (e = 0; e < n; e += 1) a[e].n ? r += 1 : (h = this.textSpans[e], c = this.textPaths[e], o = s[r], r += 1, o._mdf.m && (this.isMasked ? h.setAttribute("transform", o.m) : (h.style.webkitTransform = o.m, h.style.transform = o.m)), h.style.opacity = o.o, o.sw && o._mdf.sw && c.setAttribute("stroke-width", o.sw), o.sc && o._mdf.sc && c.setAttribute("stroke", o.sc), o.fc && o._mdf.fc && (c.setAttribute("fill", o.fc), c.style.color = o.fc));
					if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
						var u = this.innerElem.getBBox();
						this.currentBBox.w !== u.width && (this.currentBBox.w = u.width, this.svgElement.setAttribute("width", u.width)), this.currentBBox.h !== u.height && (this.currentBBox.h = u.height, this.svgElement.setAttribute("height", u.height));
						var g = 1;
						if (this.currentBBox.w !== u.width + g * 2 || this.currentBBox.h !== u.height + g * 2 || this.currentBBox.x !== u.x - g || this.currentBBox.y !== u.y - g) {
							this.currentBBox.w = u.width + g * 2, this.currentBBox.h = u.height + g * 2, this.currentBBox.x = u.x - g, this.currentBBox.y = u.y - g, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), i = this.svgElement.style;
							var p = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
							i.transform = p, i.webkitTransform = p
						}
					}
				}
			};

			function HCameraElement(i, t, e) {
				this.initFrame(), this.initBaseData(i, t, e), this.initHierarchy();
				var n = PropertyFactory.getProp;
				if (this.pe = n(this, i.pe, 0, 0, this), i.ks.p.s ? (this.px = n(this, i.ks.p.x, 1, 0, this), this.py = n(this, i.ks.p.y, 1, 0, this), this.pz = n(this, i.ks.p.z, 1, 0, this)) : this.p = n(this, i.ks.p, 1, 0, this), i.ks.a && (this.a = n(this, i.ks.a, 1, 0, this)), i.ks.or.k.length && i.ks.or.k[0].to) {
					var r, s = i.ks.or.k.length;
					for (r = 0; r < s; r += 1) i.ks.or.k[r].to = null, i.ks.or.k[r].ti = null
				}
				this.or = n(this, i.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = n(this, i.ks.rx, 0, degToRads, this), this.ry = n(this, i.ks.ry, 0, degToRads, this), this.rz = n(this, i.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
					mProp: this
				}
			}
			extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () {
				var i, t = this.comp.threeDElements.length,
					e, n, r;
				for (i = 0; i < t; i += 1)
					if (e = this.comp.threeDElements[i], e.type === "3d") {
						n = e.perspectiveElem.style, r = e.container.style;
						var s = this.pe.v + "px",
							a = "0px 0px 0px",
							o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
						n.perspective = s, n.webkitPerspective = s, r.transformOrigin = a, r.mozTransformOrigin = a, r.webkitTransformOrigin = a, n.transform = o, n.webkitTransform = o
					}
			}, HCameraElement.prototype.createElements = function () {}, HCameraElement.prototype.hide = function () {}, HCameraElement.prototype.renderFrame = function () {
				var i = this._isFirstFrame,
					t, e;
				if (this.hierarchy)
					for (e = this.hierarchy.length, t = 0; t < e; t += 1) i = this.hierarchy[t].finalTransform.mProp._mdf || i;
				if (i || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
					if (this.mat.reset(), this.hierarchy)
						for (e = this.hierarchy.length - 1, t = e; t >= 0; t -= 1) {
							var n = this.hierarchy[t].finalTransform.mProp;
							this.mat.translate(-n.p.v[0], -n.p.v[1], n.p.v[2]), this.mat.rotateX(-n.or.v[0]).rotateY(-n.or.v[1]).rotateZ(n.or.v[2]), this.mat.rotateX(-n.rx.v).rotateY(-n.ry.v).rotateZ(n.rz.v), this.mat.scale(1 / n.s.v[0], 1 / n.s.v[1], 1 / n.s.v[2]), this.mat.translate(n.a.v[0], n.a.v[1], n.a.v[2])
						}
					if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
						var r;
						this.p ? r = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : r = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
						var s = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2)),
							a = [r[0] / s, r[1] / s, r[2] / s],
							o = Math.sqrt(a[2] * a[2] + a[0] * a[0]),
							h = Math.atan2(a[1], o),
							c = Math.atan2(a[0], -a[2]);
						this.mat.rotateY(c).rotateX(-h)
					}
					this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
					var u = !this._prevMat.equals(this.mat);
					if ((u || this.pe._mdf) && this.comp.threeDElements) {
						e = this.comp.threeDElements.length;
						var g, p, _;
						for (t = 0; t < e; t += 1)
							if (g = this.comp.threeDElements[t], g.type === "3d") {
								if (u) {
									var b = this.mat.toCSS();
									_ = g.container.style, _.transform = b, _.webkitTransform = b
								}
								this.pe._mdf && (p = g.perspectiveElem.style, p.perspective = this.pe.v + "px", p.webkitPerspective = this.pe.v + "px")
							} this.mat.clone(this._prevMat)
					}
				}
				this._isFirstFrame = !1
			}, HCameraElement.prototype.prepareFrame = function (i) {
				this.prepareProperties(i, !0)
			}, HCameraElement.prototype.destroy = function () {}, HCameraElement.prototype.getBaseElement = function () {
				return null
			};

			function HImageElement(i, t, e) {
				this.assetData = t.getAssetData(i.refId), this.initElement(i, t, e)
			}
			extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () {
				var i = this.globalData.getAssetsPath(this.assetData),
					t = new Image;
				this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", i), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(t), t.crossOrigin = "anonymous", t.src = i, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
			};

			function HybridRendererBase(i, t) {
				this.animationItem = i, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
					className: t && t.className || "",
					imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
					hideOnTransparent: !(t && t.hideOnTransparent === !1),
					filterSize: {
						width: t && t.filterSize && t.filterSize.width || "400%",
						height: t && t.filterSize && t.filterSize.height || "400%",
						x: t && t.filterSize && t.filterSize.x || "-100%",
						y: t && t.filterSize && t.filterSize.y || "-100%"
					}
				}, this.globalData = {
					_mdf: !1,
					frameNum: -1,
					renderConfig: this.renderConfig
				}, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
			}
			extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function () {
				for (; this.pendingElements.length;) {
					var i = this.pendingElements.pop();
					i.checkParenting()
				}
			}, HybridRendererBase.prototype.appendElementInPos = function (i, t) {
				var e = i.getBaseElement();
				if (e) {
					var n = this.layers[t];
					if (!n.ddd || !this.supports3d)
						if (this.threeDElements) this.addTo3dContainer(e, t);
						else {
							for (var r = 0, s, a, o; r < t;) this.elements[r] && this.elements[r] !== !0 && this.elements[r].getBaseElement && (a = this.elements[r], o = this.layers[r].ddd ? this.getThreeDContainerByPos(r) : a.getBaseElement(), s = o || s), r += 1;
							s ? (!n.ddd || !this.supports3d) && this.layerElement.insertBefore(e, s) : (!n.ddd || !this.supports3d) && this.layerElement.appendChild(e)
						}
					else this.addTo3dContainer(e, t)
				}
			}, HybridRendererBase.prototype.createShape = function (i) {
				return this.supports3d ? new HShapeElement(i, this.globalData, this) : new SVGShapeElement(i, this.globalData, this)
			}, HybridRendererBase.prototype.createText = function (i) {
				return this.supports3d ? new HTextElement(i, this.globalData, this) : new SVGTextLottieElement(i, this.globalData, this)
			}, HybridRendererBase.prototype.createCamera = function (i) {
				return this.camera = new HCameraElement(i, this.globalData, this), this.camera
			}, HybridRendererBase.prototype.createImage = function (i) {
				return this.supports3d ? new HImageElement(i, this.globalData, this) : new IImageElement(i, this.globalData, this)
			}, HybridRendererBase.prototype.createSolid = function (i) {
				return this.supports3d ? new HSolidElement(i, this.globalData, this) : new ISolidElement(i, this.globalData, this)
			}, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function (i) {
				for (var t = 0, e = this.threeDElements.length; t < e;) {
					if (this.threeDElements[t].startPos <= i && this.threeDElements[t].endPos >= i) return this.threeDElements[t].perspectiveElem;
					t += 1
				}
				return null
			}, HybridRendererBase.prototype.createThreeDContainer = function (i, t) {
				var e = createTag("div"),
					n, r;
				styleDiv(e);
				var s = createTag("div");
				if (styleDiv(s), t === "3d") {
					n = e.style, n.width = this.globalData.compSize.w + "px", n.height = this.globalData.compSize.h + "px";
					var a = "50% 50%";
					n.webkitTransformOrigin = a, n.mozTransformOrigin = a, n.transformOrigin = a, r = s.style;
					var o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
					r.transform = o, r.webkitTransform = o
				}
				e.appendChild(s);
				var h = {
					container: s,
					perspectiveElem: e,
					startPos: i,
					endPos: i,
					type: t
				};
				return this.threeDElements.push(h), h
			}, HybridRendererBase.prototype.build3dContainers = function () {
				var i, t = this.layers.length,
					e, n = "";
				for (i = 0; i < t; i += 1) this.layers[i].ddd && this.layers[i].ty !== 3 ? (n !== "3d" && (n = "3d", e = this.createThreeDContainer(i, "3d")), e.endPos = Math.max(e.endPos, i)) : (n !== "2d" && (n = "2d", e = this.createThreeDContainer(i, "2d")), e.endPos = Math.max(e.endPos, i));
				for (t = this.threeDElements.length, i = t - 1; i >= 0; i -= 1) this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem)
			}, HybridRendererBase.prototype.addTo3dContainer = function (i, t) {
				for (var e = 0, n = this.threeDElements.length; e < n;) {
					if (t <= this.threeDElements[e].endPos) {
						for (var r = this.threeDElements[e].startPos, s; r < t;) this.elements[r] && this.elements[r].getBaseElement && (s = this.elements[r].getBaseElement()), r += 1;
						s ? this.threeDElements[e].container.insertBefore(i, s) : this.threeDElements[e].container.appendChild(i);
						break
					}
					e += 1
				}
			}, HybridRendererBase.prototype.configAnimation = function (i) {
				var t = createTag("div"),
					e = this.animationItem.wrapper,
					n = t.style;
				n.width = i.w + "px", n.height = i.h + "px", this.resizerElem = t, styleDiv(t), n.transformStyle = "flat", n.mozTransformStyle = "flat", n.webkitTransformStyle = "flat", this.renderConfig.className && t.setAttribute("class", this.renderConfig.className), e.appendChild(t), n.overflow = "hidden";
				var r = createNS("svg");
				r.setAttribute("width", "1"), r.setAttribute("height", "1"), styleDiv(r), this.resizerElem.appendChild(r);
				var s = createNS("defs");
				r.appendChild(s), this.data = i, this.setupGlobalData(i, r), this.globalData.defs = s, this.layers = i.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
			}, HybridRendererBase.prototype.destroy = function () {
				this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
				var i, t = this.layers ? this.layers.length : 0;
				for (i = 0; i < t; i += 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
				this.elements.length = 0, this.destroyed = !0, this.animationItem = null
			}, HybridRendererBase.prototype.updateContainerSize = function () {
				var i = this.animationItem.wrapper.offsetWidth,
					t = this.animationItem.wrapper.offsetHeight,
					e = i / t,
					n = this.globalData.compSize.w / this.globalData.compSize.h,
					r, s, a, o;
				n > e ? (r = i / this.globalData.compSize.w, s = i / this.globalData.compSize.w, a = 0, o = (t - this.globalData.compSize.h * (i / this.globalData.compSize.w)) / 2) : (r = t / this.globalData.compSize.h, s = t / this.globalData.compSize.h, a = (i - this.globalData.compSize.w * (t / this.globalData.compSize.h)) / 2, o = 0);
				var h = this.resizerElem.style;
				h.webkitTransform = "matrix3d(" + r + ",0,0,0,0," + s + ",0,0,0,0,1,0," + a + "," + o + ",0,1)", h.transform = h.webkitTransform
			}, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function () {
				this.resizerElem.style.display = "none"
			}, HybridRendererBase.prototype.show = function () {
				this.resizerElem.style.display = "block"
			}, HybridRendererBase.prototype.initItems = function () {
				if (this.buildAllItems(), this.camera) this.camera.setup();
				else {
					var i = this.globalData.compSize.w,
						t = this.globalData.compSize.h,
						e, n = this.threeDElements.length;
					for (e = 0; e < n; e += 1) {
						var r = this.threeDElements[e].perspectiveElem.style;
						r.webkitPerspective = Math.sqrt(Math.pow(i, 2) + Math.pow(t, 2)) + "px", r.perspective = r.webkitPerspective
					}
				}
			}, HybridRendererBase.prototype.searchExtraCompositions = function (i) {
				var t, e = i.length,
					n = createTag("div");
				for (t = 0; t < e; t += 1)
					if (i[t].xt) {
						var r = this.createComp(i[t], n, this.globalData.comp, null);
						r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
					}
			};

			function HCompElement(i, t, e) {
				this.layers = i.layers, this.supports3d = !i.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(i, t, e), this.tm = i.tm ? PropertyFactory.getProp(this, i.tm, 0, t.frameRate, this) : {
					_placeholder: !0
				}
			}
			extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () {
				this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
			}, HCompElement.prototype.addTo3dContainer = function (i, t) {
				for (var e = 0, n; e < t;) this.elements[e] && this.elements[e].getBaseElement && (n = this.elements[e].getBaseElement()), e += 1;
				n ? this.layerElement.insertBefore(i, n) : this.layerElement.appendChild(i)
			}, HCompElement.prototype.createComp = function (i) {
				return this.supports3d ? new HCompElement(i, this.globalData, this) : new SVGCompElement(i, this.globalData, this)
			};

			function HybridRenderer(i, t) {
				this.animationItem = i, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
					className: t && t.className || "",
					imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
					hideOnTransparent: !(t && t.hideOnTransparent === !1),
					filterSize: {
						width: t && t.filterSize && t.filterSize.width || "400%",
						height: t && t.filterSize && t.filterSize.height || "400%",
						x: t && t.filterSize && t.filterSize.x || "-100%",
						y: t && t.filterSize && t.filterSize.y || "-100%"
					},
					runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
				}, this.globalData = {
					_mdf: !1,
					frameNum: -1,
					renderConfig: this.renderConfig
				}, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
			}
			extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function (i) {
				return this.supports3d ? new HCompElement(i, this.globalData, this) : new SVGCompElement(i, this.globalData, this)
			};
			var CompExpressionInterface = function () {
				return function (i) {
					function t(e) {
						for (var n = 0, r = i.layers.length; n < r;) {
							if (i.layers[n].nm === e || i.layers[n].ind === e) return i.elements[n].layerInterface;
							n += 1
						}
						return null
					}
					return Object.defineProperty(t, "_name", {
						value: i.data.nm
					}), t.layer = t, t.pixelAspect = 1, t.height = i.data.h || i.globalData.compSize.h, t.width = i.data.w || i.globalData.compSize.w, t.pixelAspect = 1, t.frameDuration = 1 / i.globalData.frameRate, t.displayStartTime = 0, t.numLayers = i.layers.length, t
				}
			}();

			function _typeof$2(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function (e) {
					return typeof e
				} : _typeof$2 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$2(i)
			}

			function seedRandom(i, t) {
				var e = this,
					n = 256,
					r = 6,
					s = 52,
					a = "random",
					o = t.pow(n, r),
					h = t.pow(2, s),
					c = h * 2,
					u = n - 1,
					g;

				function p(x, M, T) {
					var I = [];
					M = M === !0 ? {
						entropy: !0
					} : M || {};
					var L = w(y(M.entropy ? [x, S(i)] : x === null ? f() : x, 3), I),
						F = new _(I),
						k = function () {
							for (var j = F.g(r), U = o, z = 0; j < h;) j = (j + z) * n, U *= n, z = F.g(1);
							for (; j >= c;) j /= 2, U /= 2, z >>>= 1;
							return (j + z) / U
						};
					return k.int32 = function () {
						return F.g(4) | 0
					}, k.quick = function () {
						return F.g(4) / 4294967296
					}, k.double = k, w(S(F.S), i), (M.pass || T || function (G, j, U, z) {
						return z && (z.S && b(z, F), G.state = function () {
							return b(F, {})
						}), U ? (t[a] = G, j) : G
					})(k, L, "global" in M ? M.global : this == t, M.state)
				}
				t["seed" + a] = p;

				function _(x) {
					var M, T = x.length,
						I = this,
						L = 0,
						F = I.i = I.j = 0,
						k = I.S = [];
					for (T || (x = [T++]); L < n;) k[L] = L++;
					for (L = 0; L < n; L++) k[L] = k[F = u & F + x[L % T] + (M = k[L])], k[F] = M;
					I.g = function (G) {
						for (var j, U = 0, z = I.i, $ = I.j, W = I.S; G--;) j = W[z = u & z + 1], U = U * n + W[u & (W[z] = W[$ = u & $ + j]) + (W[$] = j)];
						return I.i = z, I.j = $, U
					}
				}

				function b(x, M) {
					return M.i = x.i, M.j = x.j, M.S = x.S.slice(), M
				}

				function y(x, M) {
					var T = [],
						I = _typeof$2(x),
						L;
					if (M && I == "object")
						for (L in x) try {
							T.push(y(x[L], M - 1))
						} catch (F) {}
					return T.length ? T : I == "string" ? x : x + "\0"
				}

				function w(x, M) {
					for (var T = x + "", I, L = 0; L < T.length;) M[u & L] = u & (I ^= M[u & L] * 19) + T.charCodeAt(L++);
					return S(M)
				}

				function f() {
					try {
						if (g) return S(g.randomBytes(n));
						var x = new Uint8Array(n);
						return (e.crypto || e.msCrypto).getRandomValues(x), S(x)
					} catch (I) {
						var M = e.navigator,
							T = M && M.plugins;
						return [+new Date, e, T, e.screen, S(i)]
					}
				}

				function S(x) {
					return String.fromCharCode.apply(0, x)
				}
				w(t.random(), i)
			}

			function initialize$2(i) {
				seedRandom([], i)
			}
			var propTypes = {
				SHAPE: "shape"
			};

			function _typeof$1(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function (e) {
					return typeof e
				} : _typeof$1 = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof$1(i)
			}
			var ExpressionManager = function () {
					"use strict";
					var ob = {},
						Math = BMMath,
						window = null,
						document = null,
						XMLHttpRequest = null,
						fetch = null,
						frames = null,
						_lottieGlobal = {};
					initialize$2(BMMath);

					function resetFrame() {
						_lottieGlobal = {}
					}

					function $bm_isInstanceOfArray(i) {
						return i.constructor === Array || i.constructor === Float32Array
					}

					function isNumerable(i, t) {
						return i === "number" || t instanceof Number || i === "boolean" || i === "string"
					}

					function $bm_neg(i) {
						var t = _typeof$1(i);
						if (t === "number" || i instanceof Number || t === "boolean") return -i;
						if ($bm_isInstanceOfArray(i)) {
							var e, n = i.length,
								r = [];
							for (e = 0; e < n; e += 1) r[e] = -i[e];
							return r
						}
						return i.propType ? i.v : -i
					}
					var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
						easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
						easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

					function sum(i, t) {
						var e = _typeof$1(i),
							n = _typeof$1(t);
						if (isNumerable(e, i) && isNumerable(n, t) || e === "string" || n === "string") return i + t;
						if ($bm_isInstanceOfArray(i) && isNumerable(n, t)) return i = i.slice(0), i[0] += t, i;
						if (isNumerable(e, i) && $bm_isInstanceOfArray(t)) return t = t.slice(0), t[0] = i + t[0], t;
						if ($bm_isInstanceOfArray(i) && $bm_isInstanceOfArray(t)) {
							for (var r = 0, s = i.length, a = t.length, o = []; r < s || r < a;)(typeof i[r] == "number" || i[r] instanceof Number) && (typeof t[r] == "number" || t[r] instanceof Number) ? o[r] = i[r] + t[r] : o[r] = t[r] === void 0 ? i[r] : i[r] || t[r], r += 1;
							return o
						}
						return 0
					}
					var add = sum;

					function sub(i, t) {
						var e = _typeof$1(i),
							n = _typeof$1(t);
						if (isNumerable(e, i) && isNumerable(n, t)) return e === "string" && (i = parseInt(i, 10)), n === "string" && (t = parseInt(t, 10)), i - t;
						if ($bm_isInstanceOfArray(i) && isNumerable(n, t)) return i = i.slice(0), i[0] -= t, i;
						if (isNumerable(e, i) && $bm_isInstanceOfArray(t)) return t = t.slice(0), t[0] = i - t[0], t;
						if ($bm_isInstanceOfArray(i) && $bm_isInstanceOfArray(t)) {
							for (var r = 0, s = i.length, a = t.length, o = []; r < s || r < a;)(typeof i[r] == "number" || i[r] instanceof Number) && (typeof t[r] == "number" || t[r] instanceof Number) ? o[r] = i[r] - t[r] : o[r] = t[r] === void 0 ? i[r] : i[r] || t[r], r += 1;
							return o
						}
						return 0
					}

					function mul(i, t) {
						var e = _typeof$1(i),
							n = _typeof$1(t),
							r;
						if (isNumerable(e, i) && isNumerable(n, t)) return i * t;
						var s, a;
						if ($bm_isInstanceOfArray(i) && isNumerable(n, t)) {
							for (a = i.length, r = createTypedArray("float32", a), s = 0; s < a; s += 1) r[s] = i[s] * t;
							return r
						}
						if (isNumerable(e, i) && $bm_isInstanceOfArray(t)) {
							for (a = t.length, r = createTypedArray("float32", a), s = 0; s < a; s += 1) r[s] = i * t[s];
							return r
						}
						return 0
					}

					function div(i, t) {
						var e = _typeof$1(i),
							n = _typeof$1(t),
							r;
						if (isNumerable(e, i) && isNumerable(n, t)) return i / t;
						var s, a;
						if ($bm_isInstanceOfArray(i) && isNumerable(n, t)) {
							for (a = i.length, r = createTypedArray("float32", a), s = 0; s < a; s += 1) r[s] = i[s] / t;
							return r
						}
						if (isNumerable(e, i) && $bm_isInstanceOfArray(t)) {
							for (a = t.length, r = createTypedArray("float32", a), s = 0; s < a; s += 1) r[s] = i / t[s];
							return r
						}
						return 0
					}

					function mod(i, t) {
						return typeof i == "string" && (i = parseInt(i, 10)), typeof t == "string" && (t = parseInt(t, 10)), i % t
					}
					var $bm_sum = sum,
						$bm_sub = sub,
						$bm_mul = mul,
						$bm_div = div,
						$bm_mod = mod;

					function clamp(i, t, e) {
						if (t > e) {
							var n = e;
							e = t, t = n
						}
						return Math.min(Math.max(i, t), e)
					}

					function radiansToDegrees(i) {
						return i / degToRads
					}
					var radians_to_degrees = radiansToDegrees;

					function degreesToRadians(i) {
						return i * degToRads
					}
					var degrees_to_radians = radiansToDegrees,
						helperLengthArray = [0, 0, 0, 0, 0, 0];

					function length(i, t) {
						if (typeof i == "number" || i instanceof Number) return t = t || 0, Math.abs(i - t);
						t || (t = helperLengthArray);
						var e, n = Math.min(i.length, t.length),
							r = 0;
						for (e = 0; e < n; e += 1) r += Math.pow(t[e] - i[e], 2);
						return Math.sqrt(r)
					}

					function normalize(i) {
						return div(i, length(i))
					}

					function rgbToHsl(i) {
						var t = i[0],
							e = i[1],
							n = i[2],
							r = Math.max(t, e, n),
							s = Math.min(t, e, n),
							a, o, h = (r + s) / 2;
						if (r === s) a = 0, o = 0;
						else {
							var c = r - s;
							switch (o = h > .5 ? c / (2 - r - s) : c / (r + s), r) {
								case t:
									a = (e - n) / c + (e < n ? 6 : 0);
									break;
								case e:
									a = (n - t) / c + 2;
									break;
								case n:
									a = (t - e) / c + 4;
									break;
								default:
									break
							}
							a /= 6
						}
						return [a, o, h, i[3]]
					}

					function hue2rgb(i, t, e) {
						return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (t - i) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i + (t - i) * (2 / 3 - e) * 6 : i
					}

					function hslToRgb(i) {
						var t = i[0],
							e = i[1],
							n = i[2],
							r, s, a;
						if (e === 0) r = n, a = n, s = n;
						else {
							var o = n < .5 ? n * (1 + e) : n + e - n * e,
								h = 2 * n - o;
							r = hue2rgb(h, o, t + 1 / 3), s = hue2rgb(h, o, t), a = hue2rgb(h, o, t - 1 / 3)
						}
						return [r, s, a, i[3]]
					}

					function linear(i, t, e, n, r) {
						if ((n === void 0 || r === void 0) && (n = t, r = e, t = 0, e = 1), e < t) {
							var s = e;
							e = t, t = s
						}
						if (i <= t) return n;
						if (i >= e) return r;
						var a = e === t ? 0 : (i - t) / (e - t);
						if (!n.length) return n + (r - n) * a;
						var o, h = n.length,
							c = createTypedArray("float32", h);
						for (o = 0; o < h; o += 1) c[o] = n[o] + (r[o] - n[o]) * a;
						return c
					}

					function random(i, t) {
						if (t === void 0 && (i === void 0 ? (i = 0, t = 1) : (t = i, i = void 0)), t.length) {
							var e, n = t.length;
							i || (i = createTypedArray("float32", n));
							var r = createTypedArray("float32", n),
								s = BMMath.random();
							for (e = 0; e < n; e += 1) r[e] = i[e] + s * (t[e] - i[e]);
							return r
						}
						i === void 0 && (i = 0);
						var a = BMMath.random();
						return i + a * (t - i)
					}

					function createPath(i, t, e, n) {
						var r, s = i.length,
							a = shapePool.newElement();
						a.setPathData(!!n, s);
						var o = [0, 0],
							h, c;
						for (r = 0; r < s; r += 1) h = t && t[r] ? t[r] : o, c = e && e[r] ? e[r] : o, a.setTripleAt(i[r][0], i[r][1], c[0] + i[r][0], c[1] + i[r][1], h[0] + i[r][0], h[1] + i[r][1], r, !0);
						return a
					}

					function initiateExpression(elem, data, property) {
						function noOp(i) {
							return i
						}
						if (!elem.globalData.renderConfig.runExpressions) return noOp;
						var val = data.x,
							needsVelocity = /velocity(?![\w\d])/.test(val),
							_needsRandom = val.indexOf("random") !== -1,
							elemType = elem.data.ty,
							transform, $bm_transform, content, effect, thisProperty = property;
						thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
							get: function () {
								return thisProperty.v
							}
						}), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
						var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
							outPoint = elem.data.op / elem.comp.globalData.frameRate,
							width = elem.data.sw ? elem.data.sw : 0,
							height = elem.data.sh ? elem.data.sh : 0,
							name = elem.data.nm,
							loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
							numKeys = property.kf ? data.k.length : 0,
							active = !this.data || this.data.hd !== !0,
							wiggle = function i(t, e) {
								var n, r, s = this.pv.length ? this.pv.length : 1,
									a = createTypedArray("float32", s);
								t = 5;
								var o = Math.floor(time * t);
								for (n = 0, r = 0; n < o;) {
									for (r = 0; r < s; r += 1) a[r] += -e + e * 2 * BMMath.random();
									n += 1
								}
								var h = time * t,
									c = h - Math.floor(h),
									u = createTypedArray("float32", s);
								if (s > 1) {
									for (r = 0; r < s; r += 1) u[r] = this.pv[r] + a[r] + (-e + e * 2 * BMMath.random()) * c;
									return u
								}
								return this.pv + a[0] + (-e + e * 2 * BMMath.random()) * c
							}.bind(this);
						thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));

						function loopInDuration(i, t) {
							return loopIn(i, t, !0)
						}

						function loopOutDuration(i, t) {
							return loopOut(i, t, !0)
						}
						this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
						var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

						function lookAt(i, t) {
							var e = [t[0] - i[0], t[1] - i[1], t[2] - i[2]],
								n = Math.atan2(e[0], Math.sqrt(e[1] * e[1] + e[2] * e[2])) / degToRads,
								r = -Math.atan2(e[1], e[2]) / degToRads;
							return [r, n, 0]
						}

						function easeOut(i, t, e, n, r) {
							return applyEase(easeOutBez, i, t, e, n, r)
						}

						function easeIn(i, t, e, n, r) {
							return applyEase(easeInBez, i, t, e, n, r)
						}

						function ease(i, t, e, n, r) {
							return applyEase(easeInOutBez, i, t, e, n, r)
						}

						function applyEase(i, t, e, n, r, s) {
							r === void 0 ? (r = e, s = n) : t = (t - e) / (n - e), t > 1 ? t = 1 : t < 0 && (t = 0);
							var a = i(t);
							if ($bm_isInstanceOfArray(r)) {
								var o, h = r.length,
									c = createTypedArray("float32", h);
								for (o = 0; o < h; o += 1) c[o] = (s[o] - r[o]) * a + r[o];
								return c
							}
							return (s - r) * a + r
						}

						function nearestKey(i) {
							var t, e = data.k.length,
								n, r;
							if (!data.k.length || typeof data.k[0] == "number") n = 0, r = 0;
							else if (n = -1, i *= elem.comp.globalData.frameRate, i < data.k[0].t) n = 1, r = data.k[0].t;
							else {
								for (t = 0; t < e - 1; t += 1)
									if (i === data.k[t].t) {
										n = t + 1, r = data.k[t].t;
										break
									} else if (i > data.k[t].t && i < data.k[t + 1].t) {
									i - data.k[t].t > data.k[t + 1].t - i ? (n = t + 2, r = data.k[t + 1].t) : (n = t + 1, r = data.k[t].t);
									break
								}
								n === -1 && (n = t + 1, r = data.k[t].t)
							}
							var s = {};
							return s.index = n, s.time = r / elem.comp.globalData.frameRate, s
						}

						function key(i) {
							var t, e, n;
							if (!data.k.length || typeof data.k[0] == "number") throw new Error("The property has no keyframe at index " + i);
							i -= 1, t = {
								time: data.k[i].t / elem.comp.globalData.frameRate,
								value: []
							};
							var r = Object.prototype.hasOwnProperty.call(data.k[i], "s") ? data.k[i].s : data.k[i - 1].e;
							for (n = r.length, e = 0; e < n; e += 1) t[e] = r[e], t.value[e] = r[e];
							return t
						}

						function framesToTime(i, t) {
							return t || (t = elem.comp.globalData.frameRate), i / t
						}

						function timeToFrames(i, t) {
							return !i && i !== 0 && (i = time), t || (t = elem.comp.globalData.frameRate), i * t
						}

						function seedRandom(i) {
							BMMath.seedrandom(randSeed + i)
						}

						function sourceRectAtTime() {
							return elem.sourceRectAtTime()
						}

						function substring(i, t) {
							return typeof value == "string" ? t === void 0 ? value.substring(i) : value.substring(i, t) : ""
						}

						function substr(i, t) {
							return typeof value == "string" ? t === void 0 ? value.substr(i) : value.substr(i, t) : ""
						}

						function posterizeTime(i) {
							time = i === 0 ? 0 : Math.floor(time * i) / i, value = valueAtTime(time)
						}
						var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind,
							hasParent = !!(elem.hierarchy && elem.hierarchy.length),
							parent, randSeed = Math.floor(Math.random() * 1e6),
							globalData = elem.globalData;

						function executeExpression(i) {
							return value = i, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt)
						}
						return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression
					}
					return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob
				}(),
				Expressions = function () {
					var i = {};
					i.initExpressions = t, i.resetFrame = ExpressionManager.resetFrame;

					function t(e) {
						var n = 0,
							r = [];

						function s() {
							n += 1
						}

						function a() {
							n -= 1, n === 0 && h()
						}

						function o(c) {
							r.indexOf(c) === -1 && r.push(c)
						}

						function h() {
							var c, u = r.length;
							for (c = 0; c < u; c += 1) r[c].release();
							r.length = 0
						}
						e.renderer.compInterface = CompExpressionInterface(e.renderer), e.renderer.globalData.projectInterface.registerComposition(e.renderer), e.renderer.globalData.pushExpression = s, e.renderer.globalData.popExpression = a, e.renderer.globalData.registerExpressionProperty = o
					}
					return i
				}(),
				MaskManagerInterface = function () {
					function i(e, n) {
						this._mask = e, this._data = n
					}
					Object.defineProperty(i.prototype, "maskPath", {
						get: function () {
							return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
						}
					}), Object.defineProperty(i.prototype, "maskOpacity", {
						get: function () {
							return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100
						}
					});
					var t = function (n) {
						var r = createSizedArray(n.viewData.length),
							s, a = n.viewData.length;
						for (s = 0; s < a; s += 1) r[s] = new i(n.viewData[s], n.masksProperties[s]);
						var o = function (c) {
							for (s = 0; s < a;) {
								if (n.masksProperties[s].nm === c) return r[s];
								s += 1
							}
							return null
						};
						return o
					};
					return t
				}(),
				ExpressionPropertyInterface = function () {
					var i = {
							pv: 0,
							v: 0,
							mult: 1
						},
						t = {
							pv: [0, 0, 0],
							v: [0, 0, 0],
							mult: 1
						};

					function e(a, o, h) {
						Object.defineProperty(a, "velocity", {
							get: function () {
								return o.getVelocityAtTime(o.comp.currentFrame)
							}
						}), a.numKeys = o.keyframes ? o.keyframes.length : 0, a.key = function (c) {
							if (!a.numKeys) return 0;
							var u = "";
							"s" in o.keyframes[c - 1] ? u = o.keyframes[c - 1].s : "e" in o.keyframes[c - 2] ? u = o.keyframes[c - 2].e : u = o.keyframes[c - 2].s;
							var g = h === "unidimensional" ? new Number(u) : Object.assign({}, u);
							return g.time = o.keyframes[c - 1].t / o.elem.comp.globalData.frameRate, g.value = h === "unidimensional" ? u[0] : u, g
						}, a.valueAtTime = o.getValueAtTime, a.speedAtTime = o.getSpeedAtTime, a.velocityAtTime = o.getVelocityAtTime, a.propertyGroup = o.propertyGroup
					}

					function n(a) {
						(!a || !("pv" in a)) && (a = i);
						var o = 1 / a.mult,
							h = a.pv * o,
							c = new Number(h);
						return c.value = h, e(c, a, "unidimensional"),
							function () {
								return a.k && a.getValue(), h = a.v * o, c.value !== h && (c = new Number(h), c.value = h, e(c, a, "unidimensional")), c
							}
					}

					function r(a) {
						(!a || !("pv" in a)) && (a = t);
						var o = 1 / a.mult,
							h = a.data && a.data.l || a.pv.length,
							c = createTypedArray("float32", h),
							u = createTypedArray("float32", h);
						return c.value = u, e(c, a, "multidimensional"),
							function () {
								a.k && a.getValue();
								for (var g = 0; g < h; g += 1) u[g] = a.v[g] * o, c[g] = u[g];
								return c
							}
					}

					function s() {
						return i
					}
					return function (a) {
						return a ? a.propType === "unidimensional" ? n(a) : r(a) : s
					}
				}(),
				TransformExpressionInterface = function () {
					return function (i) {
						function t(a) {
							switch (a) {
								case "scale":
								case "Scale":
								case "ADBE Scale":
								case 6:
									return t.scale;
								case "rotation":
								case "Rotation":
								case "ADBE Rotation":
								case "ADBE Rotate Z":
								case 10:
									return t.rotation;
								case "ADBE Rotate X":
									return t.xRotation;
								case "ADBE Rotate Y":
									return t.yRotation;
								case "position":
								case "Position":
								case "ADBE Position":
								case 2:
									return t.position;
								case "ADBE Position_0":
									return t.xPosition;
								case "ADBE Position_1":
									return t.yPosition;
								case "ADBE Position_2":
									return t.zPosition;
								case "anchorPoint":
								case "AnchorPoint":
								case "Anchor Point":
								case "ADBE AnchorPoint":
								case 1:
									return t.anchorPoint;
								case "opacity":
								case "Opacity":
								case 11:
									return t.opacity;
								default:
									return null
							}
						}
						Object.defineProperty(t, "rotation", {
							get: ExpressionPropertyInterface(i.r || i.rz)
						}), Object.defineProperty(t, "zRotation", {
							get: ExpressionPropertyInterface(i.rz || i.r)
						}), Object.defineProperty(t, "xRotation", {
							get: ExpressionPropertyInterface(i.rx)
						}), Object.defineProperty(t, "yRotation", {
							get: ExpressionPropertyInterface(i.ry)
						}), Object.defineProperty(t, "scale", {
							get: ExpressionPropertyInterface(i.s)
						});
						var e, n, r, s;
						return i.p ? s = ExpressionPropertyInterface(i.p) : (e = ExpressionPropertyInterface(i.px), n = ExpressionPropertyInterface(i.py), i.pz && (r = ExpressionPropertyInterface(i.pz))), Object.defineProperty(t, "position", {
							get: function () {
								return i.p ? s() : [e(), n(), r ? r() : 0]
							}
						}), Object.defineProperty(t, "xPosition", {
							get: ExpressionPropertyInterface(i.px)
						}), Object.defineProperty(t, "yPosition", {
							get: ExpressionPropertyInterface(i.py)
						}), Object.defineProperty(t, "zPosition", {
							get: ExpressionPropertyInterface(i.pz)
						}), Object.defineProperty(t, "anchorPoint", {
							get: ExpressionPropertyInterface(i.a)
						}), Object.defineProperty(t, "opacity", {
							get: ExpressionPropertyInterface(i.o)
						}), Object.defineProperty(t, "skew", {
							get: ExpressionPropertyInterface(i.sk)
						}), Object.defineProperty(t, "skewAxis", {
							get: ExpressionPropertyInterface(i.sa)
						}), Object.defineProperty(t, "orientation", {
							get: ExpressionPropertyInterface(i.or)
						}), t
					}
				}(),
				LayerExpressionInterface = function () {
					function i(c) {
						var u = new Matrix;
						if (c !== void 0) {
							var g = this._elem.finalTransform.mProp.getValueAtTime(c);
							g.clone(u)
						} else {
							var p = this._elem.finalTransform.mProp;
							p.applyToMatrix(u)
						}
						return u
					}

					function t(c, u) {
						var g = this.getMatrix(u);
						return g.props[12] = 0, g.props[13] = 0, g.props[14] = 0, this.applyPoint(g, c)
					}

					function e(c, u) {
						var g = this.getMatrix(u);
						return this.applyPoint(g, c)
					}

					function n(c, u) {
						var g = this.getMatrix(u);
						return g.props[12] = 0, g.props[13] = 0, g.props[14] = 0, this.invertPoint(g, c)
					}

					function r(c, u) {
						var g = this.getMatrix(u);
						return this.invertPoint(g, c)
					}

					function s(c, u) {
						if (this._elem.hierarchy && this._elem.hierarchy.length) {
							var g, p = this._elem.hierarchy.length;
							for (g = 0; g < p; g += 1) this._elem.hierarchy[g].finalTransform.mProp.applyToMatrix(c)
						}
						return c.applyToPointArray(u[0], u[1], u[2] || 0)
					}

					function a(c, u) {
						if (this._elem.hierarchy && this._elem.hierarchy.length) {
							var g, p = this._elem.hierarchy.length;
							for (g = 0; g < p; g += 1) this._elem.hierarchy[g].finalTransform.mProp.applyToMatrix(c)
						}
						return c.inversePoint(u)
					}

					function o(c) {
						var u = new Matrix;
						if (u.reset(), this._elem.finalTransform.mProp.applyToMatrix(u), this._elem.hierarchy && this._elem.hierarchy.length) {
							var g, p = this._elem.hierarchy.length;
							for (g = 0; g < p; g += 1) this._elem.hierarchy[g].finalTransform.mProp.applyToMatrix(u);
							return u.inversePoint(c)
						}
						return u.inversePoint(c)
					}

					function h() {
						return [1, 1, 1, 1]
					}
					return function (c) {
						var u;

						function g(y) {
							_.mask = new MaskManagerInterface(y, c)
						}

						function p(y) {
							_.effect = y
						}

						function _(y) {
							switch (y) {
								case "ADBE Root Vectors Group":
								case "Contents":
								case 2:
									return _.shapeInterface;
								case 1:
								case 6:
								case "Transform":
								case "transform":
								case "ADBE Transform Group":
									return u;
								case 4:
								case "ADBE Effect Parade":
								case "effects":
								case "Effects":
									return _.effect;
								case "ADBE Text Properties":
									return _.textInterface;
								default:
									return null
							}
						}
						_.getMatrix = i, _.invertPoint = a, _.applyPoint = s, _.toWorld = e, _.toWorldVec = t, _.fromWorld = r, _.fromWorldVec = n, _.toComp = e, _.fromComp = o, _.sampleImage = h, _.sourceRectAtTime = c.sourceRectAtTime.bind(c), _._elem = c, u = TransformExpressionInterface(c.finalTransform.mProp);
						var b = getDescriptor(u, "anchorPoint");
						return Object.defineProperties(_, {
							hasParent: {
								get: function () {
									return c.hierarchy.length
								}
							},
							parent: {
								get: function () {
									return c.hierarchy[0].layerInterface
								}
							},
							rotation: getDescriptor(u, "rotation"),
							scale: getDescriptor(u, "scale"),
							position: getDescriptor(u, "position"),
							opacity: getDescriptor(u, "opacity"),
							anchorPoint: b,
							anchor_point: b,
							transform: {
								get: function () {
									return u
								}
							},
							active: {
								get: function () {
									return c.isInRange
								}
							}
						}), _.startTime = c.data.st, _.index = c.data.ind, _.source = c.data.refId, _.height = c.data.ty === 0 ? c.data.h : 100, _.width = c.data.ty === 0 ? c.data.w : 100, _.inPoint = c.data.ip / c.comp.globalData.frameRate, _.outPoint = c.data.op / c.comp.globalData.frameRate, _._name = c.data.nm, _.registerMaskInterface = g, _.registerEffectsInterface = p, _
					}
				}(),
				propertyGroupFactory = function () {
					return function (i, t) {
						return function (e) {
							return e = e === void 0 ? 1 : e, e <= 0 ? i : t(e - 1)
						}
					}
				}(),
				PropertyInterface = function () {
					return function (i, t) {
						var e = {
							_name: i
						};

						function n(r) {
							return r = r === void 0 ? 1 : r, r <= 0 ? e : t(r - 1)
						}
						return n
					}
				}(),
				EffectsExpressionInterface = function () {
					var i = {
						createEffectsInterface: t
					};

					function t(r, s) {
						if (r.effectsManager) {
							var a = [],
								o = r.data.ef,
								h, c = r.effectsManager.effectElements.length;
							for (h = 0; h < c; h += 1) a.push(e(o[h], r.effectsManager.effectElements[h], s, r));
							var u = r.data.ef || [],
								g = function (_) {
									for (h = 0, c = u.length; h < c;) {
										if (_ === u[h].nm || _ === u[h].mn || _ === u[h].ix) return a[h];
										h += 1
									}
									return null
								};
							return Object.defineProperty(g, "numProperties", {
								get: function () {
									return u.length
								}
							}), g
						}
						return null
					}

					function e(r, s, a, o) {
						function h(_) {
							for (var b = r.ef, y = 0, w = b.length; y < w;) {
								if (_ === b[y].nm || _ === b[y].mn || _ === b[y].ix) return b[y].ty === 5 ? u[y] : u[y]();
								y += 1
							}
							throw new Error
						}
						var c = propertyGroupFactory(h, a),
							u = [],
							g, p = r.ef.length;
						for (g = 0; g < p; g += 1) r.ef[g].ty === 5 ? u.push(e(r.ef[g], s.effectElements[g], s.effectElements[g].propertyGroup, o)) : u.push(n(s.effectElements[g], r.ef[g].ty, o, c));
						return r.mn === "ADBE Color Control" && Object.defineProperty(h, "color", {
							get: function () {
								return u[0]()
							}
						}), Object.defineProperties(h, {
							numProperties: {
								get: function () {
									return r.np
								}
							},
							_name: {
								value: r.nm
							},
							propertyGroup: {
								value: c
							}
						}), h.enabled = r.en !== 0, h.active = h.enabled, h
					}

					function n(r, s, a, o) {
						var h = ExpressionPropertyInterface(r.p);

						function c() {
							return s === 10 ? a.comp.compInterface(r.p.v) : h()
						}
						return r.p.setGroupProperty && r.p.setGroupProperty(PropertyInterface("", o)), c
					}
					return i
				}(),
				ShapePathInterface = function () {
					return function (t, e, n) {
						var r = e.sh;

						function s(o) {
							return o === "Shape" || o === "shape" || o === "Path" || o === "path" || o === "ADBE Vector Shape" || o === 2 ? s.path : null
						}
						var a = propertyGroupFactory(s, n);
						return r.setGroupProperty(PropertyInterface("Path", a)), Object.defineProperties(s, {
							path: {
								get: function () {
									return r.k && r.getValue(), r
								}
							},
							shape: {
								get: function () {
									return r.k && r.getValue(), r
								}
							},
							_name: {
								value: t.nm
							},
							ix: {
								value: t.ix
							},
							propertyIndex: {
								value: t.ix
							},
							mn: {
								value: t.mn
							},
							propertyGroup: {
								value: n
							}
						}), s
					}
				}(),
				ShapeExpressionInterface = function () {
					function i(b, y, w) {
						var f = [],
							S, x = b ? b.length : 0;
						for (S = 0; S < x; S += 1) b[S].ty === "gr" ? f.push(e(b[S], y[S], w)) : b[S].ty === "fl" ? f.push(n(b[S], y[S], w)) : b[S].ty === "st" ? f.push(a(b[S], y[S], w)) : b[S].ty === "tm" ? f.push(o(b[S], y[S], w)) : b[S].ty === "tr" || (b[S].ty === "el" ? f.push(c(b[S], y[S], w)) : b[S].ty === "sr" ? f.push(u(b[S], y[S], w)) : b[S].ty === "sh" ? f.push(ShapePathInterface(b[S], y[S], w)) : b[S].ty === "rc" ? f.push(g(b[S], y[S], w)) : b[S].ty === "rd" ? f.push(p(b[S], y[S], w)) : b[S].ty === "rp" ? f.push(_(b[S], y[S], w)) : b[S].ty === "gf" ? f.push(r(b[S], y[S], w)) : f.push(s(b[S], y[S], w)));
						return f
					}

					function t(b, y, w) {
						var f, S = function (T) {
							for (var I = 0, L = f.length; I < L;) {
								if (f[I]._name === T || f[I].mn === T || f[I].propertyIndex === T || f[I].ix === T || f[I].ind === T) return f[I];
								I += 1
							}
							return typeof T == "number" ? f[T - 1] : null
						};
						S.propertyGroup = propertyGroupFactory(S, w), f = i(b.it, y.it, S.propertyGroup), S.numProperties = f.length;
						var x = h(b.it[b.it.length - 1], y.it[y.it.length - 1], S.propertyGroup);
						return S.transform = x, S.propertyIndex = b.cix, S._name = b.nm, S
					}

					function e(b, y, w) {
						var f = function (T) {
							switch (T) {
								case "ADBE Vectors Group":
								case "Contents":
								case 2:
									return f.content;
								default:
									return f.transform
							}
						};
						f.propertyGroup = propertyGroupFactory(f, w);
						var S = t(b, y, f.propertyGroup),
							x = h(b.it[b.it.length - 1], y.it[y.it.length - 1], f.propertyGroup);
						return f.content = S, f.transform = x, Object.defineProperty(f, "_name", {
							get: function () {
								return b.nm
							}
						}), f.numProperties = b.np, f.propertyIndex = b.ix, f.nm = b.nm, f.mn = b.mn, f
					}

					function n(b, y, w) {
						function f(S) {
							return S === "Color" || S === "color" ? f.color : S === "Opacity" || S === "opacity" ? f.opacity : null
						}
						return Object.defineProperties(f, {
							color: {
								get: ExpressionPropertyInterface(y.c)
							},
							opacity: {
								get: ExpressionPropertyInterface(y.o)
							},
							_name: {
								value: b.nm
							},
							mn: {
								value: b.mn
							}
						}), y.c.setGroupProperty(PropertyInterface("Color", w)), y.o.setGroupProperty(PropertyInterface("Opacity", w)), f
					}

					function r(b, y, w) {
						function f(S) {
							return S === "Start Point" || S === "start point" ? f.startPoint : S === "End Point" || S === "end point" ? f.endPoint : S === "Opacity" || S === "opacity" ? f.opacity : null
						}
						return Object.defineProperties(f, {
							startPoint: {
								get: ExpressionPropertyInterface(y.s)
							},
							endPoint: {
								get: ExpressionPropertyInterface(y.e)
							},
							opacity: {
								get: ExpressionPropertyInterface(y.o)
							},
							type: {
								get: function () {
									return "a"
								}
							},
							_name: {
								value: b.nm
							},
							mn: {
								value: b.mn
							}
						}), y.s.setGroupProperty(PropertyInterface("Start Point", w)), y.e.setGroupProperty(PropertyInterface("End Point", w)), y.o.setGroupProperty(PropertyInterface("Opacity", w)), f
					}

					function s() {
						function b() {
							return null
						}
						return b
					}

					function a(b, y, w) {
						var f = propertyGroupFactory(L, w),
							S = propertyGroupFactory(I, f);

						function x(F) {
							Object.defineProperty(I, b.d[F].nm, {
								get: ExpressionPropertyInterface(y.d.dataProps[F].p)
							})
						}
						var M, T = b.d ? b.d.length : 0,
							I = {};
						for (M = 0; M < T; M += 1) x(M), y.d.dataProps[M].p.setGroupProperty(S);

						function L(F) {
							return F === "Color" || F === "color" ? L.color : F === "Opacity" || F === "opacity" ? L.opacity : F === "Stroke Width" || F === "stroke width" ? L.strokeWidth : null
						}
						return Object.defineProperties(L, {
							color: {
								get: ExpressionPropertyInterface(y.c)
							},
							opacity: {
								get: ExpressionPropertyInterface(y.o)
							},
							strokeWidth: {
								get: ExpressionPropertyInterface(y.w)
							},
							dash: {
								get: function () {
									return I
								}
							},
							_name: {
								value: b.nm
							},
							mn: {
								value: b.mn
							}
						}), y.c.setGroupProperty(PropertyInterface("Color", f)), y.o.setGroupProperty(PropertyInterface("Opacity", f)), y.w.setGroupProperty(PropertyInterface("Stroke Width", f)), L
					}

					function o(b, y, w) {
						function f(x) {
							return x === b.e.ix || x === "End" || x === "end" ? f.end : x === b.s.ix ? f.start : x === b.o.ix ? f.offset : null
						}
						var S = propertyGroupFactory(f, w);
						return f.propertyIndex = b.ix, y.s.setGroupProperty(PropertyInterface("Start", S)), y.e.setGroupProperty(PropertyInterface("End", S)), y.o.setGroupProperty(PropertyInterface("Offset", S)), f.propertyIndex = b.ix, f.propertyGroup = w, Object.defineProperties(f, {
							start: {
								get: ExpressionPropertyInterface(y.s)
							},
							end: {
								get: ExpressionPropertyInterface(y.e)
							},
							offset: {
								get: ExpressionPropertyInterface(y.o)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}

					function h(b, y, w) {
						function f(x) {
							return b.a.ix === x || x === "Anchor Point" ? f.anchorPoint : b.o.ix === x || x === "Opacity" ? f.opacity : b.p.ix === x || x === "Position" ? f.position : b.r.ix === x || x === "Rotation" || x === "ADBE Vector Rotation" ? f.rotation : b.s.ix === x || x === "Scale" ? f.scale : b.sk && b.sk.ix === x || x === "Skew" ? f.skew : b.sa && b.sa.ix === x || x === "Skew Axis" ? f.skewAxis : null
						}
						var S = propertyGroupFactory(f, w);
						return y.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", S)), y.transform.mProps.p.setGroupProperty(PropertyInterface("Position", S)), y.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", S)), y.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", S)), y.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", S)), y.transform.mProps.sk && (y.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", S)), y.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", S))), y.transform.op.setGroupProperty(PropertyInterface("Opacity", S)), Object.defineProperties(f, {
							opacity: {
								get: ExpressionPropertyInterface(y.transform.mProps.o)
							},
							position: {
								get: ExpressionPropertyInterface(y.transform.mProps.p)
							},
							anchorPoint: {
								get: ExpressionPropertyInterface(y.transform.mProps.a)
							},
							scale: {
								get: ExpressionPropertyInterface(y.transform.mProps.s)
							},
							rotation: {
								get: ExpressionPropertyInterface(y.transform.mProps.r)
							},
							skew: {
								get: ExpressionPropertyInterface(y.transform.mProps.sk)
							},
							skewAxis: {
								get: ExpressionPropertyInterface(y.transform.mProps.sa)
							},
							_name: {
								value: b.nm
							}
						}), f.ty = "tr", f.mn = b.mn, f.propertyGroup = w, f
					}

					function c(b, y, w) {
						function f(M) {
							return b.p.ix === M ? f.position : b.s.ix === M ? f.size : null
						}
						var S = propertyGroupFactory(f, w);
						f.propertyIndex = b.ix;
						var x = y.sh.ty === "tm" ? y.sh.prop : y.sh;
						return x.s.setGroupProperty(PropertyInterface("Size", S)), x.p.setGroupProperty(PropertyInterface("Position", S)), Object.defineProperties(f, {
							size: {
								get: ExpressionPropertyInterface(x.s)
							},
							position: {
								get: ExpressionPropertyInterface(x.p)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}

					function u(b, y, w) {
						function f(M) {
							return b.p.ix === M ? f.position : b.r.ix === M ? f.rotation : b.pt.ix === M ? f.points : b.or.ix === M || M === "ADBE Vector Star Outer Radius" ? f.outerRadius : b.os.ix === M ? f.outerRoundness : b.ir && (b.ir.ix === M || M === "ADBE Vector Star Inner Radius") ? f.innerRadius : b.is && b.is.ix === M ? f.innerRoundness : null
						}
						var S = propertyGroupFactory(f, w),
							x = y.sh.ty === "tm" ? y.sh.prop : y.sh;
						return f.propertyIndex = b.ix, x.or.setGroupProperty(PropertyInterface("Outer Radius", S)), x.os.setGroupProperty(PropertyInterface("Outer Roundness", S)), x.pt.setGroupProperty(PropertyInterface("Points", S)), x.p.setGroupProperty(PropertyInterface("Position", S)), x.r.setGroupProperty(PropertyInterface("Rotation", S)), b.ir && (x.ir.setGroupProperty(PropertyInterface("Inner Radius", S)), x.is.setGroupProperty(PropertyInterface("Inner Roundness", S))), Object.defineProperties(f, {
							position: {
								get: ExpressionPropertyInterface(x.p)
							},
							rotation: {
								get: ExpressionPropertyInterface(x.r)
							},
							points: {
								get: ExpressionPropertyInterface(x.pt)
							},
							outerRadius: {
								get: ExpressionPropertyInterface(x.or)
							},
							outerRoundness: {
								get: ExpressionPropertyInterface(x.os)
							},
							innerRadius: {
								get: ExpressionPropertyInterface(x.ir)
							},
							innerRoundness: {
								get: ExpressionPropertyInterface(x.is)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}

					function g(b, y, w) {
						function f(M) {
							return b.p.ix === M ? f.position : b.r.ix === M ? f.roundness : b.s.ix === M || M === "Size" || M === "ADBE Vector Rect Size" ? f.size : null
						}
						var S = propertyGroupFactory(f, w),
							x = y.sh.ty === "tm" ? y.sh.prop : y.sh;
						return f.propertyIndex = b.ix, x.p.setGroupProperty(PropertyInterface("Position", S)), x.s.setGroupProperty(PropertyInterface("Size", S)), x.r.setGroupProperty(PropertyInterface("Rotation", S)), Object.defineProperties(f, {
							position: {
								get: ExpressionPropertyInterface(x.p)
							},
							roundness: {
								get: ExpressionPropertyInterface(x.r)
							},
							size: {
								get: ExpressionPropertyInterface(x.s)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}

					function p(b, y, w) {
						function f(M) {
							return b.r.ix === M || M === "Round Corners 1" ? f.radius : null
						}
						var S = propertyGroupFactory(f, w),
							x = y;
						return f.propertyIndex = b.ix, x.rd.setGroupProperty(PropertyInterface("Radius", S)), Object.defineProperties(f, {
							radius: {
								get: ExpressionPropertyInterface(x.rd)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}

					function _(b, y, w) {
						function f(M) {
							return b.c.ix === M || M === "Copies" ? f.copies : b.o.ix === M || M === "Offset" ? f.offset : null
						}
						var S = propertyGroupFactory(f, w),
							x = y;
						return f.propertyIndex = b.ix, x.c.setGroupProperty(PropertyInterface("Copies", S)), x.o.setGroupProperty(PropertyInterface("Offset", S)), Object.defineProperties(f, {
							copies: {
								get: ExpressionPropertyInterface(x.c)
							},
							offset: {
								get: ExpressionPropertyInterface(x.o)
							},
							_name: {
								value: b.nm
							}
						}), f.mn = b.mn, f
					}
					return function (b, y, w) {
						var f;

						function S(M) {
							if (typeof M == "number") return M = M === void 0 ? 1 : M, M === 0 ? w : f[M - 1];
							for (var T = 0, I = f.length; T < I;) {
								if (f[T]._name === M) return f[T];
								T += 1
							}
							return null
						}

						function x() {
							return w
						}
						return S.propertyGroup = propertyGroupFactory(S, x), f = i(b, y, S.propertyGroup), S.numProperties = f.length, S._name = "Contents", S
					}
				}(),
				TextExpressionInterface = function () {
					return function (i) {
						var t;

						function e(n) {
							switch (n) {
								case "ADBE Text Document":
									return e.sourceText;
								default:
									return null
							}
						}
						return Object.defineProperty(e, "sourceText", {
							get: function () {
								i.textProperty.getValue();
								var r = i.textProperty.currentData.t;
								return (!t || r !== t.value) && (t = new String(r), t.value = r || new String(r), Object.defineProperty(t, "style", {
									get: function () {
										return {
											fillColor: i.textProperty.currentData.fc
										}
									}
								})), t
							}
						}), e
					}
				}();

			function _typeof(i) {
				"@babel/helpers - typeof";
				return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function (e) {
					return typeof e
				} : _typeof = function (e) {
					return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				}, _typeof(i)
			}
			var FootageInterface = function () {
					var i = function (n) {
							var r = "",
								s = n.getFootageData();

							function a() {
								return r = "", s = n.getFootageData(), o
							}

							function o(h) {
								if (s[h]) return r = h, s = s[h], _typeof(s) === "object" ? o : s;
								var c = h.indexOf(r);
								if (c !== -1) {
									var u = parseInt(h.substr(c + r.length), 10);
									return s = s[u], _typeof(s) === "object" ? o : s
								}
								return ""
							}
							return a
						},
						t = function (n) {
							function r(s) {
								return s === "Outline" ? r.outlineInterface() : null
							}
							return r._name = "Outline", r.outlineInterface = i(n), r
						};
					return function (e) {
						function n(r) {
							return r === "Data" ? n.dataInterface : null
						}
						return n._name = "Data", n.dataInterface = t(e), n
					}
				}(),
				interfaces = {
					layer: LayerExpressionInterface,
					effects: EffectsExpressionInterface,
					comp: CompExpressionInterface,
					shape: ShapeExpressionInterface,
					text: TextExpressionInterface,
					footage: FootageInterface
				};

			function getInterface(i) {
				return interfaces[i] || null
			}
			var expressionHelpers = function () {
				function i(a, o, h) {
					o.x && (h.k = !0, h.x = !0, h.initiateExpression = ExpressionManager.initiateExpression, h.effectsSequence.push(h.initiateExpression(a, o, h).bind(h)))
				}

				function t(a) {
					return a *= this.elem.globalData.frameRate, a -= this.offsetTime, a !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < a ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(a, this._cachingAtTime), this._cachingAtTime.lastFrame = a), this._cachingAtTime.value
				}

				function e(a) {
					var o = -.01,
						h = this.getValueAtTime(a),
						c = this.getValueAtTime(a + o),
						u = 0;
					if (h.length) {
						var g;
						for (g = 0; g < h.length; g += 1) u += Math.pow(c[g] - h[g], 2);
						u = Math.sqrt(u) * 100
					} else u = 0;
					return u
				}

				function n(a) {
					if (this.vel !== void 0) return this.vel;
					var o = -.001,
						h = this.getValueAtTime(a),
						c = this.getValueAtTime(a + o),
						u;
					if (h.length) {
						u = createTypedArray("float32", h.length);
						var g;
						for (g = 0; g < h.length; g += 1) u[g] = (c[g] - h[g]) / o
					} else u = (c - h) / o;
					return u
				}

				function r() {
					return this.pv
				}

				function s(a) {
					this.propertyGroup = a
				}
				return {
					searchExpressions: i,
					getSpeedAtTime: e,
					getVelocityAtTime: n,
					getValueAtTime: t,
					getStaticValueAtTime: r,
					setGroupProperty: s
				}
			}();

			function addPropertyDecorator() {
				function i(p, _, b) {
					if (!this.k || !this.keyframes) return this.pv;
					p = p ? p.toLowerCase() : "";
					var y = this.comp.renderedFrame,
						w = this.keyframes,
						f = w[w.length - 1].t;
					if (y <= f) return this.pv;
					var S, x;
					b ? (_ ? S = Math.abs(f - this.elem.comp.globalData.frameRate * _) : S = Math.max(0, f - this.elem.data.ip), x = f - S) : ((!_ || _ > w.length - 1) && (_ = w.length - 1), x = w[w.length - 1 - _].t, S = f - x);
					var M, T, I;
					if (p === "pingpong") {
						var L = Math.floor((y - x) / S);
						if (L % 2 !== 0) return this.getValueAtTime((S - (y - x) % S + x) / this.comp.globalData.frameRate, 0)
					} else if (p === "offset") {
						var F = this.getValueAtTime(x / this.comp.globalData.frameRate, 0),
							k = this.getValueAtTime(f / this.comp.globalData.frameRate, 0),
							G = this.getValueAtTime(((y - x) % S + x) / this.comp.globalData.frameRate, 0),
							j = Math.floor((y - x) / S);
						if (this.pv.length) {
							for (I = new Array(F.length), T = I.length, M = 0; M < T; M += 1) I[M] = (k[M] - F[M]) * j + G[M];
							return I
						}
						return (k - F) * j + G
					} else if (p === "continue") {
						var U = this.getValueAtTime(f / this.comp.globalData.frameRate, 0),
							z = this.getValueAtTime((f - .001) / this.comp.globalData.frameRate, 0);
						if (this.pv.length) {
							for (I = new Array(U.length), T = I.length, M = 0; M < T; M += 1) I[M] = U[M] + (U[M] - z[M]) * ((y - f) / this.comp.globalData.frameRate) / 5e-4;
							return I
						}
						return U + (U - z) * ((y - f) / .001)
					}
					return this.getValueAtTime(((y - x) % S + x) / this.comp.globalData.frameRate, 0)
				}

				function t(p, _, b) {
					if (!this.k) return this.pv;
					p = p ? p.toLowerCase() : "";
					var y = this.comp.renderedFrame,
						w = this.keyframes,
						f = w[0].t;
					if (y >= f) return this.pv;
					var S, x;
					b ? (_ ? S = Math.abs(this.elem.comp.globalData.frameRate * _) : S = Math.max(0, this.elem.data.op - f), x = f + S) : ((!_ || _ > w.length - 1) && (_ = w.length - 1), x = w[_].t, S = x - f);
					var M, T, I;
					if (p === "pingpong") {
						var L = Math.floor((f - y) / S);
						if (L % 2 === 0) return this.getValueAtTime(((f - y) % S + f) / this.comp.globalData.frameRate, 0)
					} else if (p === "offset") {
						var F = this.getValueAtTime(f / this.comp.globalData.frameRate, 0),
							k = this.getValueAtTime(x / this.comp.globalData.frameRate, 0),
							G = this.getValueAtTime((S - (f - y) % S + f) / this.comp.globalData.frameRate, 0),
							j = Math.floor((f - y) / S) + 1;
						if (this.pv.length) {
							for (I = new Array(F.length), T = I.length, M = 0; M < T; M += 1) I[M] = G[M] - (k[M] - F[M]) * j;
							return I
						}
						return G - (k - F) * j
					} else if (p === "continue") {
						var U = this.getValueAtTime(f / this.comp.globalData.frameRate, 0),
							z = this.getValueAtTime((f + .001) / this.comp.globalData.frameRate, 0);
						if (this.pv.length) {
							for (I = new Array(U.length), T = I.length, M = 0; M < T; M += 1) I[M] = U[M] + (U[M] - z[M]) * (f - y) / .001;
							return I
						}
						return U + (U - z) * (f - y) / .001
					}
					return this.getValueAtTime((S - ((f - y) % S + f)) / this.comp.globalData.frameRate, 0)
				}

				function e(p, _) {
					if (!this.k) return this.pv;
					if (p = (p || .4) * .5, _ = Math.floor(_ || 5), _ <= 1) return this.pv;
					var b = this.comp.renderedFrame / this.comp.globalData.frameRate,
						y = b - p,
						w = b + p,
						f = _ > 1 ? (w - y) / (_ - 1) : 1,
						S = 0,
						x = 0,
						M;
					this.pv.length ? M = createTypedArray("float32", this.pv.length) : M = 0;
					for (var T; S < _;) {
						if (T = this.getValueAtTime(y + S * f), this.pv.length)
							for (x = 0; x < this.pv.length; x += 1) M[x] += T[x];
						else M += T;
						S += 1
					}
					if (this.pv.length)
						for (x = 0; x < this.pv.length; x += 1) M[x] /= _;
					else M /= _;
					return M
				}

				function n(p) {
					this._transformCachingAtTime || (this._transformCachingAtTime = {
						v: new Matrix
					});
					var _ = this._transformCachingAtTime.v;
					if (_.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
						var b = this.a.getValueAtTime(p);
						_.translate(-b[0] * this.a.mult, -b[1] * this.a.mult, b[2] * this.a.mult)
					}
					if (this.appliedTransformations < 2) {
						var y = this.s.getValueAtTime(p);
						_.scale(y[0] * this.s.mult, y[1] * this.s.mult, y[2] * this.s.mult)
					}
					if (this.sk && this.appliedTransformations < 3) {
						var w = this.sk.getValueAtTime(p),
							f = this.sa.getValueAtTime(p);
						_.skewFromAxis(-w * this.sk.mult, f * this.sa.mult)
					}
					if (this.r && this.appliedTransformations < 4) {
						var S = this.r.getValueAtTime(p);
						_.rotate(-S * this.r.mult)
					} else if (!this.r && this.appliedTransformations < 4) {
						var x = this.rz.getValueAtTime(p),
							M = this.ry.getValueAtTime(p),
							T = this.rx.getValueAtTime(p),
							I = this.or.getValueAtTime(p);
						_.rotateZ(-x * this.rz.mult).rotateY(M * this.ry.mult).rotateX(T * this.rx.mult).rotateZ(-I[2] * this.or.mult).rotateY(I[1] * this.or.mult).rotateX(I[0] * this.or.mult)
					}
					if (this.data.p && this.data.p.s) {
						var L = this.px.getValueAtTime(p),
							F = this.py.getValueAtTime(p);
						if (this.data.p.z) {
							var k = this.pz.getValueAtTime(p);
							_.translate(L * this.px.mult, F * this.py.mult, -k * this.pz.mult)
						} else _.translate(L * this.px.mult, F * this.py.mult, 0)
					} else {
						var G = this.p.getValueAtTime(p);
						_.translate(G[0] * this.p.mult, G[1] * this.p.mult, -G[2] * this.p.mult)
					}
					return _
				}

				function r() {
					return this.v.clone(new Matrix)
				}
				var s = TransformPropertyFactory.getTransformProperty;
				TransformPropertyFactory.getTransformProperty = function (p, _, b) {
					var y = s(p, _, b);
					return y.dynamicProperties.length ? y.getValueAtTime = n.bind(y) : y.getValueAtTime = r.bind(y), y.setGroupProperty = expressionHelpers.setGroupProperty, y
				};
				var a = PropertyFactory.getProp;
				PropertyFactory.getProp = function (p, _, b, y, w) {
					var f = a(p, _, b, y, w);
					f.kf ? f.getValueAtTime = expressionHelpers.getValueAtTime.bind(f) : f.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(f), f.setGroupProperty = expressionHelpers.setGroupProperty, f.loopOut = i, f.loopIn = t, f.smooth = e, f.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(f), f.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(f), f.numKeys = _.a === 1 ? _.k.length : 0, f.propertyIndex = _.ix;
					var S = 0;
					return b !== 0 && (S = createTypedArray("float32", _.a === 1 ? _.k[0].s.length : _.k.length)), f._cachingAtTime = {
						lastFrame: initialDefaultFrame,
						lastIndex: 0,
						value: S
					}, expressionHelpers.searchExpressions(p, _, f), f.k && w.addDynamicProperty(f), f
				};

				function o(p) {
					return this._cachingAtTime || (this._cachingAtTime = {
						shapeValue: shapePool.clone(this.pv),
						lastIndex: 0,
						lastTime: initialDefaultFrame
					}), p *= this.elem.globalData.frameRate, p -= this.offsetTime, p !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < p ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = p, this.interpolateShape(p, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
				}
				var h = ShapePropertyFactory.getConstructorFunction(),
					c = ShapePropertyFactory.getKeyframedConstructorFunction();

				function u() {}
				u.prototype = {
					vertices: function (_, b) {
						this.k && this.getValue();
						var y = this.v;
						b !== void 0 && (y = this.getValueAtTime(b, 0));
						var w, f = y._length,
							S = y[_],
							x = y.v,
							M = createSizedArray(f);
						for (w = 0; w < f; w += 1) _ === "i" || _ === "o" ? M[w] = [S[w][0] - x[w][0], S[w][1] - x[w][1]] : M[w] = [S[w][0], S[w][1]];
						return M
					},
					points: function (_) {
						return this.vertices("v", _)
					},
					inTangents: function (_) {
						return this.vertices("i", _)
					},
					outTangents: function (_) {
						return this.vertices("o", _)
					},
					isClosed: function () {
						return this.v.c
					},
					pointOnPath: function (_, b) {
						var y = this.v;
						b !== void 0 && (y = this.getValueAtTime(b, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(y));
						for (var w = this._segmentsLength, f = w.lengths, S = w.totalLength * _, x = 0, M = f.length, T = 0, I; x < M;) {
							if (T + f[x].addedLength > S) {
								var L = x,
									F = y.c && x === M - 1 ? 0 : x + 1,
									k = (S - T) / f[x].addedLength;
								I = bez.getPointInSegment(y.v[L], y.v[F], y.o[L], y.i[F], k, f[x]);
								break
							} else T += f[x].addedLength;
							x += 1
						}
						return I || (I = y.c ? [y.v[0][0], y.v[0][1]] : [y.v[y._length - 1][0], y.v[y._length - 1][1]]), I
					},
					vectorOnPath: function (_, b, y) {
						_ == 1 ? _ = this.v.c : _ == 0 && (_ = .999);
						var w = this.pointOnPath(_, b),
							f = this.pointOnPath(_ + .001, b),
							S = f[0] - w[0],
							x = f[1] - w[1],
							M = Math.sqrt(Math.pow(S, 2) + Math.pow(x, 2));
						if (M === 0) return [0, 0];
						var T = y === "tangent" ? [S / M, x / M] : [-x / M, S / M];
						return T
					},
					tangentOnPath: function (_, b) {
						return this.vectorOnPath(_, b, "tangent")
					},
					normalOnPath: function (_, b) {
						return this.vectorOnPath(_, b, "normal")
					},
					setGroupProperty: expressionHelpers.setGroupProperty,
					getValueAtTime: expressionHelpers.getStaticValueAtTime
				}, extendPrototype([u], h), extendPrototype([u], c), c.prototype.getValueAtTime = o, c.prototype.initiateExpression = ExpressionManager.initiateExpression;
				var g = ShapePropertyFactory.getShapeProp;
				ShapePropertyFactory.getShapeProp = function (p, _, b, y, w) {
					var f = g(p, _, b, y, w);
					return f.propertyIndex = _.ix, f.lock = !1, b === 3 ? expressionHelpers.searchExpressions(p, _.pt, f) : b === 4 && expressionHelpers.searchExpressions(p, _.ks, f), f.k && p.addDynamicProperty(f), f
				}
			}

			function initialize$1() {
				addPropertyDecorator()
			}

			function addDecorator() {
				function i() {
					return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
				}
				TextProperty.prototype.getExpressionValue = function (t, e) {
					var n = this.calculateExpression(e);
					if (t.t !== n) {
						var r = {};
						return this.copyData(r, t), r.t = n.toString(), r.__complete = !1, r
					}
					return t
				}, TextProperty.prototype.searchProperty = function () {
					var t = this.searchKeyframes(),
						e = this.searchExpressions();
					return this.kf = t || e, this.kf
				}, TextProperty.prototype.searchExpressions = i
			}

			function initialize() {
				addDecorator()
			}

			function SVGComposableEffect() {}
			SVGComposableEffect.prototype = {
				createMergeNode: function i(t, e) {
					var n = createNS("feMerge");
					n.setAttribute("result", t);
					var r, s;
					for (s = 0; s < e.length; s += 1) r = createNS("feMergeNode"), r.setAttribute("in", e[s]), n.appendChild(r), n.appendChild(r);
					return n
				}
			};
			var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";

			function SVGTintFilter(i, t, e, n, r) {
				this.filterManager = t;
				var s = createNS("feColorMatrix");
				s.setAttribute("type", "matrix"), s.setAttribute("color-interpolation-filters", "linearRGB"), s.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = s, s.setAttribute("result", n + "_tint_1"), i.appendChild(s), s = createNS("feColorMatrix"), s.setAttribute("type", "matrix"), s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), s.setAttribute("result", n + "_tint_2"), i.appendChild(s), this.matrixFilter = s;
				var a = this.createMergeNode(n, [r, n + "_tint_1", n + "_tint_2"]);
				i.appendChild(a)
			}
			extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					var t = this.filterManager.effectElements[0].p.v,
						e = this.filterManager.effectElements[1].p.v,
						n = this.filterManager.effectElements[2].p.v / 100;
					this.linearFilter.setAttribute("values", linearFilterValue + " " + n + " 0"), this.matrixFilter.setAttribute("values", e[0] - t[0] + " 0 0 0 " + t[0] + " " + (e[1] - t[1]) + " 0 0 0 " + t[1] + " " + (e[2] - t[2]) + " 0 0 0 " + t[2] + " 0 0 0 1 0")
				}
			};

			function SVGFillFilter(i, t, e, n) {
				this.filterManager = t;
				var r = createNS("feColorMatrix");
				r.setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "sRGB"), r.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), r.setAttribute("result", n), i.appendChild(r), this.matrixFilter = r
			}
			SVGFillFilter.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					var t = this.filterManager.effectElements[2].p.v,
						e = this.filterManager.effectElements[6].p.v;
					this.matrixFilter.setAttribute("values", "0 0 0 0 " + t[0] + " 0 0 0 0 " + t[1] + " 0 0 0 0 " + t[2] + " 0 0 0 " + e + " 0")
				}
			};

			function SVGStrokeEffect(i, t, e) {
				this.initialized = !1, this.filterManager = t, this.elem = e, this.paths = []
			}
			SVGStrokeEffect.prototype.initialize = function () {
				var i = this.elem.layerElement.children || this.elem.layerElement.childNodes,
					t, e, n, r;
				for (this.filterManager.effectElements[1].p.v === 1 ? (r = this.elem.maskManager.masksProperties.length, n = 0) : (n = this.filterManager.effectElements[0].p.v - 1, r = n + 1), e = createNS("g"), e.setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1), n; n < r; n += 1) t = createNS("path"), e.appendChild(t), this.paths.push({
					p: t,
					m: n
				});
				if (this.filterManager.effectElements[10].p.v === 3) {
					var s = createNS("mask"),
						a = createElementID();
					s.setAttribute("id", a), s.setAttribute("mask-type", "alpha"), s.appendChild(e), this.elem.globalData.defs.appendChild(s);
					var o = createNS("g");
					for (o.setAttribute("mask", "url(" + getLocationHref() + "#" + a + ")"); i[0];) o.appendChild(i[0]);
					this.elem.layerElement.appendChild(o), this.masker = s, e.setAttribute("stroke", "#fff")
				} else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
					if (this.filterManager.effectElements[10].p.v === 2)
						for (i = this.elem.layerElement.children || this.elem.layerElement.childNodes; i.length;) this.elem.layerElement.removeChild(i[0]);
					this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff")
				}
				this.initialized = !0, this.pathMasker = e
			}, SVGStrokeEffect.prototype.renderFrame = function (i) {
				this.initialized || this.initialize();
				var t, e = this.paths.length,
					n, r;
				for (t = 0; t < e; t += 1)
					if (this.paths[t].m !== -1 && (n = this.elem.maskManager.viewData[this.paths[t].m], r = this.paths[t].p, (i || this.filterManager._mdf || n.prop._mdf) && r.setAttribute("d", n.lastPath), i || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || n.prop._mdf)) {
						var s;
						if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
							var a = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01,
								o = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01,
								h = r.getTotalLength();
							s = "0 0 0 " + h * a + " ";
							var c = h * (o - a),
								u = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01,
								g = Math.floor(c / u),
								p;
							for (p = 0; p < g; p += 1) s += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
							s += "0 " + h * 10 + " 0 0"
						} else s = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
						r.setAttribute("stroke-dasharray", s)
					} if ((i || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (i || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (i || this.filterManager.effectElements[3].p._mdf)) {
					var _ = this.filterManager.effectElements[3].p.v;
					this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(_[0] * 255) + "," + bmFloor(_[1] * 255) + "," + bmFloor(_[2] * 255) + ")")
				}
			};

			function SVGTritoneFilter(i, t, e, n) {
				this.filterManager = t;
				var r = createNS("feColorMatrix");
				r.setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "linearRGB"), r.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), i.appendChild(r);
				var s = createNS("feComponentTransfer");
				s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("result", n), this.matrixFilter = s;
				var a = createNS("feFuncR");
				a.setAttribute("type", "table"), s.appendChild(a), this.feFuncR = a;
				var o = createNS("feFuncG");
				o.setAttribute("type", "table"), s.appendChild(o), this.feFuncG = o;
				var h = createNS("feFuncB");
				h.setAttribute("type", "table"), s.appendChild(h), this.feFuncB = h, i.appendChild(s)
			}
			SVGTritoneFilter.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					var t = this.filterManager.effectElements[0].p.v,
						e = this.filterManager.effectElements[1].p.v,
						n = this.filterManager.effectElements[2].p.v,
						r = n[0] + " " + e[0] + " " + t[0],
						s = n[1] + " " + e[1] + " " + t[1],
						a = n[2] + " " + e[2] + " " + t[2];
					this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", s), this.feFuncB.setAttribute("tableValues", a)
				}
			};

			function SVGProLevelsFilter(i, t, e, n) {
				this.filterManager = t;
				var r = this.filterManager.effectElements,
					s = createNS("feComponentTransfer");
				(r[10].p.k || r[10].p.v !== 0 || r[11].p.k || r[11].p.v !== 1 || r[12].p.k || r[12].p.v !== 1 || r[13].p.k || r[13].p.v !== 0 || r[14].p.k || r[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", s)), (r[17].p.k || r[17].p.v !== 0 || r[18].p.k || r[18].p.v !== 1 || r[19].p.k || r[19].p.v !== 1 || r[20].p.k || r[20].p.v !== 0 || r[21].p.k || r[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", s)), (r[24].p.k || r[24].p.v !== 0 || r[25].p.k || r[25].p.v !== 1 || r[26].p.k || r[26].p.v !== 1 || r[27].p.k || r[27].p.v !== 0 || r[28].p.k || r[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", s)), (r[31].p.k || r[31].p.v !== 0 || r[32].p.k || r[32].p.v !== 1 || r[33].p.k || r[33].p.v !== 1 || r[34].p.k || r[34].p.v !== 0 || r[35].p.k || r[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", s)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (s.setAttribute("color-interpolation-filters", "sRGB"), i.appendChild(s)), (r[3].p.k || r[3].p.v !== 0 || r[4].p.k || r[4].p.v !== 1 || r[5].p.k || r[5].p.v !== 1 || r[6].p.k || r[6].p.v !== 0 || r[7].p.k || r[7].p.v !== 1) && (s = createNS("feComponentTransfer"), s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("result", n), i.appendChild(s), this.feFuncRComposed = this.createFeFunc("feFuncR", s), this.feFuncGComposed = this.createFeFunc("feFuncG", s), this.feFuncBComposed = this.createFeFunc("feFuncB", s))
			}
			SVGProLevelsFilter.prototype.createFeFunc = function (i, t) {
				var e = createNS(i);
				return e.setAttribute("type", "table"), t.appendChild(e), e
			}, SVGProLevelsFilter.prototype.getTableValue = function (i, t, e, n, r) {
				for (var s = 0, a = 256, o, h = Math.min(i, t), c = Math.max(i, t), u = Array.call(null, {
						length: a
					}), g, p = 0, _ = r - n, b = t - i; s <= 256;) o = s / 256, o <= h ? g = b < 0 ? r : n : o >= c ? g = b < 0 ? n : r : g = n + _ * Math.pow((o - i) / b, 1 / e), u[p] = g, p += 1, s += 256 / (a - 1);
				return u.join(" ")
			}, SVGProLevelsFilter.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					var t, e = this.filterManager.effectElements;
					this.feFuncRComposed && (i || e[3].p._mdf || e[4].p._mdf || e[5].p._mdf || e[6].p._mdf || e[7].p._mdf) && (t = this.getTableValue(e[3].p.v, e[4].p.v, e[5].p.v, e[6].p.v, e[7].p.v), this.feFuncRComposed.setAttribute("tableValues", t), this.feFuncGComposed.setAttribute("tableValues", t), this.feFuncBComposed.setAttribute("tableValues", t)), this.feFuncR && (i || e[10].p._mdf || e[11].p._mdf || e[12].p._mdf || e[13].p._mdf || e[14].p._mdf) && (t = this.getTableValue(e[10].p.v, e[11].p.v, e[12].p.v, e[13].p.v, e[14].p.v), this.feFuncR.setAttribute("tableValues", t)), this.feFuncG && (i || e[17].p._mdf || e[18].p._mdf || e[19].p._mdf || e[20].p._mdf || e[21].p._mdf) && (t = this.getTableValue(e[17].p.v, e[18].p.v, e[19].p.v, e[20].p.v, e[21].p.v), this.feFuncG.setAttribute("tableValues", t)), this.feFuncB && (i || e[24].p._mdf || e[25].p._mdf || e[26].p._mdf || e[27].p._mdf || e[28].p._mdf) && (t = this.getTableValue(e[24].p.v, e[25].p.v, e[26].p.v, e[27].p.v, e[28].p.v), this.feFuncB.setAttribute("tableValues", t)), this.feFuncA && (i || e[31].p._mdf || e[32].p._mdf || e[33].p._mdf || e[34].p._mdf || e[35].p._mdf) && (t = this.getTableValue(e[31].p.v, e[32].p.v, e[33].p.v, e[34].p.v, e[35].p.v), this.feFuncA.setAttribute("tableValues", t))
				}
			};

			function SVGDropShadowEffect(i, t, e, n, r) {
				var s = t.container.globalData.renderConfig.filterSize,
					a = t.data.fs || s;
				i.setAttribute("x", a.x || s.x), i.setAttribute("y", a.y || s.y), i.setAttribute("width", a.width || s.width), i.setAttribute("height", a.height || s.height), this.filterManager = t;
				var o = createNS("feGaussianBlur");
				o.setAttribute("in", "SourceAlpha"), o.setAttribute("result", n + "_drop_shadow_1"), o.setAttribute("stdDeviation", "0"), this.feGaussianBlur = o, i.appendChild(o);
				var h = createNS("feOffset");
				h.setAttribute("dx", "25"), h.setAttribute("dy", "0"), h.setAttribute("in", n + "_drop_shadow_1"), h.setAttribute("result", n + "_drop_shadow_2"), this.feOffset = h, i.appendChild(h);
				var c = createNS("feFlood");
				c.setAttribute("flood-color", "#00ff00"), c.setAttribute("flood-opacity", "1"), c.setAttribute("result", n + "_drop_shadow_3"), this.feFlood = c, i.appendChild(c);
				var u = createNS("feComposite");
				u.setAttribute("in", n + "_drop_shadow_3"), u.setAttribute("in2", n + "_drop_shadow_2"), u.setAttribute("operator", "in"), u.setAttribute("result", n + "_drop_shadow_4"), i.appendChild(u);
				var g = this.createMergeNode(n, [n + "_drop_shadow_4", r]);
				i.appendChild(g)
			}
			extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					if ((i || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), i || this.filterManager.effectElements[0].p._mdf) {
						var t = this.filterManager.effectElements[0].p.v;
						this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(t[0] * 255), Math.round(t[1] * 255), Math.round(t[2] * 255)))
					}
					if ((i || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), i || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
						var e = this.filterManager.effectElements[3].p.v,
							n = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
							r = e * Math.cos(n),
							s = e * Math.sin(n);
						this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", s)
					}
				}
			};
			var _svgMatteSymbols = [];

			function SVGMatte3Effect(i, t, e) {
				this.initialized = !1, this.filterManager = t, this.filterElem = i, this.elem = e, e.matteElement = createNS("g"), e.matteElement.appendChild(e.layerElement), e.matteElement.appendChild(e.transformedElement), e.baseElement = e.matteElement
			}
			SVGMatte3Effect.prototype.findSymbol = function (i) {
				for (var t = 0, e = _svgMatteSymbols.length; t < e;) {
					if (_svgMatteSymbols[t] === i) return _svgMatteSymbols[t];
					t += 1
				}
				return null
			}, SVGMatte3Effect.prototype.replaceInParent = function (i, t) {
				var e = i.layerElement.parentNode;
				if (e) {
					for (var n = e.children, r = 0, s = n.length; r < s && n[r] !== i.layerElement;) r += 1;
					var a;
					r <= s - 2 && (a = n[r + 1]);
					var o = createNS("use");
					o.setAttribute("href", "#" + t), a ? e.insertBefore(o, a) : e.appendChild(o)
				}
			}, SVGMatte3Effect.prototype.setElementAsMask = function (i, t) {
				if (!this.findSymbol(t)) {
					var e = createElementID(),
						n = createNS("mask");
					n.setAttribute("id", t.layerId), n.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(t);
					var r = i.globalData.defs;
					r.appendChild(n);
					var s = createNS("symbol");
					s.setAttribute("id", e), this.replaceInParent(t, e), s.appendChild(t.layerElement), r.appendChild(s);
					var a = createNS("use");
					a.setAttribute("href", "#" + e), n.appendChild(a), t.data.hd = !1, t.show()
				}
				i.setMatte(t.layerId)
			}, SVGMatte3Effect.prototype.initialize = function () {
				for (var i = this.filterManager.effectElements[0].p.v, t = this.elem.comp.elements, e = 0, n = t.length; e < n;) t[e] && t[e].data.ind === i && this.setElementAsMask(this.elem, t[e]), e += 1;
				this.initialized = !0
			}, SVGMatte3Effect.prototype.renderFrame = function () {
				this.initialized || this.initialize()
			};

			function SVGGaussianBlurEffect(i, t, e, n) {
				i.setAttribute("x", "-100%"), i.setAttribute("y", "-100%"), i.setAttribute("width", "300%"), i.setAttribute("height", "300%"), this.filterManager = t;
				var r = createNS("feGaussianBlur");
				r.setAttribute("result", n), i.appendChild(r), this.feGaussianBlur = r
			}
			SVGGaussianBlurEffect.prototype.renderFrame = function (i) {
				if (i || this.filterManager._mdf) {
					var t = .3,
						e = this.filterManager.effectElements[0].p.v * t,
						n = this.filterManager.effectElements[1].p.v,
						r = n == 3 ? 0 : e,
						s = n == 2 ? 0 : e;
					this.feGaussianBlur.setAttribute("stdDeviation", r + " " + s);
					var a = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
					this.feGaussianBlur.setAttribute("edgeMode", a)
				}
			};

			function TransformEffect() {}
			TransformEffect.prototype.init = function (i) {
				this.effectsManager = i, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1
			}, TransformEffect.prototype.renderFrame = function (i) {
				if (this._opMdf = !1, this._mdf = !1, i || this.effectsManager._mdf) {
					var t = this.effectsManager.effectElements,
						e = t[0].p.v,
						n = t[1].p.v,
						r = t[2].p.v === 1,
						s = t[3].p.v,
						a = r ? s : t[4].p.v,
						o = t[5].p.v,
						h = t[6].p.v,
						c = t[7].p.v;
					this.matrix.reset(), this.matrix.translate(-e[0], -e[1], e[2]), this.matrix.scale(a * .01, s * .01, 1), this.matrix.rotate(-c * degToRads), this.matrix.skewFromAxis(-o * degToRads, (h + 90) * degToRads), this.matrix.translate(n[0], n[1], 0), this._mdf = !0, this.opacity !== t[8].p.v && (this.opacity = t[8].p.v, this._opMdf = !0)
				}
			};

			function SVGTransformEffect(i, t) {
				this.init(t)
			}
			extendPrototype([TransformEffect], SVGTransformEffect);

			function CVTransformEffect(i) {
				this.init(i)
			}
			return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
		})
	});
	var bb = Qh((Vu, yb) => {
		(function (i, t) {
			typeof Vu == "object" && typeof yb != "undefined" ? t(Vu) : typeof define == "function" && define.amd ? define(["exports"], t) : (i = typeof globalThis != "undefined" ? globalThis : i || self, t(i.Tweakpane = {}))
		})(Vu, function (i) {
			"use strict";
			class t {
				constructor(l) {
					let [d, C] = l.split("-"), V = d.split(".");
					this.major = parseInt(V[0], 10), this.minor = parseInt(V[1], 10), this.patch = parseInt(V[2], 10), this.prerelease = C != null ? C : null
				}
				toString() {
					let l = [this.major, this.minor, this.patch].join(".");
					return this.prerelease !== null ? [l, this.prerelease].join("-") : l
				}
			}
			class e {
				constructor(l) {
					this.controller_ = l
				}
				get element() {
					return this.controller_.view.element
				}
				get disabled() {
					return this.controller_.viewProps.get("disabled")
				}
				set disabled(l) {
					this.controller_.viewProps.set("disabled", l)
				}
				get hidden() {
					return this.controller_.viewProps.get("hidden")
				}
				set hidden(l) {
					this.controller_.viewProps.set("hidden", l)
				}
				dispose() {
					this.controller_.viewProps.set("disposed", !0)
				}
			}
			class n {
				constructor(l) {
					this.target = l
				}
			}
			class r extends n {
				constructor(l, d, C, V) {
					super(l), this.value = d, this.presetKey = C, this.last = V != null ? V : !0
				}
			}
			class s extends n {
				constructor(l, d, C) {
					super(l), this.value = d, this.presetKey = C
				}
			}
			class a extends n {
				constructor(l, d) {
					super(l), this.expanded = d
				}
			}
			class o extends n {
				constructor(l, d) {
					super(l), this.index = d
				}
			}

			function h(m) {
				return m
			}

			function c(m) {
				return m == null
			}

			function u(m, l) {
				if (m.length !== l.length) return !1;
				for (let d = 0; d < m.length; d++)
					if (m[d] !== l[d]) return !1;
				return !0
			}

			function g(m, l) {
				let d = m;
				do {
					let C = Object.getOwnPropertyDescriptor(d, l);
					if (C && (C.set !== void 0 || C.writable === !0)) return !0;
					d = Object.getPrototypeOf(d)
				} while (d !== null);
				return !1
			}
			let p = {
				alreadydisposed: () => "View has been already disposed",
				invalidparams: m => `Invalid parameters for '${m.name}'`,
				nomatchingcontroller: m => `No matching controller for '${m.key}'`,
				nomatchingview: m => `No matching view for '${JSON.stringify(m.params)}'`,
				notbindable: () => "Value is not bindable",
				propertynotfound: m => `Property '${m.name}' not found`,
				shouldneverhappen: () => "This error should never happen"
			};
			class _ {
				static alreadyDisposed() {
					return new _({
						type: "alreadydisposed"
					})
				}
				static notBindable() {
					return new _({
						type: "notbindable"
					})
				}
				static propertyNotFound(l) {
					return new _({
						type: "propertynotfound",
						context: {
							name: l
						}
					})
				}
				static shouldNeverHappen() {
					return new _({
						type: "shouldneverhappen"
					})
				}
				constructor(l) {
					var d;
					this.message = (d = p[l.type](l.context)) !== null && d !== void 0 ? d : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = l.type
				}
			}
			class b {
				constructor(l, d, C) {
					this.obj_ = l, this.key_ = d, this.presetKey_ = C != null ? C : d
				}
				static isBindable(l) {
					return !(l === null || typeof l != "object" && typeof l != "function")
				}
				get key() {
					return this.key_
				}
				get presetKey() {
					return this.presetKey_
				}
				read() {
					return this.obj_[this.key_]
				}
				write(l) {
					this.obj_[this.key_] = l
				}
				writeProperty(l, d) {
					let C = this.read();
					if (!b.isBindable(C)) throw _.notBindable();
					if (!(l in C)) throw _.propertyNotFound(l);
					C[l] = d
				}
			}
			class y extends e {
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				get title() {
					var l;
					return (l = this.controller_.valueController.props.get("title")) !== null && l !== void 0 ? l : ""
				}
				set title(l) {
					this.controller_.valueController.props.set("title", l)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.controller_.valueController.emitter.on(l, () => {
						C(new n(this))
					}), this
				}
			}
			class w {
				constructor() {
					this.observers_ = {}
				}
				on(l, d) {
					let C = this.observers_[l];
					return C || (C = this.observers_[l] = []), C.push({
						handler: d
					}), this
				}
				off(l, d) {
					let C = this.observers_[l];
					return C && (this.observers_[l] = C.filter(V => V.handler !== d)), this
				}
				emit(l, d) {
					let C = this.observers_[l];
					C && C.forEach(V => {
						V.handler(d)
					})
				}
			}
			let f = "tp";

			function S(m) {
				return (d, C) => [f, "-", m, "v", d ? `_${d}` : "", C ? `-${C}` : ""].join("")
			}

			function x(m, l) {
				return d => l(m(d))
			}

			function M(m) {
				return m.rawValue
			}

			function T(m, l) {
				m.emitter.on("change", x(M, l)), l(m.rawValue)
			}

			function I(m, l, d) {
				T(m.value(l), d)
			}

			function L(m, l, d) {
				d ? m.classList.add(l) : m.classList.remove(l)
			}

			function F(m, l) {
				return d => {
					L(m, l, d)
				}
			}

			function k(m, l) {
				T(m, d => {
					l.textContent = d != null ? d : ""
				})
			}
			let G = S("btn");
			class j {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(G()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("button");
					C.classList.add(G("b")), d.viewProps.bindDisabled(C), this.element.appendChild(C), this.buttonElement = C;
					let V = l.createElement("div");
					V.classList.add(G("t")), k(d.props.value("title"), V), this.buttonElement.appendChild(V)
				}
			}
			class U {
				constructor(l, d) {
					this.emitter = new w, this.onClick_ = this.onClick_.bind(this), this.props = d.props, this.viewProps = d.viewProps, this.view = new j(l, {
						props: this.props,
						viewProps: this.viewProps
					}), this.view.buttonElement.addEventListener("click", this.onClick_)
				}
				onClick_() {
					this.emitter.emit("click", {
						sender: this
					})
				}
			}
			class z {
				constructor(l, d) {
					var C;
					this.constraint_ = d == null ? void 0 : d.constraint, this.equals_ = (C = d == null ? void 0 : d.equals) !== null && C !== void 0 ? C : (V, J) => V === J, this.emitter = new w, this.rawValue_ = l
				}
				get constraint() {
					return this.constraint_
				}
				get rawValue() {
					return this.rawValue_
				}
				set rawValue(l) {
					this.setRawValue(l, {
						forceEmit: !1,
						last: !0
					})
				}
				setRawValue(l, d) {
					let C = d != null ? d : {
							forceEmit: !1,
							last: !0
						},
						V = this.constraint_ ? this.constraint_.constrain(l) : l,
						J = this.rawValue_;
					this.equals_(J, V) && !C.forceEmit || (this.emitter.emit("beforechange", {
						sender: this
					}), this.rawValue_ = V, this.emitter.emit("change", {
						options: C,
						previousRawValue: J,
						rawValue: V,
						sender: this
					}))
				}
			}
			class $ {
				constructor(l) {
					this.emitter = new w, this.value_ = l
				}
				get rawValue() {
					return this.value_
				}
				set rawValue(l) {
					this.setRawValue(l, {
						forceEmit: !1,
						last: !0
					})
				}
				setRawValue(l, d) {
					let C = d != null ? d : {
							forceEmit: !1,
							last: !0
						},
						V = this.value_;
					V === l && !C.forceEmit || (this.emitter.emit("beforechange", {
						sender: this
					}), this.value_ = l, this.emitter.emit("change", {
						options: C,
						previousRawValue: V,
						rawValue: this.value_,
						sender: this
					}))
				}
			}

			function W(m, l) {
				let d = l == null ? void 0 : l.constraint,
					C = l == null ? void 0 : l.equals;
				return !d && !C ? new $(m) : new z(m, l)
			}
			class O {
				constructor(l) {
					this.emitter = new w, this.valMap_ = l;
					for (let d in this.valMap_) this.valMap_[d].emitter.on("change", () => {
						this.emitter.emit("change", {
							key: d,
							sender: this
						})
					})
				}
				static createCore(l) {
					return Object.keys(l).reduce((C, V) => Object.assign(C, {
						[V]: W(l[V])
					}), {})
				}
				static fromObject(l) {
					let d = this.createCore(l);
					return new O(d)
				}
				get(l) {
					return this.valMap_[l].rawValue
				}
				set(l, d) {
					this.valMap_[l].rawValue = d
				}
				value(l) {
					return this.valMap_[l]
				}
			}

			function B(m, l) {
				let C = Object.keys(l).reduce((V, J) => {
					if (V === void 0) return;
					let at = l[J],
						Ct = at(m[J]);
					return Ct.succeeded ? Object.assign(Object.assign({}, V), {
						[J]: Ct.value
					}) : void 0
				}, {});
				return C
			}

			function A(m, l) {
				return m.reduce((d, C) => {
					if (d === void 0) return;
					let V = l(C);
					if (!(!V.succeeded || V.value === void 0)) return [...d, V.value]
				}, [])
			}

			function D(m) {
				return m === null ? !1 : typeof m == "object"
			}

			function H(m) {
				return l => d => {
					if (!l && d === void 0) return {
						succeeded: !1,
						value: void 0
					};
					if (l && d === void 0) return {
						succeeded: !0,
						value: void 0
					};
					let C = m(d);
					return C !== void 0 ? {
						succeeded: !0,
						value: C
					} : {
						succeeded: !1,
						value: void 0
					}
				}
			}

			function q(m) {
				return {
					custom: l => H(l)(m),
					boolean: H(l => typeof l == "boolean" ? l : void 0)(m),
					number: H(l => typeof l == "number" ? l : void 0)(m),
					string: H(l => typeof l == "string" ? l : void 0)(m),
					function: H(l => typeof l == "function" ? l : void 0)(m),
					constant: l => H(d => d === l ? l : void 0)(m),
					raw: H(l => l)(m),
					object: l => H(d => {
						if (D(d)) return B(d, l)
					})(m),
					array: l => H(d => {
						if (Array.isArray(d)) return A(d, l)
					})(m)
				}
			}
			let Q = {
				optional: q(!0),
				required: q(!1)
			};

			function tt(m, l) {
				let d = Q.required.object(l)(m);
				return d.succeeded ? d.value : void 0
			}

			function nt(m) {
				console.warn([`Missing '${m.key}' of ${m.target} in ${m.place}.`, "Please rebuild plugins with the latest core package."].join(" "))
			}

			function ut(m) {
				return m && m.parentElement && m.parentElement.removeChild(m), null
			}
			class et {
				constructor(l) {
					this.value_ = l
				}
				static create(l) {
					return [new et(l), (d, C) => {
						l.setRawValue(d, C)
					}]
				}
				get emitter() {
					return this.value_.emitter
				}
				get rawValue() {
					return this.value_.rawValue
				}
			}
			let it = S("");

			function Et(m, l) {
				return F(m, it(void 0, l))
			}
			class wt extends O {
				constructor(l) {
					var d;
					super(l), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = et.create(W(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (d = this.get("parent")) === null || d === void 0 || d.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
				}
				static create(l) {
					var d, C, V;
					let J = l != null ? l : {};
					return new wt(O.createCore({
						disabled: (d = J.disabled) !== null && d !== void 0 ? d : !1,
						disposed: !1,
						hidden: (C = J.hidden) !== null && C !== void 0 ? C : !1,
						parent: (V = J.parent) !== null && V !== void 0 ? V : null
					}))
				}
				get globalDisabled() {
					return this.globalDisabled_
				}
				bindClassModifiers(l) {
					T(this.globalDisabled_, Et(l, "disabled")), I(this, "hidden", Et(l, "hidden"))
				}
				bindDisabled(l) {
					T(this.globalDisabled_, d => {
						l.disabled = d
					})
				}
				bindTabIndex(l) {
					T(this.globalDisabled_, d => {
						l.tabIndex = d ? -1 : 0
					})
				}
				handleDispose(l) {
					this.value("disposed").emitter.on("change", d => {
						d && l()
					})
				}
				getGlobalDisabled_() {
					let l = this.get("parent");
					return (l ? l.globalDisabled.rawValue : !1) || this.get("disabled")
				}
				updateGlobalDisabled_() {
					this.setGlobalDisabled_(this.getGlobalDisabled_())
				}
				onDisabledChange_() {
					this.updateGlobalDisabled_()
				}
				onParentGlobalDisabledChange_() {
					this.updateGlobalDisabled_()
				}
				onParentChange_(l) {
					var d;
					let C = l.previousRawValue;
					C == null || C.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (d = this.get("parent")) === null || d === void 0 || d.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_()
				}
			}

			function yt() {
				return ["veryfirst", "first", "last", "verylast"]
			}
			let At = S(""),
				Vt = {
					veryfirst: "vfst",
					first: "fst",
					last: "lst",
					verylast: "vlst"
				};
			class lt {
				constructor(l) {
					this.parent_ = null, this.blade = l.blade, this.view = l.view, this.viewProps = l.viewProps;
					let d = this.view.element;
					this.blade.value("positions").emitter.on("change", () => {
						yt().forEach(C => {
							d.classList.remove(At(void 0, Vt[C]))
						}), this.blade.get("positions").forEach(C => {
							d.classList.add(At(void 0, Vt[C]))
						})
					}), this.viewProps.handleDispose(() => {
						ut(d)
					})
				}
				get parent() {
					return this.parent_
				}
				set parent(l) {
					if (this.parent_ = l, !("parent" in this.viewProps.valMap_)) {
						nt({
							key: "parent",
							target: wt.name,
							place: "BladeController.parent"
						});
						return
					}
					this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
				}
			}
			let dt = "http://www.w3.org/2000/svg";

			function qt(m) {
				m.offsetHeight
			}

			function Zt(m, l) {
				let d = m.style.transition;
				m.style.transition = "none", l(), m.style.transition = d
			}

			function re(m) {
				return m.ontouchstart !== void 0
			}

			function de() {
				return globalThis
			}

			function Xt() {
				return de().document
			}

			function le(m) {
				let l = m.ownerDocument.defaultView;
				return l && "document" in l ? m.getContext("2d", {
					willReadFrequently: !0
				}) : null
			}
			let ye = {
				check: '<path d="M2 8l4 4l8 -8"/>',
				dropdown: '<path d="M5 7h6l-3 3 z"/>',
				p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
			};

			function Z(m, l) {
				let d = m.createElementNS(dt, "svg");
				return d.innerHTML = ye[l], d
			}

			function X(m, l, d) {
				m.insertBefore(l, m.children[d])
			}

			function pt(m) {
				m.parentElement && m.parentElement.removeChild(m)
			}

			function xt(m) {
				for (; m.children.length > 0;) m.removeChild(m.children[0])
			}

			function St(m) {
				for (; m.childNodes.length > 0;) m.removeChild(m.childNodes[0])
			}

			function Pt(m) {
				return m.relatedTarget ? m.relatedTarget : "explicitOriginalTarget" in m ? m.explicitOriginalTarget : null
			}
			let Bt = S("lbl");

			function It(m, l) {
				let d = m.createDocumentFragment();
				return l.split(`
`).map(V => m.createTextNode(V)).forEach((V, J) => {
					J > 0 && d.appendChild(m.createElement("br")), d.appendChild(V)
				}), d
			}
			class mt {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Bt()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add(Bt("l")), I(d.props, "label", J => {
						c(J) ? this.element.classList.add(Bt(void 0, "nol")) : (this.element.classList.remove(Bt(void 0, "nol")), St(C), C.appendChild(It(l, J)))
					}), this.element.appendChild(C), this.labelElement = C;
					let V = l.createElement("div");
					V.classList.add(Bt("v")), this.element.appendChild(V), this.valueElement = V
				}
			}
			class Ot extends lt {
				constructor(l, d) {
					let C = d.valueController.viewProps;
					super(Object.assign(Object.assign({}, d), {
						view: new mt(l, {
							props: d.props,
							viewProps: C
						}),
						viewProps: C
					})), this.props = d.props, this.valueController = d.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
				}
			}
			let Gt = {
				id: "button",
				type: "blade",
				accept(m) {
					let l = Q,
						d = tt(m, {
							title: l.required.string,
							view: l.required.constant("button"),
							label: l.optional.string
						});
					return d ? {
						params: d
					} : null
				},
				controller(m) {
					return new Ot(m.document, {
						blade: m.blade,
						props: O.fromObject({
							label: m.params.label
						}),
						valueController: new U(m.document, {
							props: O.fromObject({
								title: m.params.title
							}),
							viewProps: m.viewProps
						})
					})
				},
				api(m) {
					return !(m.controller instanceof Ot) || !(m.controller.valueController instanceof U) ? null : new y(m.controller)
				}
			};
			class Ut extends lt {
				constructor(l) {
					super(l), this.value = l.value
				}
			}

			function Lt() {
				return new O({
					positions: W([], {
						equals: u
					})
				})
			}
			class Nt extends O {
				constructor(l) {
					super(l)
				}
				static create(l) {
					let d = {
							completed: !0,
							expanded: l,
							expandedHeight: null,
							shouldFixHeight: !1,
							temporaryExpanded: null
						},
						C = O.createCore(d);
					return new Nt(C)
				}
				get styleExpanded() {
					var l;
					return (l = this.get("temporaryExpanded")) !== null && l !== void 0 ? l : this.get("expanded")
				}
				get styleHeight() {
					if (!this.styleExpanded) return "0";
					let l = this.get("expandedHeight");
					return this.get("shouldFixHeight") && !c(l) ? `${l}px` : "auto"
				}
				bindExpandedClass(l, d) {
					let C = () => {
						this.styleExpanded ? l.classList.add(d) : l.classList.remove(d)
					};
					I(this, "expanded", C), I(this, "temporaryExpanded", C)
				}
				cleanUpTransition() {
					this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
				}
			}

			function ce(m, l) {
				let d = 0;
				return Zt(l, () => {
					m.set("expandedHeight", null), m.set("temporaryExpanded", !0), qt(l), d = l.clientHeight, m.set("temporaryExpanded", null), qt(l)
				}), d
			}

			function be(m, l) {
				l.style.height = m.styleHeight
			}

			function Ie(m, l) {
				m.value("expanded").emitter.on("beforechange", () => {
					if (m.set("completed", !1), c(m.get("expandedHeight"))) {
						let d = ce(m, l);
						d > 0 && m.set("expandedHeight", d)
					}
					m.set("shouldFixHeight", !0), qt(l)
				}), m.emitter.on("change", () => {
					be(m, l)
				}), be(m, l), l.addEventListener("transitionend", d => {
					d.propertyName === "height" && m.cleanUpTransition()
				})
			}
			class rt extends e {
				constructor(l, d) {
					super(l), this.rackApi_ = d
				}
			}

			function gt(m, l) {
				return m.addBlade(Object.assign(Object.assign({}, l), {
					view: "button"
				}))
			}

			function Mt(m, l) {
				return m.addBlade(Object.assign(Object.assign({}, l), {
					view: "folder"
				}))
			}

			function kt(m, l) {
				let d = l != null ? l : {};
				return m.addBlade(Object.assign(Object.assign({}, d), {
					view: "separator"
				}))
			}

			function zt(m, l) {
				return m.addBlade(Object.assign(Object.assign({}, l), {
					view: "tab"
				}))
			}
			class fe {
				constructor(l) {
					this.emitter = new w, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = l
				}
				get items() {
					return this.items_
				}
				allItems() {
					return Array.from(this.cache_)
				}
				find(l) {
					for (let d of this.allItems())
						if (l(d)) return d;
					return null
				}
				includes(l) {
					return this.cache_.has(l)
				}
				add(l, d) {
					if (this.includes(l)) throw _.shouldNeverHappen();
					let C = d !== void 0 ? d : this.items_.length;
					this.items_.splice(C, 0, l), this.cache_.add(l);
					let V = this.extract_(l);
					V && (V.emitter.on("add", this.onSubListAdd_), V.emitter.on("remove", this.onSubListRemove_), V.allItems().forEach(J => {
						this.cache_.add(J)
					})), this.emitter.emit("add", {
						index: C,
						item: l,
						root: this,
						target: this
					})
				}
				remove(l) {
					let d = this.items_.indexOf(l);
					if (d < 0) return;
					this.items_.splice(d, 1), this.cache_.delete(l);
					let C = this.extract_(l);
					C && (C.emitter.off("add", this.onSubListAdd_), C.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
						index: d,
						item: l,
						root: this,
						target: this
					})
				}
				onSubListAdd_(l) {
					this.cache_.add(l.item), this.emitter.emit("add", {
						index: l.index,
						item: l.item,
						root: this,
						target: l.target
					})
				}
				onSubListRemove_(l) {
					this.cache_.delete(l.item), this.emitter.emit("remove", {
						index: l.index,
						item: l.item,
						root: this,
						target: l.target
					})
				}
			}
			class Ae extends e {
				constructor(l) {
					super(l), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new w, this.controller_.binding.emitter.on("change", this.onBindingChange_)
				}
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
				refresh() {
					this.controller_.binding.read()
				}
				onBindingChange_(l) {
					let d = l.sender.target.read();
					this.emitter_.emit("change", {
						event: new r(this, d, this.controller_.binding.target.presetKey, l.options.last)
					})
				}
			}
			class xe extends Ot {
				constructor(l, d) {
					super(l, d), this.binding = d.binding
				}
			}
			class Vi extends e {
				constructor(l) {
					super(l), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new w, this.controller_.binding.emitter.on("update", this.onBindingUpdate_)
				}
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
				refresh() {
					this.controller_.binding.read()
				}
				onBindingUpdate_(l) {
					let d = l.sender.target.read();
					this.emitter_.emit("update", {
						event: new s(this, d, this.controller_.binding.target.presetKey)
					})
				}
			}
			class ge extends Ot {
				constructor(l, d) {
					super(l, d), this.binding = d.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
						this.binding.dispose()
					})
				}
			}

			function vi(m) {
				return m instanceof fr ? m.apiSet_ : m instanceof rt ? m.rackApi_.apiSet_ : null
			}

			function ci(m, l) {
				let d = m.find(C => C.controller_ === l);
				if (!d) throw _.shouldNeverHappen();
				return d
			}

			function pr(m, l, d) {
				if (!b.isBindable(m)) throw _.notBindable();
				return new b(m, l, d)
			}
			class fr extends e {
				constructor(l, d) {
					super(l), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new w, this.apiSet_ = new fe(vi), this.pool_ = d;
					let C = this.controller_.rack;
					C.emitter.on("add", this.onRackAdd_), C.emitter.on("remove", this.onRackRemove_), C.emitter.on("inputchange", this.onRackInputChange_), C.emitter.on("monitorupdate", this.onRackMonitorUpdate_), C.children.forEach(V => {
						this.setUpApi_(V)
					})
				}
				get children() {
					return this.controller_.rack.children.map(l => ci(this.apiSet_, l))
				}
				addInput(l, d, C) {
					let V = C != null ? C : {},
						J = this.controller_.view.element.ownerDocument,
						at = this.pool_.createInput(J, pr(l, d, V.presetKey), V),
						Ct = new Ae(at);
					return this.add(Ct, V.index)
				}
				addMonitor(l, d, C) {
					let V = C != null ? C : {},
						J = this.controller_.view.element.ownerDocument,
						at = this.pool_.createMonitor(J, pr(l, d), V),
						Ct = new Vi(at);
					return this.add(Ct, V.index)
				}
				addFolder(l) {
					return Mt(this, l)
				}
				addButton(l) {
					return gt(this, l)
				}
				addSeparator(l) {
					return kt(this, l)
				}
				addTab(l) {
					return zt(this, l)
				}
				add(l, d) {
					this.controller_.rack.add(l.controller_, d);
					let C = this.apiSet_.find(V => V.controller_ === l.controller_);
					return C && this.apiSet_.remove(C), this.apiSet_.add(l), l
				}
				remove(l) {
					this.controller_.rack.remove(l.controller_)
				}
				addBlade(l) {
					let d = this.controller_.view.element.ownerDocument,
						C = this.pool_.createBlade(d, l),
						V = this.pool_.createBladeApi(C);
					return this.add(V, l.index)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
				setUpApi_(l) {
					this.apiSet_.find(C => C.controller_ === l) || this.apiSet_.add(this.pool_.createBladeApi(l))
				}
				onRackAdd_(l) {
					this.setUpApi_(l.bladeController)
				}
				onRackRemove_(l) {
					if (l.isRoot) {
						let d = ci(this.apiSet_, l.bladeController);
						this.apiSet_.remove(d)
					}
				}
				onRackInputChange_(l) {
					let d = l.bladeController;
					if (d instanceof xe) {
						let C = ci(this.apiSet_, d),
							V = d.binding;
						this.emitter_.emit("change", {
							event: new r(C, V.target.read(), V.target.presetKey, l.options.last)
						})
					} else if (d instanceof Ut) {
						let C = ci(this.apiSet_, d);
						this.emitter_.emit("change", {
							event: new r(C, d.value.rawValue, void 0, l.options.last)
						})
					}
				}
				onRackMonitorUpdate_(l) {
					if (!(l.bladeController instanceof ge)) throw _.shouldNeverHappen();
					let d = ci(this.apiSet_, l.bladeController),
						C = l.bladeController.binding;
					this.emitter_.emit("update", {
						event: new s(d, C.target.read(), C.target.presetKey)
					})
				}
			}
			class Ls extends rt {
				constructor(l, d) {
					super(l, new fr(l.rackController, d)), this.emitter_ = new w, this.controller_.foldable.value("expanded").emitter.on("change", C => {
						this.emitter_.emit("fold", {
							event: new a(this, C.sender.rawValue)
						})
					}), this.rackApi_.on("change", C => {
						this.emitter_.emit("change", {
							event: C
						})
					}), this.rackApi_.on("update", C => {
						this.emitter_.emit("update", {
							event: C
						})
					})
				}
				get expanded() {
					return this.controller_.foldable.get("expanded")
				}
				set expanded(l) {
					this.controller_.foldable.set("expanded", l)
				}
				get title() {
					return this.controller_.props.get("title")
				}
				set title(l) {
					this.controller_.props.set("title", l)
				}
				get children() {
					return this.rackApi_.children
				}
				addInput(l, d, C) {
					return this.rackApi_.addInput(l, d, C)
				}
				addMonitor(l, d, C) {
					return this.rackApi_.addMonitor(l, d, C)
				}
				addFolder(l) {
					return this.rackApi_.addFolder(l)
				}
				addButton(l) {
					return this.rackApi_.addButton(l)
				}
				addSeparator(l) {
					return this.rackApi_.addSeparator(l)
				}
				addTab(l) {
					return this.rackApi_.addTab(l)
				}
				add(l, d) {
					return this.rackApi_.add(l, d)
				}
				remove(l) {
					this.rackApi_.remove(l)
				}
				addBlade(l) {
					return this.rackApi_.addBlade(l)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
			}
			class ks extends lt {
				constructor(l) {
					super({
						blade: l.blade,
						view: l.view,
						viewProps: l.rackController.viewProps
					}), this.rackController = l.rackController
				}
			}
			class Ko {
				constructor(l, d) {
					let C = S(d.viewName);
					this.element = l.createElement("div"), this.element.classList.add(C()), d.viewProps.bindClassModifiers(this.element)
				}
			}

			function K(m, l) {
				for (let d = 0; d < m.length; d++) {
					let C = m[d];
					if (C instanceof xe && C.binding === l) return C
				}
				return null
			}

			function ct(m, l) {
				for (let d = 0; d < m.length; d++) {
					let C = m[d];
					if (C instanceof ge && C.binding === l) return C
				}
				return null
			}

			function vt(m, l) {
				for (let d = 0; d < m.length; d++) {
					let C = m[d];
					if (C instanceof Ut && C.value === l) return C
				}
				return null
			}

			function ot(m) {
				return m instanceof $t ? m.rack : m instanceof ks ? m.rackController.rack : null
			}

			function _t(m) {
				let l = ot(m);
				return l ? l.bcSet_ : null
			}
			class Ht {
				constructor(l) {
					var d, C;
					this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new w, this.blade_ = (d = l.blade) !== null && d !== void 0 ? d : null, (C = this.blade_) === null || C === void 0 || C.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = l.viewProps, this.bcSet_ = new fe(_t), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
				}
				get children() {
					return this.bcSet_.items
				}
				add(l, d) {
					var C;
					(C = l.parent) === null || C === void 0 || C.remove(l), g(l, "parent") ? l.parent = this : (l.parent_ = this, nt({
						key: "parent",
						target: "BladeController",
						place: "BladeRack.add"
					})), this.bcSet_.add(l, d)
				}
				remove(l) {
					g(l, "parent") ? l.parent = null : (l.parent_ = null, nt({
						key: "parent",
						target: "BladeController",
						place: "BladeRack.remove"
					})), this.bcSet_.remove(l)
				}
				find(l) {
					return this.bcSet_.allItems().filter(d => d instanceof l)
				}
				onSetAdd_(l) {
					this.updatePositions_();
					let d = l.target === l.root;
					if (this.emitter.emit("add", {
							bladeController: l.item,
							index: l.index,
							isRoot: d,
							sender: this
						}), !d) return;
					let C = l.item;
					if (C.viewProps.emitter.on("change", this.onChildViewPropsChange_), C.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), C.viewProps.handleDispose(this.onChildDispose_), C instanceof xe) C.binding.emitter.on("change", this.onChildInputChange_);
					else if (C instanceof ge) C.binding.emitter.on("update", this.onChildMonitorUpdate_);
					else if (C instanceof Ut) C.value.emitter.on("change", this.onChildValueChange_);
					else {
						let V = ot(C);
						if (V) {
							let J = V.emitter;
							J.on("layout", this.onDescendantLayout_), J.on("inputchange", this.onDescendantInputChange_), J.on("monitorupdate", this.onDescendantMonitorUpdate_)
						}
					}
				}
				onSetRemove_(l) {
					this.updatePositions_();
					let d = l.target === l.root;
					if (this.emitter.emit("remove", {
							bladeController: l.item,
							isRoot: d,
							sender: this
						}), !d) return;
					let C = l.item;
					if (C instanceof xe) C.binding.emitter.off("change", this.onChildInputChange_);
					else if (C instanceof ge) C.binding.emitter.off("update", this.onChildMonitorUpdate_);
					else if (C instanceof Ut) C.value.emitter.off("change", this.onChildValueChange_);
					else {
						let V = ot(C);
						if (V) {
							let J = V.emitter;
							J.off("layout", this.onDescendantLayout_), J.off("inputchange", this.onDescendantInputChange_), J.off("monitorupdate", this.onDescendantMonitorUpdate_)
						}
					}
				}
				updatePositions_() {
					let l = this.bcSet_.items.filter(V => !V.viewProps.get("hidden")),
						d = l[0],
						C = l[l.length - 1];
					this.bcSet_.items.forEach(V => {
						let J = [];
						V === d && (J.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && J.push("veryfirst")), V === C && (J.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && J.push("verylast")), V.blade.set("positions", J)
					})
				}
				onChildPositionsChange_() {
					this.updatePositions_(), this.emitter.emit("layout", {
						sender: this
					})
				}
				onChildViewPropsChange_(l) {
					this.updatePositions_(), this.emitter.emit("layout", {
						sender: this
					})
				}
				onChildDispose_() {
					this.bcSet_.items.filter(d => d.viewProps.get("disposed")).forEach(d => {
						this.bcSet_.remove(d)
					})
				}
				onChildInputChange_(l) {
					let d = K(this.find(xe), l.sender);
					if (!d) throw _.alreadyDisposed();
					this.emitter.emit("inputchange", {
						bladeController: d,
						options: l.options,
						sender: this
					})
				}
				onChildMonitorUpdate_(l) {
					let d = ct(this.find(ge), l.sender);
					if (!d) throw _.alreadyDisposed();
					this.emitter.emit("monitorupdate", {
						bladeController: d,
						sender: this
					})
				}
				onChildValueChange_(l) {
					let d = vt(this.find(Ut), l.sender);
					if (!d) throw _.alreadyDisposed();
					this.emitter.emit("inputchange", {
						bladeController: d,
						options: l.options,
						sender: this
					})
				}
				onDescendantLayout_(l) {
					this.updatePositions_(), this.emitter.emit("layout", {
						sender: this
					})
				}
				onDescendantInputChange_(l) {
					this.emitter.emit("inputchange", {
						bladeController: l.bladeController,
						options: l.options,
						sender: this
					})
				}
				onDescendantMonitorUpdate_(l) {
					this.emitter.emit("monitorupdate", {
						bladeController: l.bladeController,
						sender: this
					})
				}
				onBladePositionsChange_() {
					this.updatePositions_()
				}
			}
			class $t extends lt {
				constructor(l, d) {
					super(Object.assign(Object.assign({}, d), {
						view: new Ko(l, {
							viewName: "brk",
							viewProps: d.viewProps
						})
					})), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
					let C = new Ht({
						blade: d.root ? void 0 : d.blade,
						viewProps: d.viewProps
					});
					C.emitter.on("add", this.onRackAdd_), C.emitter.on("remove", this.onRackRemove_), this.rack = C, this.viewProps.handleDispose(() => {
						for (let V = this.rack.children.length - 1; V >= 0; V--) this.rack.children[V].viewProps.set("disposed", !0)
					})
				}
				onRackAdd_(l) {
					l.isRoot && X(this.view.element, l.bladeController.view.element, l.index)
				}
				onRackRemove_(l) {
					l.isRoot && pt(l.bladeController.view.element)
				}
			}
			let Yt = S("cnt");
			class ee {
				constructor(l, d) {
					var C;
					this.className_ = S((C = d.viewName) !== null && C !== void 0 ? C : "fld"), this.element = l.createElement("div"), this.element.classList.add(this.className_(), Yt()), d.viewProps.bindClassModifiers(this.element), this.foldable_ = d.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), I(this.foldable_, "completed", F(this.element, this.className_(void 0, "cpl")));
					let V = l.createElement("button");
					V.classList.add(this.className_("b")), I(d.props, "title", Kt => {
						c(Kt) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
					}), d.viewProps.bindDisabled(V), this.element.appendChild(V), this.buttonElement = V;
					let J = l.createElement("div");
					J.classList.add(this.className_("i")), this.element.appendChild(J);
					let at = l.createElement("div");
					at.classList.add(this.className_("t")), k(d.props.value("title"), at), this.buttonElement.appendChild(at), this.titleElement = at;
					let Ct = l.createElement("div");
					Ct.classList.add(this.className_("m")), this.buttonElement.appendChild(Ct);
					let jt = d.containerElement;
					jt.classList.add(this.className_("c")), this.element.appendChild(jt), this.containerElement = jt
				}
			}
			class te extends ks {
				constructor(l, d) {
					var C;
					let V = Nt.create((C = d.expanded) !== null && C !== void 0 ? C : !0),
						J = new $t(l, {
							blade: d.blade,
							root: d.root,
							viewProps: d.viewProps
						});
					super(Object.assign(Object.assign({}, d), {
						rackController: J,
						view: new ee(l, {
							containerElement: J.view.element,
							foldable: V,
							props: d.props,
							viewName: d.root ? "rot" : void 0,
							viewProps: d.viewProps
						})
					})), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = d.props, this.foldable = V, Ie(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
						this.foldable.cleanUpTransition()
					}), this.rackController.rack.emitter.on("remove", () => {
						this.foldable.cleanUpTransition()
					}), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
				}
				get document() {
					return this.view.element.ownerDocument
				}
				onTitleClick_() {
					this.foldable.set("expanded", !this.foldable.get("expanded"))
				}
			}
			let se = {
				id: "folder",
				type: "blade",
				accept(m) {
					let l = Q,
						d = tt(m, {
							title: l.required.string,
							view: l.required.constant("folder"),
							expanded: l.optional.boolean
						});
					return d ? {
						params: d
					} : null
				},
				controller(m) {
					return new te(m.document, {
						blade: m.blade,
						expanded: m.params.expanded,
						props: O.fromObject({
							title: m.params.title
						}),
						viewProps: m.viewProps
					})
				},
				api(m) {
					return m.controller instanceof te ? new Ls(m.controller, m.pool) : null
				}
			};
			class Jt extends Ut {
				constructor(l, d) {
					let C = d.valueController.viewProps;
					super(Object.assign(Object.assign({}, d), {
						value: d.valueController.value,
						view: new mt(l, {
							props: d.props,
							viewProps: C
						}),
						viewProps: C
					})), this.props = d.props, this.valueController = d.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
				}
			}
			class we extends e {}
			let Ke = S("spr");
			class Ci {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Ke()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("hr");
					C.classList.add(Ke("r")), this.element.appendChild(C)
				}
			}
			class Ti extends lt {
				constructor(l, d) {
					super(Object.assign(Object.assign({}, d), {
						view: new Ci(l, {
							viewProps: d.viewProps
						})
					}))
				}
			}
			let Be = {
					id: "separator",
					type: "blade",
					accept(m) {
						let d = tt(m, {
							view: Q.required.constant("separator")
						});
						return d ? {
							params: d
						} : null
					},
					controller(m) {
						return new Ti(m.document, {
							blade: m.blade,
							viewProps: m.viewProps
						})
					},
					api(m) {
						return m.controller instanceof Ti ? new we(m.controller) : null
					}
				},
				Wt = S("tbi");
			class Rs {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Wt()), d.viewProps.bindClassModifiers(this.element), I(d.props, "selected", J => {
						J ? this.element.classList.add(Wt(void 0, "sel")) : this.element.classList.remove(Wt(void 0, "sel"))
					});
					let C = l.createElement("button");
					C.classList.add(Wt("b")), d.viewProps.bindDisabled(C), this.element.appendChild(C), this.buttonElement = C;
					let V = l.createElement("div");
					V.classList.add(Wt("t")), k(d.props.value("title"), V), this.buttonElement.appendChild(V), this.titleElement = V
				}
			}
			class Ve {
				constructor(l, d) {
					this.emitter = new w, this.onClick_ = this.onClick_.bind(this), this.props = d.props, this.viewProps = d.viewProps, this.view = new Rs(l, {
						props: d.props,
						viewProps: d.viewProps
					}), this.view.buttonElement.addEventListener("click", this.onClick_)
				}
				onClick_() {
					this.emitter.emit("click", {
						sender: this
					})
				}
			}
			class un {
				constructor(l, d) {
					this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Ve(l, {
						props: d.itemProps,
						viewProps: wt.create()
					}), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new $t(l, {
						blade: Lt(),
						viewProps: wt.create()
					}), this.props = d.props, I(this.props, "selected", C => {
						this.itemController.props.set("selected", C), this.contentController.viewProps.set("hidden", !C)
					})
				}
				get itemController() {
					return this.ic_
				}
				get contentController() {
					return this.cc_
				}
				onItemClick_() {
					this.props.set("selected", !0)
				}
			}
			class qr {
				constructor(l, d) {
					this.controller_ = l, this.rackApi_ = d
				}
				get title() {
					var l;
					return (l = this.controller_.itemController.props.get("title")) !== null && l !== void 0 ? l : ""
				}
				set title(l) {
					this.controller_.itemController.props.set("title", l)
				}
				get selected() {
					return this.controller_.props.get("selected")
				}
				set selected(l) {
					this.controller_.props.set("selected", l)
				}
				get children() {
					return this.rackApi_.children
				}
				addButton(l) {
					return this.rackApi_.addButton(l)
				}
				addFolder(l) {
					return this.rackApi_.addFolder(l)
				}
				addSeparator(l) {
					return this.rackApi_.addSeparator(l)
				}
				addTab(l) {
					return this.rackApi_.addTab(l)
				}
				add(l, d) {
					this.rackApi_.add(l, d)
				}
				remove(l) {
					this.rackApi_.remove(l)
				}
				addInput(l, d, C) {
					return this.rackApi_.addInput(l, d, C)
				}
				addMonitor(l, d, C) {
					return this.rackApi_.addMonitor(l, d, C)
				}
				addBlade(l) {
					return this.rackApi_.addBlade(l)
				}
			}
			class $n extends rt {
				constructor(l, d) {
					super(l, new fr(l.rackController, d)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new w, this.pageApiMap_ = new Map, this.rackApi_.on("change", C => {
						this.emitter_.emit("change", {
							event: C
						})
					}), this.rackApi_.on("update", C => {
						this.emitter_.emit("update", {
							event: C
						})
					}), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach(C => {
						this.setUpPageApi_(C)
					})
				}
				get pages() {
					return this.controller_.pageSet.items.map(l => {
						let d = this.pageApiMap_.get(l);
						if (!d) throw _.shouldNeverHappen();
						return d
					})
				}
				addPage(l) {
					let d = this.controller_.view.element.ownerDocument,
						C = new un(d, {
							itemProps: O.fromObject({
								selected: !1,
								title: l.title
							}),
							props: O.fromObject({
								selected: !1
							})
						});
					this.controller_.add(C, l.index);
					let V = this.pageApiMap_.get(C);
					if (!V) throw _.shouldNeverHappen();
					return V
				}
				removePage(l) {
					this.controller_.remove(l)
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
				setUpPageApi_(l) {
					let d = this.rackApi_.apiSet_.find(V => V.controller_ === l.contentController);
					if (!d) throw _.shouldNeverHappen();
					let C = new qr(l, d);
					this.pageApiMap_.set(l, C)
				}
				onPageAdd_(l) {
					this.setUpPageApi_(l.item)
				}
				onPageRemove_(l) {
					if (!this.pageApiMap_.get(l.item)) throw _.shouldNeverHappen();
					this.pageApiMap_.delete(l.item)
				}
				onSelect_(l) {
					this.emitter_.emit("select", {
						event: new o(this, l.rawValue)
					})
				}
			}
			let jr = -1;
			class ni {
				constructor() {
					this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = W(!0), this.selectedIndex = W(jr), this.items_ = []
				}
				add(l, d) {
					let C = d != null ? d : this.items_.length;
					this.items_.splice(C, 0, l), l.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_()
				}
				remove(l) {
					let d = this.items_.indexOf(l);
					d < 0 || (this.items_.splice(d, 1), l.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_())
				}
				keepSelection_() {
					if (this.items_.length === 0) {
						this.selectedIndex.rawValue = jr, this.empty.rawValue = !0;
						return
					}
					let l = this.items_.findIndex(d => d.rawValue);
					l < 0 ? (this.items_.forEach((d, C) => {
						d.rawValue = C === 0
					}), this.selectedIndex.rawValue = 0) : (this.items_.forEach((d, C) => {
						d.rawValue = C === l
					}), this.selectedIndex.rawValue = l), this.empty.rawValue = !1
				}
				onItemSelectedChange_(l) {
					if (l.rawValue) {
						let d = this.items_.findIndex(C => C === l.sender);
						this.items_.forEach((C, V) => {
							C.rawValue = V === d
						}), this.selectedIndex.rawValue = d
					} else this.keepSelection_()
				}
			}
			let yi = S("tab");
			class dn {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(yi(), Yt()), d.viewProps.bindClassModifiers(this.element), T(d.empty, F(this.element, yi(void 0, "nop")));
					let C = l.createElement("div");
					C.classList.add(yi("t")), this.element.appendChild(C), this.itemsElement = C;
					let V = l.createElement("div");
					V.classList.add(yi("i")), this.element.appendChild(V);
					let J = d.contentsElement;
					J.classList.add(yi("c")), this.element.appendChild(J), this.contentsElement = J
				}
			}
			class Ze extends ks {
				constructor(l, d) {
					let C = new $t(l, {
							blade: d.blade,
							viewProps: d.viewProps
						}),
						V = new ni;
					super({
						blade: d.blade,
						rackController: C,
						view: new dn(l, {
							contentsElement: C.view.element,
							empty: V.empty,
							viewProps: d.viewProps
						})
					}), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new fe(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = V
				}
				get pageSet() {
					return this.pageSet_
				}
				add(l, d) {
					this.pageSet_.add(l, d)
				}
				remove(l) {
					this.pageSet_.remove(this.pageSet_.items[l])
				}
				onPageAdd_(l) {
					let d = l.item;
					X(this.view.itemsElement, d.itemController.view.element, l.index), d.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(d.contentController, l.index), this.tab.add(d.props.value("selected"))
				}
				onPageRemove_(l) {
					let d = l.item;
					pt(d.itemController.view.element), d.itemController.viewProps.set("parent", null), this.rackController.rack.remove(d.contentController), this.tab.remove(d.props.value("selected"))
				}
			}
			let mr = {
				id: "tab",
				type: "blade",
				accept(m) {
					let l = Q,
						d = tt(m, {
							pages: l.required.array(l.required.object({
								title: l.required.string
							})),
							view: l.required.constant("tab")
						});
					return !d || d.pages.length === 0 ? null : {
						params: d
					}
				},
				controller(m) {
					let l = new Ze(m.document, {
						blade: m.blade,
						viewProps: m.viewProps
					});
					return m.params.pages.forEach(d => {
						let C = new un(m.document, {
							itemProps: O.fromObject({
								selected: !1,
								title: d.title
							}),
							props: O.fromObject({
								selected: !1
							})
						});
						l.add(C)
					}), l
				},
				api(m) {
					return m.controller instanceof Ze ? new $n(m.controller, m.pool) : null
				}
			};

			function Zo(m, l) {
				let d = m.accept(l.params);
				if (!d) return null;
				let C = Q.optional.boolean(l.params.disabled).value,
					V = Q.optional.boolean(l.params.hidden).value;
				return m.controller({
					blade: Lt(),
					document: l.document,
					params: Object.assign(Object.assign({}, d.params), {
						disabled: C,
						hidden: V
					}),
					viewProps: wt.create({
						disabled: C,
						hidden: V
					})
				})
			}
			class Fs {
				constructor() {
					this.disabled = !1, this.emitter = new w
				}
				dispose() {}
				tick() {
					this.disabled || this.emitter.emit("tick", {
						sender: this
					})
				}
			}
			class Jo {
				constructor(l, d) {
					this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = l, this.emitter = new w, this.interval_ = d, this.setTimer_()
				}
				get disabled() {
					return this.disabled_
				}
				set disabled(l) {
					this.disabled_ = l, this.disabled_ ? this.clearTimer_() : this.setTimer_()
				}
				dispose() {
					this.clearTimer_()
				}
				clearTimer_() {
					if (this.timerId_ === null) return;
					let l = this.doc_.defaultView;
					l && l.clearInterval(this.timerId_), this.timerId_ = null
				}
				setTimer_() {
					if (this.clearTimer_(), this.interval_ <= 0) return;
					let l = this.doc_.defaultView;
					l && (this.timerId_ = l.setInterval(this.onTick_, this.interval_))
				}
				onTick_() {
					this.disabled_ || this.emitter.emit("tick", {
						sender: this
					})
				}
			}
			class Ra {
				constructor(l) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.reader = l.reader, this.writer = l.writer, this.emitter = new w, this.value = l.value, this.value.emitter.on("change", this.onValueChange_), this.target = l.target, this.read()
				}
				read() {
					let l = this.target.read();
					l !== void 0 && (this.value.rawValue = this.reader(l))
				}
				write_(l) {
					this.writer(this.target, l)
				}
				onValueChange_(l) {
					this.write_(l.rawValue), this.emitter.emit("change", {
						options: l.options,
						rawValue: l.rawValue,
						sender: this
					})
				}
			}

			function $e(m, l) {
				for (; m.length < l;) m.push(void 0)
			}

			function Ah(m) {
				let l = [];
				return $e(l, m), W(l)
			}

			function Xr(m) {
				let l = m.indexOf(void 0);
				return l < 0 ? m : m.slice(0, l)
			}

			function zi(m, l) {
				let d = [...Xr(m), l];
				return d.length > m.length ? d.splice(0, d.length - m.length) : $e(d, m.length), d
			}
			class pd {
				constructor(l) {
					this.onTick_ = this.onTick_.bind(this), this.reader_ = l.reader, this.target = l.target, this.emitter = new w, this.value = l.value, this.ticker = l.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read()
				}
				dispose() {
					this.ticker.dispose()
				}
				read() {
					let l = this.target.read();
					if (l === void 0) return;
					let d = this.value.rawValue,
						C = this.reader_(l);
					this.value.rawValue = zi(d, C), this.emitter.emit("update", {
						rawValue: C,
						sender: this
					})
				}
				onTick_(l) {
					this.read()
				}
			}
			class Os {
				constructor(l) {
					this.constraints = l
				}
				constrain(l) {
					return this.constraints.reduce((d, C) => C.constrain(d), l)
				}
			}

			function rn(m, l) {
				if (m instanceof l) return m;
				if (m instanceof Os) {
					let d = m.constraints.reduce((C, V) => C || (V instanceof l ? V : null), null);
					if (d) return d
				}
				return null
			}
			class Yr {
				constructor(l) {
					this.values = O.fromObject({
						max: l.max,
						min: l.min
					})
				}
				constrain(l) {
					let d = this.values.get("max"),
						C = this.values.get("min");
					return Math.min(Math.max(l, C), d)
				}
			}
			class Ns {
				constructor(l) {
					this.values = O.fromObject({
						options: l
					})
				}
				get options() {
					return this.values.get("options")
				}
				constrain(l) {
					let d = this.values.get("options");
					return d.length === 0 || d.filter(V => V.value === l).length > 0 ? l : d[0].value
				}
			}
			class Qo {
				constructor(l) {
					this.values = O.fromObject({
						max: l.max,
						min: l.min
					})
				}
				get maxValue() {
					return this.values.get("max")
				}
				get minValue() {
					return this.values.get("min")
				}
				constrain(l) {
					let d = this.values.get("max"),
						C = this.values.get("min"),
						V = l;
					return c(C) || (V = Math.max(V, C)), c(d) || (V = Math.min(V, d)), V
				}
			}
			class Fa {
				constructor(l, d = 0) {
					this.step = l, this.origin = d
				}
				constrain(l) {
					let d = this.origin % this.step,
						C = Math.round((l - d) / this.step);
					return d + C * this.step
				}
			}
			let Kr = S("lst");
			class Dh {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = d.props, this.element = l.createElement("div"), this.element.classList.add(Kr()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("select");
					C.classList.add(Kr("s")), d.viewProps.bindDisabled(C), this.element.appendChild(C), this.selectElement = C;
					let V = l.createElement("div");
					V.classList.add(Kr("m")), V.appendChild(Z(l, "dropdown")), this.element.appendChild(V), d.value.emitter.on("change", this.onValueChange_), this.value_ = d.value, I(this.props_, "options", J => {
						xt(this.selectElement), J.forEach(at => {
							let Ct = l.createElement("option");
							Ct.textContent = at.text, this.selectElement.appendChild(Ct)
						}), this.update_()
					})
				}
				update_() {
					let l = this.props_.get("options").map(d => d.value);
					this.selectElement.selectedIndex = l.indexOf(this.value_.rawValue)
				}
				onValueChange_() {
					this.update_()
				}
			}
			class Vs {
				constructor(l, d) {
					this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = d.props, this.value = d.value, this.viewProps = d.viewProps, this.view = new Dh(l, {
						props: this.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.selectElement.addEventListener("change", this.onSelectChange_)
				}
				onSelectChange_(l) {
					let d = l.currentTarget;
					this.value.rawValue = this.props.get("options")[d.selectedIndex].value
				}
			}
			let Ih = S("pop");
			class fd {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Ih()), d.viewProps.bindClassModifiers(this.element), T(d.shows, F(this.element, Ih(void 0, "v")))
				}
			}
			class Lh {
				constructor(l, d) {
					this.shows = W(!1), this.viewProps = d.viewProps, this.view = new fd(l, {
						shows: this.shows,
						viewProps: this.viewProps
					})
				}
			}
			let kh = S("txt");
			class md {
				constructor(l, d) {
					this.onChange_ = this.onChange_.bind(this), this.element = l.createElement("div"), this.element.classList.add(kh()), d.viewProps.bindClassModifiers(this.element), this.props_ = d.props, this.props_.emitter.on("change", this.onChange_);
					let C = l.createElement("input");
					C.classList.add(kh("i")), C.type = "text", d.viewProps.bindDisabled(C), this.element.appendChild(C), this.inputElement = C, d.value.emitter.on("change", this.onChange_), this.value_ = d.value, this.refresh()
				}
				refresh() {
					let l = this.props_.get("formatter");
					this.inputElement.value = l(this.value_.rawValue)
				}
				onChange_() {
					this.refresh()
				}
			}
			class Oa {
				constructor(l, d) {
					this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = d.parser, this.props = d.props, this.value = d.value, this.viewProps = d.viewProps, this.view = new md(l, {
						props: d.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.inputElement.addEventListener("change", this.onInputChange_)
				}
				onInputChange_(l) {
					let C = l.currentTarget.value,
						V = this.parser_(C);
					c(V) || (this.value.rawValue = V), this.view.refresh()
				}
			}

			function vd(m) {
				return String(m)
			}

			function Rh(m) {
				return m === "false" ? !1 : !!m
			}

			function Fh(m) {
				return vd(m)
			}
			class gd {
				constructor(l) {
					this.text = l
				}
				evaluate() {
					return Number(this.text)
				}
				toString() {
					return this.text
				}
			}
			let _d = {
				"**": (m, l) => Math.pow(m, l),
				"*": (m, l) => m * l,
				"/": (m, l) => m / l,
				"%": (m, l) => m % l,
				"+": (m, l) => m + l,
				"-": (m, l) => m - l,
				"<<": (m, l) => m << l,
				">>": (m, l) => m >> l,
				">>>": (m, l) => m >>> l,
				"&": (m, l) => m & l,
				"^": (m, l) => m ^ l,
				"|": (m, l) => m | l
			};
			class yd {
				constructor(l, d, C) {
					this.left = d, this.operator = l, this.right = C
				}
				evaluate() {
					let l = _d[this.operator];
					if (!l) throw new Error(`unexpected binary operator: '${this.operator}`);
					return l(this.left.evaluate(), this.right.evaluate())
				}
				toString() {
					return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
				}
			}
			let Oh = {
				"+": m => m,
				"-": m => -m,
				"~": m => ~m
			};
			class bd {
				constructor(l, d) {
					this.operator = l, this.expression = d
				}
				evaluate() {
					let l = Oh[this.operator];
					if (!l) throw new Error(`unexpected unary operator: '${this.operator}`);
					return l(this.expression.evaluate())
				}
				toString() {
					return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
				}
			}

			function tl(m) {
				return (l, d) => {
					for (let C = 0; C < m.length; C++) {
						let V = m[C](l, d);
						if (V !== "") return V
					}
					return ""
				}
			}

			function vr(m, l) {
				var d;
				let C = m.substr(l).match(/^\s+/);
				return (d = C && C[0]) !== null && d !== void 0 ? d : ""
			}

			function xd(m, l) {
				let d = m.substr(l, 1);
				return d.match(/^[1-9]$/) ? d : ""
			}

			function zs(m, l) {
				var d;
				let C = m.substr(l).match(/^[0-9]+/);
				return (d = C && C[0]) !== null && d !== void 0 ? d : ""
			}

			function wd(m, l) {
				let d = zs(m, l);
				if (d !== "") return d;
				let C = m.substr(l, 1);
				if (l += 1, C !== "-" && C !== "+") return "";
				let V = zs(m, l);
				return V === "" ? "" : C + V
			}

			function pn(m, l) {
				let d = m.substr(l, 1);
				if (l += 1, d.toLowerCase() !== "e") return "";
				let C = wd(m, l);
				return C === "" ? "" : d + C
			}

			function Nh(m, l) {
				let d = m.substr(l, 1);
				if (d === "0") return d;
				let C = xd(m, l);
				return l += C.length, C === "" ? "" : C + zs(m, l)
			}

			function Sd(m, l) {
				let d = Nh(m, l);
				if (l += d.length, d === "") return "";
				let C = m.substr(l, 1);
				if (l += C.length, C !== ".") return "";
				let V = zs(m, l);
				return l += V.length, d + C + V + pn(m, l)
			}

			function Vh(m, l) {
				let d = m.substr(l, 1);
				if (l += d.length, d !== ".") return "";
				let C = zs(m, l);
				return l += C.length, C === "" ? "" : d + C + pn(m, l)
			}

			function Ed(m, l) {
				let d = Nh(m, l);
				return l += d.length, d === "" ? "" : d + pn(m, l)
			}
			let zh = tl([Sd, Vh, Ed]);

			function el(m, l) {
				var d;
				let C = m.substr(l).match(/^[01]+/);
				return (d = C && C[0]) !== null && d !== void 0 ? d : ""
			}

			function Md(m, l) {
				let d = m.substr(l, 2);
				if (l += d.length, d.toLowerCase() !== "0b") return "";
				let C = el(m, l);
				return C === "" ? "" : d + C
			}

			function Bh(m, l) {
				var d;
				let C = m.substr(l).match(/^[0-7]+/);
				return (d = C && C[0]) !== null && d !== void 0 ? d : ""
			}

			function Bi(m, l) {
				let d = m.substr(l, 2);
				if (l += d.length, d.toLowerCase() !== "0o") return "";
				let C = Bh(m, l);
				return C === "" ? "" : d + C
			}

			function Cd(m, l) {
				var d;
				let C = m.substr(l).match(/^[0-9a-f]+/i);
				return (d = C && C[0]) !== null && d !== void 0 ? d : ""
			}

			function Td(m, l) {
				let d = m.substr(l, 2);
				if (l += d.length, d.toLowerCase() !== "0x") return "";
				let C = Cd(m, l);
				return C === "" ? "" : d + C
			}
			let il = tl([Md, Bi, Td]),
				Pd = tl([il, zh]);

			function qn(m, l) {
				let d = Pd(m, l);
				return l += d.length, d === "" ? null : {
					evaluable: new gd(d),
					cursor: l
				}
			}

			function nl(m, l) {
				let d = m.substr(l, 1);
				if (l += d.length, d !== "(") return null;
				let C = Na(m, l);
				if (!C) return null;
				l = C.cursor, l += vr(m, l).length;
				let V = m.substr(l, 1);
				return l += V.length, V !== ")" ? null : {
					evaluable: C.evaluable,
					cursor: l
				}
			}

			function Ad(m, l) {
				var d;
				return (d = qn(m, l)) !== null && d !== void 0 ? d : nl(m, l)
			}

			function rl(m, l) {
				let d = Ad(m, l);
				if (d) return d;
				let C = m.substr(l, 1);
				if (l += C.length, C !== "+" && C !== "-" && C !== "~") return null;
				let V = rl(m, l);
				return V ? (l = V.cursor, {
					cursor: l,
					evaluable: new bd(C, V.evaluable)
				}) : null
			}

			function Dd(m, l, d) {
				d += vr(l, d).length;
				let C = m.filter(V => l.startsWith(V, d))[0];
				return C ? (d += C.length, d += vr(l, d).length, {
					cursor: d,
					operator: C
				}) : null
			}

			function gr(m, l) {
				return (d, C) => {
					let V = m(d, C);
					if (!V) return null;
					C = V.cursor;
					let J = V.evaluable;
					for (;;) {
						let at = Dd(l, d, C);
						if (!at) break;
						C = at.cursor;
						let Ct = m(d, C);
						if (!Ct) return null;
						C = Ct.cursor, J = new yd(at.operator, J, Ct.evaluable)
					}
					return J ? {
						cursor: C,
						evaluable: J
					} : null
				}
			}
			let Uh = [
				["**"],
				["*", "/", "%"],
				["+", "-"],
				["<<", ">>>", ">>"],
				["&"],
				["^"],
				["|"]
			].reduce((m, l) => gr(m, l), rl);

			function Na(m, l) {
				return l += vr(m, l).length, Uh(m, l)
			}

			function Gh(m) {
				let l = Na(m, 0);
				return !l || l.cursor + vr(m, l.cursor).length !== m.length ? null : l.evaluable
			}

			function fn(m) {
				var l;
				let d = Gh(m);
				return (l = d == null ? void 0 : d.evaluate()) !== null && l !== void 0 ? l : null
			}

			function An(m) {
				if (typeof m == "number") return m;
				if (typeof m == "string") {
					let l = fn(m);
					if (!c(l)) return l
				}
				return 0
			}

			function Id(m) {
				return String(m)
			}

			function Qe(m) {
				return l => l.toFixed(Math.max(Math.min(m, 20), 0))
			}
			let Hh = Qe(0);

			function Bs(m) {
				return Hh(m) + "%"
			}

			function sl(m) {
				return String(m)
			}

			function jn(m) {
				return m
			}

			function Zr({
				primary: m,
				secondary: l,
				forward: d,
				backward: C
			}) {
				let V = !1;

				function J(at) {
					V || (V = !0, at(), V = !1)
				}
				m.emitter.on("change", at => {
					J(() => {
						l.setRawValue(d(m, l), at.options)
					})
				}), l.emitter.on("change", at => {
					J(() => {
						m.setRawValue(C(m, l), at.options)
					}), J(() => {
						l.setRawValue(d(m, l), at.options)
					})
				}), J(() => {
					l.setRawValue(d(m, l), {
						forceEmit: !1,
						last: !0
					})
				})
			}

			function ui(m, l) {
				let d = m * (l.altKey ? .1 : 1) * (l.shiftKey ? 10 : 1);
				return l.upKey ? +d : l.downKey ? -d : 0
			}

			function Us(m) {
				return {
					altKey: m.altKey,
					downKey: m.key === "ArrowDown",
					shiftKey: m.shiftKey,
					upKey: m.key === "ArrowUp"
				}
			}

			function mn(m) {
				return {
					altKey: m.altKey,
					downKey: m.key === "ArrowLeft",
					shiftKey: m.shiftKey,
					upKey: m.key === "ArrowRight"
				}
			}

			function Wh(m) {
				return m === "ArrowUp" || m === "ArrowDown"
			}

			function Va(m) {
				return Wh(m) || m === "ArrowLeft" || m === "ArrowRight"
			}

			function al(m, l) {
				var d, C;
				let V = l.ownerDocument.defaultView,
					J = l.getBoundingClientRect();
				return {
					x: m.pageX - (((d = V && V.scrollX) !== null && d !== void 0 ? d : 0) + J.left),
					y: m.pageY - (((C = V && V.scrollY) !== null && C !== void 0 ? C : 0) + J.top)
				}
			}
			class _r {
				constructor(l) {
					this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = l, this.emitter = new w, l.addEventListener("touchstart", this.onTouchStart_, {
						passive: !1
					}), l.addEventListener("touchmove", this.onTouchMove_, {
						passive: !0
					}), l.addEventListener("touchend", this.onTouchEnd_), l.addEventListener("mousedown", this.onMouseDown_)
				}
				computePosition_(l) {
					let d = this.elem_.getBoundingClientRect();
					return {
						bounds: {
							width: d.width,
							height: d.height
						},
						point: l ? {
							x: l.x,
							y: l.y
						} : null
					}
				}
				onMouseDown_(l) {
					var d;
					l.preventDefault(), (d = l.currentTarget) === null || d === void 0 || d.focus();
					let C = this.elem_.ownerDocument;
					C.addEventListener("mousemove", this.onDocumentMouseMove_), C.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
						altKey: l.altKey,
						data: this.computePosition_(al(l, this.elem_)),
						sender: this,
						shiftKey: l.shiftKey
					})
				}
				onDocumentMouseMove_(l) {
					this.emitter.emit("move", {
						altKey: l.altKey,
						data: this.computePosition_(al(l, this.elem_)),
						sender: this,
						shiftKey: l.shiftKey
					})
				}
				onDocumentMouseUp_(l) {
					let d = this.elem_.ownerDocument;
					d.removeEventListener("mousemove", this.onDocumentMouseMove_), d.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
						altKey: l.altKey,
						data: this.computePosition_(al(l, this.elem_)),
						sender: this,
						shiftKey: l.shiftKey
					})
				}
				onTouchStart_(l) {
					l.preventDefault();
					let d = l.targetTouches.item(0),
						C = this.elem_.getBoundingClientRect();
					this.emitter.emit("down", {
						altKey: l.altKey,
						data: this.computePosition_(d ? {
							x: d.clientX - C.left,
							y: d.clientY - C.top
						} : void 0),
						sender: this,
						shiftKey: l.shiftKey
					}), this.lastTouch_ = d
				}
				onTouchMove_(l) {
					let d = l.targetTouches.item(0),
						C = this.elem_.getBoundingClientRect();
					this.emitter.emit("move", {
						altKey: l.altKey,
						data: this.computePosition_(d ? {
							x: d.clientX - C.left,
							y: d.clientY - C.top
						} : void 0),
						sender: this,
						shiftKey: l.shiftKey
					}), this.lastTouch_ = d
				}
				onTouchEnd_(l) {
					var d;
					let C = (d = l.targetTouches.item(0)) !== null && d !== void 0 ? d : this.lastTouch_,
						V = this.elem_.getBoundingClientRect();
					this.emitter.emit("up", {
						altKey: l.altKey,
						data: this.computePosition_(C ? {
							x: C.clientX - V.left,
							y: C.clientY - V.top
						} : void 0),
						sender: this,
						shiftKey: l.shiftKey
					})
				}
			}

			function Le(m, l, d, C, V) {
				let J = (m - l) / (d - l);
				return C + J * (V - C)
			}

			function ol(m) {
				return String(m.toFixed(10)).split(".")[1].replace(/0+$/, "").length
			}

			function qe(m, l, d) {
				return Math.min(Math.max(m, l), d)
			}

			function Jr(m, l) {
				return (m % l + l) % l
			}
			let Pi = S("txt");
			class ll {
				constructor(l, d) {
					this.onChange_ = this.onChange_.bind(this), this.props_ = d.props, this.props_.emitter.on("change", this.onChange_), this.element = l.createElement("div"), this.element.classList.add(Pi(), Pi(void 0, "num")), d.arrayPosition && this.element.classList.add(Pi(void 0, d.arrayPosition)), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("input");
					C.classList.add(Pi("i")), C.type = "text", d.viewProps.bindDisabled(C), this.element.appendChild(C), this.inputElement = C, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = d.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Pi()), this.inputElement.classList.add(Pi("i"));
					let V = l.createElement("div");
					V.classList.add(Pi("k")), this.element.appendChild(V), this.knobElement = V;
					let J = l.createElementNS(dt, "svg");
					J.classList.add(Pi("g")), this.knobElement.appendChild(J);
					let at = l.createElementNS(dt, "path");
					at.classList.add(Pi("gb")), J.appendChild(at), this.guideBodyElem_ = at;
					let Ct = l.createElementNS(dt, "path");
					Ct.classList.add(Pi("gh")), J.appendChild(Ct), this.guideHeadElem_ = Ct;
					let jt = l.createElement("div");
					jt.classList.add(S("tt")()), this.knobElement.appendChild(jt), this.tooltipElem_ = jt, d.value.emitter.on("change", this.onChange_), this.value = d.value, this.refresh()
				}
				onDraggingChange_(l) {
					if (l.rawValue === null) {
						this.element.classList.remove(Pi(void 0, "drg"));
						return
					}
					this.element.classList.add(Pi(void 0, "drg"));
					let d = l.rawValue / this.props_.get("draggingScale"),
						C = d + (d > 0 ? -1 : d < 0 ? 1 : 0),
						V = qe(-C, -4, 4);
					this.guideHeadElem_.setAttributeNS(null, "d", [`M ${C+V},0 L${C},4 L${C+V},8`, `M ${d},-1 L${d},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${d},4`);
					let J = this.props_.get("formatter");
					this.tooltipElem_.textContent = J(this.value.rawValue), this.tooltipElem_.style.left = `${d}px`
				}
				refresh() {
					let l = this.props_.get("formatter");
					this.inputElement.value = l(this.value.rawValue)
				}
				onChange_() {
					this.refresh()
				}
			}
			class Gs {
				constructor(l, d) {
					var C;
					this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = d.baseStep, this.parser_ = d.parser, this.props = d.props, this.sliderProps_ = (C = d.sliderProps) !== null && C !== void 0 ? C : null, this.value = d.value, this.viewProps = d.viewProps, this.dragging_ = W(null), this.view = new ll(l, {
						arrayPosition: d.arrayPosition,
						dragging: this.dragging_,
						props: this.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
					let V = new _r(this.view.knobElement);
					V.emitter.on("down", this.onPointerDown_), V.emitter.on("move", this.onPointerMove_), V.emitter.on("up", this.onPointerUp_)
				}
				constrainValue_(l) {
					var d, C;
					let V = (d = this.sliderProps_) === null || d === void 0 ? void 0 : d.get("minValue"),
						J = (C = this.sliderProps_) === null || C === void 0 ? void 0 : C.get("maxValue"),
						at = l;
					return V !== void 0 && (at = Math.max(at, V)), J !== void 0 && (at = Math.min(at, J)), at
				}
				onInputChange_(l) {
					let C = l.currentTarget.value,
						V = this.parser_(C);
					c(V) || (this.value.rawValue = this.constrainValue_(V)), this.view.refresh()
				}
				onInputKeyDown_(l) {
					let d = ui(this.baseStep_, Us(l));
					d !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + d), {
						forceEmit: !1,
						last: !1
					})
				}
				onInputKeyUp_(l) {
					ui(this.baseStep_, Us(l)) !== 0 && this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
				onPointerDown_() {
					this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
				}
				computeDraggingValue_(l) {
					if (!l.point) return null;
					let d = l.point.x - l.bounds.width / 2;
					return this.constrainValue_(this.originRawValue_ + d * this.props.get("draggingScale"))
				}
				onPointerMove_(l) {
					let d = this.computeDraggingValue_(l.data);
					d !== null && (this.value.setRawValue(d, {
						forceEmit: !1,
						last: !1
					}), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
				}
				onPointerUp_(l) {
					let d = this.computeDraggingValue_(l.data);
					d !== null && (this.value.setRawValue(d, {
						forceEmit: !0,
						last: !0
					}), this.dragging_.rawValue = null)
				}
			}
			let hl = S("sld");
			class Ai {
				constructor(l, d) {
					this.onChange_ = this.onChange_.bind(this), this.props_ = d.props, this.props_.emitter.on("change", this.onChange_), this.element = l.createElement("div"), this.element.classList.add(hl()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add(hl("t")), d.viewProps.bindTabIndex(C), this.element.appendChild(C), this.trackElement = C;
					let V = l.createElement("div");
					V.classList.add(hl("k")), this.trackElement.appendChild(V), this.knobElement = V, d.value.emitter.on("change", this.onChange_), this.value = d.value, this.update_()
				}
				update_() {
					let l = qe(Le(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
					this.knobElement.style.width = `${l}%`
				}
				onChange_() {
					this.update_()
				}
			}
			class cl {
				constructor(l, d) {
					this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = d.baseStep, this.value = d.value, this.viewProps = d.viewProps, this.props = d.props, this.view = new Ai(l, {
						props: this.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.ptHandler_ = new _r(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
				}
				handlePointerEvent_(l, d) {
					l.point && this.value.setRawValue(Le(qe(l.point.x, 0, l.bounds.width), 0, l.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), d)
				}
				onPointerDownOrMove_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !0,
						last: !0
					})
				}
				onKeyDown_(l) {
					let d = ui(this.baseStep_, mn(l));
					d !== 0 && this.value.setRawValue(this.value.rawValue + d, {
						forceEmit: !1,
						last: !1
					})
				}
				onKeyUp_(l) {
					ui(this.baseStep_, mn(l)) !== 0 && this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			let Hs = S("sldtxt");
			class ul {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Hs());
					let C = l.createElement("div");
					C.classList.add(Hs("s")), this.sliderView_ = d.sliderView, C.appendChild(this.sliderView_.element), this.element.appendChild(C);
					let V = l.createElement("div");
					V.classList.add(Hs("t")), this.textView_ = d.textView, V.appendChild(this.textView_.element), this.element.appendChild(V)
				}
			}
			class za {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.sliderC_ = new cl(l, {
						baseStep: d.baseStep,
						props: d.sliderProps,
						value: d.value,
						viewProps: this.viewProps
					}), this.textC_ = new Gs(l, {
						baseStep: d.baseStep,
						parser: d.parser,
						props: d.textProps,
						sliderProps: d.sliderProps,
						value: d.value,
						viewProps: d.viewProps
					}), this.view = new ul(l, {
						sliderView: this.sliderC_.view,
						textView: this.textC_.view
					})
				}
				get sliderController() {
					return this.sliderC_
				}
				get textController() {
					return this.textC_
				}
			}

			function sn(m, l) {
				m.write(l)
			}

			function Ws(m) {
				let l = Q;
				if (Array.isArray(m)) return l.required.array(l.required.object({
					text: l.required.string,
					value: l.required.raw
				}))(m).value;
				if (typeof m == "object") return l.required.raw(m).value
			}

			function dl(m) {
				if (m === "inline" || m === "popup") return m
			}

			function Dn(m) {
				let l = Q;
				return l.required.object({
					max: l.optional.number,
					min: l.optional.number,
					step: l.optional.number
				})(m).value
			}

			function $h(m) {
				if (Array.isArray(m)) return m;
				let l = [];
				return Object.keys(m).forEach(d => {
					l.push({
						text: d,
						value: m[d]
					})
				}), l
			}

			function pl(m) {
				return c(m) ? null : new Ns($h(m))
			}

			function Ld(m) {
				let l = m ? rn(m, Fa) : null;
				return l ? l.step : null
			}

			function Ba(m, l) {
				let d = m && rn(m, Fa);
				return d ? ol(d.step) : Math.max(ol(l), 2)
			}

			function yr(m) {
				let l = Ld(m);
				return l != null ? l : 1
			}

			function br(m, l) {
				var d;
				let C = m && rn(m, Fa),
					V = Math.abs((d = C == null ? void 0 : C.step) !== null && d !== void 0 ? d : l);
				return V === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(V)) - 1)
			}
			let $s = S("ckb");
			class qs {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.element = l.createElement("div"), this.element.classList.add($s()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("label");
					C.classList.add($s("l")), this.element.appendChild(C);
					let V = l.createElement("input");
					V.classList.add($s("i")), V.type = "checkbox", C.appendChild(V), this.inputElement = V, d.viewProps.bindDisabled(this.inputElement);
					let J = l.createElement("div");
					J.classList.add($s("w")), C.appendChild(J);
					let at = Z(l, "check");
					J.appendChild(at), d.value.emitter.on("change", this.onValueChange_), this.value = d.value, this.update_()
				}
				update_() {
					this.inputElement.checked = this.value.rawValue
				}
				onValueChange_() {
					this.update_()
				}
			}
			class qh {
				constructor(l, d) {
					this.onInputChange_ = this.onInputChange_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.view = new qs(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.view.inputElement.addEventListener("change", this.onInputChange_)
				}
				onInputChange_(l) {
					let d = l.currentTarget;
					this.value.rawValue = d.checked
				}
			}

			function jh(m) {
				let l = [],
					d = pl(m.options);
				return d && l.push(d), new Os(l)
			}
			let Ua = {
					id: "input-bool",
					type: "input",
					accept: (m, l) => {
						if (typeof m != "boolean") return null;
						let C = tt(l, {
							options: Q.optional.custom(Ws)
						});
						return C ? {
							initialValue: m,
							params: C
						} : null
					},
					binding: {
						reader: m => Rh,
						constraint: m => jh(m.params),
						writer: m => sn
					},
					controller: m => {
						let l = m.document,
							d = m.value,
							C = m.constraint,
							V = C && rn(C, Ns);
						return V ? new Vs(l, {
							props: new O({
								options: V.values.value("options")
							}),
							value: d,
							viewProps: m.viewProps
						}) : new qh(l, {
							value: d,
							viewProps: m.viewProps
						})
					}
				},
				xr = S("col");
			class fl {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(xr()), d.foldable.bindExpandedClass(this.element, xr(void 0, "expanded")), I(d.foldable, "completed", F(this.element, xr(void 0, "cpl")));
					let C = l.createElement("div");
					C.classList.add(xr("h")), this.element.appendChild(C);
					let V = l.createElement("div");
					V.classList.add(xr("s")), C.appendChild(V), this.swatchElement = V;
					let J = l.createElement("div");
					if (J.classList.add(xr("t")), C.appendChild(J), this.textElement = J, d.pickerLayout === "inline") {
						let at = l.createElement("div");
						at.classList.add(xr("p")), this.element.appendChild(at), this.pickerElement = at
					} else this.pickerElement = null
				}
			}

			function kd(m, l, d) {
				let C = qe(m / 255, 0, 1),
					V = qe(l / 255, 0, 1),
					J = qe(d / 255, 0, 1),
					at = Math.max(C, V, J),
					Ct = Math.min(C, V, J),
					jt = at - Ct,
					Kt = 0,
					Ee = 0,
					Me = (Ct + at) / 2;
				return jt !== 0 && (Ee = jt / (1 - Math.abs(at + Ct - 1)), C === at ? Kt = (V - J) / jt : V === at ? Kt = 2 + (J - C) / jt : Kt = 4 + (C - V) / jt, Kt = Kt / 6 + (Kt < 0 ? 1 : 0)), [Kt * 360, Ee * 100, Me * 100]
			}

			function Rd(m, l, d) {
				let C = (m % 360 + 360) % 360,
					V = qe(l / 100, 0, 1),
					J = qe(d / 100, 0, 1),
					at = (1 - Math.abs(2 * J - 1)) * V,
					Ct = at * (1 - Math.abs(C / 60 % 2 - 1)),
					jt = J - at / 2,
					Kt, Ee, Me;
				return C >= 0 && C < 60 ? [Kt, Ee, Me] = [at, Ct, 0] : C >= 60 && C < 120 ? [Kt, Ee, Me] = [Ct, at, 0] : C >= 120 && C < 180 ? [Kt, Ee, Me] = [0, at, Ct] : C >= 180 && C < 240 ? [Kt, Ee, Me] = [0, Ct, at] : C >= 240 && C < 300 ? [Kt, Ee, Me] = [Ct, 0, at] : [Kt, Ee, Me] = [at, 0, Ct], [(Kt + jt) * 255, (Ee + jt) * 255, (Me + jt) * 255]
			}

			function Fd(m, l, d) {
				let C = qe(m / 255, 0, 1),
					V = qe(l / 255, 0, 1),
					J = qe(d / 255, 0, 1),
					at = Math.max(C, V, J),
					Ct = Math.min(C, V, J),
					jt = at - Ct,
					Kt;
				jt === 0 ? Kt = 0 : at === C ? Kt = 60 * (((V - J) / jt % 6 + 6) % 6) : at === V ? Kt = 60 * ((J - C) / jt + 2) : Kt = 60 * ((C - V) / jt + 4);
				let Ee = at === 0 ? 0 : jt / at,
					Me = at;
				return [Kt, Ee * 100, Me * 100]
			}

			function Xh(m, l, d) {
				let C = Jr(m, 360),
					V = qe(l / 100, 0, 1),
					J = qe(d / 100, 0, 1),
					at = J * V,
					Ct = at * (1 - Math.abs(C / 60 % 2 - 1)),
					jt = J - at,
					Kt, Ee, Me;
				return C >= 0 && C < 60 ? [Kt, Ee, Me] = [at, Ct, 0] : C >= 60 && C < 120 ? [Kt, Ee, Me] = [Ct, at, 0] : C >= 120 && C < 180 ? [Kt, Ee, Me] = [0, at, Ct] : C >= 180 && C < 240 ? [Kt, Ee, Me] = [0, Ct, at] : C >= 240 && C < 300 ? [Kt, Ee, Me] = [Ct, 0, at] : [Kt, Ee, Me] = [at, 0, Ct], [(Kt + jt) * 255, (Ee + jt) * 255, (Me + jt) * 255]
			}

			function R(m, l, d) {
				let C = d + l * (100 - Math.abs(2 * d - 100)) / 200;
				return [m, C !== 0 ? l * (100 - Math.abs(2 * d - 100)) / C : 0, d + l * (100 - Math.abs(2 * d - 100)) / (2 * 100)]
			}

			function E(m, l, d) {
				let C = 100 - Math.abs(d * (200 - l) / 100 - 100);
				return [m, C !== 0 ? l * d / C : 0, d * (200 - l) / (2 * 100)]
			}

			function P(m) {
				return [m[0], m[1], m[2]]
			}

			function N(m, l) {
				return [m[0], m[1], m[2], l]
			}
			let Y = {
				hsl: {
					hsl: (m, l, d) => [m, l, d],
					hsv: R,
					rgb: Rd
				},
				hsv: {
					hsl: E,
					hsv: (m, l, d) => [m, l, d],
					rgb: Xh
				},
				rgb: {
					hsl: kd,
					hsv: Fd,
					rgb: (m, l, d) => [m, l, d]
				}
			};

			function st(m, l) {
				return [l === "float" ? 1 : m === "rgb" ? 255 : 360, l === "float" ? 1 : m === "rgb" ? 255 : 100, l === "float" ? 1 : m === "rgb" ? 255 : 100]
			}

			function ft(m, l) {
				return m === l ? l : Jr(m, l)
			}

			function Tt(m, l, d) {
				var C;
				let V = st(l, d);
				return [l === "rgb" ? qe(m[0], 0, V[0]) : ft(m[0], V[0]), qe(m[1], 0, V[1]), qe(m[2], 0, V[2]), qe((C = m[3]) !== null && C !== void 0 ? C : 1, 0, 1)]
			}

			function me(m, l, d, C) {
				let V = st(l, d),
					J = st(l, C);
				return m.map((at, Ct) => at / V[Ct] * J[Ct])
			}

			function Ui(m, l, d) {
				let C = me(m, l.mode, l.type, "int"),
					V = Y[l.mode][d.mode](...C);
				return me(V, d.mode, "int", d.type)
			}

			function Gi(m, l) {
				return typeof m != "object" || c(m) ? !1 : l in m && typeof m[l] == "number"
			}
			class ae {
				static black(l = "int") {
					return new ae([0, 0, 0], "rgb", l)
				}
				static fromObject(l, d = "int") {
					let C = "a" in l ? [l.r, l.g, l.b, l.a] : [l.r, l.g, l.b];
					return new ae(C, "rgb", d)
				}
				static toRgbaObject(l, d = "int") {
					return l.toRgbaObject(d)
				}
				static isRgbColorObject(l) {
					return Gi(l, "r") && Gi(l, "g") && Gi(l, "b")
				}
				static isRgbaColorObject(l) {
					return this.isRgbColorObject(l) && Gi(l, "a")
				}
				static isColorObject(l) {
					return this.isRgbColorObject(l)
				}
				static equals(l, d) {
					if (l.mode !== d.mode) return !1;
					let C = l.comps_,
						V = d.comps_;
					for (let J = 0; J < C.length; J++)
						if (C[J] !== V[J]) return !1;
					return !0
				}
				constructor(l, d, C = "int") {
					this.mode = d, this.type = C, this.comps_ = Tt(l, d, C)
				}
				getComponents(l, d = "int") {
					return N(Ui(P(this.comps_), {
						mode: this.mode,
						type: this.type
					}, {
						mode: l != null ? l : this.mode,
						type: d
					}), this.comps_[3])
				}
				toRgbaObject(l = "int") {
					let d = this.getComponents("rgb", l);
					return {
						r: d[0],
						g: d[1],
						b: d[2],
						a: d[3]
					}
				}
			}
			let Xn = S("colp");
			class Od {
				constructor(l, d) {
					this.alphaViews_ = null, this.element = l.createElement("div"), this.element.classList.add(Xn()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add(Xn("hsv"));
					let V = l.createElement("div");
					V.classList.add(Xn("sv")), this.svPaletteView_ = d.svPaletteView, V.appendChild(this.svPaletteView_.element), C.appendChild(V);
					let J = l.createElement("div");
					J.classList.add(Xn("h")), this.hPaletteView_ = d.hPaletteView, J.appendChild(this.hPaletteView_.element), C.appendChild(J), this.element.appendChild(C);
					let at = l.createElement("div");
					if (at.classList.add(Xn("rgb")), this.textView_ = d.textView, at.appendChild(this.textView_.element), this.element.appendChild(at), d.alphaViews) {
						this.alphaViews_ = {
							palette: d.alphaViews.palette,
							text: d.alphaViews.text
						};
						let Ct = l.createElement("div");
						Ct.classList.add(Xn("a"));
						let jt = l.createElement("div");
						jt.classList.add(Xn("ap")), jt.appendChild(this.alphaViews_.palette.element), Ct.appendChild(jt);
						let Kt = l.createElement("div");
						Kt.classList.add(Xn("at")), Kt.appendChild(this.alphaViews_.text.element), Ct.appendChild(Kt), this.element.appendChild(Ct)
					}
				}
				get allFocusableElements() {
					let l = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map(d => d.inputElement)];
					return this.alphaViews_ && l.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), l
				}
			}

			function Ax(m) {
				return m === "int" ? "int" : m === "float" ? "float" : void 0
			}

			function Nd(m) {
				let l = Q;
				return tt(m, {
					alpha: l.optional.boolean,
					color: l.optional.object({
						alpha: l.optional.boolean,
						type: l.optional.custom(Ax)
					}),
					expanded: l.optional.boolean,
					picker: l.optional.custom(dl)
				})
			}

			function js(m) {
				return m ? .1 : 1
			}

			function Xs(m) {
				var l;
				return (l = m.color) === null || l === void 0 ? void 0 : l.type
			}

			function Dx(m, l) {
				return m.alpha === l.alpha && m.mode === l.mode && m.notation === l.notation && m.type === l.type
			}

			function vn(m, l) {
				let d = m.match(/^(.+)%$/);
				return Math.min(d ? parseFloat(d[1]) * .01 * l : parseFloat(m), l)
			}
			let Ix = {
				deg: m => m,
				grad: m => m * 360 / 400,
				rad: m => m * 360 / (2 * Math.PI),
				turn: m => m * 360
			};

			function dv(m) {
				let l = m.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
				if (!l) return parseFloat(m);
				let d = parseFloat(l[1]),
					C = l[2];
				return Ix[C](d)
			}

			function pv(m) {
				let l = m.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
				if (!l) return null;
				let d = [vn(l[1], 255), vn(l[2], 255), vn(l[3], 255)];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) ? null : d
			}

			function fv(m) {
				return l => {
					let d = pv(l);
					return d ? new ae(d, "rgb", m) : null
				}
			}

			function mv(m) {
				let l = m.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
				if (!l) return null;
				let d = [vn(l[1], 255), vn(l[2], 255), vn(l[3], 255), vn(l[4], 1)];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) || isNaN(d[3]) ? null : d
			}

			function vv(m) {
				return l => {
					let d = mv(l);
					return d ? new ae(d, "rgb", m) : null
				}
			}

			function gv(m) {
				let l = m.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
				if (!l) return null;
				let d = [dv(l[1]), vn(l[2], 100), vn(l[3], 100)];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) ? null : d
			}

			function _v(m) {
				return l => {
					let d = gv(l);
					return d ? new ae(d, "hsl", m) : null
				}
			}

			function yv(m) {
				let l = m.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
				if (!l) return null;
				let d = [dv(l[1]), vn(l[2], 100), vn(l[3], 100), vn(l[4], 1)];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) || isNaN(d[3]) ? null : d
			}

			function bv(m) {
				return l => {
					let d = yv(l);
					return d ? new ae(d, "hsl", m) : null
				}
			}

			function xv(m) {
				let l = m.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
				if (l) return [parseInt(l[1] + l[1], 16), parseInt(l[2] + l[2], 16), parseInt(l[3] + l[3], 16)];
				let d = m.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
				return d ? [parseInt(d[1], 16), parseInt(d[2], 16), parseInt(d[3], 16)] : null
			}

			function Lx(m) {
				let l = xv(m);
				return l ? new ae(l, "rgb", "int") : null
			}

			function wv(m) {
				let l = m.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
				if (l) return [parseInt(l[1] + l[1], 16), parseInt(l[2] + l[2], 16), parseInt(l[3] + l[3], 16), Le(parseInt(l[4] + l[4], 16), 0, 255, 0, 1)];
				let d = m.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
				return d ? [parseInt(d[1], 16), parseInt(d[2], 16), parseInt(d[3], 16), Le(parseInt(d[4], 16), 0, 255, 0, 1)] : null
			}

			function kx(m) {
				let l = wv(m);
				return l ? new ae(l, "rgb", "int") : null
			}

			function Sv(m) {
				let l = m.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
				if (!l) return null;
				let d = [parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) ? null : d
			}

			function Ev(m) {
				return l => {
					let d = Sv(l);
					return d ? new ae(d, "rgb", m) : null
				}
			}

			function Mv(m) {
				let l = m.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
				if (!l) return null;
				let d = [parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3]), parseFloat(l[4])];
				return isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]) || isNaN(d[3]) ? null : d
			}

			function Cv(m) {
				return l => {
					let d = Mv(l);
					return d ? new ae(d, "rgb", m) : null
				}
			}
			let Rx = [{
				parser: xv,
				result: {
					alpha: !1,
					mode: "rgb",
					notation: "hex"
				}
			}, {
				parser: wv,
				result: {
					alpha: !0,
					mode: "rgb",
					notation: "hex"
				}
			}, {
				parser: pv,
				result: {
					alpha: !1,
					mode: "rgb",
					notation: "func"
				}
			}, {
				parser: mv,
				result: {
					alpha: !0,
					mode: "rgb",
					notation: "func"
				}
			}, {
				parser: gv,
				result: {
					alpha: !1,
					mode: "hsl",
					notation: "func"
				}
			}, {
				parser: yv,
				result: {
					alpha: !0,
					mode: "hsl",
					notation: "func"
				}
			}, {
				parser: Sv,
				result: {
					alpha: !1,
					mode: "rgb",
					notation: "object"
				}
			}, {
				parser: Mv,
				result: {
					alpha: !0,
					mode: "rgb",
					notation: "object"
				}
			}];

			function Fx(m) {
				return Rx.reduce((l, {
					parser: d,
					result: C
				}) => l || (d(m) ? C : null), null)
			}

			function Vd(m, l = "int") {
				let d = Fx(m);
				return d ? d.notation === "hex" && l !== "float" ? Object.assign(Object.assign({}, d), {
					type: "int"
				}) : d.notation === "func" ? Object.assign(Object.assign({}, d), {
					type: l
				}) : null : null
			}
			let Tv = {
				int: [Lx, kx, fv("int"), vv("int"), _v("int"), bv("int"), Ev("int"), Cv("int")],
				float: [fv("float"), vv("float"), _v("float"), bv("float"), Ev("float"), Cv("float")]
			};

			function Ox(m) {
				let l = Tv[m];
				return d => {
					if (typeof d != "string") return ae.black(m);
					let C = l.reduce((V, J) => V || J(d), null);
					return C != null ? C : ae.black(m)
				}
			}

			function zd(m) {
				let l = Tv[m];
				return d => l.reduce((C, V) => C || V(d), null)
			}

			function Pv(m) {
				let l = qe(Math.floor(m), 0, 255).toString(16);
				return l.length === 1 ? `0${l}` : l
			}

			function Av(m, l = "#") {
				let d = P(m.getComponents("rgb")).map(Pv).join("");
				return `${l}${d}`
			}

			function Bd(m, l = "#") {
				let d = m.getComponents("rgb"),
					C = [d[0], d[1], d[2], d[3] * 255].map(Pv).join("");
				return `${l}${C}`
			}

			function Dv(m, l) {
				let d = Qe(l === "float" ? 2 : 0);
				return `rgb(${P(m.getComponents("rgb",l)).map(V=>d(V)).join(", ")})`
			}

			function Nx(m) {
				return l => Dv(l, m)
			}

			function Yh(m, l) {
				let d = Qe(2),
					C = Qe(l === "float" ? 2 : 0);
				return `rgba(${m.getComponents("rgb",l).map((J,at)=>(at===3?d:C)(J)).join(", ")})`
			}

			function Vx(m) {
				return l => Yh(l, m)
			}

			function zx(m) {
				let l = [Qe(0), Bs, Bs];
				return `hsl(${P(m.getComponents("hsl")).map((C,V)=>l[V](C)).join(", ")})`
			}

			function Bx(m) {
				let l = [Qe(0), Bs, Bs, Qe(2)];
				return `hsla(${m.getComponents("hsl").map((C,V)=>l[V](C)).join(", ")})`
			}

			function Iv(m, l) {
				let d = Qe(l === "float" ? 2 : 0),
					C = ["r", "g", "b"];
				return `{${P(m.getComponents("rgb",l)).map((J,at)=>`${C[at]}: ${d(J)}`).join(", ")}}`
			}

			function Ux(m) {
				return l => Iv(l, m)
			}

			function Lv(m, l) {
				let d = Qe(2),
					C = Qe(l === "float" ? 2 : 0),
					V = ["r", "g", "b", "a"];
				return `{${m.getComponents("rgb",l).map((at,Ct)=>{let jt=Ct===3?d:C;return`${V[Ct]}: ${jt(at)}`}).join(", ")}}`
			}

			function Gx(m) {
				return l => Lv(l, m)
			}
			let Hx = [{
				format: {
					alpha: !1,
					mode: "rgb",
					notation: "hex",
					type: "int"
				},
				stringifier: Av
			}, {
				format: {
					alpha: !0,
					mode: "rgb",
					notation: "hex",
					type: "int"
				},
				stringifier: Bd
			}, {
				format: {
					alpha: !1,
					mode: "hsl",
					notation: "func",
					type: "int"
				},
				stringifier: zx
			}, {
				format: {
					alpha: !0,
					mode: "hsl",
					notation: "func",
					type: "int"
				},
				stringifier: Bx
			}, ...["int", "float"].reduce((m, l) => [...m, {
				format: {
					alpha: !1,
					mode: "rgb",
					notation: "func",
					type: l
				},
				stringifier: Nx(l)
			}, {
				format: {
					alpha: !0,
					mode: "rgb",
					notation: "func",
					type: l
				},
				stringifier: Vx(l)
			}, {
				format: {
					alpha: !1,
					mode: "rgb",
					notation: "object",
					type: l
				},
				stringifier: Ux(l)
			}, {
				format: {
					alpha: !0,
					mode: "rgb",
					notation: "object",
					type: l
				},
				stringifier: Gx(l)
			}], [])];

			function Ud(m) {
				return Hx.reduce((l, d) => l || (Dx(d.format, m) ? d.stringifier : null), null)
			}
			let ml = S("apl");
			class Wx {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.value = d.value, this.value.emitter.on("change", this.onValueChange_), this.element = l.createElement("div"), this.element.classList.add(ml()), d.viewProps.bindClassModifiers(this.element), d.viewProps.bindTabIndex(this.element);
					let C = l.createElement("div");
					C.classList.add(ml("b")), this.element.appendChild(C);
					let V = l.createElement("div");
					V.classList.add(ml("c")), C.appendChild(V), this.colorElem_ = V;
					let J = l.createElement("div");
					J.classList.add(ml("m")), this.element.appendChild(J), this.markerElem_ = J;
					let at = l.createElement("div");
					at.classList.add(ml("p")), this.markerElem_.appendChild(at), this.previewElem_ = at, this.update_()
				}
				update_() {
					let l = this.value.rawValue,
						d = l.getComponents("rgb"),
						C = new ae([d[0], d[1], d[2], 0], "rgb"),
						V = new ae([d[0], d[1], d[2], 255], "rgb"),
						J = ["to right", Yh(C), Yh(V)];
					this.colorElem_.style.background = `linear-gradient(${J.join(",")})`, this.previewElem_.style.backgroundColor = Yh(l);
					let at = Le(d[3], 0, 1, 0, 100);
					this.markerElem_.style.left = `${at}%`
				}
				onValueChange_() {
					this.update_()
				}
			}
			class $x {
				constructor(l, d) {
					this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.view = new Wx(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.ptHandler_ = new _r(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
				}
				handlePointerEvent_(l, d) {
					if (!l.point) return;
					let C = l.point.x / l.bounds.width,
						V = this.value.rawValue,
						[J, at, Ct] = V.getComponents("hsv");
					this.value.setRawValue(new ae([J, at, Ct, C], "hsv"), d)
				}
				onPointerDown_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerMove_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !0,
						last: !0
					})
				}
				onKeyDown_(l) {
					let d = ui(js(!0), mn(l));
					if (d === 0) return;
					let C = this.value.rawValue,
						[V, J, at, Ct] = C.getComponents("hsv");
					this.value.setRawValue(new ae([V, J, at, Ct + d], "hsv"), {
						forceEmit: !1,
						last: !1
					})
				}
				onKeyUp_(l) {
					ui(js(!0), mn(l)) !== 0 && this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			let Ga = S("coltxt");

			function qx(m) {
				let l = m.createElement("select"),
					d = [{
						text: "RGB",
						value: "rgb"
					}, {
						text: "HSL",
						value: "hsl"
					}, {
						text: "HSV",
						value: "hsv"
					}];
				return l.appendChild(d.reduce((C, V) => {
					let J = m.createElement("option");
					return J.textContent = V.text, J.value = V.value, C.appendChild(J), C
				}, m.createDocumentFragment())), l
			}
			class jx {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Ga()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add(Ga("m")), this.modeElem_ = qx(l), this.modeElem_.classList.add(Ga("ms")), C.appendChild(this.modeSelectElement), d.viewProps.bindDisabled(this.modeElem_);
					let V = l.createElement("div");
					V.classList.add(Ga("mm")), V.appendChild(Z(l, "dropdown")), C.appendChild(V), this.element.appendChild(C);
					let J = l.createElement("div");
					J.classList.add(Ga("w")), this.element.appendChild(J), this.textsElem_ = J, this.textViews_ = d.textViews, this.applyTextViews_(), T(d.colorMode, at => {
						this.modeElem_.value = at
					})
				}
				get modeSelectElement() {
					return this.modeElem_
				}
				get textViews() {
					return this.textViews_
				}
				set textViews(l) {
					this.textViews_ = l, this.applyTextViews_()
				}
				applyTextViews_() {
					xt(this.textsElem_);
					let l = this.element.ownerDocument;
					this.textViews_.forEach(d => {
						let C = l.createElement("div");
						C.classList.add(Ga("c")), C.appendChild(d.element), this.textsElem_.appendChild(C)
					})
				}
			}

			function Xx(m) {
				return Qe(m === "float" ? 2 : 0)
			}

			function Yx(m, l, d) {
				let C = st(m, l)[d];
				return new Yr({
					min: 0,
					max: C
				})
			}

			function Gd(m, l, d) {
				return new Gs(m, {
					arrayPosition: d === 0 ? "fst" : d === 3 - 1 ? "lst" : "mid",
					baseStep: js(!1),
					parser: l.parser,
					props: O.fromObject({
						draggingScale: l.colorType === "float" ? .01 : 1,
						formatter: Xx(l.colorType)
					}),
					value: W(0, {
						constraint: Yx(l.colorMode, l.colorType, d)
					}),
					viewProps: l.viewProps
				})
			}
			class Kx {
				constructor(l, d) {
					this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = d.colorType, this.parser_ = d.parser, this.value = d.value, this.viewProps = d.viewProps, this.colorMode = W(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(l), this.view = new jx(l, {
						colorMode: this.colorMode,
						textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
						viewProps: this.viewProps
					}), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
				}
				createComponentControllers_(l) {
					let d = {
							colorMode: this.colorMode.rawValue,
							colorType: this.colorType_,
							parser: this.parser_,
							viewProps: this.viewProps
						},
						C = [Gd(l, d, 0), Gd(l, d, 1), Gd(l, d, 2)];
					return C.forEach((V, J) => {
						Zr({
							primary: this.value,
							secondary: V.value,
							forward: at => at.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[J],
							backward: (at, Ct) => {
								let jt = this.colorMode.rawValue,
									Kt = at.rawValue.getComponents(jt, this.colorType_);
								return Kt[J] = Ct.rawValue, new ae(N(P(Kt), Kt[3]), jt, this.colorType_)
							}
						})
					}), C
				}
				onModeSelectChange_(l) {
					let d = l.currentTarget;
					this.colorMode.rawValue = d.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
				}
			}
			let Hd = S("hpl");
			class Zx {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.value = d.value, this.value.emitter.on("change", this.onValueChange_), this.element = l.createElement("div"), this.element.classList.add(Hd()), d.viewProps.bindClassModifiers(this.element), d.viewProps.bindTabIndex(this.element);
					let C = l.createElement("div");
					C.classList.add(Hd("c")), this.element.appendChild(C);
					let V = l.createElement("div");
					V.classList.add(Hd("m")), this.element.appendChild(V), this.markerElem_ = V, this.update_()
				}
				update_() {
					let l = this.value.rawValue,
						[d] = l.getComponents("hsv");
					this.markerElem_.style.backgroundColor = Dv(new ae([d, 100, 100], "hsv"));
					let C = Le(d, 0, 360, 0, 100);
					this.markerElem_.style.left = `${C}%`
				}
				onValueChange_() {
					this.update_()
				}
			}
			class Jx {
				constructor(l, d) {
					this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.view = new Zx(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.ptHandler_ = new _r(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
				}
				handlePointerEvent_(l, d) {
					if (!l.point) return;
					let C = Le(qe(l.point.x, 0, l.bounds.width), 0, l.bounds.width, 0, 360),
						V = this.value.rawValue,
						[, J, at, Ct] = V.getComponents("hsv");
					this.value.setRawValue(new ae([C, J, at, Ct], "hsv"), d)
				}
				onPointerDown_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerMove_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !0,
						last: !0
					})
				}
				onKeyDown_(l) {
					let d = ui(js(!1), mn(l));
					if (d === 0) return;
					let C = this.value.rawValue,
						[V, J, at, Ct] = C.getComponents("hsv");
					this.value.setRawValue(new ae([V + d, J, at, Ct], "hsv"), {
						forceEmit: !1,
						last: !1
					})
				}
				onKeyUp_(l) {
					ui(js(!1), mn(l)) !== 0 && this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			let Wd = S("svp"),
				kv = 64;
			class Qx {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), this.value = d.value, this.value.emitter.on("change", this.onValueChange_), this.element = l.createElement("div"), this.element.classList.add(Wd()), d.viewProps.bindClassModifiers(this.element), d.viewProps.bindTabIndex(this.element);
					let C = l.createElement("canvas");
					C.height = kv, C.width = kv, C.classList.add(Wd("c")), this.element.appendChild(C), this.canvasElement = C;
					let V = l.createElement("div");
					V.classList.add(Wd("m")), this.element.appendChild(V), this.markerElem_ = V, this.update_()
				}
				update_() {
					let l = le(this.canvasElement);
					if (!l) return;
					let C = this.value.rawValue.getComponents("hsv"),
						V = this.canvasElement.width,
						J = this.canvasElement.height,
						at = l.getImageData(0, 0, V, J),
						Ct = at.data;
					for (let Ee = 0; Ee < J; Ee++)
						for (let Me = 0; Me < V; Me++) {
							let Ys = Le(Me, 0, V, 0, 100),
								gl = Le(Ee, 0, J, 100, 0),
								_l = Xh(C[0], Ys, gl),
								Kh = (Ee * V + Me) * 4;
							Ct[Kh] = _l[0], Ct[Kh + 1] = _l[1], Ct[Kh + 2] = _l[2], Ct[Kh + 3] = 255
						}
					l.putImageData(at, 0, 0);
					let jt = Le(C[1], 0, 100, 0, 100);
					this.markerElem_.style.left = `${jt}%`;
					let Kt = Le(C[2], 0, 100, 100, 0);
					this.markerElem_.style.top = `${Kt}%`
				}
				onValueChange_() {
					this.update_()
				}
			}
			class tw {
				constructor(l, d) {
					this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.view = new Qx(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.ptHandler_ = new _r(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
				}
				handlePointerEvent_(l, d) {
					if (!l.point) return;
					let C = Le(l.point.x, 0, l.bounds.width, 0, 100),
						V = Le(l.point.y, 0, l.bounds.height, 100, 0),
						[J, , , at] = this.value.rawValue.getComponents("hsv");
					this.value.setRawValue(new ae([J, C, V, at], "hsv"), d)
				}
				onPointerDown_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerMove_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !0,
						last: !0
					})
				}
				onKeyDown_(l) {
					Va(l.key) && l.preventDefault();
					let [d, C, V, J] = this.value.rawValue.getComponents("hsv"), at = js(!1), Ct = ui(at, mn(l)), jt = ui(at, Us(l));
					Ct === 0 && jt === 0 || this.value.setRawValue(new ae([d, C + Ct, V + jt, J], "hsv"), {
						forceEmit: !1,
						last: !1
					})
				}
				onKeyUp_(l) {
					let d = js(!1),
						C = ui(d, mn(l)),
						V = ui(d, Us(l));
					C === 0 && V === 0 || this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			class ew {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.hPaletteC_ = new Jx(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.svPaletteC_ = new tw(l, {
						value: this.value,
						viewProps: this.viewProps
					}), this.alphaIcs_ = d.supportsAlpha ? {
						palette: new $x(l, {
							value: this.value,
							viewProps: this.viewProps
						}),
						text: new Gs(l, {
							parser: fn,
							baseStep: .1,
							props: O.fromObject({
								draggingScale: .01,
								formatter: Qe(2)
							}),
							value: W(0, {
								constraint: new Yr({
									min: 0,
									max: 1
								})
							}),
							viewProps: this.viewProps
						})
					} : null, this.alphaIcs_ && Zr({
						primary: this.value,
						secondary: this.alphaIcs_.text.value,
						forward: C => C.rawValue.getComponents()[3],
						backward: (C, V) => {
							let J = C.rawValue.getComponents();
							return J[3] = V.rawValue, new ae(J, C.rawValue.mode)
						}
					}), this.textC_ = new Kx(l, {
						colorType: d.colorType,
						parser: fn,
						value: this.value,
						viewProps: this.viewProps
					}), this.view = new Od(l, {
						alphaViews: this.alphaIcs_ ? {
							palette: this.alphaIcs_.palette.view,
							text: this.alphaIcs_.text.view
						} : null,
						hPaletteView: this.hPaletteC_.view,
						supportsAlpha: d.supportsAlpha,
						svPaletteView: this.svPaletteC_.view,
						textView: this.textC_.view,
						viewProps: this.viewProps
					})
				}
				get textController() {
					return this.textC_
				}
			}
			let $d = S("colsw");
			class iw {
				constructor(l, d) {
					this.onValueChange_ = this.onValueChange_.bind(this), d.value.emitter.on("change", this.onValueChange_), this.value = d.value, this.element = l.createElement("div"), this.element.classList.add($d()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add($d("sw")), this.element.appendChild(C), this.swatchElem_ = C;
					let V = l.createElement("button");
					V.classList.add($d("b")), d.viewProps.bindDisabled(V), this.element.appendChild(V), this.buttonElement = V, this.update_()
				}
				update_() {
					let l = this.value.rawValue;
					this.swatchElem_.style.backgroundColor = Bd(l)
				}
				onValueChange_() {
					this.update_()
				}
			}
			class nw {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.view = new iw(l, {
						value: this.value,
						viewProps: this.viewProps
					})
				}
			}
			class qd {
				constructor(l, d) {
					this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.foldable_ = Nt.create(d.expanded), this.swatchC_ = new nw(l, {
						value: this.value,
						viewProps: this.viewProps
					});
					let C = this.swatchC_.view.buttonElement;
					C.addEventListener("blur", this.onButtonBlur_), C.addEventListener("click", this.onButtonClick_), this.textC_ = new Oa(l, {
						parser: d.parser,
						props: O.fromObject({
							formatter: d.formatter
						}),
						value: this.value,
						viewProps: this.viewProps
					}), this.view = new fl(l, {
						foldable: this.foldable_,
						pickerLayout: d.pickerLayout
					}), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = d.pickerLayout === "popup" ? new Lh(l, {
						viewProps: this.viewProps
					}) : null;
					let V = new ew(l, {
						colorType: d.colorType,
						supportsAlpha: d.supportsAlpha,
						value: this.value,
						viewProps: this.viewProps
					});
					V.view.allFocusableElements.forEach(J => {
						J.addEventListener("blur", this.onPopupChildBlur_), J.addEventListener("keydown", this.onPopupChildKeydown_)
					}), this.pickerC_ = V, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(V.view.element), Zr({
						primary: this.foldable_.value("expanded"),
						secondary: this.popC_.shows,
						forward: J => J.rawValue,
						backward: (J, at) => at.rawValue
					})) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Ie(this.foldable_, this.view.pickerElement))
				}
				get textController() {
					return this.textC_
				}
				onButtonBlur_(l) {
					if (!this.popC_) return;
					let d = this.view.element,
						C = l.relatedTarget;
					(!C || !d.contains(C)) && (this.popC_.shows.rawValue = !1)
				}
				onButtonClick_() {
					this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
				}
				onPopupChildBlur_(l) {
					if (!this.popC_) return;
					let d = this.popC_.view.element,
						C = Pt(l);
					C && d.contains(C) || C && C === this.swatchC_.view.buttonElement && !re(d.ownerDocument) || (this.popC_.shows.rawValue = !1)
				}
				onPopupChildKeydown_(l) {
					this.popC_ ? l.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && l.key === "Escape" && this.swatchC_.view.buttonElement.focus()
				}
			}

			function rw(m, l) {
				return ae.isColorObject(m) ? ae.fromObject(m, l) : ae.black(l)
			}

			function sw(m) {
				return P(m.getComponents("rgb")).reduce((l, d) => l << 8 | Math.floor(d) & 255, 0)
			}

			function aw(m) {
				return m.getComponents("rgb").reduce((l, d, C) => {
					let V = Math.floor(C === 3 ? d * 255 : d) & 255;
					return l << 8 | V
				}, 0) >>> 0
			}

			function ow(m) {
				return new ae([m >> 16 & 255, m >> 8 & 255, m & 255], "rgb")
			}

			function lw(m) {
				return new ae([m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, Le(m & 255, 0, 255, 0, 1)], "rgb")
			}

			function hw(m) {
				return typeof m != "number" ? ae.black() : ow(m)
			}

			function cw(m) {
				return typeof m != "number" ? ae.black() : lw(m)
			}

			function uw(m) {
				let l = Ud(m);
				return l ? (d, C) => {
					sn(d, l(C))
				} : null
			}

			function dw(m) {
				let l = m ? aw : sw;
				return (d, C) => {
					sn(d, l(C))
				}
			}

			function pw(m, l, d) {
				let C = l.toRgbaObject(d);
				m.writeProperty("r", C.r), m.writeProperty("g", C.g), m.writeProperty("b", C.b), m.writeProperty("a", C.a)
			}

			function fw(m, l, d) {
				let C = l.toRgbaObject(d);
				m.writeProperty("r", C.r), m.writeProperty("g", C.g), m.writeProperty("b", C.b)
			}

			function mw(m, l) {
				return (d, C) => {
					m ? pw(d, C, l) : fw(d, C, l)
				}
			}

			function jd(m) {
				var l;
				return !!(m != null && m.alpha || !((l = m == null ? void 0 : m.color) === null || l === void 0) && l.alpha)
			}

			function vw(m) {
				return m ? l => Bd(l, "0x") : l => Av(l, "0x")
			}

			function gw(m) {
				return "color" in m || "view" in m && m.view === "color"
			}
			let _w = {
				id: "input-color-number",
				type: "input",
				accept: (m, l) => {
					if (typeof m != "number" || !gw(l)) return null;
					let d = Nd(l);
					return d ? {
						initialValue: m,
						params: d
					} : null
				},
				binding: {
					reader: m => jd(m.params) ? cw : hw,
					equals: ae.equals,
					writer: m => dw(jd(m.params))
				},
				controller: m => {
					let l = jd(m.params),
						d = "expanded" in m.params ? m.params.expanded : void 0,
						C = "picker" in m.params ? m.params.picker : void 0;
					return new qd(m.document, {
						colorType: "int",
						expanded: d != null ? d : !1,
						formatter: vw(l),
						parser: zd("int"),
						pickerLayout: C != null ? C : "popup",
						supportsAlpha: l,
						value: m.value,
						viewProps: m.viewProps
					})
				}
			};

			function yw(m) {
				return ae.isRgbaColorObject(m)
			}

			function bw(m) {
				return l => rw(l, m)
			}

			function xw(m, l) {
				return d => m ? Lv(d, l) : Iv(d, l)
			}
			let ww = {
					id: "input-color-object",
					type: "input",
					accept: (m, l) => {
						if (!ae.isColorObject(m)) return null;
						let d = Nd(l);
						return d ? {
							initialValue: m,
							params: d
						} : null
					},
					binding: {
						reader: m => bw(Xs(m.params)),
						equals: ae.equals,
						writer: m => mw(yw(m.initialValue), Xs(m.params))
					},
					controller: m => {
						var l;
						let d = ae.isRgbaColorObject(m.initialValue),
							C = "expanded" in m.params ? m.params.expanded : void 0,
							V = "picker" in m.params ? m.params.picker : void 0,
							J = (l = Xs(m.params)) !== null && l !== void 0 ? l : "int";
						return new qd(m.document, {
							colorType: J,
							expanded: C != null ? C : !1,
							formatter: xw(d, J),
							parser: zd(J),
							pickerLayout: V != null ? V : "popup",
							supportsAlpha: d,
							value: m.value,
							viewProps: m.viewProps
						})
					}
				},
				Sw = {
					id: "input-color-string",
					type: "input",
					accept: (m, l) => {
						if (typeof m != "string" || "view" in l && l.view === "text") return null;
						let d = Vd(m, Xs(l));
						if (!d || !Ud(d)) return null;
						let V = Nd(l);
						return V ? {
							initialValue: m,
							params: V
						} : null
					},
					binding: {
						reader: m => {
							var l;
							return Ox((l = Xs(m.params)) !== null && l !== void 0 ? l : "int")
						},
						equals: ae.equals,
						writer: m => {
							let l = Vd(m.initialValue, Xs(m.params));
							if (!l) throw _.shouldNeverHappen();
							let d = uw(l);
							if (!d) throw _.notBindable();
							return d
						}
					},
					controller: m => {
						let l = Vd(m.initialValue, Xs(m.params));
						if (!l) throw _.shouldNeverHappen();
						let d = Ud(l);
						if (!d) throw _.shouldNeverHappen();
						let C = "expanded" in m.params ? m.params.expanded : void 0,
							V = "picker" in m.params ? m.params.picker : void 0;
						return new qd(m.document, {
							colorType: l.type,
							expanded: C != null ? C : !1,
							formatter: d,
							parser: zd(l.type),
							pickerLayout: V != null ? V : "popup",
							supportsAlpha: l.alpha,
							value: m.value,
							viewProps: m.viewProps
						})
					}
				};
			class Qr {
				constructor(l) {
					this.components = l.components, this.asm_ = l.assembly
				}
				constrain(l) {
					let d = this.asm_.toComponents(l).map((C, V) => {
						var J, at;
						return (at = (J = this.components[V]) === null || J === void 0 ? void 0 : J.constrain(C)) !== null && at !== void 0 ? at : C
					});
					return this.asm_.fromComponents(d)
				}
			}
			let Rv = S("pndtxt");
			class Ew {
				constructor(l, d) {
					this.textViews = d.textViews, this.element = l.createElement("div"), this.element.classList.add(Rv()), this.textViews.forEach(C => {
						let V = l.createElement("div");
						V.classList.add(Rv("a")), V.appendChild(C.element), this.element.appendChild(V)
					})
				}
			}

			function Mw(m, l, d) {
				return new Gs(m, {
					arrayPosition: d === 0 ? "fst" : d === l.axes.length - 1 ? "lst" : "mid",
					baseStep: l.axes[d].baseStep,
					parser: l.parser,
					props: l.axes[d].textProps,
					value: W(0, {
						constraint: l.axes[d].constraint
					}),
					viewProps: l.viewProps
				})
			}
			class Xd {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.acs_ = d.axes.map((C, V) => Mw(l, d, V)), this.acs_.forEach((C, V) => {
						Zr({
							primary: this.value,
							secondary: C.value,
							forward: J => d.assembly.toComponents(J.rawValue)[V],
							backward: (J, at) => {
								let Ct = d.assembly.toComponents(J.rawValue);
								return Ct[V] = at.rawValue, d.assembly.fromComponents(Ct)
							}
						})
					}), this.view = new Ew(l, {
						textViews: this.acs_.map(C => C.view)
					})
				}
			}

			function Fv(m, l) {
				return "step" in m && !c(m.step) ? new Fa(m.step, l) : null
			}

			function Ov(m) {
				return !c(m.max) && !c(m.min) ? new Yr({
					max: m.max,
					min: m.min
				}) : !c(m.max) || !c(m.min) ? new Qo({
					max: m.max,
					min: m.min
				}) : null
			}

			function Cw(m) {
				let l = rn(m, Yr);
				if (l) return [l.values.get("min"), l.values.get("max")];
				let d = rn(m, Qo);
				return d ? [d.minValue, d.maxValue] : [void 0, void 0]
			}

			function Tw(m, l) {
				let d = [],
					C = Fv(m, l);
				C && d.push(C);
				let V = Ov(m);
				V && d.push(V);
				let J = pl(m.options);
				return J && d.push(J), new Os(d)
			}
			let Pw = {
				id: "input-number",
				type: "input",
				accept: (m, l) => {
					if (typeof m != "number") return null;
					let d = Q,
						C = tt(l, {
							format: d.optional.function,
							max: d.optional.number,
							min: d.optional.number,
							options: d.optional.custom(Ws),
							step: d.optional.number
						});
					return C ? {
						initialValue: m,
						params: C
					} : null
				},
				binding: {
					reader: m => An,
					constraint: m => Tw(m.params, m.initialValue),
					writer: m => sn
				},
				controller: m => {
					var l;
					let d = m.value,
						C = m.constraint,
						V = C && rn(C, Ns);
					if (V) return new Vs(m.document, {
						props: new O({
							options: V.values.value("options")
						}),
						value: d,
						viewProps: m.viewProps
					});
					let J = (l = "format" in m.params ? m.params.format : void 0) !== null && l !== void 0 ? l : Qe(Ba(C, d.rawValue)),
						at = C && rn(C, Yr);
					return at ? new za(m.document, {
						baseStep: yr(C),
						parser: fn,
						sliderProps: new O({
							maxValue: at.values.value("max"),
							minValue: at.values.value("min")
						}),
						textProps: O.fromObject({
							draggingScale: br(C, d.rawValue),
							formatter: J
						}),
						value: d,
						viewProps: m.viewProps
					}) : new Gs(m.document, {
						baseStep: yr(C),
						parser: fn,
						props: O.fromObject({
							draggingScale: br(C, d.rawValue),
							formatter: J
						}),
						value: d,
						viewProps: m.viewProps
					})
				}
			};
			class ts {
				constructor(l = 0, d = 0) {
					this.x = l, this.y = d
				}
				getComponents() {
					return [this.x, this.y]
				}
				static isObject(l) {
					if (c(l)) return !1;
					let d = l.x,
						C = l.y;
					return !(typeof d != "number" || typeof C != "number")
				}
				static equals(l, d) {
					return l.x === d.x && l.y === d.y
				}
				toObject() {
					return {
						x: this.x,
						y: this.y
					}
				}
			}
			let Nv = {
					toComponents: m => m.getComponents(),
					fromComponents: m => new ts(...m)
				},
				Ha = S("p2d");
			class Aw {
				constructor(l, d) {
					this.element = l.createElement("div"), this.element.classList.add(Ha()), d.viewProps.bindClassModifiers(this.element), T(d.expanded, F(this.element, Ha(void 0, "expanded")));
					let C = l.createElement("div");
					C.classList.add(Ha("h")), this.element.appendChild(C);
					let V = l.createElement("button");
					V.classList.add(Ha("b")), V.appendChild(Z(l, "p2dpad")), d.viewProps.bindDisabled(V), C.appendChild(V), this.buttonElement = V;
					let J = l.createElement("div");
					if (J.classList.add(Ha("t")), C.appendChild(J), this.textElement = J, d.pickerLayout === "inline") {
						let at = l.createElement("div");
						at.classList.add(Ha("p")), this.element.appendChild(at), this.pickerElement = at
					} else this.pickerElement = null
				}
			}
			let es = S("p2dp");
			class Dw {
				constructor(l, d) {
					this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = d.invertsY, this.maxValue_ = d.maxValue, this.element = l.createElement("div"), this.element.classList.add(es()), d.layout === "popup" && this.element.classList.add(es(void 0, "p")), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("div");
					C.classList.add(es("p")), d.viewProps.bindTabIndex(C), this.element.appendChild(C), this.padElement = C;
					let V = l.createElementNS(dt, "svg");
					V.classList.add(es("g")), this.padElement.appendChild(V), this.svgElem_ = V;
					let J = l.createElementNS(dt, "line");
					J.classList.add(es("ax")), J.setAttributeNS(null, "x1", "0"), J.setAttributeNS(null, "y1", "50%"), J.setAttributeNS(null, "x2", "100%"), J.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(J);
					let at = l.createElementNS(dt, "line");
					at.classList.add(es("ax")), at.setAttributeNS(null, "x1", "50%"), at.setAttributeNS(null, "y1", "0"), at.setAttributeNS(null, "x2", "50%"), at.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(at);
					let Ct = l.createElementNS(dt, "line");
					Ct.classList.add(es("l")), Ct.setAttributeNS(null, "x1", "50%"), Ct.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(Ct), this.lineElem_ = Ct;
					let jt = l.createElement("div");
					jt.classList.add(es("m")), this.padElement.appendChild(jt), this.markerElem_ = jt, d.value.emitter.on("change", this.onValueChange_), this.value = d.value, this.update_()
				}
				get allFocusableElements() {
					return [this.padElement]
				}
				update_() {
					let [l, d] = this.value.rawValue.getComponents(), C = this.maxValue_, V = Le(l, -C, +C, 0, 100), J = Le(d, -C, +C, 0, 100), at = this.invertsY_ ? 100 - J : J;
					this.lineElem_.setAttributeNS(null, "x2", `${V}%`), this.lineElem_.setAttributeNS(null, "y2", `${at}%`), this.markerElem_.style.left = `${V}%`, this.markerElem_.style.top = `${at}%`
				}
				onValueChange_() {
					this.update_()
				}
				onFoldableChange_() {
					this.update_()
				}
			}

			function Vv(m, l, d) {
				return [ui(l[0], mn(m)), ui(l[1], Us(m)) * (d ? 1 : -1)]
			}
			class Iw {
				constructor(l, d) {
					this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.baseSteps_ = d.baseSteps, this.maxValue_ = d.maxValue, this.invertsY_ = d.invertsY, this.view = new Dw(l, {
						invertsY: this.invertsY_,
						layout: d.layout,
						maxValue: this.maxValue_,
						value: this.value,
						viewProps: this.viewProps
					}), this.ptHandler_ = new _r(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
				}
				handlePointerEvent_(l, d) {
					if (!l.point) return;
					let C = this.maxValue_,
						V = Le(l.point.x, 0, l.bounds.width, -C, +C),
						J = Le(this.invertsY_ ? l.bounds.height - l.point.y : l.point.y, 0, l.bounds.height, -C, +C);
					this.value.setRawValue(new ts(V, J), d)
				}
				onPointerDown_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerMove_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(l) {
					this.handlePointerEvent_(l.data, {
						forceEmit: !0,
						last: !0
					})
				}
				onPadKeyDown_(l) {
					Va(l.key) && l.preventDefault();
					let [d, C] = Vv(l, this.baseSteps_, this.invertsY_);
					d === 0 && C === 0 || this.value.setRawValue(new ts(this.value.rawValue.x + d, this.value.rawValue.y + C), {
						forceEmit: !1,
						last: !1
					})
				}
				onPadKeyUp_(l) {
					let [d, C] = Vv(l, this.baseSteps_, this.invertsY_);
					d === 0 && C === 0 || this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			class Lw {
				constructor(l, d) {
					var C, V;
					this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = d.value, this.viewProps = d.viewProps, this.foldable_ = Nt.create(d.expanded), this.popC_ = d.pickerLayout === "popup" ? new Lh(l, {
						viewProps: this.viewProps
					}) : null;
					let J = new Iw(l, {
						baseSteps: [d.axes[0].baseStep, d.axes[1].baseStep],
						invertsY: d.invertsY,
						layout: d.pickerLayout,
						maxValue: d.maxValue,
						value: this.value,
						viewProps: this.viewProps
					});
					J.view.allFocusableElements.forEach(at => {
						at.addEventListener("blur", this.onPopupChildBlur_), at.addEventListener("keydown", this.onPopupChildKeydown_)
					}), this.pickerC_ = J, this.textC_ = new Xd(l, {
						assembly: Nv,
						axes: d.axes,
						parser: d.parser,
						value: this.value,
						viewProps: this.viewProps
					}), this.view = new Aw(l, {
						expanded: this.foldable_.value("expanded"),
						pickerLayout: d.pickerLayout,
						viewProps: this.viewProps
					}), this.view.textElement.appendChild(this.textC_.view.element), (C = this.view.buttonElement) === null || C === void 0 || C.addEventListener("blur", this.onPadButtonBlur_), (V = this.view.buttonElement) === null || V === void 0 || V.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Zr({
						primary: this.foldable_.value("expanded"),
						secondary: this.popC_.shows,
						forward: at => at.rawValue,
						backward: (at, Ct) => Ct.rawValue
					})) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Ie(this.foldable_, this.view.pickerElement))
				}
				onPadButtonBlur_(l) {
					if (!this.popC_) return;
					let d = this.view.element,
						C = l.relatedTarget;
					(!C || !d.contains(C)) && (this.popC_.shows.rawValue = !1)
				}
				onPadButtonClick_() {
					this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
				}
				onPopupChildBlur_(l) {
					if (!this.popC_) return;
					let d = this.popC_.view.element,
						C = Pt(l);
					C && d.contains(C) || C && C === this.view.buttonElement && !re(d.ownerDocument) || (this.popC_.shows.rawValue = !1)
				}
				onPopupChildKeydown_(l) {
					this.popC_ ? l.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && l.key === "Escape" && this.view.buttonElement.focus()
				}
			}
			class Wa {
				constructor(l = 0, d = 0, C = 0) {
					this.x = l, this.y = d, this.z = C
				}
				getComponents() {
					return [this.x, this.y, this.z]
				}
				static isObject(l) {
					if (c(l)) return !1;
					let d = l.x,
						C = l.y,
						V = l.z;
					return !(typeof d != "number" || typeof C != "number" || typeof V != "number")
				}
				static equals(l, d) {
					return l.x === d.x && l.y === d.y && l.z === d.z
				}
				toObject() {
					return {
						x: this.x,
						y: this.y,
						z: this.z
					}
				}
			}
			let zv = {
				toComponents: m => m.getComponents(),
				fromComponents: m => new Wa(...m)
			};

			function kw(m) {
				return Wa.isObject(m) ? new Wa(m.x, m.y, m.z) : new Wa
			}

			function Rw(m, l) {
				m.writeProperty("x", l.x), m.writeProperty("y", l.y), m.writeProperty("z", l.z)
			}

			function Fw(m, l) {
				return new Qr({
					assembly: zv,
					components: [wr("x" in m ? m.x : void 0, l.x), wr("y" in m ? m.y : void 0, l.y), wr("z" in m ? m.z : void 0, l.z)]
				})
			}

			function Yd(m, l) {
				return {
					baseStep: yr(l),
					constraint: l,
					textProps: O.fromObject({
						draggingScale: br(l, m),
						formatter: Qe(Ba(l, m))
					})
				}
			}
			let Ow = {
				id: "input-point3d",
				type: "input",
				accept: (m, l) => {
					if (!Wa.isObject(m)) return null;
					let d = Q,
						C = tt(l, {
							x: d.optional.custom(Dn),
							y: d.optional.custom(Dn),
							z: d.optional.custom(Dn)
						});
					return C ? {
						initialValue: m,
						params: C
					} : null
				},
				binding: {
					reader: m => kw,
					constraint: m => Fw(m.params, m.initialValue),
					equals: Wa.equals,
					writer: m => Rw
				},
				controller: m => {
					let l = m.value,
						d = m.constraint;
					if (!(d instanceof Qr)) throw _.shouldNeverHappen();
					return new Xd(m.document, {
						assembly: zv,
						axes: [Yd(l.rawValue.x, d.components[0]), Yd(l.rawValue.y, d.components[1]), Yd(l.rawValue.z, d.components[2])],
						parser: fn,
						value: l,
						viewProps: m.viewProps
					})
				}
			};
			class $a {
				constructor(l = 0, d = 0, C = 0, V = 0) {
					this.x = l, this.y = d, this.z = C, this.w = V
				}
				getComponents() {
					return [this.x, this.y, this.z, this.w]
				}
				static isObject(l) {
					if (c(l)) return !1;
					let d = l.x,
						C = l.y,
						V = l.z,
						J = l.w;
					return !(typeof d != "number" || typeof C != "number" || typeof V != "number" || typeof J != "number")
				}
				static equals(l, d) {
					return l.x === d.x && l.y === d.y && l.z === d.z && l.w === d.w
				}
				toObject() {
					return {
						x: this.x,
						y: this.y,
						z: this.z,
						w: this.w
					}
				}
			}
			let Bv = {
				toComponents: m => m.getComponents(),
				fromComponents: m => new $a(...m)
			};

			function Nw(m) {
				return $a.isObject(m) ? new $a(m.x, m.y, m.z, m.w) : new $a
			}

			function Vw(m, l) {
				m.writeProperty("x", l.x), m.writeProperty("y", l.y), m.writeProperty("z", l.z), m.writeProperty("w", l.w)
			}

			function zw(m, l) {
				return new Qr({
					assembly: Bv,
					components: [wr("x" in m ? m.x : void 0, l.x), wr("y" in m ? m.y : void 0, l.y), wr("z" in m ? m.z : void 0, l.z), wr("w" in m ? m.w : void 0, l.w)]
				})
			}

			function Bw(m, l) {
				return {
					baseStep: yr(l),
					constraint: l,
					textProps: O.fromObject({
						draggingScale: br(l, m),
						formatter: Qe(Ba(l, m))
					})
				}
			}
			let Uw = {
				id: "input-point4d",
				type: "input",
				accept: (m, l) => {
					if (!$a.isObject(m)) return null;
					let d = Q,
						C = tt(l, {
							x: d.optional.custom(Dn),
							y: d.optional.custom(Dn),
							z: d.optional.custom(Dn),
							w: d.optional.custom(Dn)
						});
					return C ? {
						initialValue: m,
						params: C
					} : null
				},
				binding: {
					reader: m => Nw,
					constraint: m => zw(m.params, m.initialValue),
					equals: $a.equals,
					writer: m => Vw
				},
				controller: m => {
					let l = m.value,
						d = m.constraint;
					if (!(d instanceof Qr)) throw _.shouldNeverHappen();
					return new Xd(m.document, {
						assembly: Bv,
						axes: l.rawValue.getComponents().map((C, V) => Bw(C, d.components[V])),
						parser: fn,
						value: l,
						viewProps: m.viewProps
					})
				}
			};

			function Gw(m) {
				let l = [],
					d = pl(m.options);
				return d && l.push(d), new Os(l)
			}
			let Hw = {
					id: "input-string",
					type: "input",
					accept: (m, l) => {
						if (typeof m != "string") return null;
						let C = tt(l, {
							options: Q.optional.custom(Ws)
						});
						return C ? {
							initialValue: m,
							params: C
						} : null
					},
					binding: {
						reader: m => sl,
						constraint: m => Gw(m.params),
						writer: m => sn
					},
					controller: m => {
						let l = m.document,
							d = m.value,
							C = m.constraint,
							V = C && rn(C, Ns);
						return V ? new Vs(l, {
							props: new O({
								options: V.values.value("options")
							}),
							value: d,
							viewProps: m.viewProps
						}) : new Oa(l, {
							parser: J => J,
							props: O.fromObject({
								formatter: jn
							}),
							value: d,
							viewProps: m.viewProps
						})
					}
				},
				vl = {
					monitor: {
						defaultInterval: 200,
						defaultLineCount: 3
					}
				},
				Uv = S("mll");
			class Ww {
				constructor(l, d) {
					this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = d.formatter, this.element = l.createElement("div"), this.element.classList.add(Uv()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("textarea");
					C.classList.add(Uv("i")), C.style.height = `calc(var(--bld-us) * ${d.lineCount})`, C.readOnly = !0, d.viewProps.bindDisabled(C), this.element.appendChild(C), this.textareaElem_ = C, d.value.emitter.on("change", this.onValueUpdate_), this.value = d.value, this.update_()
				}
				update_() {
					let l = this.textareaElem_,
						d = l.scrollTop === l.scrollHeight - l.clientHeight,
						C = [];
					this.value.rawValue.forEach(V => {
						V !== void 0 && C.push(this.formatter_(V))
					}), l.textContent = C.join(`
`), d && (l.scrollTop = l.scrollHeight)
				}
				onValueUpdate_() {
					this.update_()
				}
			}
			class Kd {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.view = new Ww(l, {
						formatter: d.formatter,
						lineCount: d.lineCount,
						value: this.value,
						viewProps: this.viewProps
					})
				}
			}
			let Gv = S("sgl");
			class $w {
				constructor(l, d) {
					this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = d.formatter, this.element = l.createElement("div"), this.element.classList.add(Gv()), d.viewProps.bindClassModifiers(this.element);
					let C = l.createElement("input");
					C.classList.add(Gv("i")), C.readOnly = !0, C.type = "text", d.viewProps.bindDisabled(C), this.element.appendChild(C), this.inputElement = C, d.value.emitter.on("change", this.onValueUpdate_), this.value = d.value, this.update_()
				}
				update_() {
					let l = this.value.rawValue,
						d = l[l.length - 1];
					this.inputElement.value = d !== void 0 ? this.formatter_(d) : ""
				}
				onValueUpdate_() {
					this.update_()
				}
			}
			class Zd {
				constructor(l, d) {
					this.value = d.value, this.viewProps = d.viewProps, this.view = new $w(l, {
						formatter: d.formatter,
						value: this.value,
						viewProps: this.viewProps
					})
				}
			}
			let qw = {
					id: "monitor-bool",
					type: "monitor",
					accept: (m, l) => {
						if (typeof m != "boolean") return null;
						let C = tt(l, {
							lineCount: Q.optional.number
						});
						return C ? {
							initialValue: m,
							params: C
						} : null
					},
					binding: {
						reader: m => Rh
					},
					controller: m => {
						var l;
						return m.value.rawValue.length === 1 ? new Zd(m.document, {
							formatter: Fh,
							value: m.value,
							viewProps: m.viewProps
						}) : new Kd(m.document, {
							formatter: Fh,
							lineCount: (l = m.params.lineCount) !== null && l !== void 0 ? l : vl.monitor.defaultLineCount,
							value: m.value,
							viewProps: m.viewProps
						})
					}
				},
				is = S("grl");
			class jw {
				constructor(l, d) {
					this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = l.createElement("div"), this.element.classList.add(is()), d.viewProps.bindClassModifiers(this.element), this.formatter_ = d.formatter, this.props_ = d.props, this.cursor_ = d.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
					let C = l.createElementNS(dt, "svg");
					C.classList.add(is("g")), C.style.height = `calc(var(--bld-us) * ${d.lineCount})`, this.element.appendChild(C), this.svgElem_ = C;
					let V = l.createElementNS(dt, "polyline");
					this.svgElem_.appendChild(V), this.lineElem_ = V;
					let J = l.createElement("div");
					J.classList.add(is("t"), S("tt")()), this.element.appendChild(J), this.tooltipElem_ = J, d.value.emitter.on("change", this.onValueUpdate_), this.value = d.value, this.update_()
				}
				get graphElement() {
					return this.svgElem_
				}
				update_() {
					let l = this.svgElem_.getBoundingClientRect(),
						d = this.value.rawValue.length - 1,
						C = this.props_.get("minValue"),
						V = this.props_.get("maxValue"),
						J = [];
					this.value.rawValue.forEach((Ee, Me) => {
						if (Ee === void 0) return;
						let Ys = Le(Me, 0, d, 0, l.width),
							gl = Le(Ee, C, V, l.height, 0);
						J.push([Ys, gl].join(","))
					}), this.lineElem_.setAttributeNS(null, "points", J.join(" "));
					let at = this.tooltipElem_,
						Ct = this.value.rawValue[this.cursor_.rawValue];
					if (Ct === void 0) {
						at.classList.remove(is("t", "a"));
						return
					}
					let jt = Le(this.cursor_.rawValue, 0, d, 0, l.width),
						Kt = Le(Ct, C, V, l.height, 0);
					at.style.left = `${jt}px`, at.style.top = `${Kt}px`, at.textContent = `${this.formatter_(Ct)}`, at.classList.contains(is("t", "a")) || (at.classList.add(is("t", "a"), is("t", "in")), qt(at), at.classList.remove(is("t", "in")))
				}
				onValueUpdate_() {
					this.update_()
				}
				onCursorChange_() {
					this.update_()
				}
			}
			class Xw {
				constructor(l, d) {
					if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = d.props, this.value = d.value, this.viewProps = d.viewProps, this.cursor_ = W(-1), this.view = new jw(l, {
							cursor: this.cursor_,
							formatter: d.formatter,
							lineCount: d.lineCount,
							props: this.props_,
							value: this.value,
							viewProps: this.viewProps
						}), !re(l)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
					else {
						let C = new _r(this.view.element);
						C.emitter.on("down", this.onGraphPointerDown_), C.emitter.on("move", this.onGraphPointerMove_), C.emitter.on("up", this.onGraphPointerUp_)
					}
				}
				onGraphMouseLeave_() {
					this.cursor_.rawValue = -1
				}
				onGraphMouseMove_(l) {
					let d = this.view.element.getBoundingClientRect();
					this.cursor_.rawValue = Math.floor(Le(l.offsetX, 0, d.width, 0, this.value.rawValue.length))
				}
				onGraphPointerDown_(l) {
					this.onGraphPointerMove_(l)
				}
				onGraphPointerMove_(l) {
					if (!l.data.point) {
						this.cursor_.rawValue = -1;
						return
					}
					this.cursor_.rawValue = Math.floor(Le(l.data.point.x, 0, l.data.bounds.width, 0, this.value.rawValue.length))
				}
				onGraphPointerUp_() {
					this.cursor_.rawValue = -1
				}
			}

			function Jd(m) {
				return "format" in m && !c(m.format) ? m.format : Qe(2)
			}

			function Yw(m) {
				var l;
				return m.value.rawValue.length === 1 ? new Zd(m.document, {
					formatter: Jd(m.params),
					value: m.value,
					viewProps: m.viewProps
				}) : new Kd(m.document, {
					formatter: Jd(m.params),
					lineCount: (l = m.params.lineCount) !== null && l !== void 0 ? l : vl.monitor.defaultLineCount,
					value: m.value,
					viewProps: m.viewProps
				})
			}

			function Kw(m) {
				var l, d, C;
				return new Xw(m.document, {
					formatter: Jd(m.params),
					lineCount: (l = m.params.lineCount) !== null && l !== void 0 ? l : vl.monitor.defaultLineCount,
					props: O.fromObject({
						maxValue: (d = "max" in m.params ? m.params.max : null) !== null && d !== void 0 ? d : 100,
						minValue: (C = "min" in m.params ? m.params.min : null) !== null && C !== void 0 ? C : 0
					}),
					value: m.value,
					viewProps: m.viewProps
				})
			}

			function Hv(m) {
				return "view" in m && m.view === "graph"
			}
			let Zw = {
					id: "monitor-number",
					type: "monitor",
					accept: (m, l) => {
						if (typeof m != "number") return null;
						let d = Q,
							C = tt(l, {
								format: d.optional.function,
								lineCount: d.optional.number,
								max: d.optional.number,
								min: d.optional.number,
								view: d.optional.string
							});
						return C ? {
							initialValue: m,
							params: C
						} : null
					},
					binding: {
						defaultBufferSize: m => Hv(m) ? 64 : 1,
						reader: m => An
					},
					controller: m => Hv(m.params) ? Kw(m) : Yw(m)
				},
				Jw = {
					id: "monitor-string",
					type: "monitor",
					accept: (m, l) => {
						if (typeof m != "string") return null;
						let d = Q,
							C = tt(l, {
								lineCount: d.optional.number,
								multiline: d.optional.boolean
							});
						return C ? {
							initialValue: m,
							params: C
						} : null
					},
					binding: {
						reader: m => sl
					},
					controller: m => {
						var l;
						let d = m.value;
						return d.rawValue.length > 1 || "multiline" in m.params && m.params.multiline ? new Kd(m.document, {
							formatter: jn,
							lineCount: (l = m.params.lineCount) !== null && l !== void 0 ? l : vl.monitor.defaultLineCount,
							value: d,
							viewProps: m.viewProps
						}) : new Zd(m.document, {
							formatter: jn,
							value: d,
							viewProps: m.viewProps
						})
					}
				};

			function Qw(m, l) {
				var d;
				let C = m.accept(l.target.read(), l.params);
				if (c(C)) return null;
				let V = Q,
					J = {
						target: l.target,
						initialValue: C.initialValue,
						params: C.params
					},
					at = m.binding.reader(J),
					Ct = m.binding.constraint ? m.binding.constraint(J) : void 0,
					jt = W(at(C.initialValue), {
						constraint: Ct,
						equals: m.binding.equals
					}),
					Kt = new Ra({
						reader: at,
						target: l.target,
						value: jt,
						writer: m.binding.writer(J)
					}),
					Ee = V.optional.boolean(l.params.disabled).value,
					Me = V.optional.boolean(l.params.hidden).value,
					Ys = m.controller({
						constraint: Ct,
						document: l.document,
						initialValue: C.initialValue,
						params: C.params,
						value: Kt.value,
						viewProps: wt.create({
							disabled: Ee,
							hidden: Me
						})
					});
				return new xe(l.document, {
					binding: Kt,
					blade: Lt(),
					props: O.fromObject({
						label: "label" in l.params ? (d = V.optional.string(l.params.label).value) !== null && d !== void 0 ? d : null : l.target.key
					}),
					valueController: Ys
				})
			}

			function t1(m, l) {
				return l === 0 ? new Fs : new Jo(m, l != null ? l : vl.monitor.defaultInterval)
			}

			function e1(m, l) {
				var d, C, V;
				let J = Q,
					at = m.accept(l.target.read(), l.params);
				if (c(at)) return null;
				let Ct = {
						target: l.target,
						initialValue: at.initialValue,
						params: at.params
					},
					jt = m.binding.reader(Ct),
					Kt = (C = (d = J.optional.number(l.params.bufferSize).value) !== null && d !== void 0 ? d : m.binding.defaultBufferSize && m.binding.defaultBufferSize(at.params)) !== null && C !== void 0 ? C : 1,
					Ee = J.optional.number(l.params.interval).value,
					Me = new pd({
						reader: jt,
						target: l.target,
						ticker: t1(l.document, Ee),
						value: Ah(Kt)
					}),
					Ys = J.optional.boolean(l.params.disabled).value,
					gl = J.optional.boolean(l.params.hidden).value,
					_l = m.controller({
						document: l.document,
						params: at.params,
						value: Me.value,
						viewProps: wt.create({
							disabled: Ys,
							hidden: gl
						})
					});
				return new ge(l.document, {
					binding: Me,
					blade: Lt(),
					props: O.fromObject({
						label: "label" in l.params ? (V = J.optional.string(l.params.label).value) !== null && V !== void 0 ? V : null : l.target.key
					}),
					valueController: _l
				})
			}
			class i1 {
				constructor() {
					this.pluginsMap_ = {
						blades: [],
						inputs: [],
						monitors: []
					}
				}
				getAll() {
					return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
				}
				register(l) {
					l.type === "blade" ? this.pluginsMap_.blades.unshift(l) : l.type === "input" ? this.pluginsMap_.inputs.unshift(l) : l.type === "monitor" && this.pluginsMap_.monitors.unshift(l)
				}
				createInput(l, d, C) {
					let V = d.read();
					if (c(V)) throw new _({
						context: {
							key: d.key
						},
						type: "nomatchingcontroller"
					});
					let J = this.pluginsMap_.inputs.reduce((at, Ct) => at != null ? at : Qw(Ct, {
						document: l,
						target: d,
						params: C
					}), null);
					if (J) return J;
					throw new _({
						context: {
							key: d.key
						},
						type: "nomatchingcontroller"
					})
				}
				createMonitor(l, d, C) {
					let V = this.pluginsMap_.monitors.reduce((J, at) => J != null ? J : e1(at, {
						document: l,
						params: C,
						target: d
					}), null);
					if (V) return V;
					throw new _({
						context: {
							key: d.key
						},
						type: "nomatchingcontroller"
					})
				}
				createBlade(l, d) {
					let C = this.pluginsMap_.blades.reduce((V, J) => V != null ? V : Zo(J, {
						document: l,
						params: d
					}), null);
					if (!C) throw new _({
						type: "nomatchingview",
						context: {
							params: d
						}
					});
					return C
				}
				createBladeApi(l) {
					if (l instanceof xe) return new Ae(l);
					if (l instanceof ge) return new Vi(l);
					if (l instanceof $t) return new fr(l, this);
					let d = this.pluginsMap_.blades.reduce((C, V) => C != null ? C : V.api({
						controller: l,
						pool: this
					}), null);
					if (!d) throw _.shouldNeverHappen();
					return d
				}
			}

			function n1() {
				let m = new i1;
				return [h1, Ow, Uw, Hw, Pw, Sw, ww, _w, Ua, qw, Jw, Zw, Gt, se, Be, mr].forEach(l => {
					m.register(l)
				}), m
			}

			function r1(m) {
				return ts.isObject(m) ? new ts(m.x, m.y) : new ts
			}

			function s1(m, l) {
				m.writeProperty("x", l.x), m.writeProperty("y", l.y)
			}

			function wr(m, l) {
				if (!m) return;
				let d = [],
					C = Fv(m, l);
				C && d.push(C);
				let V = Ov(m);
				return V && d.push(V), new Os(d)
			}

			function a1(m, l) {
				return new Qr({
					assembly: Nv,
					components: [wr("x" in m ? m.x : void 0, l.x), wr("y" in m ? m.y : void 0, l.y)]
				})
			}

			function Wv(m, l) {
				let [d, C] = m ? Cw(m) : [];
				if (!c(d) || !c(C)) return Math.max(Math.abs(d != null ? d : 0), Math.abs(C != null ? C : 0));
				let V = yr(m);
				return Math.max(Math.abs(V) * 10, Math.abs(l) * 10)
			}

			function o1(m, l) {
				let d = l instanceof Qr ? l.components[0] : void 0,
					C = l instanceof Qr ? l.components[1] : void 0,
					V = Wv(d, m.x),
					J = Wv(C, m.y);
				return Math.max(V, J)
			}

			function $v(m, l) {
				return {
					baseStep: yr(l),
					constraint: l,
					textProps: O.fromObject({
						draggingScale: br(l, m),
						formatter: Qe(Ba(l, m))
					})
				}
			}

			function l1(m) {
				if (!("y" in m)) return !1;
				let l = m.y;
				return l && "inverted" in l ? !!l.inverted : !1
			}
			let h1 = {
				id: "input-point2d",
				type: "input",
				accept: (m, l) => {
					if (!ts.isObject(m)) return null;
					let d = Q,
						C = tt(l, {
							expanded: d.optional.boolean,
							picker: d.optional.custom(dl),
							x: d.optional.custom(Dn),
							y: d.optional.object({
								inverted: d.optional.boolean,
								max: d.optional.number,
								min: d.optional.number,
								step: d.optional.number
							})
						});
					return C ? {
						initialValue: m,
						params: C
					} : null
				},
				binding: {
					reader: m => r1,
					constraint: m => a1(m.params, m.initialValue),
					equals: ts.equals,
					writer: m => s1
				},
				controller: m => {
					let l = m.document,
						d = m.value,
						C = m.constraint;
					if (!(C instanceof Qr)) throw _.shouldNeverHappen();
					let V = "expanded" in m.params ? m.params.expanded : void 0,
						J = "picker" in m.params ? m.params.picker : void 0;
					return new Lw(l, {
						axes: [$v(d.rawValue.x, C.components[0]), $v(d.rawValue.y, C.components[1])],
						expanded: V != null ? V : !1,
						invertsY: l1(m.params),
						maxValue: o1(d.rawValue, C),
						parser: fn,
						pickerLayout: J != null ? J : "popup",
						value: d,
						viewProps: m.viewProps
					})
				}
			};
			class qv extends e {
				constructor(l) {
					super(l), this.emitter_ = new w, this.controller_.valueController.value.emitter.on("change", d => {
						this.emitter_.emit("change", {
							event: new r(this, d.rawValue)
						})
					})
				}
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				get options() {
					return this.controller_.valueController.props.get("options")
				}
				set options(l) {
					this.controller_.valueController.props.set("options", l)
				}
				get value() {
					return this.controller_.valueController.value.rawValue
				}
				set value(l) {
					this.controller_.valueController.value.rawValue = l
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
			}
			class jv extends e {
				constructor(l) {
					super(l), this.emitter_ = new w, this.controller_.valueController.value.emitter.on("change", d => {
						this.emitter_.emit("change", {
							event: new r(this, d.rawValue)
						})
					})
				}
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				get maxValue() {
					return this.controller_.valueController.sliderController.props.get("maxValue")
				}
				set maxValue(l) {
					this.controller_.valueController.sliderController.props.set("maxValue", l)
				}
				get minValue() {
					return this.controller_.valueController.sliderController.props.get("minValue")
				}
				set minValue(l) {
					this.controller_.valueController.sliderController.props.set("minValue", l)
				}
				get value() {
					return this.controller_.valueController.value.rawValue
				}
				set value(l) {
					this.controller_.valueController.value.rawValue = l
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
			}
			class Xv extends e {
				constructor(l) {
					super(l), this.emitter_ = new w, this.controller_.valueController.value.emitter.on("change", d => {
						this.emitter_.emit("change", {
							event: new r(this, d.rawValue)
						})
					})
				}
				get label() {
					return this.controller_.props.get("label")
				}
				set label(l) {
					this.controller_.props.set("label", l)
				}
				get formatter() {
					return this.controller_.valueController.props.get("formatter")
				}
				set formatter(l) {
					this.controller_.valueController.props.set("formatter", l)
				}
				get value() {
					return this.controller_.valueController.value.rawValue
				}
				set value(l) {
					this.controller_.valueController.value.rawValue = l
				}
				on(l, d) {
					let C = d.bind(this);
					return this.emitter_.on(l, V => {
						C(V.event)
					}), this
				}
			}
			let c1 = function () {
				return {
					id: "list",
					type: "blade",
					accept(m) {
						let l = Q,
							d = tt(m, {
								options: l.required.custom(Ws),
								value: l.required.raw,
								view: l.required.constant("list"),
								label: l.optional.string
							});
						return d ? {
							params: d
						} : null
					},
					controller(m) {
						let l = new Ns($h(m.params.options)),
							d = W(m.params.value, {
								constraint: l
							}),
							C = new Vs(m.document, {
								props: new O({
									options: l.values.value("options")
								}),
								value: d,
								viewProps: m.viewProps
							});
						return new Jt(m.document, {
							blade: m.blade,
							props: O.fromObject({
								label: m.params.label
							}),
							valueController: C
						})
					},
					api(m) {
						return !(m.controller instanceof Jt) || !(m.controller.valueController instanceof Vs) ? null : new qv(m.controller)
					}
				}
			}();

			function u1(m) {
				return m.reduce((l, d) => Object.assign(l, {
					[d.presetKey]: d.read()
				}), {})
			}

			function d1(m, l) {
				m.forEach(d => {
					let C = l[d.target.presetKey];
					C !== void 0 && d.writer(d.target, d.reader(C))
				})
			}
			class p1 extends Ls {
				constructor(l, d) {
					super(l, d)
				}
				get element() {
					return this.controller_.view.element
				}
				importPreset(l) {
					let d = this.controller_.rackController.rack.find(xe).map(C => C.binding);
					d1(d, l), this.refresh()
				}
				exportPreset() {
					let l = this.controller_.rackController.rack.find(xe).map(d => d.binding.target);
					return u1(l)
				}
				refresh() {
					this.controller_.rackController.rack.find(xe).forEach(l => {
						l.binding.read()
					}), this.controller_.rackController.rack.find(ge).forEach(l => {
						l.binding.read()
					})
				}
			}
			class f1 extends te {
				constructor(l, d) {
					super(l, {
						expanded: d.expanded,
						blade: d.blade,
						props: d.props,
						root: !0,
						viewProps: d.viewProps
					})
				}
			}
			let m1 = {
					id: "slider",
					type: "blade",
					accept(m) {
						let l = Q,
							d = tt(m, {
								max: l.required.number,
								min: l.required.number,
								view: l.required.constant("slider"),
								format: l.optional.function,
								label: l.optional.string,
								value: l.optional.number
							});
						return d ? {
							params: d
						} : null
					},
					controller(m) {
						var l, d;
						let C = (l = m.params.value) !== null && l !== void 0 ? l : 0,
							V = new Yr({
								max: m.params.max,
								min: m.params.min
							}),
							J = new za(m.document, {
								baseStep: 1,
								parser: fn,
								sliderProps: new O({
									maxValue: V.values.value("max"),
									minValue: V.values.value("min")
								}),
								textProps: O.fromObject({
									draggingScale: br(void 0, C),
									formatter: (d = m.params.format) !== null && d !== void 0 ? d : Id
								}),
								value: W(C, {
									constraint: V
								}),
								viewProps: m.viewProps
							});
						return new Jt(m.document, {
							blade: m.blade,
							props: O.fromObject({
								label: m.params.label
							}),
							valueController: J
						})
					},
					api(m) {
						return !(m.controller instanceof Jt) || !(m.controller.valueController instanceof za) ? null : new jv(m.controller)
					}
				},
				v1 = function () {
					return {
						id: "text",
						type: "blade",
						accept(m) {
							let l = Q,
								d = tt(m, {
									parse: l.required.function,
									value: l.required.raw,
									view: l.required.constant("text"),
									format: l.optional.function,
									label: l.optional.string
								});
							return d ? {
								params: d
							} : null
						},
						controller(m) {
							var l;
							let d = new Oa(m.document, {
								parser: m.params.parse,
								props: O.fromObject({
									formatter: (l = m.params.format) !== null && l !== void 0 ? l : C => String(C)
								}),
								value: W(m.params.value),
								viewProps: m.viewProps
							});
							return new Jt(m.document, {
								blade: m.blade,
								props: O.fromObject({
									label: m.params.label
								}),
								valueController: d
							})
						},
						api(m) {
							return !(m.controller instanceof Jt) || !(m.controller.valueController instanceof Oa) ? null : new Xv(m.controller)
						}
					}
				}();

			function g1(m) {
				let l = m.createElement("div");
				return l.classList.add(S("dfw")()), m.body && m.body.appendChild(l), l
			}

			function Yv(m, l, d) {
				if (m.querySelector(`style[data-tp-style=${l}]`)) return;
				let C = m.createElement("style");
				C.dataset.tpStyle = l, C.textContent = d, m.head.appendChild(C)
			}
			class _1 extends p1 {
				constructor(l) {
					var d, C;
					let V = l != null ? l : {},
						J = (d = V.document) !== null && d !== void 0 ? d : Xt(),
						at = n1(),
						Ct = new f1(J, {
							expanded: V.expanded,
							blade: Lt(),
							props: O.fromObject({
								title: V.title
							}),
							viewProps: wt.create()
						});
					super(Ct, at), this.pool_ = at, this.containerElem_ = (C = V.container) !== null && C !== void 0 ? C : g1(J), this.containerElem_.appendChild(this.element), this.doc_ = J, this.usesDefaultWrapper_ = !V.container, this.setUpDefaultPlugins_()
				}
				get document() {
					if (!this.doc_) throw _.alreadyDisposed();
					return this.doc_
				}
				dispose() {
					let l = this.containerElem_;
					if (!l) throw _.alreadyDisposed();
					if (this.usesDefaultWrapper_) {
						let d = l.parentElement;
						d && d.removeChild(l)
					}
					this.containerElem_ = null, this.doc_ = null, super.dispose()
				}
				registerPlugin(l) {
					("plugin" in l ? [l.plugin] : "plugins" in l ? l.plugins : []).forEach(C => {
						this.pool_.register(C), this.embedPluginStyle_(C)
					})
				}
				embedPluginStyle_(l) {
					l.css && Yv(this.document, `plugin-${l.id}`, l.css)
				}
				setUpDefaultPlugins_() {
					Yv(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach(l => {
						this.embedPluginStyle_(l)
					}), this.registerPlugin({
						plugins: [m1, c1, mr, v1]
					})
				}
			}
			let y1 = new t("3.1.10");
			i.BladeApi = e, i.ButtonApi = y, i.FolderApi = Ls, i.InputBindingApi = Ae, i.ListApi = qv, i.MonitorBindingApi = Vi, i.Pane = _1, i.SeparatorApi = we, i.SliderApi = jv, i.TabApi = $n, i.TabPageApi = qr, i.TextApi = Xv, i.TpChangeEvent = r, i.VERSION = y1, Object.defineProperty(i, "__esModule", {
				value: !0
			})
		})
	});
	var wb = Qh((zu, xb) => {
		(function (i, t) {
			typeof zu == "object" && typeof xb != "undefined" ? t(zu) : typeof define == "function" && define.amd ? define(["exports"], t) : (i = typeof globalThis != "undefined" ? globalThis : i || self, t(i.TweakpaneEssentialsPlugin = {}))
		})(zu, function (i) {
			"use strict";
			class t {
				constructor(E) {
					this.controller_ = E
				}
				get element() {
					return this.controller_.view.element
				}
				get disabled() {
					return this.controller_.viewProps.get("disabled")
				}
				set disabled(E) {
					this.controller_.viewProps.set("disabled", E)
				}
				get hidden() {
					return this.controller_.viewProps.get("hidden")
				}
				set hidden(E) {
					this.controller_.viewProps.set("hidden", E)
				}
				dispose() {
					this.controller_.viewProps.set("disposed", !0)
				}
			}
			class e {
				constructor(E) {
					this.target = E
				}
			}
			class n extends e {
				constructor(E, P, N, Y) {
					super(E), this.value = P, this.presetKey = N, this.last = Y != null ? Y : !0
				}
			}

			function r(R) {
				return R
			}

			function s(R) {
				return R == null
			}
			let a = {
				alreadydisposed: () => "View has been already disposed",
				invalidparams: R => `Invalid parameters for '${R.name}'`,
				nomatchingcontroller: R => `No matching controller for '${R.key}'`,
				nomatchingview: R => `No matching view for '${JSON.stringify(R.params)}'`,
				notbindable: () => "Value is not bindable",
				propertynotfound: R => `Property '${R.name}' not found`,
				shouldneverhappen: () => "This error should never happen"
			};
			class o {
				constructor(E) {
					var P;
					this.message = (P = a[E.type](E.context)) !== null && P !== void 0 ? P : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = E.type
				}
				static alreadyDisposed() {
					return new o({
						type: "alreadydisposed"
					})
				}
				static notBindable() {
					return new o({
						type: "notbindable"
					})
				}
				static propertyNotFound(E) {
					return new o({
						type: "propertynotfound",
						context: {
							name: E
						}
					})
				}
				static shouldNeverHappen() {
					return new o({
						type: "shouldneverhappen"
					})
				}
			}
			class h {
				constructor() {
					this.observers_ = {}
				}
				on(E, P) {
					let N = this.observers_[E];
					return N || (N = this.observers_[E] = []), N.push({
						handler: P
					}), this
				}
				off(E, P) {
					let N = this.observers_[E];
					return N && (this.observers_[E] = N.filter(Y => Y.handler !== P)), this
				}
				emit(E, P) {
					let N = this.observers_[E];
					N && N.forEach(Y => {
						Y.handler(P)
					})
				}
			}
			let c = "tp";

			function u(R) {
				return (P, N) => [c, "-", R, "v", P ? `_${P}` : "", N ? `-${N}` : ""].join("")
			}

			function g(R, E) {
				return P => E(R(P))
			}

			function p(R) {
				return R.rawValue
			}

			function _(R, E) {
				R.emitter.on("change", g(p, E)), E(R.rawValue)
			}

			function b(R, E, P) {
				_(R.value(E), P)
			}

			function y(R, E, P) {
				P ? R.classList.add(E) : R.classList.remove(E)
			}

			function w(R, E) {
				return P => {
					y(R, E, P)
				}
			}

			function f(R, E) {
				_(R, P => {
					E.textContent = P != null ? P : ""
				})
			}
			let S = u("btn");
			class x {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(S()), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElement("button");
					N.classList.add(S("b")), P.viewProps.bindDisabled(N), this.element.appendChild(N), this.buttonElement = N;
					let Y = E.createElement("div");
					Y.classList.add(S("t")), f(P.props.value("title"), Y), this.buttonElement.appendChild(Y)
				}
			}
			class M {
				constructor(E, P) {
					this.emitter = new h, this.onClick_ = this.onClick_.bind(this), this.props = P.props, this.viewProps = P.viewProps, this.view = new x(E, {
						props: this.props,
						viewProps: this.viewProps
					}), this.view.buttonElement.addEventListener("click", this.onClick_)
				}
				onClick_() {
					this.emitter.emit("click", {
						sender: this
					})
				}
			}
			class T {
				constructor(E, P) {
					var N;
					this.constraint_ = P == null ? void 0 : P.constraint, this.equals_ = (N = P == null ? void 0 : P.equals) !== null && N !== void 0 ? N : (Y, st) => Y === st, this.emitter = new h, this.rawValue_ = E
				}
				get constraint() {
					return this.constraint_
				}
				get rawValue() {
					return this.rawValue_
				}
				set rawValue(E) {
					this.setRawValue(E, {
						forceEmit: !1,
						last: !0
					})
				}
				setRawValue(E, P) {
					let N = P != null ? P : {
							forceEmit: !1,
							last: !0
						},
						Y = this.constraint_ ? this.constraint_.constrain(E) : E,
						st = this.rawValue_;
					this.equals_(st, Y) && !N.forceEmit || (this.emitter.emit("beforechange", {
						sender: this
					}), this.rawValue_ = Y, this.emitter.emit("change", {
						options: N,
						previousRawValue: st,
						rawValue: Y,
						sender: this
					}))
				}
			}
			class I {
				constructor(E) {
					this.emitter = new h, this.value_ = E
				}
				get rawValue() {
					return this.value_
				}
				set rawValue(E) {
					this.setRawValue(E, {
						forceEmit: !1,
						last: !0
					})
				}
				setRawValue(E, P) {
					let N = P != null ? P : {
							forceEmit: !1,
							last: !0
						},
						Y = this.value_;
					Y === E && !N.forceEmit || (this.emitter.emit("beforechange", {
						sender: this
					}), this.value_ = E, this.emitter.emit("change", {
						options: N,
						previousRawValue: Y,
						rawValue: this.value_,
						sender: this
					}))
				}
			}

			function L(R, E) {
				let P = E == null ? void 0 : E.constraint,
					N = E == null ? void 0 : E.equals;
				return !P && !N ? new I(R) : new T(R, E)
			}
			class F {
				constructor(E) {
					this.emitter = new h, this.valMap_ = E;
					for (let P in this.valMap_) this.valMap_[P].emitter.on("change", () => {
						this.emitter.emit("change", {
							key: P,
							sender: this
						})
					})
				}
				static createCore(E) {
					return Object.keys(E).reduce((N, Y) => Object.assign(N, {
						[Y]: L(E[Y])
					}), {})
				}
				static fromObject(E) {
					let P = this.createCore(E);
					return new F(P)
				}
				get(E) {
					return this.valMap_[E].rawValue
				}
				set(E, P) {
					this.valMap_[E].rawValue = P
				}
				value(E) {
					return this.valMap_[E]
				}
			}

			function k(R, E) {
				let N = Object.keys(E).reduce((Y, st) => {
					if (Y === void 0) return;
					let ft = E[st],
						Tt = ft(R[st]);
					return Tt.succeeded ? Object.assign(Object.assign({}, Y), {
						[st]: Tt.value
					}) : void 0
				}, {});
				return N
			}

			function G(R, E) {
				return R.reduce((P, N) => {
					if (P === void 0) return;
					let Y = E(N);
					if (!(!Y.succeeded || Y.value === void 0)) return [...P, Y.value]
				}, [])
			}

			function j(R) {
				return R === null ? !1 : typeof R == "object"
			}

			function U(R) {
				return E => P => {
					if (!E && P === void 0) return {
						succeeded: !1,
						value: void 0
					};
					if (E && P === void 0) return {
						succeeded: !0,
						value: void 0
					};
					let N = R(P);
					return N !== void 0 ? {
						succeeded: !0,
						value: N
					} : {
						succeeded: !1,
						value: void 0
					}
				}
			}

			function z(R) {
				return {
					custom: E => U(E)(R),
					boolean: U(E => typeof E == "boolean" ? E : void 0)(R),
					number: U(E => typeof E == "number" ? E : void 0)(R),
					string: U(E => typeof E == "string" ? E : void 0)(R),
					function: U(E => typeof E == "function" ? E : void 0)(R),
					constant: E => U(P => P === E ? E : void 0)(R),
					raw: U(E => E)(R),
					object: E => U(P => {
						if (j(P)) return k(P, E)
					})(R),
					array: E => U(P => {
						if (Array.isArray(P)) return G(P, E)
					})(R)
				}
			}
			let $ = {
				optional: z(!0),
				required: z(!1)
			};

			function W(R, E) {
				let P = $.required.object(E)(R);
				return P.succeeded ? P.value : void 0
			}

			function O(R) {
				console.warn([`Missing '${R.key}' of ${R.target} in ${R.place}.`, "Please rebuild plugins with the latest core package."].join(" "))
			}

			function B(R) {
				return R && R.parentElement && R.parentElement.removeChild(R), null
			}
			class A {
				constructor(E) {
					this.value_ = E
				}
				static create(E) {
					return [new A(E), (P, N) => {
						E.setRawValue(P, N)
					}]
				}
				get emitter() {
					return this.value_.emitter
				}
				get rawValue() {
					return this.value_.rawValue
				}
			}
			let D = u("");

			function H(R, E) {
				return w(R, D(void 0, E))
			}
			class q extends F {
				constructor(E) {
					var P;
					super(E), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = A.create(L(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (P = this.get("parent")) === null || P === void 0 || P.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
				}
				static create(E) {
					var P, N, Y;
					let st = E != null ? E : {};
					return new q(F.createCore({
						disabled: (P = st.disabled) !== null && P !== void 0 ? P : !1,
						disposed: !1,
						hidden: (N = st.hidden) !== null && N !== void 0 ? N : !1,
						parent: (Y = st.parent) !== null && Y !== void 0 ? Y : null
					}))
				}
				get globalDisabled() {
					return this.globalDisabled_
				}
				bindClassModifiers(E) {
					_(this.globalDisabled_, H(E, "disabled")), b(this, "hidden", H(E, "hidden"))
				}
				bindDisabled(E) {
					_(this.globalDisabled_, P => {
						E.disabled = P
					})
				}
				bindTabIndex(E) {
					_(this.globalDisabled_, P => {
						E.tabIndex = P ? -1 : 0
					})
				}
				handleDispose(E) {
					this.value("disposed").emitter.on("change", P => {
						P && E()
					})
				}
				getGlobalDisabled_() {
					let E = this.get("parent");
					return (E ? E.globalDisabled.rawValue : !1) || this.get("disabled")
				}
				updateGlobalDisabled_() {
					this.setGlobalDisabled_(this.getGlobalDisabled_())
				}
				onDisabledChange_() {
					this.updateGlobalDisabled_()
				}
				onParentGlobalDisabledChange_() {
					this.updateGlobalDisabled_()
				}
				onParentChange_(E) {
					var P;
					let N = E.previousRawValue;
					N == null || N.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (P = this.get("parent")) === null || P === void 0 || P.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_()
				}
			}

			function Q() {
				return ["veryfirst", "first", "last", "verylast"]
			}
			let tt = u(""),
				nt = {
					veryfirst: "vfst",
					first: "fst",
					last: "lst",
					verylast: "vlst"
				};
			class ut {
				constructor(E) {
					this.parent_ = null, this.blade = E.blade, this.view = E.view, this.viewProps = E.viewProps;
					let P = this.view.element;
					this.blade.value("positions").emitter.on("change", () => {
						Q().forEach(N => {
							P.classList.remove(tt(void 0, nt[N]))
						}), this.blade.get("positions").forEach(N => {
							P.classList.add(tt(void 0, nt[N]))
						})
					}), this.viewProps.handleDispose(() => {
						B(P)
					})
				}
				get parent() {
					return this.parent_
				}
				set parent(E) {
					if (this.parent_ = E, !("parent" in this.viewProps.valMap_)) {
						O({
							key: "parent",
							target: q.name,
							place: "BladeController.parent"
						});
						return
					}
					this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
				}
			}
			let et = "http://www.w3.org/2000/svg";

			function it(R) {
				R.offsetHeight
			}

			function Et(R, E) {
				let P = R.style.transition;
				R.style.transition = "none", E(), R.style.transition = P
			}

			function wt(R) {
				return R.ontouchstart !== void 0
			}

			function yt(R) {
				for (; R.childNodes.length > 0;) R.removeChild(R.childNodes[0])
			}

			function At(R) {
				return R.relatedTarget ? R.relatedTarget : "explicitOriginalTarget" in R ? R.explicitOriginalTarget : null
			}
			let Vt = u("lbl");

			function lt(R, E) {
				let P = R.createDocumentFragment();
				return E.split(`
`).map(Y => R.createTextNode(Y)).forEach((Y, st) => {
					st > 0 && P.appendChild(R.createElement("br")), P.appendChild(Y)
				}), P
			}
			class dt {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(Vt()), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElement("div");
					N.classList.add(Vt("l")), b(P.props, "label", st => {
						s(st) ? this.element.classList.add(Vt(void 0, "nol")) : (this.element.classList.remove(Vt(void 0, "nol")), yt(N), N.appendChild(lt(E, st)))
					}), this.element.appendChild(N), this.labelElement = N;
					let Y = E.createElement("div");
					Y.classList.add(Vt("v")), this.element.appendChild(Y), this.valueElement = Y
				}
			}
			class qt extends ut {
				constructor(E, P) {
					let N = P.valueController.viewProps;
					super(Object.assign(Object.assign({}, P), {
						view: new dt(E, {
							props: P.props,
							viewProps: N
						}),
						viewProps: N
					})), this.props = P.props, this.valueController = P.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
				}
			}
			class Zt extends ut {
				constructor(E) {
					super(E), this.value = E.value
				}
			}
			class re extends F {
				constructor(E) {
					super(E)
				}
				static create(E) {
					let P = {
							completed: !0,
							expanded: E,
							expandedHeight: null,
							shouldFixHeight: !1,
							temporaryExpanded: null
						},
						N = F.createCore(P);
					return new re(N)
				}
				get styleExpanded() {
					var E;
					return (E = this.get("temporaryExpanded")) !== null && E !== void 0 ? E : this.get("expanded")
				}
				get styleHeight() {
					if (!this.styleExpanded) return "0";
					let E = this.get("expandedHeight");
					return this.get("shouldFixHeight") && !s(E) ? `${E}px` : "auto"
				}
				bindExpandedClass(E, P) {
					let N = () => {
						this.styleExpanded ? E.classList.add(P) : E.classList.remove(P)
					};
					b(this, "expanded", N), b(this, "temporaryExpanded", N)
				}
				cleanUpTransition() {
					this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
				}
			}

			function de(R) {
				return re.create(R)
			}

			function Xt(R, E) {
				let P = 0;
				return Et(E, () => {
					R.set("expandedHeight", null), R.set("temporaryExpanded", !0), it(E), P = E.clientHeight, R.set("temporaryExpanded", null), it(E)
				}), P
			}

			function le(R, E) {
				E.style.height = R.styleHeight
			}

			function ye(R, E) {
				R.value("expanded").emitter.on("beforechange", () => {
					R.set("completed", !1), s(R.get("expandedHeight")) && R.set("expandedHeight", Xt(R, E)), R.set("shouldFixHeight", !0), it(E)
				}), R.emitter.on("change", () => {
					le(R, E)
				}), le(R, E), E.addEventListener("transitionend", P => {
					P.propertyName === "height" && R.cleanUpTransition()
				})
			}
			class Z {
				constructor(E, P) {
					let N = u(P.viewName);
					this.element = E.createElement("div"), this.element.classList.add(N()), P.viewProps.bindClassModifiers(this.element)
				}
			}
			class X extends Zt {
				constructor(E, P) {
					let N = P.valueController.viewProps;
					super(Object.assign(Object.assign({}, P), {
						value: P.valueController.value,
						view: new dt(E, {
							props: P.props,
							viewProps: N
						}),
						viewProps: N
					})), this.props = P.props, this.valueController = P.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
				}
			}
			class pt {
				constructor() {
					this.disabled = !1, this.emitter = new h
				}
				dispose() {}
				tick() {
					this.disabled || this.emitter.emit("tick", {
						sender: this
					})
				}
			}
			class xt {
				constructor(E, P) {
					this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = E, this.emitter = new h, this.interval_ = P, this.setTimer_()
				}
				get disabled() {
					return this.disabled_
				}
				set disabled(E) {
					this.disabled_ = E, this.disabled_ ? this.clearTimer_() : this.setTimer_()
				}
				dispose() {
					this.clearTimer_()
				}
				clearTimer_() {
					if (this.timerId_ === null) return;
					let E = this.doc_.defaultView;
					E && E.clearInterval(this.timerId_), this.timerId_ = null
				}
				setTimer_() {
					if (this.clearTimer_(), this.interval_ <= 0) return;
					let E = this.doc_.defaultView;
					E && (this.timerId_ = E.setInterval(this.onTick_, this.interval_))
				}
				onTick_() {
					this.disabled_ || this.emitter.emit("tick", {
						sender: this
					})
				}
			}
			class St {
				constructor(E) {
					this.constraints = E
				}
				constrain(E) {
					return this.constraints.reduce((P, N) => N.constrain(P), E)
				}
			}

			function Pt(R, E) {
				if (R instanceof E) return R;
				if (R instanceof St) {
					let P = R.constraints.reduce((N, Y) => N || (Y instanceof E ? Y : null), null);
					if (P) return P
				}
				return null
			}
			class Bt {
				constructor(E) {
					this.values = F.fromObject({
						max: E.max,
						min: E.min
					})
				}
				constrain(E) {
					let P = this.values.get("max"),
						N = this.values.get("min");
					return Math.min(Math.max(E, N), P)
				}
			}
			class It {
				constructor(E) {
					this.values = F.fromObject({
						max: E.max,
						min: E.min
					})
				}
				get maxValue() {
					return this.values.get("max")
				}
				get minValue() {
					return this.values.get("min")
				}
				constrain(E) {
					let P = this.values.get("max"),
						N = this.values.get("min"),
						Y = E;
					return s(N) || (Y = Math.max(Y, N)), s(P) || (Y = Math.min(Y, P)), Y
				}
			}
			class mt {
				constructor(E, P = 0) {
					this.step = E, this.origin = P
				}
				constrain(E) {
					let P = this.origin % this.step,
						N = Math.round((E - P) / this.step);
					return P + N * this.step
				}
			}
			let Ot = u("pop");
			class Gt {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(Ot()), P.viewProps.bindClassModifiers(this.element), _(P.shows, w(this.element, Ot(void 0, "v")))
				}
			}
			class Ut {
				constructor(E, P) {
					this.shows = L(!1), this.viewProps = P.viewProps, this.view = new Gt(E, {
						shows: this.shows,
						viewProps: this.viewProps
					})
				}
			}
			let Lt = u("txt");
			class Nt {
				constructor(E, P) {
					this.onChange_ = this.onChange_.bind(this), this.element = E.createElement("div"), this.element.classList.add(Lt()), P.viewProps.bindClassModifiers(this.element), this.props_ = P.props, this.props_.emitter.on("change", this.onChange_);
					let N = E.createElement("input");
					N.classList.add(Lt("i")), N.type = "text", P.viewProps.bindDisabled(N), this.element.appendChild(N), this.inputElement = N, P.value.emitter.on("change", this.onChange_), this.value_ = P.value, this.refresh()
				}
				refresh() {
					let E = this.props_.get("formatter");
					this.inputElement.value = E(this.value_.rawValue)
				}
				onChange_() {
					this.refresh()
				}
			}
			class ce {
				constructor(E, P) {
					this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = P.parser, this.props = P.props, this.value = P.value, this.viewProps = P.viewProps, this.view = new Nt(E, {
						props: P.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.inputElement.addEventListener("change", this.onInputChange_)
				}
				onInputChange_(E) {
					let N = E.currentTarget.value,
						Y = this.parser_(N);
					s(Y) || (this.value.rawValue = Y), this.view.refresh()
				}
			}

			function be(R) {
				return R === "false" ? !1 : !!R
			}
			class Ie {
				constructor(E) {
					this.text = E
				}
				evaluate() {
					return Number(this.text)
				}
				toString() {
					return this.text
				}
			}
			let rt = {
				"**": (R, E) => Math.pow(R, E),
				"*": (R, E) => R * E,
				"/": (R, E) => R / E,
				"%": (R, E) => R % E,
				"+": (R, E) => R + E,
				"-": (R, E) => R - E,
				"<<": (R, E) => R << E,
				">>": (R, E) => R >> E,
				">>>": (R, E) => R >>> E,
				"&": (R, E) => R & E,
				"^": (R, E) => R ^ E,
				"|": (R, E) => R | E
			};
			class gt {
				constructor(E, P, N) {
					this.left = P, this.operator = E, this.right = N
				}
				evaluate() {
					let E = rt[this.operator];
					if (!E) throw new Error(`unexpected binary operator: '${this.operator}`);
					return E(this.left.evaluate(), this.right.evaluate())
				}
				toString() {
					return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
				}
			}
			let Mt = {
				"+": R => R,
				"-": R => -R,
				"~": R => ~R
			};
			class kt {
				constructor(E, P) {
					this.operator = E, this.expression = P
				}
				evaluate() {
					let E = Mt[this.operator];
					if (!E) throw new Error(`unexpected unary operator: '${this.operator}`);
					return E(this.expression.evaluate())
				}
				toString() {
					return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
				}
			}

			function zt(R) {
				return (E, P) => {
					for (let N = 0; N < R.length; N++) {
						let Y = R[N](E, P);
						if (Y !== "") return Y
					}
					return ""
				}
			}

			function fe(R, E) {
				var P;
				let N = R.substr(E).match(/^\s+/);
				return (P = N && N[0]) !== null && P !== void 0 ? P : ""
			}

			function Ae(R, E) {
				let P = R.substr(E, 1);
				return P.match(/^[1-9]$/) ? P : ""
			}

			function xe(R, E) {
				var P;
				let N = R.substr(E).match(/^[0-9]+/);
				return (P = N && N[0]) !== null && P !== void 0 ? P : ""
			}

			function Vi(R, E) {
				let P = xe(R, E);
				if (P !== "") return P;
				let N = R.substr(E, 1);
				if (E += 1, N !== "-" && N !== "+") return "";
				let Y = xe(R, E);
				return Y === "" ? "" : N + Y
			}

			function ge(R, E) {
				let P = R.substr(E, 1);
				if (E += 1, P.toLowerCase() !== "e") return "";
				let N = Vi(R, E);
				return N === "" ? "" : P + N
			}

			function vi(R, E) {
				let P = R.substr(E, 1);
				if (P === "0") return P;
				let N = Ae(R, E);
				return E += N.length, N === "" ? "" : N + xe(R, E)
			}

			function ci(R, E) {
				let P = vi(R, E);
				if (E += P.length, P === "") return "";
				let N = R.substr(E, 1);
				if (E += N.length, N !== ".") return "";
				let Y = xe(R, E);
				return E += Y.length, P + N + Y + ge(R, E)
			}

			function pr(R, E) {
				let P = R.substr(E, 1);
				if (E += P.length, P !== ".") return "";
				let N = xe(R, E);
				return E += N.length, N === "" ? "" : P + N + ge(R, E)
			}

			function fr(R, E) {
				let P = vi(R, E);
				return E += P.length, P === "" ? "" : P + ge(R, E)
			}
			let Ls = zt([ci, pr, fr]);

			function ks(R, E) {
				var P;
				let N = R.substr(E).match(/^[01]+/);
				return (P = N && N[0]) !== null && P !== void 0 ? P : ""
			}

			function Ko(R, E) {
				let P = R.substr(E, 2);
				if (E += P.length, P.toLowerCase() !== "0b") return "";
				let N = ks(R, E);
				return N === "" ? "" : P + N
			}

			function K(R, E) {
				var P;
				let N = R.substr(E).match(/^[0-7]+/);
				return (P = N && N[0]) !== null && P !== void 0 ? P : ""
			}

			function ct(R, E) {
				let P = R.substr(E, 2);
				if (E += P.length, P.toLowerCase() !== "0o") return "";
				let N = K(R, E);
				return N === "" ? "" : P + N
			}

			function vt(R, E) {
				var P;
				let N = R.substr(E).match(/^[0-9a-f]+/i);
				return (P = N && N[0]) !== null && P !== void 0 ? P : ""
			}

			function ot(R, E) {
				let P = R.substr(E, 2);
				if (E += P.length, P.toLowerCase() !== "0x") return "";
				let N = vt(R, E);
				return N === "" ? "" : P + N
			}
			let _t = zt([Ko, ct, ot]),
				Ht = zt([_t, Ls]);

			function $t(R, E) {
				let P = Ht(R, E);
				return E += P.length, P === "" ? null : {
					evaluable: new Ie(P),
					cursor: E
				}
			}

			function Yt(R, E) {
				let P = R.substr(E, 1);
				if (E += P.length, P !== "(") return null;
				let N = Ke(R, E);
				if (!N) return null;
				E = N.cursor, E += fe(R, E).length;
				let Y = R.substr(E, 1);
				return E += Y.length, Y !== ")" ? null : {
					evaluable: N.evaluable,
					cursor: E
				}
			}

			function ee(R, E) {
				var P;
				return (P = $t(R, E)) !== null && P !== void 0 ? P : Yt(R, E)
			}

			function te(R, E) {
				let P = ee(R, E);
				if (P) return P;
				let N = R.substr(E, 1);
				if (E += N.length, N !== "+" && N !== "-" && N !== "~") return null;
				let Y = te(R, E);
				return Y ? (E = Y.cursor, {
					cursor: E,
					evaluable: new kt(N, Y.evaluable)
				}) : null
			}

			function se(R, E, P) {
				P += fe(E, P).length;
				let N = R.filter(Y => E.startsWith(Y, P))[0];
				return N ? (P += N.length, P += fe(E, P).length, {
					cursor: P,
					operator: N
				}) : null
			}

			function Jt(R, E) {
				return (P, N) => {
					let Y = R(P, N);
					if (!Y) return null;
					N = Y.cursor;
					let st = Y.evaluable;
					for (;;) {
						let ft = se(E, P, N);
						if (!ft) break;
						N = ft.cursor;
						let Tt = R(P, N);
						if (!Tt) return null;
						N = Tt.cursor, st = new gt(ft.operator, st, Tt.evaluable)
					}
					return st ? {
						cursor: N,
						evaluable: st
					} : null
				}
			}
			let we = [
				["**"],
				["*", "/", "%"],
				["+", "-"],
				["<<", ">>>", ">>"],
				["&"],
				["^"],
				["|"]
			].reduce((R, E) => Jt(R, E), te);

			function Ke(R, E) {
				return E += fe(R, E).length, we(R, E)
			}

			function Ci(R) {
				let E = Ke(R, 0);
				return !E || E.cursor + fe(R, E.cursor).length !== R.length ? null : E.evaluable
			}

			function Ti(R) {
				var E;
				let P = Ci(R);
				return (E = P == null ? void 0 : P.evaluate()) !== null && E !== void 0 ? E : null
			}

			function Be(R) {
				if (typeof R == "number") return R;
				if (typeof R == "string") {
					let E = Ti(R);
					if (!s(E)) return E
				}
				return 0
			}

			function Wt(R) {
				return E => E.toFixed(Math.max(Math.min(R, 20), 0))
			}
			let Rs = Wt(0);

			function Ve(R) {
				return Rs(R) + "%"
			}

			function un(R) {
				return String(R)
			}

			function qr(R, E) {
				for (; R.length < E;) R.push(void 0)
			}

			function $n(R) {
				let E = [];
				return qr(E, R), L(E)
			}

			function jr(R) {
				let E = R.indexOf(void 0);
				return E < 0 ? R : R.slice(0, E)
			}

			function ni(R, E) {
				let P = [...jr(R), E];
				return P.length > R.length ? P.splice(0, P.length - R.length) : qr(P, R.length), P
			}

			function yi({
				primary: R,
				secondary: E,
				forward: P,
				backward: N
			}) {
				let Y = !1;

				function st(ft) {
					Y || (Y = !0, ft(), Y = !1)
				}
				R.emitter.on("change", ft => {
					st(() => {
						E.setRawValue(P(R, E), ft.options)
					})
				}), E.emitter.on("change", ft => {
					st(() => {
						R.setRawValue(N(R, E), ft.options)
					}), st(() => {
						E.setRawValue(P(R, E), ft.options)
					})
				}), st(() => {
					E.setRawValue(P(R, E), {
						forceEmit: !1,
						last: !0
					})
				})
			}

			function dn(R, E) {
				let P = R * (E.altKey ? .1 : 1) * (E.shiftKey ? 10 : 1);
				return E.upKey ? +P : E.downKey ? -P : 0
			}

			function Ze(R) {
				return {
					altKey: R.altKey,
					downKey: R.key === "ArrowDown",
					shiftKey: R.shiftKey,
					upKey: R.key === "ArrowUp"
				}
			}

			function mr(R) {
				return {
					altKey: R.altKey,
					downKey: R.key === "ArrowLeft",
					shiftKey: R.shiftKey,
					upKey: R.key === "ArrowRight"
				}
			}

			function Zo(R) {
				return R === "ArrowUp" || R === "ArrowDown"
			}

			function Fs(R) {
				return Zo(R) || R === "ArrowLeft" || R === "ArrowRight"
			}

			function Jo(R, E) {
				var P, N;
				let Y = E.ownerDocument.defaultView,
					st = E.getBoundingClientRect();
				return {
					x: R.pageX - (((P = Y && Y.scrollX) !== null && P !== void 0 ? P : 0) + st.left),
					y: R.pageY - (((N = Y && Y.scrollY) !== null && N !== void 0 ? N : 0) + st.top)
				}
			}
			class Ra {
				constructor(E) {
					this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = E, this.emitter = new h, E.addEventListener("touchstart", this.onTouchStart_, {
						passive: !1
					}), E.addEventListener("touchmove", this.onTouchMove_, {
						passive: !0
					}), E.addEventListener("touchend", this.onTouchEnd_), E.addEventListener("mousedown", this.onMouseDown_)
				}
				computePosition_(E) {
					let P = this.elem_.getBoundingClientRect();
					return {
						bounds: {
							width: P.width,
							height: P.height
						},
						point: E ? {
							x: E.x,
							y: E.y
						} : null
					}
				}
				onMouseDown_(E) {
					var P;
					E.preventDefault(), (P = E.currentTarget) === null || P === void 0 || P.focus();
					let N = this.elem_.ownerDocument;
					N.addEventListener("mousemove", this.onDocumentMouseMove_), N.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
						altKey: E.altKey,
						data: this.computePosition_(Jo(E, this.elem_)),
						sender: this,
						shiftKey: E.shiftKey
					})
				}
				onDocumentMouseMove_(E) {
					this.emitter.emit("move", {
						altKey: E.altKey,
						data: this.computePosition_(Jo(E, this.elem_)),
						sender: this,
						shiftKey: E.shiftKey
					})
				}
				onDocumentMouseUp_(E) {
					let P = this.elem_.ownerDocument;
					P.removeEventListener("mousemove", this.onDocumentMouseMove_), P.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
						altKey: E.altKey,
						data: this.computePosition_(Jo(E, this.elem_)),
						sender: this,
						shiftKey: E.shiftKey
					})
				}
				onTouchStart_(E) {
					E.preventDefault();
					let P = E.targetTouches.item(0),
						N = this.elem_.getBoundingClientRect();
					this.emitter.emit("down", {
						altKey: E.altKey,
						data: this.computePosition_(P ? {
							x: P.clientX - N.left,
							y: P.clientY - N.top
						} : void 0),
						sender: this,
						shiftKey: E.shiftKey
					}), this.lastTouch_ = P
				}
				onTouchMove_(E) {
					let P = E.targetTouches.item(0),
						N = this.elem_.getBoundingClientRect();
					this.emitter.emit("move", {
						altKey: E.altKey,
						data: this.computePosition_(P ? {
							x: P.clientX - N.left,
							y: P.clientY - N.top
						} : void 0),
						sender: this,
						shiftKey: E.shiftKey
					}), this.lastTouch_ = P
				}
				onTouchEnd_(E) {
					var P;
					let N = (P = E.targetTouches.item(0)) !== null && P !== void 0 ? P : this.lastTouch_,
						Y = this.elem_.getBoundingClientRect();
					this.emitter.emit("up", {
						altKey: E.altKey,
						data: this.computePosition_(N ? {
							x: N.clientX - Y.left,
							y: N.clientY - Y.top
						} : void 0),
						sender: this,
						shiftKey: E.shiftKey
					})
				}
			}

			function $e(R, E, P, N, Y) {
				let st = (R - E) / (P - E);
				return N + st * (Y - N)
			}

			function Ah(R) {
				return String(R.toFixed(10)).split(".")[1].replace(/0+$/, "").length
			}

			function Xr(R, E, P) {
				return Math.min(Math.max(R, E), P)
			}
			let zi = u("txt");
			class pd {
				constructor(E, P) {
					this.onChange_ = this.onChange_.bind(this), this.props_ = P.props, this.props_.emitter.on("change", this.onChange_), this.element = E.createElement("div"), this.element.classList.add(zi(), zi(void 0, "num")), P.arrayPosition && this.element.classList.add(zi(void 0, P.arrayPosition)), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElement("input");
					N.classList.add(zi("i")), N.type = "text", P.viewProps.bindDisabled(N), this.element.appendChild(N), this.inputElement = N, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = P.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(zi()), this.inputElement.classList.add(zi("i"));
					let Y = E.createElement("div");
					Y.classList.add(zi("k")), this.element.appendChild(Y), this.knobElement = Y;
					let st = E.createElementNS(et, "svg");
					st.classList.add(zi("g")), this.knobElement.appendChild(st);
					let ft = E.createElementNS(et, "path");
					ft.classList.add(zi("gb")), st.appendChild(ft), this.guideBodyElem_ = ft;
					let Tt = E.createElementNS(et, "path");
					Tt.classList.add(zi("gh")), st.appendChild(Tt), this.guideHeadElem_ = Tt;
					let me = E.createElement("div");
					me.classList.add(u("tt")()), this.knobElement.appendChild(me), this.tooltipElem_ = me, P.value.emitter.on("change", this.onChange_), this.value = P.value, this.refresh()
				}
				onDraggingChange_(E) {
					if (E.rawValue === null) {
						this.element.classList.remove(zi(void 0, "drg"));
						return
					}
					this.element.classList.add(zi(void 0, "drg"));
					let P = E.rawValue / this.props_.get("draggingScale"),
						N = P + (P > 0 ? -1 : P < 0 ? 1 : 0),
						Y = Xr(-N, -4, 4);
					this.guideHeadElem_.setAttributeNS(null, "d", [`M ${N+Y},0 L${N},4 L${N+Y},8`, `M ${P},-1 L${P},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${P},4`);
					let st = this.props_.get("formatter");
					this.tooltipElem_.textContent = st(this.value.rawValue), this.tooltipElem_.style.left = `${P}px`
				}
				refresh() {
					let E = this.props_.get("formatter");
					this.inputElement.value = E(this.value.rawValue)
				}
				onChange_() {
					this.refresh()
				}
			}
			class Os {
				constructor(E, P) {
					var N;
					this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = P.baseStep, this.parser_ = P.parser, this.props = P.props, this.sliderProps_ = (N = P.sliderProps) !== null && N !== void 0 ? N : null, this.value = P.value, this.viewProps = P.viewProps, this.dragging_ = L(null), this.view = new pd(E, {
						arrayPosition: P.arrayPosition,
						dragging: this.dragging_,
						props: this.props,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
					let Y = new Ra(this.view.knobElement);
					Y.emitter.on("down", this.onPointerDown_), Y.emitter.on("move", this.onPointerMove_), Y.emitter.on("up", this.onPointerUp_)
				}
				constrainValue_(E) {
					var P, N;
					let Y = (P = this.sliderProps_) === null || P === void 0 ? void 0 : P.get("minValue"),
						st = (N = this.sliderProps_) === null || N === void 0 ? void 0 : N.get("maxValue"),
						ft = E;
					return Y !== void 0 && (ft = Math.max(ft, Y)), st !== void 0 && (ft = Math.min(ft, st)), ft
				}
				onInputChange_(E) {
					let N = E.currentTarget.value,
						Y = this.parser_(N);
					s(Y) || (this.value.rawValue = this.constrainValue_(Y)), this.view.refresh()
				}
				onInputKeyDown_(E) {
					let P = dn(this.baseStep_, Ze(E));
					P !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + P), {
						forceEmit: !1,
						last: !1
					})
				}
				onInputKeyUp_(E) {
					dn(this.baseStep_, Ze(E)) !== 0 && this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
				onPointerDown_() {
					this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
				}
				computeDraggingValue_(E) {
					if (!E.point) return null;
					let P = E.point.x - E.bounds.width / 2;
					return this.constrainValue_(this.originRawValue_ + P * this.props.get("draggingScale"))
				}
				onPointerMove_(E) {
					let P = this.computeDraggingValue_(E.data);
					P !== null && (this.value.setRawValue(P, {
						forceEmit: !1,
						last: !1
					}), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
				}
				onPointerUp_(E) {
					let P = this.computeDraggingValue_(E.data);
					P !== null && (this.value.setRawValue(P, {
						forceEmit: !0,
						last: !0
					}), this.dragging_.rawValue = null)
				}
			}

			function rn(R, E) {
				R.write(E)
			}

			function Yr(R) {
				let E = R ? Pt(R, mt) : null;
				return E ? E.step : null
			}

			function Ns(R, E) {
				let P = R && Pt(R, mt);
				return P ? Ah(P.step) : Math.max(Ah(E), 2)
			}

			function Qo(R) {
				let E = Yr(R);
				return E != null ? E : 1
			}

			function Fa(R, E) {
				var P;
				let N = R && Pt(R, mt),
					Y = Math.abs((P = N == null ? void 0 : N.step) !== null && P !== void 0 ? P : E);
				return Y === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(Y)) - 1)
			}

			function Kr(R) {
				return [R[0], R[1], R[2]]
			}

			function Dh(R) {
				let E = Xr(Math.floor(R), 0, 255).toString(16);
				return E.length === 1 ? `0${E}` : E
			}

			function Vs(R, E = "#") {
				let P = Kr(R.getComponents("rgb")).map(Dh).join("");
				return `${E}${P}`
			}

			function Ih(R, E = "#") {
				let P = R.getComponents("rgb"),
					N = [P[0], P[1], P[2], P[3] * 255].map(Dh).join("");
				return `${E}${N}`
			}

			function fd(R, E) {
				let P = Wt(E === "float" ? 2 : 0);
				return `rgb(${Kr(R.getComponents("rgb",E)).map(Y=>P(Y)).join(", ")})`
			}

			function Lh(R) {
				return E => fd(E, R)
			}

			function kh(R, E) {
				let P = Wt(2),
					N = Wt(E === "float" ? 2 : 0);
				return `rgba(${R.getComponents("rgb",E).map((st,ft)=>(ft===3?P:N)(st)).join(", ")})`
			}

			function md(R) {
				return E => kh(E, R)
			}

			function Oa(R) {
				let E = [Wt(0), Ve, Ve];
				return `hsl(${Kr(R.getComponents("hsl")).map((N,Y)=>E[Y](N)).join(", ")})`
			}

			function vd(R) {
				let E = [Wt(0), Ve, Ve, Wt(2)];
				return `hsla(${R.getComponents("hsl").map((N,Y)=>E[Y](N)).join(", ")})`
			}

			function Rh(R, E) {
				let P = Wt(E === "float" ? 2 : 0),
					N = ["r", "g", "b"];
				return `{${Kr(R.getComponents("rgb",E)).map((st,ft)=>`${N[ft]}: ${P(st)}`).join(", ")}}`
			}

			function Fh(R) {
				return E => Rh(E, R)
			}

			function gd(R, E) {
				let P = Wt(2),
					N = Wt(E === "float" ? 2 : 0),
					Y = ["r", "g", "b", "a"];
				return `{${R.getComponents("rgb",E).map((ft,Tt)=>{let me=Tt===3?P:N;return`${Y[Tt]}: ${me(ft)}`}).join(", ")}}`
			}

			function _d(R) {
				return E => gd(E, R)
			} [...["int", "float"].reduce((R, E) => [...R, {
				format: {
					alpha: !1,
					mode: "rgb",
					notation: "func",
					type: E
				},
				stringifier: Lh(E)
			}, {
				format: {
					alpha: !0,
					mode: "rgb",
					notation: "func",
					type: E
				},
				stringifier: md(E)
			}, {
				format: {
					alpha: !1,
					mode: "rgb",
					notation: "object",
					type: E
				},
				stringifier: Fh(E)
			}, {
				format: {
					alpha: !0,
					mode: "rgb",
					notation: "object",
					type: E
				},
				stringifier: _d(E)
			}], [])];
			class yd {
				constructor(E) {
					this.components = E.components, this.asm_ = E.assembly
				}
				constrain(E) {
					let P = this.asm_.toComponents(E).map((N, Y) => {
						var st, ft;
						return (ft = (st = this.components[Y]) === null || st === void 0 ? void 0 : st.constrain(N)) !== null && ft !== void 0 ? ft : N
					});
					return this.asm_.fromComponents(P)
				}
			}
			let Oh = u("pndtxt");
			class bd {
				constructor(E, P) {
					this.textViews = P.textViews, this.element = E.createElement("div"), this.element.classList.add(Oh()), this.textViews.forEach(N => {
						let Y = E.createElement("div");
						Y.classList.add(Oh("a")), Y.appendChild(N.element), this.element.appendChild(Y)
					})
				}
			}

			function tl(R, E, P) {
				return new Os(R, {
					arrayPosition: P === 0 ? "fst" : P === E.axes.length - 1 ? "lst" : "mid",
					baseStep: E.axes[P].baseStep,
					parser: E.parser,
					props: E.axes[P].textProps,
					value: L(0, {
						constraint: E.axes[P].constraint
					}),
					viewProps: E.viewProps
				})
			}
			class vr {
				constructor(E, P) {
					this.value = P.value, this.viewProps = P.viewProps, this.acs_ = P.axes.map((N, Y) => tl(E, P, Y)), this.acs_.forEach((N, Y) => {
						yi({
							primary: this.value,
							secondary: N.value,
							forward: st => P.assembly.toComponents(st.rawValue)[Y],
							backward: (st, ft) => {
								let Tt = P.assembly.toComponents(st.rawValue);
								return Tt[Y] = ft.rawValue, P.assembly.fromComponents(Tt)
							}
						})
					}), this.view = new bd(E, {
						textViews: this.acs_.map(N => N.view)
					})
				}
			}

			function xd(R, E) {
				return "step" in R && !s(R.step) ? new mt(R.step, E) : null
			}

			function zs(R) {
				return !s(R.max) && !s(R.min) ? new Bt({
					max: R.max,
					min: R.min
				}) : !s(R.max) || !s(R.min) ? new It({
					max: R.max,
					min: R.min
				}) : null
			}
			let wd = {
					monitor: {
						defaultInterval: 200,
						defaultLineCount: 3
					}
				},
				pn = u("grl");
			class Nh {
				constructor(E, P) {
					this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = E.createElement("div"), this.element.classList.add(pn()), P.viewProps.bindClassModifiers(this.element), this.formatter_ = P.formatter, this.props_ = P.props, this.cursor_ = P.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
					let N = E.createElementNS(et, "svg");
					N.classList.add(pn("g")), N.style.height = `calc(var(--bld-us) * ${P.lineCount})`, this.element.appendChild(N), this.svgElem_ = N;
					let Y = E.createElementNS(et, "polyline");
					this.svgElem_.appendChild(Y), this.lineElem_ = Y;
					let st = E.createElement("div");
					st.classList.add(pn("t"), u("tt")()), this.element.appendChild(st), this.tooltipElem_ = st, P.value.emitter.on("change", this.onValueUpdate_), this.value = P.value, this.update_()
				}
				get graphElement() {
					return this.svgElem_
				}
				update_() {
					let E = this.svgElem_.getBoundingClientRect(),
						P = this.value.rawValue.length - 1,
						N = this.props_.get("minValue"),
						Y = this.props_.get("maxValue"),
						st = [];
					this.value.rawValue.forEach((Gi, ae) => {
						if (Gi === void 0) return;
						let Xn = $e(ae, 0, P, 0, E.width),
							Od = $e(Gi, N, Y, E.height, 0);
						st.push([Xn, Od].join(","))
					}), this.lineElem_.setAttributeNS(null, "points", st.join(" "));
					let ft = this.tooltipElem_,
						Tt = this.value.rawValue[this.cursor_.rawValue];
					if (Tt === void 0) {
						ft.classList.remove(pn("t", "a"));
						return
					}
					let me = $e(this.cursor_.rawValue, 0, P, 0, E.width),
						Ui = $e(Tt, N, Y, E.height, 0);
					ft.style.left = `${me}px`, ft.style.top = `${Ui}px`, ft.textContent = `${this.formatter_(Tt)}`, ft.classList.contains(pn("t", "a")) || (ft.classList.add(pn("t", "a"), pn("t", "in")), it(ft), ft.classList.remove(pn("t", "in")))
				}
				onValueUpdate_() {
					this.update_()
				}
				onCursorChange_() {
					this.update_()
				}
			}
			class Sd {
				constructor(E, P) {
					if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = P.props, this.value = P.value, this.viewProps = P.viewProps, this.cursor_ = L(-1), this.view = new Nh(E, {
							cursor: this.cursor_,
							formatter: P.formatter,
							lineCount: P.lineCount,
							props: this.props_,
							value: this.value,
							viewProps: this.viewProps
						}), !wt(E)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
					else {
						let N = new Ra(this.view.element);
						N.emitter.on("down", this.onGraphPointerDown_), N.emitter.on("move", this.onGraphPointerMove_), N.emitter.on("up", this.onGraphPointerUp_)
					}
				}
				onGraphMouseLeave_() {
					this.cursor_.rawValue = -1
				}
				onGraphMouseMove_(E) {
					let P = this.view.element.getBoundingClientRect();
					this.cursor_.rawValue = Math.floor($e(E.offsetX, 0, P.width, 0, this.value.rawValue.length))
				}
				onGraphPointerDown_(E) {
					this.onGraphPointerMove_(E)
				}
				onGraphPointerMove_(E) {
					if (!E.data.point) {
						this.cursor_.rawValue = -1;
						return
					}
					this.cursor_.rawValue = Math.floor($e(E.data.point.x, 0, E.data.bounds.width, 0, this.value.rawValue.length))
				}
				onGraphPointerUp_() {
					this.cursor_.rawValue = -1
				}
			}
			class Vh {
				constructor(E) {
					this.controller_ = E
				}
				get disabled() {
					return this.controller_.viewProps.get("disabled")
				}
				set disabled(E) {
					this.controller_.viewProps.set("disabled", E)
				}
				get title() {
					var E;
					return (E = this.controller_.props.get("title")) !== null && E !== void 0 ? E : ""
				}
				set title(E) {
					this.controller_.props.set("title", E)
				}
				on(E, P) {
					let N = P.bind(this);
					return this.controller_.emitter.on(E, () => {
						N(new e(this))
					}), this
				}
			}
			class Ed extends e {
				constructor(E, P, N) {
					super(E), this.cell = P, this.index = N
				}
			}
			class zh extends t {
				constructor(E) {
					super(E), this.cellToApiMap_ = new Map, this.emitter_ = new h;
					let P = this.controller_.valueController;
					P.cellControllers.forEach((N, Y) => {
						let st = new Vh(N);
						this.cellToApiMap_.set(N, st), N.emitter.on("click", () => {
							let ft = Y % P.size[0],
								Tt = Math.floor(Y / P.size[0]);
							this.emitter_.emit("click", {
								event: new Ed(this, st, [ft, Tt])
							})
						})
					})
				}
				cell(E, P) {
					let N = this.controller_.valueController,
						Y = N.cellControllers[P * N.size[0] + E];
					return this.cellToApiMap_.get(Y)
				}
				on(E, P) {
					let N = P.bind(this);
					return this.emitter_.on(E, Y => {
						N(Y.event)
					}), this
				}
			}
			class el {
				constructor(E, P) {
					this.size = P.size;
					let [N, Y] = this.size, st = [];
					for (let ft = 0; ft < Y; ft++)
						for (let Tt = 0; Tt < N; Tt++) {
							let me = new M(E, {
								props: F.fromObject(Object.assign({}, P.cellConfig(Tt, ft))),
								viewProps: q.create()
							});
							st.push(me)
						}
					this.cellCs_ = st, this.viewProps = q.create(), this.viewProps.handleDispose(() => {
						this.cellCs_.forEach(ft => {
							ft.viewProps.set("disposed", !0)
						})
					}), this.view = new Z(E, {
						viewProps: this.viewProps,
						viewName: "btngrid"
					}), this.view.element.style.gridTemplateColumns = `repeat(${N}, 1fr)`, this.cellCs_.forEach(ft => {
						this.view.element.appendChild(ft.view.element)
					})
				}
				get cellControllers() {
					return this.cellCs_
				}
			}
			let Md = {
				id: "buttongrid",
				type: "blade",
				css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
				accept(R) {
					let E = $,
						P = W(R, {
							cells: E.required.function,
							size: E.required.array(E.required.number),
							view: E.required.constant("buttongrid"),
							label: E.optional.string
						});
					return P ? {
						params: P
					} : null
				},
				controller(R) {
					return new qt(R.document, {
						blade: R.blade,
						props: F.fromObject({
							label: R.params.label
						}),
						valueController: new el(R.document, {
							cellConfig: R.params.cells,
							size: R.params.size
						})
					})
				},
				api(R) {
					return !(R.controller instanceof qt) || !(R.controller.valueController instanceof el) ? null : new zh(R.controller)
				}
			};
			class Bh extends t {
				get label() {
					return this.controller_.props.get("label")
				}
				set label(E) {
					this.controller_.props.set("label", E)
				}
				get value() {
					return this.controller_.valueController.value.rawValue
				}
				set value(E) {
					this.controller_.valueController.value.rawValue = E
				}
				on(E, P) {
					let N = P.bind(this);
					return this.controller_.valueController.value.emitter.on(E, Y => {
						N(new n(this, Y.rawValue, void 0, Y.options.last))
					}), this
				}
			}

			function Bi(R, E, P) {
				return R * (1 - P) + E * P
			}
			let Cd = 20,
				Td = .001,
				il = 100;

			function Pd(R, E) {
				let P = .25,
					N = .5,
					Y = -1;
				for (let st = 0; st < Cd; st++) {
					let [ft, Tt] = R.curve(N);
					if (N += P * (ft < E ? 1 : -1), Y = Tt, P *= .5, Math.abs(E - ft) < Td) break
				}
				return Y
			}
			class qn {
				constructor(E = 0, P = 0, N = 1, Y = 1) {
					this.cache_ = [], this.comps_ = [E, P, N, Y]
				}
				get x1() {
					return this.comps_[0]
				}
				get y1() {
					return this.comps_[1]
				}
				get x2() {
					return this.comps_[2]
				}
				get y2() {
					return this.comps_[3]
				}
				static isObject(E) {
					return s(E) || !Array.isArray(E) ? !1 : typeof E[0] == "number" && typeof E[1] == "number" && typeof E[2] == "number" && typeof E[3] == "number"
				}
				static equals(E, P) {
					return E.x1 === P.x1 && E.y1 === P.y1 && E.x2 === P.x2 && E.y2 === P.y2
				}
				curve(E) {
					let P = Bi(0, this.x1, E),
						N = Bi(0, this.y1, E),
						Y = Bi(this.x1, this.x2, E),
						st = Bi(this.y1, this.y2, E),
						ft = Bi(this.x2, 1, E),
						Tt = Bi(this.y2, 1, E),
						me = Bi(P, Y, E),
						Ui = Bi(N, st, E),
						Gi = Bi(Y, ft, E),
						ae = Bi(st, Tt, E);
					return [Bi(me, Gi, E), Bi(Ui, ae, E)]
				}
				y(E) {
					if (this.cache_.length === 0) {
						let P = [];
						for (let N = 0; N < il; N++) P.push(Pd(this, $e(N, 0, il - 1, 0, 1)));
						this.cache_ = P
					}
					return this.cache_[Math.round($e(Xr(E, 0, 1), 0, 1, 0, il - 1))]
				}
				toObject() {
					return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]]
				}
			}
			let nl = {
				toComponents: R => R.toObject(),
				fromComponents: R => new qn(...R)
			};

			function Ad(R) {
				let E = Wt(2);
				return `cubic-bezier(${R.toObject().map(N=>E(N)).join(", ")})`
			}
			let rl = [0, .5, .5, 1];

			function Dd(R) {
				let E = R.match(/^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/);
				if (!E) return new qn(...rl);
				let P = [E[1], E[2], E[3], E[4]].reduce((N, Y) => {
					if (!N) return null;
					let st = Number(Y);
					return isNaN(st) ? null : [...N, st]
				}, []);
				return new qn(...P != null ? P : rl)
			}
			let gr = u("cbz");
			class Uh {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(gr()), P.viewProps.bindClassModifiers(this.element), P.foldable.bindExpandedClass(this.element, gr(void 0, "expanded")), b(P.foldable, "completed", w(this.element, gr(void 0, "cpl")));
					let N = E.createElement("div");
					N.classList.add(gr("h")), this.element.appendChild(N);
					let Y = E.createElement("button");
					Y.classList.add(gr("b")), P.viewProps.bindDisabled(Y);
					let st = E.createElementNS(et, "svg");
					st.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>', Y.appendChild(st), N.appendChild(Y), this.buttonElement = Y;
					let ft = E.createElement("div");
					if (ft.classList.add(gr("t")), N.appendChild(ft), this.textElement = ft, P.pickerLayout === "inline") {
						let Tt = E.createElement("div");
						Tt.classList.add(gr("p")), this.element.appendChild(Tt), this.pickerElement = Tt
					} else this.pickerElement = null
				}
			}
			let Na = u("cbzp");
			class Gh {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(Na()), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElement("div");
					N.classList.add(Na("g")), this.element.appendChild(N), this.graphElement = N;
					let Y = E.createElement("div");
					Y.classList.add(Na("t")), this.element.appendChild(Y), this.textElement = Y
				}
			}

			function fn(R, E) {
				let P = new MutationObserver(Y => {
						for (let st of Y) st.type === "childList" && st.addedNodes.forEach(ft => {
							ft.contains(ft) && (E(), P.disconnect())
						})
					}),
					N = R.ownerDocument;
				P.observe(N.body, {
					attributes: !0,
					childList: !0,
					subtree: !0
				})
			}
			let An = u("cbzg");

			function Id(R, E) {
				return P => E(R(P))
			}
			class Qe {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(An()), P.viewProps.bindClassModifiers(this.element), P.viewProps.bindTabIndex(this.element);
					let N = E.createElement("div");
					N.classList.add(An("p")), this.element.appendChild(N), this.previewElement = N;
					let Y = E.createElementNS(et, "svg");
					Y.classList.add(An("g")), this.element.appendChild(Y), this.svgElem_ = Y;
					let st = E.createElementNS(et, "path");
					st.classList.add(An("u")), this.svgElem_.appendChild(st), this.guideElem_ = st;
					let ft = E.createElementNS(et, "polyline");
					ft.classList.add(An("l")), this.svgElem_.appendChild(ft), this.lineElem_ = ft, this.handleElems_ = [E.createElement("div"), E.createElement("div")], this.handleElems_.forEach(Tt => {
						Tt.classList.add(An("h")), this.element.appendChild(Tt)
					}), this.vectorElems_ = [E.createElementNS(et, "line"), E.createElementNS(et, "line")], this.vectorElems_.forEach(Tt => {
						Tt.classList.add(An("v")), this.svgElem_.appendChild(Tt)
					}), this.value_ = P.value, this.value_.emitter.on("change", this.onValueChange_.bind(this)), this.sel_ = P.selection, this.handleElems_.forEach((Tt, me) => {
						_(this.sel_, Id(Ui => Ui === me, w(Tt, An("h", "sel"))))
					}), fn(this.element, () => {
						this.refresh()
					})
				}
				getVertMargin_(E) {
					return E * .25
				}
				valueToPosition(E, P) {
					let N = this.element.getBoundingClientRect(),
						Y = N.width,
						st = N.height,
						ft = this.getVertMargin_(st);
					return {
						x: $e(E, 0, 1, 0, Y),
						y: $e(P, 0, 1, st - ft, ft)
					}
				}
				positionToValue(E, P) {
					let N = this.element.getBoundingClientRect(),
						Y = N.width,
						st = N.height,
						ft = this.getVertMargin_(st);
					return {
						x: Xr($e(E, 0, Y, 0, 1), 0, 1),
						y: $e(P, st - ft, ft, 0, 1)
					}
				}
				refresh() {
					this.guideElem_.setAttributeNS(null, "d", [0, 1].map(st => {
						let ft = this.valueToPosition(0, st),
							Tt = this.valueToPosition(1, st);
						return [`M ${ft.x},${ft.y}`, `L ${Tt.x},${Tt.y}`].join(" ")
					}).join(" "));
					let E = this.value_.rawValue,
						P = [],
						N = 0;
					for (;;) {
						let st = this.valueToPosition(...E.curve(N));
						if (P.push([st.x, st.y].join(",")), N >= 1) break;
						N = Math.min(N + .05, 1)
					}
					this.lineElem_.setAttributeNS(null, "points", P.join(" "));
					let Y = E.toObject();
					[0, 1].forEach(st => {
						let ft = this.valueToPosition(st, st),
							Tt = this.valueToPosition(Y[st * 2], Y[st * 2 + 1]),
							me = this.vectorElems_[st];
						me.setAttributeNS(null, "x1", String(ft.x)), me.setAttributeNS(null, "y1", String(ft.y)), me.setAttributeNS(null, "x2", String(Tt.x)), me.setAttributeNS(null, "y2", String(Tt.y));
						let Ui = this.handleElems_[st];
						Ui.style.left = `${Tt.x}px`, Ui.style.top = `${Tt.y}px`
					})
				}
				onValueChange_() {
					this.refresh()
				}
			}
			let Hh = 24,
				Bs = 400,
				sl = 1e3,
				jn = u("cbzprv");
			class Zr {
				constructor(E, P) {
					this.stopped_ = !0, this.startTime_ = -1, this.onDispose_ = this.onDispose_.bind(this), this.onTimer_ = this.onTimer_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.element = E.createElement("div"), this.element.classList.add(jn()), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElementNS(et, "svg");
					N.classList.add(jn("g")), this.element.appendChild(N), this.svgElem_ = N;
					let Y = E.createElementNS(et, "path");
					Y.classList.add(jn("t")), this.svgElem_.appendChild(Y), this.ticksElem_ = Y;
					let st = E.createElement("div");
					st.classList.add(jn("m")), this.element.appendChild(st), this.markerElem_ = st, this.value_ = P.value, this.value_.emitter.on("change", this.onValueChange_), P.viewProps.handleDispose(this.onDispose_), fn(this.element, () => {
						this.refresh()
					})
				}
				play() {
					this.stop(), this.updateMarker_(0), this.markerElem_.classList.add(jn("m", "a")), this.startTime_ = new Date().getTime() + Bs, this.stopped_ = !1, requestAnimationFrame(this.onTimer_)
				}
				stop() {
					this.stopped_ = !0, this.markerElem_.classList.remove(jn("m", "a"))
				}
				onDispose_() {
					this.stop()
				}
				updateMarker_(E) {
					let P = this.value_.rawValue.y(Xr(E, 0, 1));
					this.markerElem_.style.left = `${P*100}%`
				}
				refresh() {
					let E = this.svgElem_.getBoundingClientRect(),
						P = E.width,
						N = E.height,
						Y = [],
						st = this.value_.rawValue;
					for (let ft = 0; ft < Hh; ft++) {
						let Tt = $e(ft, 0, Hh - 1, 0, 1),
							me = $e(st.y(Tt), 0, 1, 0, P);
						Y.push(`M ${me},0 v${N}`)
					}
					this.ticksElem_.setAttributeNS(null, "d", Y.join(" "))
				}
				onTimer_() {
					if (this.startTime_ === null) return;
					let E = new Date().getTime() - this.startTime_,
						P = E / sl;
					this.updateMarker_(P), E > sl + Bs && this.stop(), this.stopped_ || requestAnimationFrame(this.onTimer_)
				}
				onValueChange_() {
					this.refresh(), this.play()
				}
			}

			function ui(R, E, P, N) {
				let Y = P - R,
					st = N - E;
				return Math.sqrt(Y * Y + st * st)
			}

			function Us(R, E, P, N) {
				let Y = ui(R, E, P, N),
					st = Math.atan2(N - E, P - R),
					ft = Math.round(st / (Math.PI / 4)) * Math.PI / 4;
				return {
					x: R + Math.cos(ft) * Y,
					y: E + Math.sin(ft) * Y
				}
			}
			class mn {
				constructor(E, P) {
					this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = P.baseStep, this.value = P.value, this.sel_ = L(0), this.viewProps = P.viewProps, this.view = new Qe(E, {
						selection: this.sel_,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_), this.prevView_ = new Zr(E, {
						value: this.value,
						viewProps: this.viewProps
					}), this.prevView_.element.addEventListener("mousedown", Y => {
						Y.stopImmediatePropagation(), Y.preventDefault(), this.prevView_.play()
					}), this.view.previewElement.appendChild(this.prevView_.element);
					let N = new Ra(this.view.element);
					N.emitter.on("down", this.onPointerDown_), N.emitter.on("move", this.onPointerMove_), N.emitter.on("up", this.onPointerUp_)
				}
				refresh() {
					this.view.refresh(), this.prevView_.refresh(), this.prevView_.play()
				}
				updateValue_(E, P, N) {
					let Y = this.sel_.rawValue,
						st = this.value.rawValue.toObject(),
						ft = this.view.positionToValue(E.x, E.y),
						Tt = P ? Us(Y, Y, ft.x, ft.y) : ft;
					st[Y * 2] = Tt.x, st[Y * 2 + 1] = Tt.y, this.value.setRawValue(new qn(...st), N)
				}
				onPointerDown_(E) {
					let P = E.data;
					if (!P.point) return;
					let N = this.value.rawValue,
						Y = this.view.valueToPosition(N.x1, N.y1),
						st = ui(P.point.x, P.point.y, Y.x, Y.y),
						ft = this.view.valueToPosition(N.x2, N.y2),
						Tt = ui(P.point.x, P.point.y, ft.x, ft.y);
					this.sel_.rawValue = st <= Tt ? 0 : 1, this.updateValue_(P.point, E.shiftKey, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerMove_(E) {
					let P = E.data;
					P.point && this.updateValue_(P.point, E.shiftKey, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(E) {
					let P = E.data;
					P.point && this.updateValue_(P.point, E.shiftKey, {
						forceEmit: !0,
						last: !0
					})
				}
				onKeyDown_(E) {
					Fs(E.key) && E.preventDefault();
					let P = this.sel_.rawValue,
						N = this.value.rawValue.toObject();
					N[P * 2] += dn(this.baseStep_, mr(E)), N[P * 2 + 1] += dn(this.baseStep_, Ze(E)), this.value.setRawValue(new qn(...N), {
						forceEmit: !1,
						last: !1
					})
				}
				onKeyUp_(E) {
					Fs(E.key) && E.preventDefault();
					let P = dn(this.baseStep_, mr(E)),
						N = dn(this.baseStep_, Ze(E));
					P === 0 && N === 0 || this.value.setRawValue(this.value.rawValue, {
						forceEmit: !0,
						last: !0
					})
				}
			}
			class Wh {
				constructor(E, P) {
					this.value = P.value, this.viewProps = P.viewProps, this.view = new Gh(E, {
						viewProps: this.viewProps
					}), this.gc_ = new mn(E, {
						baseStep: P.axis.baseStep,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.graphElement.appendChild(this.gc_.view.element);
					let N = Object.assign(Object.assign({}, P.axis), {
							constraint: new It({
								max: 1,
								min: 0
							})
						}),
						Y = Object.assign(Object.assign({}, P.axis), {
							constraint: void 0
						});
					this.tc_ = new vr(E, {
						assembly: nl,
						axes: [N, Y, N, Y],
						parser: Ti,
						value: this.value,
						viewProps: this.viewProps
					}), this.view.textElement.appendChild(this.tc_.view.element)
				}
				get allFocusableElements() {
					return [this.gc_.view.element, ...this.tc_.view.textViews.map(E => E.inputElement)]
				}
				refresh() {
					this.gc_.refresh()
				}
			}
			class Va {
				constructor(E, P) {
					this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = P.value, this.viewProps = P.viewProps, this.foldable_ = de(P.expanded), this.view = new Uh(E, {
						foldable: this.foldable_,
						pickerLayout: P.pickerLayout,
						viewProps: this.viewProps
					}), this.view.buttonElement.addEventListener("blur", this.onButtonBlur_), this.view.buttonElement.addEventListener("click", this.onButtonClick_), this.tc_ = new ce(E, {
						parser: Dd,
						props: F.fromObject({
							formatter: Ad
						}),
						value: this.value,
						viewProps: this.viewProps
					}), this.view.textElement.appendChild(this.tc_.view.element), this.popC_ = P.pickerLayout === "popup" ? new Ut(E, {
						viewProps: this.viewProps
					}) : null;
					let N = new Wh(E, {
						axis: P.axis,
						value: this.value,
						viewProps: this.viewProps
					});
					N.allFocusableElements.forEach(Y => {
						Y.addEventListener("blur", this.onPopupChildBlur_), Y.addEventListener("keydown", this.onPopupChildKeydown_)
					}), this.pickerC_ = N, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), _(this.popC_.shows, Y => {
						Y && N.refresh()
					}), yi({
						primary: this.foldable_.value("expanded"),
						secondary: this.popC_.shows,
						forward: Y => Y.rawValue,
						backward: (Y, st) => st.rawValue
					})) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ye(this.foldable_, this.view.pickerElement))
				}
				onButtonBlur_(E) {
					if (!this.popC_) return;
					let P = E.relatedTarget;
					(!P || !this.popC_.view.element.contains(P)) && (this.popC_.shows.rawValue = !1)
				}
				onButtonClick_() {
					this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.allFocusableElements[0].focus()
				}
				onPopupChildBlur_(E) {
					if (!this.popC_) return;
					let P = this.popC_.view.element,
						N = At(E);
					N && P.contains(N) || N && N === this.view.buttonElement && !wt(P.ownerDocument) || (this.popC_.shows.rawValue = !1)
				}
				onPopupChildKeydown_(E) {
					this.popC_ && E.key === "Escape" && (this.popC_.shows.rawValue = !1)
				}
			}

			function al() {
				return new yd({
					assembly: nl,
					components: [0, 1, 2, 3].map(R => R % 2 === 0 ? new It({
						min: 0,
						max: 1
					}) : void 0)
				})
			}
			let _r = {
				id: "cubic-bezier",
				type: "blade",
				css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
				accept(R) {
					let E = $,
						P = W(R, {
							value: E.required.array(E.required.number),
							view: E.required.constant("cubicbezier"),
							expanded: E.optional.boolean,
							label: E.optional.string,
							picker: E.optional.custom(N => N === "inline" || N === "popup" ? N : void 0)
						});
					return P ? {
						params: P
					} : null
				},
				controller(R) {
					var E, P;
					let N = new qn(...R.params.value),
						Y = L(N, {
							constraint: al(),
							equals: qn.equals
						}),
						st = new Va(R.document, {
							axis: {
								baseStep: .1,
								textProps: F.fromObject({
									draggingScale: .01,
									formatter: Wt(2)
								})
							},
							expanded: (E = R.params.expanded) !== null && E !== void 0 ? E : !1,
							pickerLayout: (P = R.params.picker) !== null && P !== void 0 ? P : "popup",
							value: Y,
							viewProps: R.viewProps
						});
					return new X(R.document, {
						blade: R.blade,
						props: F.fromObject({
							label: R.params.label
						}),
						valueController: st
					})
				},
				api(R) {
					return !(R.controller instanceof X) || !(R.controller.valueController instanceof Va) ? null : new Bh(R.controller)
				}
			};
			class Le extends t {
				begin() {
					this.controller_.valueController.begin()
				}
				end() {
					this.controller_.valueController.end()
				}
			}
			let ol = 20;
			class qe {
				constructor() {
					this.start_ = null, this.duration_ = 0, this.fps_ = null, this.frameCount_ = 0, this.timestamps_ = []
				}
				get duration() {
					return this.duration_
				}
				get fps() {
					return this.fps_
				}
				begin(E) {
					this.start_ = E.getTime()
				}
				calculateFps_(E) {
					if (this.timestamps_.length === 0) return null;
					let P = this.timestamps_[0];
					return 1e3 * (this.frameCount_ - P.frameCount) / (E - P.time)
				}
				compactTimestamps_() {
					if (this.timestamps_.length <= ol) return;
					let E = this.timestamps_.length - ol;
					this.timestamps_.splice(0, E);
					let P = this.timestamps_[0].frameCount;
					this.timestamps_.forEach(N => {
						N.frameCount -= P
					}), this.frameCount_ -= P
				}
				end(E) {
					if (this.start_ === null) return;
					let P = E.getTime();
					this.duration_ = P - this.start_, this.start_ = null, this.fps_ = this.calculateFps_(P), this.timestamps_.push({
						frameCount: this.frameCount_,
						time: P
					}), ++this.frameCount_, this.compactTimestamps_()
				}
			}
			let Jr = u("fps");
			class Pi {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(Jr()), P.viewProps.bindClassModifiers(this.element), this.graphElement = E.createElement("div"), this.graphElement.classList.add(Jr("g")), this.element.appendChild(this.graphElement);
					let N = E.createElement("div");
					N.classList.add(Jr("l")), this.element.appendChild(N);
					let Y = E.createElement("span");
					Y.classList.add(Jr("v")), Y.textContent = "--", N.appendChild(Y), this.valueElement = Y;
					let st = E.createElement("span");
					st.classList.add(Jr("u")), st.textContent = "FPS", N.appendChild(st)
				}
			}
			class ll {
				constructor(E, P) {
					this.stopwatch_ = new qe, this.onTick_ = this.onTick_.bind(this), this.ticker_ = P.ticker, this.ticker_.emitter.on("tick", this.onTick_), this.value_ = P.value, this.viewProps = P.viewProps, this.view = new Pi(E, {
						viewProps: this.viewProps
					}), this.graphC_ = new Sd(E, {
						formatter: Wt(0),
						lineCount: P.lineCount,
						props: F.fromObject({
							maxValue: P.maxValue,
							minValue: P.minValue
						}),
						value: this.value_,
						viewProps: this.viewProps
					}), this.view.graphElement.appendChild(this.graphC_.view.element), this.viewProps.handleDispose(() => {
						this.graphC_.viewProps.set("disposed", !0), this.ticker_.dispose()
					})
				}
				begin() {
					this.stopwatch_.begin(new Date)
				}
				end() {
					this.stopwatch_.end(new Date)
				}
				onTick_() {
					let E = this.stopwatch_.fps;
					if (E !== null) {
						let P = this.value_.rawValue;
						this.value_.rawValue = ni(P, E), this.view.valueElement.textContent = E.toFixed(0)
					}
				}
			}

			function Gs(R, E) {
				return E === 0 ? new pt : new xt(R, E != null ? E : wd.monitor.defaultInterval)
			}
			let hl = {
				id: "fpsgraph",
				type: "blade",
				accept(R) {
					let E = $,
						P = W(R, {
							view: E.required.constant("fpsgraph"),
							interval: E.optional.number,
							label: E.optional.string,
							lineCount: E.optional.number,
							max: E.optional.number,
							min: E.optional.number
						});
					return P ? {
						params: P
					} : null
				},
				controller(R) {
					var E, P, N, Y;
					let st = (E = R.params.interval) !== null && E !== void 0 ? E : 500;
					return new qt(R.document, {
						blade: R.blade,
						props: F.fromObject({
							label: R.params.label
						}),
						valueController: new ll(R.document, {
							lineCount: (P = R.params.lineCount) !== null && P !== void 0 ? P : 2,
							maxValue: (N = R.params.max) !== null && N !== void 0 ? N : 90,
							minValue: (Y = R.params.min) !== null && Y !== void 0 ? Y : 0,
							ticker: Gs(R.document, st),
							value: $n(80),
							viewProps: R.viewProps
						})
					})
				},
				api(R) {
					return !(R.controller instanceof qt) || !(R.controller.valueController instanceof ll) ? null : new Le(R.controller)
				}
			};
			class Ai {
				constructor(E, P) {
					this.min = E, this.max = P
				}
				static isObject(E) {
					if (typeof E != "object" || E === null) return !1;
					let P = E.min,
						N = E.max;
					return !(typeof P != "number" || typeof N != "number")
				}
				static equals(E, P) {
					return E.min === P.min && E.max === P.max
				}
				get length() {
					return this.max - this.min
				}
				toObject() {
					return {
						min: this.min,
						max: this.max
					}
				}
			}
			let cl = {
				fromComponents: R => new Ai(R[0], R[1]),
				toComponents: R => [R.min, R.max]
			};
			class Hs {
				constructor(E) {
					this.edge = E
				}
				constrain(E) {
					var P, N, Y, st, ft, Tt, me, Ui;
					if (E.min <= E.max) return new Ai((N = (P = this.edge) === null || P === void 0 ? void 0 : P.constrain(E.min)) !== null && N !== void 0 ? N : E.min, (st = (Y = this.edge) === null || Y === void 0 ? void 0 : Y.constrain(E.max)) !== null && st !== void 0 ? st : E.max);
					let Gi = (E.min + E.max) / 2;
					return new Ai((Tt = (ft = this.edge) === null || ft === void 0 ? void 0 : ft.constrain(Gi)) !== null && Tt !== void 0 ? Tt : Gi, (Ui = (me = this.edge) === null || me === void 0 ? void 0 : me.constrain(Gi)) !== null && Ui !== void 0 ? Ui : Gi)
				}
			}
			let ul = u("rsltxt");
			class za {
				constructor(E, P) {
					this.sliderView_ = P.sliderView, this.textView_ = P.textView, this.element = E.createElement("div"), this.element.classList.add(ul());
					let N = E.createElement("div");
					N.classList.add(ul("s")), N.appendChild(this.sliderView_.element), this.element.appendChild(N);
					let Y = E.createElement("div");
					Y.classList.add(ul("t")), Y.appendChild(this.textView_.element), this.element.appendChild(Y)
				}
			}
			let sn = u("rsl");
			class Ws {
				constructor(E, P) {
					this.onSliderPropsChange_ = this.onSliderPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.sliderProps_ = P.sliderProps, this.sliderProps_.emitter.on("change", this.onSliderPropsChange_), this.element = E.createElement("div"), this.element.classList.add(sn()), P.viewProps.bindClassModifiers(this.element), this.value_ = P.value, this.value_.emitter.on("change", this.onValueChange_);
					let N = E.createElement("div");
					N.classList.add(sn("t")), this.element.appendChild(N), this.trackElement = N;
					let Y = E.createElement("div");
					Y.classList.add(sn("b")), N.appendChild(Y), this.barElement = Y;
					let st = ["min", "max"].map(ft => {
						let Tt = E.createElement("div");
						return Tt.classList.add(sn("k"), sn("k", ft)), N.appendChild(Tt), Tt
					});
					this.knobElements = [st[0], st[1]], this.update_()
				}
				valueToX_(E) {
					let P = this.sliderProps_.get("minValue"),
						N = this.sliderProps_.get("maxValue");
					return Xr($e(E, P, N, 0, 1), 0, 1) * 100
				}
				update_() {
					let E = this.value_.rawValue;
					E.length === 0 ? this.element.classList.add(sn(void 0, "zero")) : this.element.classList.remove(sn(void 0, "zero"));
					let P = [this.valueToX_(E.min), this.valueToX_(E.max)];
					this.barElement.style.left = `${P[0]}%`, this.barElement.style.right = `${100-P[1]}%`, this.knobElements.forEach((N, Y) => {
						N.style.left = `${P[Y]}%`
					})
				}
				onSliderPropsChange_() {
					this.update_()
				}
				onValueChange_() {
					this.update_()
				}
			}
			class dl {
				constructor(E, P) {
					this.grabbing_ = null, this.grabOffset_ = 0, this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.sliderProps = P.sliderProps, this.viewProps = P.viewProps, this.value = P.value, this.view = new Ws(E, {
						sliderProps: this.sliderProps,
						value: this.value,
						viewProps: P.viewProps
					});
					let N = new Ra(this.view.trackElement);
					N.emitter.on("down", this.onPointerDown_), N.emitter.on("move", this.onPointerMove_), N.emitter.on("up", this.onPointerUp_)
				}
				ofs_() {
					return this.grabbing_ === "min" ? this.view.knobElements[0].getBoundingClientRect().width / 2 : this.grabbing_ === "max" ? -this.view.knobElements[1].getBoundingClientRect().width / 2 : 0
				}
				valueFromData_(E) {
					if (!E.point) return null;
					let P = (E.point.x + this.ofs_()) / E.bounds.width,
						N = this.sliderProps.get("minValue"),
						Y = this.sliderProps.get("maxValue");
					return $e(P, 0, 1, N, Y)
				}
				onPointerDown_(E) {
					if (!E.data.point) return;
					let P = E.data.point.x / E.data.bounds.width,
						N = this.value.rawValue,
						Y = this.sliderProps.get("minValue"),
						st = this.sliderProps.get("maxValue"),
						ft = $e(N.min, Y, st, 0, 1),
						Tt = $e(N.max, Y, st, 0, 1);
					Math.abs(Tt - P) <= .025 ? this.grabbing_ = "max" : Math.abs(ft - P) <= .025 ? this.grabbing_ = "min" : P >= ft && P <= Tt ? (this.grabbing_ = "length", this.grabOffset_ = $e(P - ft, 0, 1, 0, st - Y)) : P < ft ? (this.grabbing_ = "min", this.onPointerMove_(E)) : P > Tt && (this.grabbing_ = "max", this.onPointerMove_(E))
				}
				applyPointToValue_(E, P) {
					let N = this.valueFromData_(E);
					if (N === null) return;
					let Y = this.sliderProps.get("minValue"),
						st = this.sliderProps.get("maxValue");
					if (this.grabbing_ === "min") this.value.setRawValue(new Ai(N, this.value.rawValue.max), P);
					else if (this.grabbing_ === "max") this.value.setRawValue(new Ai(this.value.rawValue.min, N), P);
					else if (this.grabbing_ === "length") {
						let ft = this.value.rawValue.length,
							Tt = N - this.grabOffset_,
							me = Tt + ft;
						Tt < Y ? (Tt = Y, me = Y + ft) : me > st && (Tt = st - ft, me = st), this.value.setRawValue(new Ai(Tt, me), P)
					}
				}
				onPointerMove_(E) {
					this.applyPointToValue_(E.data, {
						forceEmit: !1,
						last: !1
					})
				}
				onPointerUp_(E) {
					this.applyPointToValue_(E.data, {
						forceEmit: !0,
						last: !0
					}), this.grabbing_ = null
				}
			}
			class Dn {
				constructor(E, P) {
					this.value = P.value, this.viewProps = P.viewProps, this.sc_ = new dl(E, P);
					let N = {
						baseStep: P.baseStep,
						constraint: P.constraint,
						textProps: F.fromObject({
							draggingScale: P.draggingScale,
							formatter: P.formatter
						})
					};
					this.tc_ = new vr(E, {
						assembly: cl,
						axes: [N, N],
						parser: P.parser,
						value: this.value,
						viewProps: P.viewProps
					}), this.view = new za(E, {
						sliderView: this.sc_.view,
						textView: this.tc_.view
					})
				}
				get textController() {
					return this.tc_
				}
			}

			function $h(R) {
				return Ai.isObject(R) ? new Ai(R.min, R.max) : new Ai(0, 0)
			}

			function pl(R, E) {
				R.writeProperty("max", E.max), R.writeProperty("min", E.min)
			}

			function Ld(R) {
				let E = [],
					P = zs(R);
				P && E.push(P);
				let N = xd(R);
				return N && E.push(N), new Hs(new St(E))
			}
			let Ba = {
				id: "input-interval",
				type: "input",
				css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
				accept: (R, E) => {
					if (!Ai.isObject(R)) return null;
					let P = $,
						N = W(E, {
							format: P.optional.function,
							max: P.optional.number,
							min: P.optional.number,
							step: P.optional.number
						});
					return N ? {
						initialValue: new Ai(R.min, R.max),
						params: N
					} : null
				},
				binding: {
					reader: R => $h,
					constraint: R => Ld(R.params),
					equals: Ai.equals,
					writer: R => pl
				},
				controller(R) {
					var E;
					let P = R.value,
						N = R.constraint;
					if (!(N instanceof Hs)) throw o.shouldNeverHappen();
					let Y = (P.rawValue.min + P.rawValue.max) / 2,
						st = (E = R.params.format) !== null && E !== void 0 ? E : Wt(Ns(N.edge, Y)),
						ft = N.edge && Pt(N.edge, Bt);
					if (ft) return new Dn(R.document, {
						baseStep: Qo(N.edge),
						constraint: N.edge,
						draggingScale: Fa(N.edge, Y),
						formatter: st,
						parser: Ti,
						sliderProps: new F({
							maxValue: ft.values.value("max"),
							minValue: ft.values.value("min")
						}),
						value: P,
						viewProps: R.viewProps
					});
					let Tt = {
						baseStep: Qo(N.edge),
						constraint: N.edge,
						textProps: F.fromObject({
							draggingScale: Y,
							formatter: st
						})
					};
					return new vr(R.document, {
						assembly: cl,
						axes: [Tt, Tt],
						parser: Ti,
						value: P,
						viewProps: R.viewProps
					})
				}
			};
			class yr {
				constructor(E) {
					this.controller_ = E
				}
				get disabled() {
					return this.controller_.viewProps.get("disabled")
				}
				set disabled(E) {
					this.controller_.viewProps.set("disabled", E)
				}
				get title() {
					var E;
					return (E = this.controller_.props.get("title")) !== null && E !== void 0 ? E : ""
				}
				set title(E) {
					this.controller_.props.set("title", E)
				}
			}
			class br extends n {
				constructor(E, P, N, Y, st) {
					super(E, Y, st), this.cell = P, this.index = N
				}
			}
			class $s extends t {
				constructor(E) {
					super(E), this.cellToApiMap_ = new Map, this.controller_.valueController.cellControllers.forEach(N => {
						let Y = new yr(N);
						this.cellToApiMap_.set(N, Y)
					})
				}
				get value() {
					return this.controller_.value
				}
				cell(E, P) {
					let N = this.controller_.valueController,
						Y = N.cellControllers[P * N.size[0] + E];
					return this.cellToApiMap_.get(Y)
				}
				on(E, P) {
					let N = P.bind(this);
					this.controller_.value.emitter.on(E, Y => {
						let st = this.controller_.valueController,
							ft = st.findCellByValue(Y.rawValue);
						if (!ft) return;
						let Tt = this.cellToApiMap_.get(ft);
						if (!Tt) return;
						let me = st.cellControllers.indexOf(ft);
						N(new br(this, Tt, [me % st.size[0], Math.floor(me / st.size[0])], Y.rawValue, void 0))
					})
				}
			}
			let qs = u("rad");
			class qh {
				constructor(E, P) {
					this.element = E.createElement("div"), this.element.classList.add(qs()), P.viewProps.bindClassModifiers(this.element);
					let N = E.createElement("label");
					N.classList.add(qs("l")), this.element.appendChild(N);
					let Y = E.createElement("input");
					Y.classList.add(qs("i")), Y.name = P.name, Y.type = "radio", P.viewProps.bindDisabled(Y), N.appendChild(Y), this.inputElement = Y;
					let st = E.createElement("div");
					st.classList.add(qs("b")), N.appendChild(st);
					let ft = E.createElement("div");
					ft.classList.add(qs("t")), st.appendChild(ft), b(P.props, "title", Tt => {
						ft.textContent = Tt
					})
				}
			}
			class jh {
				constructor(E, P) {
					this.props = P.props, this.viewProps = P.viewProps, this.view = new qh(E, {
						name: P.name,
						props: this.props,
						viewProps: this.viewProps
					})
				}
			}
			class Ua {
				constructor(E, P) {
					this.cellCs_ = [], this.cellValues_ = [], this.onCellInputChange_ = this.onCellInputChange_.bind(this), this.size = P.size;
					let [N, Y] = this.size;
					for (let st = 0; st < Y; st++)
						for (let ft = 0; ft < N; ft++) {
							let Tt = new jh(E, {
								name: P.groupName,
								props: F.fromObject(Object.assign({}, P.cellConfig(ft, st))),
								viewProps: q.create()
							});
							this.cellCs_.push(Tt), this.cellValues_.push(P.cellConfig(ft, st).value)
						}
					this.value = P.value, _(this.value, st => {
						let ft = this.findCellByValue(st);
						ft && (ft.view.inputElement.checked = !0)
					}), this.viewProps = q.create(), this.view = new Z(E, {
						viewProps: this.viewProps,
						viewName: "radgrid"
					}), this.view.element.style.gridTemplateColumns = `repeat(${N}, 1fr)`, this.cellCs_.forEach(st => {
						st.view.inputElement.addEventListener("change", this.onCellInputChange_), this.view.element.appendChild(st.view.element)
					})
				}
				get cellControllers() {
					return this.cellCs_
				}
				findCellByValue(E) {
					let P = this.cellValues_.findIndex(N => N === E);
					return P < 0 ? null : this.cellCs_[P]
				}
				onCellInputChange_(E) {
					let P = E.currentTarget,
						N = this.cellCs_.findIndex(Y => Y.view.inputElement === P);
					N < 0 || (this.value.rawValue = this.cellValues_[N])
				}
			}
			let xr = function () {
				return {
					id: "radiogrid",
					type: "blade",
					accept(R) {
						let E = $,
							P = W(R, {
								cells: E.required.function,
								groupName: E.required.string,
								size: E.required.array(E.required.number),
								value: E.required.raw,
								view: E.required.constant("radiogrid"),
								label: E.optional.string
							});
						return P ? {
							params: P
						} : null
					},
					controller(R) {
						return new X(R.document, {
							blade: R.blade,
							props: F.fromObject({
								label: R.params.label
							}),
							valueController: new Ua(R.document, {
								groupName: R.params.groupName,
								cellConfig: R.params.cells,
								size: R.params.size,
								value: L(R.params.value)
							})
						})
					},
					api(R) {
						return !(R.controller instanceof X) || !(R.controller.valueController instanceof Ua) ? null : new $s(R.controller)
					}
				}
			}();

			function fl(R) {
				return {
					id: "input-radiogrid",
					type: "input",
					accept(E, P) {
						if (!R.isType(E)) return null;
						let N = $,
							Y = W(P, {
								cells: N.required.function,
								groupName: N.required.string,
								size: N.required.array(N.required.number),
								view: N.required.constant("radiogrid")
							});
						return Y ? {
							initialValue: E,
							params: Y
						} : null
					},
					binding: R.binding,
					controller: E => new Ua(E.document, {
						cellConfig: E.params.cells,
						groupName: E.params.groupName,
						size: E.params.size,
						value: E.value
					})
				}
			}
			let kd = fl({
					isType: R => typeof R == "number",
					binding: {
						reader: R => Be,
						writer: R => rn
					}
				}),
				Rd = fl({
					isType: R => typeof R == "string",
					binding: {
						reader: R => un,
						writer: R => rn
					}
				}),
				Fd = fl({
					isType: R => typeof R == "boolean",
					binding: {
						reader: R => be,
						writer: R => rn
					}
				}),
				Xh = [Md, _r, hl, Ba, xr, Fd, kd, Rd];
			i.ButtonCellApi = Vh, i.ButtonGridApi = zh, i.ButtonGridController = el, i.CubicBezier = qn, i.CubicBezierApi = Bh, i.CubicBezierAssembly = nl, i.CubicBezierController = Va, i.CubicBezierGraphController = mn, i.CubicBezierGraphView = Qe, i.CubicBezierPickerController = Wh, i.CubicBezierPickerView = Gh, i.CubicBezierPreviewView = Zr, i.CubicBezierView = Uh, i.FpsGraphBladeApi = Le, i.FpsGraphController = ll, i.FpsView = Pi, i.Fpswatch = qe, i.Interval = Ai, i.IntervalAssembly = cl, i.IntervalConstraint = Hs, i.RadioCellApi = yr, i.RadioController = jh, i.RadioGridApi = $s, i.RadioGridController = Ua, i.RadioView = qh, i.RangeSliderController = dl, i.RangeSliderTextController = Dn, i.RangeSliderTextView = za, i.RangeSliderView = Ws, i.TpRadioGridChangeEvent = br, i.plugins = Xh, Object.defineProperty(i, "__esModule", {
				value: !0
			})
		})
	});
	var bx = Qh((yx, ud) => {
		(function (i, t) {
			typeof define == "function" && define.amd ? define([], function () {
				return i.svg4everybody = t()
			}) : typeof ud == "object" && ud.exports ? ud.exports = t() : i.svg4everybody = t()
		})(yx, function () {
			function i(r, s, a) {
				if (a) {
					var o = document.createDocumentFragment(),
						h = !s.hasAttribute("viewBox") && a.getAttribute("viewBox");
					h && s.setAttribute("viewBox", h);
					for (var c = a.cloneNode(!0); c.childNodes.length;) o.appendChild(c.firstChild);
					r.appendChild(o)
				}
			}

			function t(r) {
				r.onreadystatechange = function () {
					if (r.readyState === 4) {
						var s = r._cachedDocument;
						s || (s = r._cachedDocument = document.implementation.createHTMLDocument(""), s.body.innerHTML = r.responseText, r._cachedTarget = {}), r._embeds.splice(0).map(function (a) {
							var o = r._cachedTarget[a.id];
							o || (o = r._cachedTarget[a.id] = s.getElementById(a.id)), i(a.parent, a.svg, o)
						})
					}
				}, r.onreadystatechange()
			}

			function e(r) {
				function s() {
					for (var f = 0; f < y.length;) {
						var S = y[f],
							x = S.parentNode,
							M = n(x),
							T = S.getAttribute("xlink:href") || S.getAttribute("href");
						if (!T && o.attributeName && (T = S.getAttribute(o.attributeName)), M && T) {
							if (a)
								if (!o.validate || o.validate(T, M, S)) {
									x.removeChild(S);
									var I = T.split("#"),
										L = I.shift(),
										F = I.join("#");
									if (L.length) {
										var k = _[L];
										k || (k = _[L] = new XMLHttpRequest, k.open("GET", L), k.send(), k._embeds = []), k._embeds.push({
											parent: x,
											svg: M,
											id: F
										}), t(k)
									} else i(x, M, document.getElementById(F))
								} else ++f, ++w
						} else ++f
					}(!y.length || y.length - w > 0) && b(s, 67)
				}
				var a, o = Object(r),
					h = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
					c = /\bAppleWebKit\/(\d+)\b/,
					u = /\bEdge\/12\.(\d+)\b/,
					g = /\bEdge\/.(\d+)\b/,
					p = window.top !== window.self;
				a = "polyfill" in o ? o.polyfill : h.test(navigator.userAgent) || (navigator.userAgent.match(u) || [])[1] < 10547 || (navigator.userAgent.match(c) || [])[1] < 537 || g.test(navigator.userAgent) && p;
				var _ = {},
					b = window.requestAnimationFrame || setTimeout,
					y = document.getElementsByTagName("use"),
					w = 0;
				a && s()
			}

			function n(r) {
				for (var s = r; s.nodeName.toLowerCase() !== "svg" && (s = s.parentNode););
				return s
			}
			return e
		})
	});
	var wx = {};
	Qv(wx, {
		gridHelper: () => qI
	});

	function qI({
		gutterCssVar: i = HI,
		marginCssVar: t = WI,
		rgbaColor: e = $I
	} = {}) {
		let n = document.createElement("div");
		document.body.append(n), xx(n, e), jI(n, i, t), XI(n, e)
	}

	function jI(i, t, e) {
		let n = i.style;
		n.zIndex = "10000", n.position = "fixed", n.top = "0", n.left = "0", n.display = "flex", n.width = "100%", n.height = "100%", n.columnGap = `var(${t}, 0)`, n.paddingLeft = `var(${e}, 0)`, n.paddingRight = `var(${e}, 0)`, n.pointerEvents = "none", n.visibility = "hidden"
	}

	function xx(i, t) {
		i.innerHTML = "";
		let e = Number(window.getComputedStyle(i).getPropertyValue("--grid-columns")),
			n;
		for (var r = 0; r < e; r++) n = document.createElement("div"), n.style.flex = "1 1 0", n.style.backgroundColor = t, i.appendChild(n)
	}

	function XI(i, t) {
		window.addEventListener("resize", () => xx(i, t));
		let e = !1,
			n = !1;
		document.addEventListener("keydown", r => {
			r.key == "Control" ? e = !0 : e && r.key == "g" && (n ? i.style.visibility = "hidden" : i.style.visibility = "visible", n = !n)
		}), document.addEventListener("keyup", r => {
			r.key == "Control" && (e = !1)
		})
	}
	var HI, WI, $I, Sx = C1(() => {
		HI = "--grid-gutter", WI = "--grid-margin", $I = "rgba(255, 0, 0, .1)"
	});

	function ec(i) {
		"@babel/helpers - typeof";
		return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ec = function (t) {
			return typeof t
		} : ec = function (t) {
			return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
		}, ec(i)
	}

	function ig(i, t) {
		if (!(i instanceof t)) throw new TypeError("Cannot call a class as a function")
	}

	function tg(i, t) {
		for (var e = 0; e < t.length; e++) {
			var n = t[e];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n)
		}
	}

	function ng(i, t, e) {
		return t && tg(i.prototype, t), e && tg(i, e), i
	}

	function eg(i, t, e) {
		return t in i ? Object.defineProperty(i, t, {
			value: e,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : i[t] = e, i
	}

	function tc(i, t) {
		return D1(i) || L1(i, t) || rg(i, t) || R1()
	}

	function P1(i) {
		return A1(i) || I1(i) || rg(i) || k1()
	}

	function A1(i) {
		if (Array.isArray(i)) return ep(i)
	}

	function D1(i) {
		if (Array.isArray(i)) return i
	}

	function I1(i) {
		if (typeof Symbol != "undefined" && Symbol.iterator in Object(i)) return Array.from(i)
	}

	function L1(i, t) {
		if (!(typeof Symbol == "undefined" || !(Symbol.iterator in Object(i)))) {
			var e = [],
				n = !0,
				r = !1,
				s = void 0;
			try {
				for (var a = i[Symbol.iterator](), o; !(n = (o = a.next()).done) && (e.push(o.value), !(t && e.length === t)); n = !0);
			} catch (h) {
				r = !0, s = h
			} finally {
				try {
					!n && a.return != null && a.return()
				} finally {
					if (r) throw s
				}
			}
			return e
		}
	}

	function rg(i, t) {
		if (i) {
			if (typeof i == "string") return ep(i, t);
			var e = Object.prototype.toString.call(i).slice(8, -1);
			if (e === "Object" && i.constructor && (e = i.constructor.name), e === "Map" || e === "Set") return Array.from(i);
			if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return ep(i, t)
		}
	}

	function ep(i, t) {
		(t == null || t > i.length) && (t = i.length);
		for (var e = 0, n = new Array(t); e < t; e++) n[e] = i[e];
		return n
	}

	function k1() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}

	function R1() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	var pe = function () {
			function i(t) {
				ig(this, i), this.mAttr = "data-" + t.dataName, this.mCaptureEvents = ["mouseenter", "mouseleave"], this.el = t.el
			}
			return ng(i, [{
				key: "mInit",
				value: function (e) {
					var n = this;
					this.modules = e, this.mCheckEventTarget = this.mCheckEventTarget.bind(this), this.events && Object.keys(this.events).forEach(function (r) {
						return n.mAddEvent(r)
					})
				}
			}, {
				key: "mUpdate",
				value: function (e) {
					this.modules = e
				}
			}, {
				key: "mDestroy",
				value: function () {
					var e = this;
					this.events && Object.keys(this.events).forEach(function (n) {
						return e.mRemoveEvent(n)
					})
				}
			}, {
				key: "mAddEvent",
				value: function (e) {
					var n = !!this.mCaptureEvents.includes(e);
					this.el.addEventListener(e, this.mCheckEventTarget, n)
				}
			}, {
				key: "mRemoveEvent",
				value: function (e) {
					var n = !!this.mCaptureEvents.includes(e);
					this.el.removeEventListener(e, this.mCheckEventTarget, n)
				}
			}, {
				key: "mCheckEventTarget",
				value: function (e) {
					var n = this.events[e.type];
					if (typeof n == "string") this[n](e);
					else {
						var r = "[" + this.mAttr + "]",
							s = e.target;
						if (this.mCaptureEvents.includes(e.type)) s.matches(r) && this.mCallEventMethod(e, n, s);
						else
							for (; s && s !== document && !(s.matches(r) && this.mCallEventMethod(e, n, s) != "undefined");) s = s.parentNode
					}
				}
			}, {
				key: "mCallEventMethod",
				value: function (e, n, r) {
					var s = r.getAttribute(this.mAttr);
					if (n.hasOwnProperty(s)) {
						var a = n[s];
						e.hasOwnProperty("currentTarget") || Object.defineProperty(e, "currentTarget", {
							value: r
						}), e.hasOwnProperty("curTarget") || Object.defineProperty(e, "curTarget", {
							value: r
						}), this[a](e)
					}
				}
			}, {
				key: "$",
				value: function (e, n) {
					var r = e.indexOf("."),
						s = e.indexOf("#"),
						a = e.indexOf("["),
						o = [r, s, a].filter(function (p) {
							return p != -1
						}),
						h = !1,
						c = e,
						u = "",
						g = this.el;
					return o.length && (h = Math.min.apply(Math, P1(o)), c = e.slice(0, h), u = e.slice(h)), ec(n) == "object" && (g = n), g.querySelectorAll("[" + this.mAttr + "=" + c + "]" + u)
				}
			}, {
				key: "parent",
				value: function (e, n) {
					for (var r = "[" + this.mAttr + "=" + e + "]", s = n.parentNode; s && s !== document;) {
						if (s.matches(r)) return s;
						s = s.parentNode
					}
				}
			}, {
				key: "getData",
				value: function (e, n) {
					var r = n || this.el;
					return r.getAttribute(this.mAttr + "-" + e)
				}
			}, {
				key: "setData",
				value: function (e, n, r) {
					var s = r || this.el;
					return s.setAttribute(this.mAttr + "-" + e, n)
				}
			}, {
				key: "call",
				value: function (e, n, r, s) {
					var a = this;
					n && !r && (r = n, n = !1), this.modules[r] && (s ? this.modules[r][s] && this.modules[r][s][e](n) : Object.keys(this.modules[r]).forEach(function (o) {
						a.modules[r][o][e](n)
					}))
				}
			}, {
				key: "on",
				value: function (e, n, r, s) {
					var a = this;
					this.modules[n] && (s ? this.modules[n][s].el.addEventListener(e, function (o) {
						return r(o)
					}) : Object.keys(this.modules[n]).forEach(function (o) {
						a.modules[n][o].el.addEventListener(e, function (h) {
							return r(h)
						})
					}))
				}
			}, {
				key: "init",
				value: function () {}
			}, {
				key: "destroy",
				value: function () {}
			}]), i
		}(),
		F1 = function () {
			function i(t) {
				ig(this, i), this.app, this.modules = t.modules, this.currentModules = {}, this.activeModules = {}, this.newModules = {}, this.moduleId = 0
			}
			return ng(i, [{
				key: "init",
				value: function (e, n) {
					var r = this,
						s = n || document,
						a = s.querySelectorAll("*");
					e && !this.app && (this.app = e), this.activeModules.app = {
						app: this.app
					}, a.forEach(function (o) {
						Array.from(o.attributes).forEach(function (h) {
							if (h.name.startsWith("data-module")) {
								var c = !1,
									u = h.name.split("-").splice(2),
									g = r.toCamel(u);
								if (r.modules[g] ? c = !0 : r.modules[r.toUpper(g)] && (g = r.toUpper(g), c = !0), c) {
									var p = {
											el: o,
											name: g,
											dataName: u.join("-")
										},
										_ = new r.modules[g](p),
										b = h.value;
									b || (r.moduleId++, b = "m" + r.moduleId, o.setAttribute(h.name, b)), r.addActiveModule(g, b, _);
									var y = g + "-" + b;
									n ? r.newModules[y] = _ : r.currentModules[y] = _
								}
							}
						})
					}), Object.entries(this.currentModules).forEach(function (o) {
						var h = tc(o, 2),
							c = h[0],
							u = h[1];
						if (n) {
							var g = c.split("-"),
								p = g.shift(),
								_ = g.pop();
							r.addActiveModule(p, _, u)
						} else r.initModule(u)
					})
				}
			}, {
				key: "initModule",
				value: function (e) {
					e.mInit(this.activeModules), e.init()
				}
			}, {
				key: "addActiveModule",
				value: function (e, n, r) {
					this.activeModules[e] ? Object.assign(this.activeModules[e], eg({}, n, r)) : this.activeModules[e] = eg({}, n, r)
				}
			}, {
				key: "update",
				value: function (e) {
					var n = this;
					this.init(this.app, e), Object.entries(this.currentModules).forEach(function (r) {
						var s = tc(r, 2),
							a = s[0],
							o = s[1];
						o.mUpdate(n.activeModules)
					}), Object.entries(this.newModules).forEach(function (r) {
						var s = tc(r, 2),
							a = s[0],
							o = s[1];
						n.initModule(o)
					}), Object.assign(this.currentModules, this.newModules)
				}
			}, {
				key: "destroy",
				value: function (e) {
					e ? this.destroyScope(e) : this.destroyModules()
				}
			}, {
				key: "destroyScope",
				value: function (e) {
					var n = this,
						r = e.querySelectorAll("*");
					r.forEach(function (s) {
						Array.from(s.attributes).forEach(function (a) {
							if (a.name.startsWith("data-module")) {
								var o = a.value,
									h = a.name.split("-").splice(2),
									c = n.toCamel(h) + "-" + o,
									u = !1;
								n.currentModules[c] ? u = !0 : n.currentModules[n.toUpper(c)] && (c = n.toUpper(c), u = !0), u && (n.destroyModule(n.currentModules[c]), delete n.currentModules[c])
							}
						})
					}), this.activeModules = {}, this.newModules = {}
				}
			}, {
				key: "destroyModules",
				value: function () {
					var e = this;
					Object.entries(this.currentModules).forEach(function (n) {
						var r = tc(n, 2),
							s = r[0],
							a = r[1];
						e.destroyModule(a)
					}), this.currentModules = []
				}
			}, {
				key: "destroyModule",
				value: function (e) {
					e.mDestroy(), e.destroy()
				}
			}, {
				key: "toCamel",
				value: function (e) {
					var n = this;
					return e.reduce(function (r, s) {
						return r + n.toUpper(s)
					})
				}
			}, {
				key: "toUpper",
				value: function (e) {
					return e.charAt(0).toUpperCase() + e.slice(1)
				}
			}]), i
		}(),
		sg = F1;
	var uv = {};
	Qv(uv, {
		AnimText: () => Ln,
		AnimTextScroll: () => wc,
		CookieConsent: () => Ic,
		Example: () => Lc,
		Filters: () => ms,
		Header: () => la,
		Load: () => Rc,
		Loader: () => vs,
		ModalAreas: () => Wl,
		ModalMenu: () => nr,
		ModalTeam: () => $l,
		ModalTeamTrigger: () => Uc,
		ModalVideo: () => ql,
		ModalVideoTrigger: () => Gc,
		Rail: () => Hc,
		SceneHypermesh: () => lh,
		SceneMenu: () => mi,
		Scroll: () => $u,
		SkipLink: () => qu,
		SliderFancy: () => ka,
		SliderHero: () => Ph,
		TeamList: () => dr
	});
	var ip = "production",
		ag = window.matchMedia("(any-pointer:coarse)").matches,
		ie = Object.freeze({
			NAME: ip,
			IS_PROD: ip === "production",
			IS_DEV: ip === "development",
			IS_MOBILE: ag,
			IS_DESKTOP: !ag,
			IS_TOUCH: "ontouchstart" in document.documentElement,
			REDUCED_MOTION: window.matchMedia("(prefers-reduced-motion: reduce)").matches
		}),
		ti = Object.freeze({
			LOADING: "is-loading",
			LOADED: "is-loaded",
			READY: "is-ready",
			FONTS_LOADED: "fonts-loaded",
			LAZY_CONTAINER: "c-asset",
			LAZY_LOADED: "-lazy-loaded",
			LAZY_LOADING: "-lazy-loading",
			LAZY_ERROR: "-lazy-error",
			REDUCED_MOTION: "reduced-motion"
		}),
		Ce = Object.freeze({
			RESIZE_END: "loco.resizeEnd",
			READY: "loco.ready"
		}),
		Yn = Object.freeze({
			EAGER: [{
				family: "Fellix",
				style: "normal",
				weight: "400"
			}, {
				family: "Fellix",
				style: "normal",
				weight: "500"
			}, {
				family: "Fellix",
				style: "normal",
				weight: "700"
			}, {
				family: "Helvetica Now Text",
				style: "normal",
				weight: "400"
			}]
		}),
		di = {
			window: {
				width: window.innerWidth,
				height: window.innerHeight
			},
			headerHeight: 136
		},
		ZI = Object.freeze({
			delimiters: ["${", "}"]
		});
	var lg = "fonts" in document;

	function O1(i, t) {
		for (let [e, n] of Object.entries(t)) switch (e) {
			case "family": {
				if (ic(i[e]) !== n) return !1;
				break
			}
			case "weight": {
				if (i[e] != n) return !1;
				break
			}
			default: {
				if (i[e] !== n) return !1;
				break
			}
		}
		return !0
	}

	function N1(i, t) {
		let e = ic(i.family);
		return ic(e) === t || t.endsWith(ic(e)) && (t.match(i.weight) || t.match(i.style)), !0
	}

	function V1(i) {
		let t = [];
		for (let e of document.fonts) O1(e, i) && t.push(e);
		return t
	}

	function z1(i) {
		let t = [];
		for (let e of document.fonts) N1(e, i) && t.push(e);
		return t
	}

	function hg(i) {
		Array.isArray(i) || (i = [i]);
		let t = new Set;
		return i.forEach(e => {
			if (e) switch (typeof e) {
				case "string":
					t.add(...z1(e));
					return;
				case "object":
					t.add(...V1(e));
					return
			}
			throw new TypeError("Expected font query to be font shorthand or font reference")
		}), [...t]
	}

	function cg(i, t = !1) {
		return Di(this, null, function* () {
			var e;
			if (((e = i.size) != null ? e : i.length) === 0) throw new TypeError("Expected at least one font");
			return yield B1([...i], t)
		})
	}

	function og(i) {
		return Di(this, null, function* () {
			if (i) return yield(i.status === "unloaded" ? i.load() : i.loaded).then(t => t, t => i)
		})
	}

	function B1(i, t = !1) {
		return Di(this, null, function* () {
			t && console.group("[loadFonts:API]", i.length, "/", document.fonts.size);
			let e = [];
			for (let n of i) n instanceof FontFace ? (document.fonts.has(n) || document.fonts.add(n), e.push(og(n))) : e.push(...hg(n).map(r => og(r)));
			return t && console.groupEnd(), yield Promise.all(e)
		})
	}

	function ic(i) {
		return i.replace(/['"]+/g, "")
	}

	function ns(i) {
		return Di(this, null, function* () {
			let t = hg(i);
			return yield Promise.all(t.map(e => e == null ? void 0 : e.loaded))
		})
	}

	function Sr(i) {
		if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return i
	}

	function _g(i, t) {
		i.prototype = Object.create(t.prototype), i.prototype.constructor = i, i.__proto__ = t
	}
	var qi = {
			autoSleep: 120,
			force3D: "auto",
			nullTargetWarn: 1,
			units: {
				lineHeight: ""
			}
		},
		Xa = {
			duration: .5,
			overwrite: !1,
			delay: 0
		},
		xp, xi, je, bn = 1e8,
		Re = 1 / bn,
		cp = Math.PI * 2,
		U1 = cp / 4,
		G1 = 0,
		yg = Math.sqrt,
		H1 = Math.cos,
		W1 = Math.sin,
		ri = function (t) {
			return typeof t == "string"
		},
		Xe = function (t) {
			return typeof t == "function"
		},
		Mr = function (t) {
			return typeof t == "number"
		},
		pc = function (t) {
			return typeof t == "undefined"
		},
		Zn = function (t) {
			return typeof t == "object"
		},
		$i = function (t) {
			return t !== !1
		},
		wp = function () {
			return typeof window != "undefined"
		},
		nc = function (t) {
			return Xe(t) || ri(t)
		},
		bg = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () {},
		wi = Array.isArray,
		up = /(?:-?\.?\d|\.)+/gi,
		Sp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
		ta = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
		np = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
		Ep = /[+-]=-?[.\d]+/,
		xg = /[^,'"\[\]\s]+/gi,
		$1 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
		Ue, yn, dp, Mp, an = {},
		oc = {},
		wg, Sg = function (t) {
			return (oc = Qs(t, an)) && si
		},
		fc = function (t, e) {
			return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
		},
		lc = function (t, e) {
			return !e && console.warn(t)
		},
		Eg = function (t, e) {
			return t && (an[t] = e) && oc && (oc[t] = e) || an
		},
		Ml = function () {
			return 0
		},
		q1 = {
			suppressEvents: !0,
			isStart: !0,
			kill: !1
		},
		rc = {
			suppressEvents: !0,
			kill: !1
		},
		j1 = {
			suppressEvents: !0
		},
		Cp = {},
		ss = [],
		pp = {},
		Mg, Hi = {},
		rp = {},
		ug = 30,
		sc = [],
		Tp = "",
		Pp = function (t) {
			var e = t[0],
				n, r;
			if (Zn(e) || Xe(e) || (t = [t]), !(n = (e._gsap || {}).harness)) {
				for (r = sc.length; r-- && !sc[r].targetTest(e););
				n = sc[r]
			}
			for (r = t.length; r--;) t[r] && (t[r]._gsap || (t[r]._gsap = new Ip(t[r], n))) || t.splice(r, 1);
			return t
		},
		as = function (t) {
			return t._gsap || Pp(xn(t))[0]._gsap
		},
		Ap = function (t, e, n) {
			return (n = t[e]) && Xe(n) ? t[e]() : pc(n) && t.getAttribute && t.getAttribute(e) || n
		},
		Ii = function (t, e) {
			return (t = t.split(",")).forEach(e) || t
		},
		Ye = function (t) {
			return Math.round(t * 1e5) / 1e5 || 0
		},
		gi = function (t) {
			return Math.round(t * 1e7) / 1e7 || 0
		},
		ea = function (t, e) {
			var n = e.charAt(0),
				r = parseFloat(e.substr(2));
			return t = parseFloat(t), n === "+" ? t + r : n === "-" ? t - r : n === "*" ? t * r : t / r
		},
		X1 = function (t, e) {
			for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;);
			return r < n
		},
		hc = function () {
			var t = ss.length,
				e = ss.slice(0),
				n, r;
			for (pp = {}, ss.length = 0, n = 0; n < t; n++) r = e[n], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0)
		},
		Cg = function (t, e, n, r) {
			ss.length && !xi && hc(), t.render(e, n, r || xi && e < 0 && (t._initted || t._startAt)), ss.length && !xi && hc()
		},
		Tg = function (t) {
			var e = parseFloat(t);
			return (e || e === 0) && (t + "").match(xg).length < 2 ? e : ri(t) ? t.trim() : t
		},
		Pg = function (t) {
			return t
		},
		Sn = function (t, e) {
			for (var n in e) n in t || (t[n] = e[n]);
			return t
		},
		Y1 = function (t) {
			return function (e, n) {
				for (var r in n) r in e || r === "duration" && t || r === "ease" || (e[r] = n[r])
			}
		},
		Qs = function (t, e) {
			for (var n in e) t[n] = e[n];
			return t
		},
		dg = function i(t, e) {
			for (var n in e) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (t[n] = Zn(e[n]) ? i(t[n] || (t[n] = {}), e[n]) : e[n]);
			return t
		},
		cc = function (t, e) {
			var n = {},
				r;
			for (r in t) r in e || (n[r] = t[r]);
			return n
		},
		wl = function (t) {
			var e = t.parent || Ue,
				n = t.keyframes ? Y1(wi(t.keyframes)) : Sn;
			if ($i(t.inherit))
				for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
			return t
		},
		K1 = function (t, e) {
			for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];);
			return n < 0
		},
		Ag = function (t, e, n, r, s) {
			n === void 0 && (n = "_first"), r === void 0 && (r = "_last");
			var a = t[r],
				o;
			if (s)
				for (o = e[s]; a && a[s] > o;) a = a._prev;
			return a ? (e._next = a._next, a._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = a, e.parent = e._dp = t, e
		},
		mc = function (t, e, n, r) {
			n === void 0 && (n = "_first"), r === void 0 && (r = "_last");
			var s = e._prev,
				a = e._next;
			s ? s._next = a : t[n] === e && (t[n] = a), a ? a._prev = s : t[r] === e && (t[r] = s), e._next = e._prev = e.parent = null
		},
		os = function (t, e) {
			t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
		},
		Ks = function (t, e) {
			if (t && (!e || e._end > t._dur || e._start < 0))
				for (var n = t; n;) n._dirty = 1, n = n.parent;
			return t
		},
		Z1 = function (t) {
			for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
			return t
		},
		fp = function (t, e, n, r) {
			return t._startAt && (xi ? t._startAt.revert(rc) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
		},
		J1 = function i(t) {
			return !t || t._ts && i(t.parent)
		},
		pg = function (t) {
			return t._repeat ? Ya(t._tTime, t = t.duration() + t._rDelay) * t : 0
		},
		Ya = function (t, e) {
			var n = Math.floor(t /= e);
			return t && n === t ? n - 1 : n
		},
		uc = function (t, e) {
			return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
		},
		vc = function (t) {
			return t._end = gi(t._start + (t._tDur / Math.abs(t._ts || t._rts || Re) || 0))
		},
		gc = function (t, e) {
			var n = t._dp;
			return n && n.smoothChildTiming && t._ts && (t._start = gi(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), vc(t), n._dirty || Ks(n, t)), t
		},
		Dg = function (t, e) {
			var n;
			if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = uc(t.rawTime(), e), (!e._dur || Pl(0, e.totalDuration(), n) - e._tTime > Re) && e.render(n, !0)), Ks(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
				if (t._dur < t.duration())
					for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
				t._zTime = -Re
			}
		},
		Kn = function (t, e, n, r) {
			return e.parent && os(e), e._start = gi((Mr(n) ? n : n || t !== Ue ? _n(t, n, e) : t._time) + e._delay), e._end = gi(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Ag(t, e, "_first", "_last", t._sort ? "_start" : 0), mp(e) || (t._recent = e), r || Dg(t, e), t._ts < 0 && gc(t, t._tTime), t
		},
		Ig = function (t, e) {
			return (an.ScrollTrigger || fc("scrollTrigger", e)) && an.ScrollTrigger.create(e, t)
		},
		Lg = function (t, e, n, r, s) {
			if (Rp(t, e, s), !t._initted) return 1;
			if (!n && t._pt && !xi && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && Mg !== Wi.frame) return ss.push(t), t._lazy = [s, r], 1
		},
		Q1 = function i(t) {
			var e = t.parent;
			return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || i(e))
		},
		mp = function (t) {
			var e = t.data;
			return e === "isFromStart" || e === "isStart"
		},
		tS = function (t, e, n, r) {
			var s = t.ratio,
				a = e < 0 || !e && (!t._start && Q1(t) && !(!t._initted && mp(t)) || (t._ts < 0 || t._dp._ts < 0) && !mp(t)) ? 0 : 1,
				o = t._rDelay,
				h = 0,
				c, u, g;
			if (o && t._repeat && (h = Pl(0, t._tDur, e), u = Ya(h, o), t._yoyo && u & 1 && (a = 1 - a), u !== Ya(t._tTime, o) && (s = 1 - a, t.vars.repeatRefresh && t._initted && t.invalidate())), a !== s || xi || r || t._zTime === Re || !e && t._zTime) {
				if (!t._initted && Lg(t, e, r, n, h)) return;
				for (g = t._zTime, t._zTime = e || (n ? Re : 0), n || (n = e && !g), t.ratio = a, t._from && (a = 1 - a), t._time = 0, t._tTime = h, c = t._pt; c;) c.r(a, c.d), c = c._next;
				e < 0 && fp(t, e, n, !0), t._onUpdate && !n && wn(t, "onUpdate"), h && t._repeat && !n && t.parent && wn(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === a && (a && os(t, 1), !n && !xi && (wn(t, a ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
			} else t._zTime || (t._zTime = e)
		},
		eS = function (t, e, n) {
			var r;
			if (n > e)
				for (r = t._first; r && r._start <= n;) {
					if (r.data === "isPause" && r._start > e) return r;
					r = r._next
				} else
					for (r = t._last; r && r._start >= n;) {
						if (r.data === "isPause" && r._start < e) return r;
						r = r._prev
					}
		},
		Ka = function (t, e, n, r) {
			var s = t._repeat,
				a = gi(e) || 0,
				o = t._tTime / t._tDur;
			return o && !r && (t._time *= a / t._dur), t._dur = a, t._tDur = s ? s < 0 ? 1e10 : gi(a * (s + 1) + t._rDelay * s) : a, o > 0 && !r && gc(t, t._tTime = t._tDur * o), t.parent && vc(t), n || Ks(t.parent, t), t
		},
		fg = function (t) {
			return t instanceof bi ? Ks(t) : Ka(t, t._dur)
		},
		iS = {
			_start: 0,
			endTime: Ml,
			totalDuration: Ml
		},
		_n = function i(t, e, n) {
			var r = t.labels,
				s = t._recent || iS,
				a = t.duration() >= bn ? s.endTime(!1) : t._dur,
				o, h, c;
			return ri(e) && (isNaN(e) || e in r) ? (h = e.charAt(0), c = e.substr(-1) === "%", o = e.indexOf("="), h === "<" || h === ">" ? (o >= 0 && (e = e.replace(/=/, "")), (h === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(e.substr(1)) || 0) * (c ? (o < 0 ? s : n).totalDuration() / 100 : 1)) : o < 0 ? (e in r || (r[e] = a), r[e]) : (h = parseFloat(e.charAt(o - 1) + e.substr(o + 1)), c && n && (h = h / 100 * (wi(n) ? n[0] : n).totalDuration()), o > 1 ? i(t, e.substr(0, o - 1), n) + h : a + h)) : e == null ? a : +e
		},
		Sl = function (t, e, n) {
			var r = Mr(e[1]),
				s = (r ? 2 : 1) + (t < 2 ? 0 : 1),
				a = e[s],
				o, h;
			if (r && (a.duration = e[1]), a.parent = n, t) {
				for (o = a, h = n; h && !("immediateRender" in o);) o = h.vars.defaults || {}, h = $i(h.vars.inherit) && h.parent;
				a.immediateRender = $i(o.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[s - 1]
			}
			return new Je(e[0], a, e[s + 1])
		},
		ls = function (t, e) {
			return t || t === 0 ? e(t) : e
		},
		Pl = function (t, e, n) {
			return n < t ? t : n > e ? e : n
		},
		_i = function (t, e) {
			return !ri(t) || !(e = $1.exec(t)) ? "" : e[1]
		},
		nS = function (t, e, n) {
			return ls(n, function (r) {
				return Pl(t, e, r)
			})
		},
		vp = [].slice,
		kg = function (t, e) {
			return t && Zn(t) && "length" in t && (!e && !t.length || t.length - 1 in t && Zn(t[0])) && !t.nodeType && t !== yn
		},
		rS = function (t, e, n) {
			return n === void 0 && (n = []), t.forEach(function (r) {
				var s;
				return ri(r) && !e || kg(r, 1) ? (s = n).push.apply(s, xn(r)) : n.push(r)
			}) || n
		},
		xn = function (t, e, n) {
			return je && !e && je.selector ? je.selector(t) : ri(t) && !n && (dp || !Za()) ? vp.call((e || Mp).querySelectorAll(t), 0) : wi(t) ? rS(t, n) : kg(t) ? vp.call(t, 0) : t ? [t] : []
		},
		gp = function (t) {
			return t = xn(t)[0] || lc("Invalid scope") || {},
				function (e) {
					var n = t.current || t.nativeElement || t;
					return xn(e, n.querySelectorAll ? n : n === t ? lc("Invalid scope") || Mp.createElement("div") : t)
				}
		},
		Rg = function (t) {
			return t.sort(function () {
				return .5 - Math.random()
			})
		},
		Fg = function (t) {
			if (Xe(t)) return t;
			var e = Zn(t) ? t : {
					each: t
				},
				n = Zs(e.ease),
				r = e.from || 0,
				s = parseFloat(e.base) || 0,
				a = {},
				o = r > 0 && r < 1,
				h = isNaN(r) || o,
				c = e.axis,
				u = r,
				g = r;
			return ri(r) ? u = g = {
					center: .5,
					edges: .5,
					end: 1
				} [r] || 0 : !o && h && (u = r[0], g = r[1]),
				function (p, _, b) {
					var y = (b || e).length,
						w = a[y],
						f, S, x, M, T, I, L, F, k;
					if (!w) {
						if (k = e.grid === "auto" ? 0 : (e.grid || [1, bn])[1], !k) {
							for (L = -bn; L < (L = b[k++].getBoundingClientRect().left) && k < y;);
							k--
						}
						for (w = a[y] = [], f = h ? Math.min(k, y) * u - .5 : r % k, S = k === bn ? 0 : h ? y * g / k - .5 : r / k | 0, L = 0, F = bn, I = 0; I < y; I++) x = I % k - f, M = S - (I / k | 0), w[I] = T = c ? Math.abs(c === "y" ? M : x) : yg(x * x + M * M), T > L && (L = T), T < F && (F = T);
						r === "random" && Rg(w), w.max = L - F, w.min = F, w.v = y = (parseFloat(e.amount) || parseFloat(e.each) * (k > y ? y - 1 : c ? c === "y" ? y / k : k : Math.max(k, y / k)) || 0) * (r === "edges" ? -1 : 1), w.b = y < 0 ? s - y : s, w.u = _i(e.amount || e.each) || 0, n = n && y < 0 ? Wg(n) : n
					}
					return y = (w[p] - w.min) / w.max || 0, gi(w.b + (n ? n(y) : y) * w.v) + w.u
				}
		},
		_p = function (t) {
			var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
			return function (n) {
				var r = gi(Math.round(parseFloat(n) / t) * t * e);
				return (r - r % 1) / e + (Mr(n) ? 0 : _i(n))
			}
		},
		Og = function (t, e) {
			var n = wi(t),
				r, s;
			return !n && Zn(t) && (r = n = t.radius || bn, t.values ? (t = xn(t.values), (s = !Mr(t[0])) && (r *= r)) : t = _p(t.increment)), ls(e, n ? Xe(t) ? function (a) {
				return s = t(a), Math.abs(s - a) <= r ? s : a
			} : function (a) {
				for (var o = parseFloat(s ? a.x : a), h = parseFloat(s ? a.y : 0), c = bn, u = 0, g = t.length, p, _; g--;) s ? (p = t[g].x - o, _ = t[g].y - h, p = p * p + _ * _) : p = Math.abs(t[g] - o), p < c && (c = p, u = g);
				return u = !r || c <= r ? t[u] : a, s || u === a || Mr(a) ? u : u + _i(a)
			} : _p(t))
		},
		Ng = function (t, e, n, r) {
			return ls(wi(t) ? !e : n === !0 ? !!(n = 0) : !r, function () {
				return wi(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + n * .99)) / n) * n * r) / r
			})
		},
		sS = function () {
			for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
			return function (r) {
				return e.reduce(function (s, a) {
					return a(s)
				}, r)
			}
		},
		aS = function (t, e) {
			return function (n) {
				return t(parseFloat(n)) + (e || _i(n))
			}
		},
		oS = function (t, e, n) {
			return zg(t, e, 0, 1, n)
		},
		Vg = function (t, e, n) {
			return ls(n, function (r) {
				return t[~~e(r)]
			})
		},
		lS = function i(t, e, n) {
			var r = e - t;
			return wi(t) ? Vg(t, i(0, t.length), e) : ls(n, function (s) {
				return (r + (s - t) % r) % r + t
			})
		},
		hS = function i(t, e, n) {
			var r = e - t,
				s = r * 2;
			return wi(t) ? Vg(t, i(0, t.length - 1), e) : ls(n, function (a) {
				return a = (s + (a - t) % s) % s || 0, t + (a > r ? s - a : a)
			})
		},
		Ja = function (t) {
			for (var e = 0, n = "", r, s, a, o; ~(r = t.indexOf("random(", e));) a = t.indexOf(")", r), o = t.charAt(r + 7) === "[", s = t.substr(r + 7, a - r - 7).match(o ? xg : up), n += t.substr(e, r - e) + Ng(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), e = a + 1;
			return n + t.substr(e, t.length - e)
		},
		zg = function (t, e, n, r, s) {
			var a = e - t,
				o = r - n;
			return ls(s, function (h) {
				return n + ((h - t) / a * o || 0)
			})
		},
		cS = function i(t, e, n, r) {
			var s = isNaN(t + e) ? 0 : function (_) {
				return (1 - _) * t + _ * e
			};
			if (!s) {
				var a = ri(t),
					o = {},
					h, c, u, g, p;
				if (n === !0 && (r = 1) && (n = null), a) t = {
					p: t
				}, e = {
					p: e
				};
				else if (wi(t) && !wi(e)) {
					for (u = [], g = t.length, p = g - 2, c = 1; c < g; c++) u.push(i(t[c - 1], t[c]));
					g--, s = function (b) {
						b *= g;
						var y = Math.min(p, ~~b);
						return u[y](b - y)
					}, n = e
				} else r || (t = Qs(wi(t) ? [] : {}, t));
				if (!u) {
					for (h in e) Lp.call(o, t, h, "get", e[h]);
					s = function (b) {
						return Np(b, o) || (a ? t.p : t)
					}
				}
			}
			return ls(n, s)
		},
		mg = function (t, e, n) {
			var r = t.labels,
				s = bn,
				a, o, h;
			for (a in r) o = r[a] - e, o < 0 == !!n && o && s > (o = Math.abs(o)) && (h = a, s = o);
			return h
		},
		wn = function (t, e, n) {
			var r = t.vars,
				s = r[e],
				a = je,
				o = t._ctx,
				h, c, u;
			if (s) return h = r[e + "Params"], c = r.callbackScope || t, n && ss.length && hc(), o && (je = o), u = h ? s.apply(c, h) : s.call(c), je = a, u
		},
		bl = function (t) {
			return os(t), t.scrollTrigger && t.scrollTrigger.kill(!!xi), t.progress() < 1 && wn(t, "onInterrupt"), t
		},
		ja, Bg = [],
		Ug = function (t) {
			if (wp() && t) {
				t = !t.name && t.default || t;
				var e = t.name,
					n = Xe(t),
					r = e && !n && t.init ? function () {
						this._props = []
					} : t,
					s = {
						init: Ml,
						render: Np,
						add: Lp,
						kill: CS,
						modifier: MS,
						rawVars: 0
					},
					a = {
						targetTest: 0,
						get: 0,
						getSetter: _c,
						aliases: {},
						register: 0
					};
				if (Za(), t !== r) {
					if (Hi[e]) return;
					Sn(r, Sn(cc(t, s), a)), Qs(r.prototype, Qs(s, cc(t, a))), Hi[r.prop = e] = r, t.targetTest && (sc.push(r), Cp[e] = 1), e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
				}
				Eg(e, r), t.register && t.register(si, r, Li)
			} else t && Bg.push(t)
		},
		ke = 255,
		xl = {
			aqua: [0, ke, ke],
			lime: [0, ke, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, ke],
			navy: [0, 0, 128],
			white: [ke, ke, ke],
			olive: [128, 128, 0],
			yellow: [ke, ke, 0],
			orange: [ke, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [ke, 0, 0],
			pink: [ke, 192, 203],
			cyan: [0, ke, ke],
			transparent: [ke, ke, ke, 0]
		},
		sp = function (t, e, n) {
			return t += t < 0 ? 1 : t > 1 ? -1 : 0, (t * 6 < 1 ? e + (n - e) * t * 6 : t < .5 ? n : t * 3 < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * ke + .5 | 0
		},
		Gg = function (t, e, n) {
			var r = t ? Mr(t) ? [t >> 16, t >> 8 & ke, t & ke] : 0 : xl.black,
				s, a, o, h, c, u, g, p, _, b;
			if (!r) {
				if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)), xl[t]) r = xl[t];
				else if (t.charAt(0) === "#") {
					if (t.length < 6 && (s = t.charAt(1), a = t.charAt(2), o = t.charAt(3), t = "#" + s + s + a + a + o + o + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")), t.length === 9) return r = parseInt(t.substr(1, 6), 16), [r >> 16, r >> 8 & ke, r & ke, parseInt(t.substr(7), 16) / 255];
					t = parseInt(t.substr(1), 16), r = [t >> 16, t >> 8 & ke, t & ke]
				} else if (t.substr(0, 3) === "hsl") {
					if (r = b = t.match(up), !e) h = +r[0] % 360 / 360, c = +r[1] / 100, u = +r[2] / 100, a = u <= .5 ? u * (c + 1) : u + c - u * c, s = u * 2 - a, r.length > 3 && (r[3] *= 1), r[0] = sp(h + 1 / 3, s, a), r[1] = sp(h, s, a), r[2] = sp(h - 1 / 3, s, a);
					else if (~t.indexOf("=")) return r = t.match(Sp), n && r.length < 4 && (r[3] = 1), r
				} else r = t.match(up) || xl.transparent;
				r = r.map(Number)
			}
			return e && !b && (s = r[0] / ke, a = r[1] / ke, o = r[2] / ke, g = Math.max(s, a, o), p = Math.min(s, a, o), u = (g + p) / 2, g === p ? h = c = 0 : (_ = g - p, c = u > .5 ? _ / (2 - g - p) : _ / (g + p), h = g === s ? (a - o) / _ + (a < o ? 6 : 0) : g === a ? (o - s) / _ + 2 : (s - a) / _ + 4, h *= 60), r[0] = ~~(h + .5), r[1] = ~~(c * 100 + .5), r[2] = ~~(u * 100 + .5)), n && r.length < 4 && (r[3] = 1), r
		},
		Hg = function (t) {
			var e = [],
				n = [],
				r = -1;
			return t.split(Er).forEach(function (s) {
				var a = s.match(ta) || [];
				e.push.apply(e, a), n.push(r += a.length + 1)
			}), e.c = n, e
		},
		vg = function (t, e, n) {
			var r = "",
				s = (t + r).match(Er),
				a = e ? "hsla(" : "rgba(",
				o = 0,
				h, c, u, g;
			if (!s) return t;
			if (s = s.map(function (p) {
					return (p = Gg(p, e, 1)) && a + (e ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")"
				}), n && (u = Hg(t), h = n.c, h.join(r) !== u.c.join(r)))
				for (c = t.replace(Er, "1").split(ta), g = c.length - 1; o < g; o++) r += c[o] + (~h.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (u.length ? u : s.length ? s : n).shift());
			if (!c)
				for (c = t.split(Er), g = c.length - 1; o < g; o++) r += c[o] + s[o];
			return r + c[g]
		},
		Er = function () {
			var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
				t;
			for (t in xl) i += "|" + t + "\\b";
			return new RegExp(i + ")", "gi")
		}(),
		uS = /hsl[a]?\(/,
		Dp = function (t) {
			var e = t.join(" "),
				n;
			if (Er.lastIndex = 0, Er.test(e)) return n = uS.test(e), t[1] = vg(t[1], n), t[0] = vg(t[0], n, Hg(t[1])), !0
		},
		Cl, Wi = function () {
			var i = Date.now,
				t = 500,
				e = 33,
				n = i(),
				r = n,
				s = 1e3 / 240,
				a = s,
				o = [],
				h, c, u, g, p, _, b = function y(w) {
					var f = i() - r,
						S = w === !0,
						x, M, T, I;
					if (f > t && (n += f - e), r += f, T = r - n, x = T - a, (x > 0 || S) && (I = ++g.frame, p = T - g.time * 1e3, g.time = T = T / 1e3, a += x + (x >= s ? 4 : s - x), M = 1), S || (h = c(y)), M)
						for (_ = 0; _ < o.length; _++) o[_](T, p, I, w)
				};
			return g = {
				time: 0,
				frame: 0,
				tick: function () {
					b(!0)
				},
				deltaRatio: function (w) {
					return p / (1e3 / (w || 60))
				},
				wake: function () {
					wg && (!dp && wp() && (yn = dp = window, Mp = yn.document || {}, an.gsap = si, (yn.gsapVersions || (yn.gsapVersions = [])).push(si.version), Sg(oc || yn.GreenSockGlobals || !yn.gsap && yn || {}), u = yn.requestAnimationFrame, Bg.forEach(Ug)), h && g.sleep(), c = u || function (w) {
						return setTimeout(w, a - g.time * 1e3 + 1 | 0)
					}, Cl = 1, b(2))
				},
				sleep: function () {
					(u ? yn.cancelAnimationFrame : clearTimeout)(h), Cl = 0, c = Ml
				},
				lagSmoothing: function (w, f) {
					t = w || 1 / 0, e = Math.min(f || 33, t)
				},
				fps: function (w) {
					s = 1e3 / (w || 240), a = g.time * 1e3 + s
				},
				add: function (w, f, S) {
					var x = f ? function (M, T, I, L) {
						w(M, T, I, L), g.remove(x)
					} : w;
					return g.remove(w), o[S ? "unshift" : "push"](x), Za(), x
				},
				remove: function (w, f) {
					~(f = o.indexOf(w)) && o.splice(f, 1) && _ >= f && _--
				},
				_listeners: o
			}, g
		}(),
		Za = function () {
			return !Cl && Wi.wake()
		},
		ve = {},
		dS = /^[\d.\-M][\d.\-,\s]/,
		pS = /["']/g,
		fS = function (t) {
			for (var e = {}, n = t.substr(1, t.length - 3).split(":"), r = n[0], s = 1, a = n.length, o, h, c; s < a; s++) h = n[s], o = s !== a - 1 ? h.lastIndexOf(",") : h.length, c = h.substr(0, o), e[r] = isNaN(c) ? c.replace(pS, "").trim() : +c, r = h.substr(o + 1).trim();
			return e
		},
		mS = function (t) {
			var e = t.indexOf("(") + 1,
				n = t.indexOf(")"),
				r = t.indexOf("(", e);
			return t.substring(e, ~r && r < n ? t.indexOf(")", n + 1) : n)
		},
		vS = function (t) {
			var e = (t + "").split("("),
				n = ve[e[0]];
			return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [fS(e[1])] : mS(t).split(",").map(Tg)) : ve._CE && dS.test(t) ? ve._CE("", t) : n
		},
		Wg = function (t) {
			return function (e) {
				return 1 - t(1 - e)
			}
		},
		$g = function i(t, e) {
			for (var n = t._first, r; n;) n instanceof bi ? i(n, e) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== e && (n.timeline ? i(n.timeline, e) : (r = n._ease, n._ease = n._yEase, n._yEase = r, n._yoyo = e)), n = n._next
		},
		Zs = function (t, e) {
			return t && (Xe(t) ? t : ve[t] || vS(t)) || e
		},
		ia = function (t, e, n, r) {
			n === void 0 && (n = function (h) {
				return 1 - e(1 - h)
			}), r === void 0 && (r = function (h) {
				return h < .5 ? e(h * 2) / 2 : 1 - e((1 - h) * 2) / 2
			});
			var s = {
					easeIn: e,
					easeOut: n,
					easeInOut: r
				},
				a;
			return Ii(t, function (o) {
				ve[o] = an[o] = s, ve[a = o.toLowerCase()] = n;
				for (var h in s) ve[a + (h === "easeIn" ? ".in" : h === "easeOut" ? ".out" : ".inOut")] = ve[o + "." + h] = s[h]
			}), s
		},
		qg = function (t) {
			return function (e) {
				return e < .5 ? (1 - t(1 - e * 2)) / 2 : .5 + t((e - .5) * 2) / 2
			}
		},
		ap = function i(t, e, n) {
			var r = e >= 1 ? e : 1,
				s = (n || (t ? .3 : .45)) / (e < 1 ? e : 1),
				a = s / cp * (Math.asin(1 / r) || 0),
				o = function (u) {
					return u === 1 ? 1 : r * Math.pow(2, -10 * u) * W1((u - a) * s) + 1
				},
				h = t === "out" ? o : t === "in" ? function (c) {
					return 1 - o(1 - c)
				} : qg(o);
			return s = cp / s, h.config = function (c, u) {
				return i(t, c, u)
			}, h
		},
		op = function i(t, e) {
			e === void 0 && (e = 1.70158);
			var n = function (a) {
					return a ? --a * a * ((e + 1) * a + e) + 1 : 0
				},
				r = t === "out" ? n : t === "in" ? function (s) {
					return 1 - n(1 - s)
				} : qg(n);
			return r.config = function (s) {
				return i(t, s)
			}, r
		};
	Ii("Linear,Quad,Cubic,Quart,Quint,Strong", function (i, t) {
		var e = t < 5 ? t + 1 : t;
		ia(i + ",Power" + (e - 1), t ? function (n) {
			return Math.pow(n, e)
		} : function (n) {
			return n
		}, function (n) {
			return 1 - Math.pow(1 - n, e)
		}, function (n) {
			return n < .5 ? Math.pow(n * 2, e) / 2 : 1 - Math.pow((1 - n) * 2, e) / 2
		})
	});
	ve.Linear.easeNone = ve.none = ve.Linear.easeIn;
	ia("Elastic", ap("in"), ap("out"), ap());
	(function (i, t) {
		var e = 1 / t,
			n = 2 * e,
			r = 2.5 * e,
			s = function (o) {
				return o < e ? i * o * o : o < n ? i * Math.pow(o - 1.5 / t, 2) + .75 : o < r ? i * (o -= 2.25 / t) * o + .9375 : i * Math.pow(o - 2.625 / t, 2) + .984375
			};
		ia("Bounce", function (a) {
			return 1 - s(1 - a)
		}, s)
	})(7.5625, 2.75);
	ia("Expo", function (i) {
		return i ? Math.pow(2, 10 * (i - 1)) : 0
	});
	ia("Circ", function (i) {
		return -(yg(1 - i * i) - 1)
	});
	ia("Sine", function (i) {
		return i === 1 ? 1 : -H1(i * U1) + 1
	});
	ia("Back", op("in"), op("out"), op());
	ve.SteppedEase = ve.steps = an.SteppedEase = {
		config: function (t, e) {
			t === void 0 && (t = 1);
			var n = 1 / t,
				r = t + (e ? 0 : 1),
				s = e ? 1 : 0,
				a = 1 - Re;
			return function (o) {
				return ((r * Pl(0, a, o) | 0) + s) * n
			}
		}
	};
	Xa.ease = ve["quad.out"];
	Ii("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (i) {
		return Tp += i + "," + i + "Params,"
	});
	var Ip = function (t, e) {
			this.id = G1++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Ap, this.set = e ? e.getSetter : _c
		},
		Tl = function () {
			function i(e) {
				this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, Ka(this, +e.duration, 1, 1), this.data = e.data, je && (this._ctx = je, je.data.push(this)), Cl || Wi.wake()
			}
			var t = i.prototype;
			return t.delay = function (n) {
				return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
			}, t.duration = function (n) {
				return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
			}, t.totalDuration = function (n) {
				return arguments.length ? (this._dirty = 0, Ka(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
			}, t.totalTime = function (n, r) {
				if (Za(), !arguments.length) return this._tTime;
				var s = this._dp;
				if (s && s.smoothChildTiming && this._ts) {
					for (gc(this, n), !s._dp || s.parent || Dg(s, this); s && s.parent;) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent;
					!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Kn(this._dp, this, this._start - this._delay)
				}
				return (this._tTime !== n || !this._dur && !r || this._initted && Math.abs(this._zTime) === Re || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), Cg(this, n, r)), this
			}, t.time = function (n, r) {
				return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + pg(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), r) : this._time
			}, t.totalProgress = function (n, r) {
				return arguments.length ? this.totalTime(this.totalDuration() * n, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
			}, t.progress = function (n, r) {
				return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + pg(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
			}, t.iteration = function (n, r) {
				var s = this.duration() + this._rDelay;
				return arguments.length ? this.totalTime(this._time + (n - 1) * s, r) : this._repeat ? Ya(this._tTime, s) + 1 : 1
			}, t.timeScale = function (n) {
				if (!arguments.length) return this._rts === -Re ? 0 : this._rts;
				if (this._rts === n) return this;
				var r = this.parent && this._ts ? uc(this.parent._time, this) : this._tTime;
				return this._rts = +n || 0, this._ts = this._ps || n === -Re ? 0 : this._rts, this.totalTime(Pl(-Math.abs(this._delay), this._tDur, r), !0), vc(this), Z1(this)
			}, t.paused = function (n) {
				return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Za(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Re && (this._tTime -= Re)))), this) : this._ps
			}, t.startTime = function (n) {
				if (arguments.length) {
					this._start = n;
					var r = this.parent || this._dp;
					return r && (r._sort || !this.parent) && Kn(r, this, n - this._delay), this
				}
				return this._start
			}, t.endTime = function (n) {
				return this._start + ($i(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
			}, t.rawTime = function (n) {
				var r = this.parent || this._dp;
				return r ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? uc(r.rawTime(n), this) : this._tTime : this._tTime
			}, t.revert = function (n) {
				n === void 0 && (n = j1);
				var r = xi;
				return xi = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), xi = r, this
			}, t.globalTime = function (n) {
				for (var r = this, s = arguments.length ? n : r.rawTime(); r;) s = r._start + s / (r._ts || 1), r = r._dp;
				return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(n) : s
			}, t.repeat = function (n) {
				return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, fg(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
			}, t.repeatDelay = function (n) {
				if (arguments.length) {
					var r = this._time;
					return this._rDelay = n, fg(this), r ? this.time(r) : this
				}
				return this._rDelay
			}, t.yoyo = function (n) {
				return arguments.length ? (this._yoyo = n, this) : this._yoyo
			}, t.seek = function (n, r) {
				return this.totalTime(_n(this, n), $i(r))
			}, t.restart = function (n, r) {
				return this.play().totalTime(n ? -this._delay : 0, $i(r))
			}, t.play = function (n, r) {
				return n != null && this.seek(n, r), this.reversed(!1).paused(!1)
			}, t.reverse = function (n, r) {
				return n != null && this.seek(n || this.totalDuration(), r), this.reversed(!0).paused(!1)
			}, t.pause = function (n, r) {
				return n != null && this.seek(n, r), this.paused(!0)
			}, t.resume = function () {
				return this.paused(!1)
			}, t.reversed = function (n) {
				return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Re : 0)), this) : this._rts < 0
			}, t.invalidate = function () {
				return this._initted = this._act = 0, this._zTime = -Re, this
			}, t.isActive = function () {
				var n = this.parent || this._dp,
					r = this._start,
					s;
				return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= r && s < this.endTime(!0) - Re)
			}, t.eventCallback = function (n, r, s) {
				var a = this.vars;
				return arguments.length > 1 ? (r ? (a[n] = r, s && (a[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = r)) : delete a[n], this) : a[n]
			}, t.then = function (n) {
				var r = this;
				return new Promise(function (s) {
					var a = Xe(n) ? n : Pg,
						o = function () {
							var c = r.then;
							r.then = null, Xe(a) && (a = a(r)) && (a.then || a === r) && (r.then = c), s(a), r.then = c
						};
					r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? o() : r._prom = o
				})
			}, t.kill = function () {
				bl(this)
			}, i
		}();
	Sn(Tl.prototype, {
		_time: 0,
		_start: 0,
		_end: 0,
		_tTime: 0,
		_tDur: 0,
		_dirty: 0,
		_repeat: 0,
		_yoyo: !1,
		parent: null,
		_initted: !1,
		_rDelay: 0,
		_ts: 1,
		_dp: 0,
		ratio: 0,
		_zTime: -Re,
		_prom: 0,
		_ps: !1,
		_rts: 1
	});
	var bi = function (i) {
		_g(t, i);

		function t(n, r) {
			var s;
			return n === void 0 && (n = {}), s = i.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = $i(n.sortChildren), Ue && Kn(n.parent || Ue, Sr(s), r), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && Ig(Sr(s), n.scrollTrigger), s
		}
		var e = t.prototype;
		return e.to = function (r, s, a) {
			return Sl(0, arguments, this), this
		}, e.from = function (r, s, a) {
			return Sl(1, arguments, this), this
		}, e.fromTo = function (r, s, a, o) {
			return Sl(2, arguments, this), this
		}, e.set = function (r, s, a) {
			return s.duration = 0, s.parent = this, wl(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Je(r, s, _n(this, a), 1), this
		}, e.call = function (r, s, a) {
			return Kn(this, Je.delayedCall(0, r, s), a)
		}, e.staggerTo = function (r, s, a, o, h, c, u) {
			return a.duration = s, a.stagger = a.stagger || o, a.onComplete = c, a.onCompleteParams = u, a.parent = this, new Je(r, a, _n(this, h)), this
		}, e.staggerFrom = function (r, s, a, o, h, c, u) {
			return a.runBackwards = 1, wl(a).immediateRender = $i(a.immediateRender), this.staggerTo(r, s, a, o, h, c, u)
		}, e.staggerFromTo = function (r, s, a, o, h, c, u, g) {
			return o.startAt = a, wl(o).immediateRender = $i(o.immediateRender), this.staggerTo(r, s, o, h, c, u, g)
		}, e.render = function (r, s, a) {
			var o = this._time,
				h = this._dirty ? this.totalDuration() : this._tDur,
				c = this._dur,
				u = r <= 0 ? 0 : gi(r),
				g = this._zTime < 0 != r < 0 && (this._initted || !c),
				p, _, b, y, w, f, S, x, M, T, I, L;
			if (this !== Ue && u > h && r >= 0 && (u = h), u !== this._tTime || a || g) {
				if (o !== this._time && c && (u += this._time - o, r += this._time - o), p = u, M = this._start, x = this._ts, f = !x, g && (c || (o = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) {
					if (I = this._yoyo, w = c + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(w * 100 + r, s, a);
					if (p = gi(u % w), u === h ? (y = this._repeat, p = c) : (y = ~~(u / w), y && y === u / w && (p = c, y--), p > c && (p = c)), T = Ya(this._tTime, w), !o && this._tTime && T !== y && this._tTime - T * w - this._dur <= 0 && (T = y), I && y & 1 && (p = c - p, L = 1), y !== T && !this._lock) {
						var F = I && T & 1,
							k = F === (I && y & 1);
						if (y < T && (F = !F), o = F ? 0 : u % c ? c : u, this._lock = 1, this.render(o || (L ? 0 : gi(y * w)), s, !c)._lock = 0, this._tTime = u, !s && this.parent && wn(this, "onRepeat"), this.vars.repeatRefresh && !L && (this.invalidate()._lock = 1), o && o !== this._time || f !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
						if (c = this._dur, h = this._tDur, k && (this._lock = 2, o = F ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !L && this.invalidate()), this._lock = 0, !this._ts && !f) return this;
						$g(this, L)
					}
				}
				if (this._hasPause && !this._forcing && this._lock < 2 && (S = eS(this, gi(o), gi(p)), S && (u -= p - (p = S._start))), this._tTime = u, this._time = p, this._act = !x, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, o = 0), !o && p && !s && !y && (wn(this, "onStart"), this._tTime !== u)) return this;
				if (p >= o && r >= 0)
					for (_ = this._first; _;) {
						if (b = _._next, (_._act || p >= _._start) && _._ts && S !== _) {
							if (_.parent !== this) return this.render(r, s, a);
							if (_.render(_._ts > 0 ? (p - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (p - _._start) * _._ts, s, a), p !== this._time || !this._ts && !f) {
								S = 0, b && (u += this._zTime = -Re);
								break
							}
						}
						_ = b
					} else {
						_ = this._last;
						for (var G = r < 0 ? r : p; _;) {
							if (b = _._prev, (_._act || G <= _._end) && _._ts && S !== _) {
								if (_.parent !== this) return this.render(r, s, a);
								if (_.render(_._ts > 0 ? (G - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (G - _._start) * _._ts, s, a || xi && (_._initted || _._startAt)), p !== this._time || !this._ts && !f) {
									S = 0, b && (u += this._zTime = G ? -Re : Re);
									break
								}
							}
							_ = b
						}
					}
				if (S && !s && (this.pause(), S.render(p >= o ? 0 : -Re)._zTime = p >= o ? 1 : -1, this._ts)) return this._start = M, vc(this), this.render(r, s, a);
				this._onUpdate && !s && wn(this, "onUpdate", !0), (u === h && this._tTime >= this.totalDuration() || !u && o) && (M === this._start || Math.abs(x) !== Math.abs(this._ts)) && (this._lock || ((r || !c) && (u === h && this._ts > 0 || !u && this._ts < 0) && os(this, 1), !s && !(r < 0 && !o) && (u || o || !h) && (wn(this, u === h && r >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < h && this.timeScale() > 0) && this._prom())))
			}
			return this
		}, e.add = function (r, s) {
			var a = this;
			if (Mr(s) || (s = _n(this, s, r)), !(r instanceof Tl)) {
				if (wi(r)) return r.forEach(function (o) {
					return a.add(o, s)
				}), this;
				if (ri(r)) return this.addLabel(r, s);
				if (Xe(r)) r = Je.delayedCall(0, r);
				else return this
			}
			return this !== r ? Kn(this, r, s) : this
		}, e.getChildren = function (r, s, a, o) {
			r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -bn);
			for (var h = [], c = this._first; c;) c._start >= o && (c instanceof Je ? s && h.push(c) : (a && h.push(c), r && h.push.apply(h, c.getChildren(!0, s, a)))), c = c._next;
			return h
		}, e.getById = function (r) {
			for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)
				if (s[a].vars.id === r) return s[a]
		}, e.remove = function (r) {
			return ri(r) ? this.removeLabel(r) : Xe(r) ? this.killTweensOf(r) : (mc(this, r), r === this._recent && (this._recent = this._last), Ks(this))
		}, e.totalTime = function (r, s) {
			return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = gi(Wi.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), i.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime
		}, e.addLabel = function (r, s) {
			return this.labels[r] = _n(this, s), this
		}, e.removeLabel = function (r) {
			return delete this.labels[r], this
		}, e.addPause = function (r, s, a) {
			var o = Je.delayedCall(0, s || Ml, a);
			return o.data = "isPause", this._hasPause = 1, Kn(this, o, _n(this, r))
		}, e.removePause = function (r) {
			var s = this._first;
			for (r = _n(this, r); s;) s._start === r && s.data === "isPause" && os(s), s = s._next
		}, e.killTweensOf = function (r, s, a) {
			for (var o = this.getTweensOf(r, a), h = o.length; h--;) rs !== o[h] && o[h].kill(r, s);
			return this
		}, e.getTweensOf = function (r, s) {
			for (var a = [], o = xn(r), h = this._first, c = Mr(s), u; h;) h instanceof Je ? X1(h._targets, o) && (c ? (!rs || h._initted && h._ts) && h.globalTime(0) <= s && h.globalTime(h.totalDuration()) > s : !s || h.isActive()) && a.push(h) : (u = h.getTweensOf(o, s)).length && a.push.apply(a, u), h = h._next;
			return a
		}, e.tweenTo = function (r, s) {
			s = s || {};
			var a = this,
				o = _n(a, r),
				h = s,
				c = h.startAt,
				u = h.onStart,
				g = h.onStartParams,
				p = h.immediateRender,
				_, b = Je.to(a, Sn({
					ease: s.ease || "none",
					lazy: !1,
					immediateRender: !1,
					time: o,
					overwrite: "auto",
					duration: s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || Re,
					onStart: function () {
						if (a.pause(), !_) {
							var w = s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale());
							b._dur !== w && Ka(b, w, 0, 1).render(b._time, !0, !0), _ = 1
						}
						u && u.apply(b, g || [])
					}
				}, s));
			return p ? b.render(0) : b
		}, e.tweenFromTo = function (r, s, a) {
			return this.tweenTo(s, Sn({
				startAt: {
					time: _n(this, r)
				}
			}, a))
		}, e.recent = function () {
			return this._recent
		}, e.nextLabel = function (r) {
			return r === void 0 && (r = this._time), mg(this, _n(this, r))
		}, e.previousLabel = function (r) {
			return r === void 0 && (r = this._time), mg(this, _n(this, r), 1)
		}, e.currentLabel = function (r) {
			return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + Re)
		}, e.shiftChildren = function (r, s, a) {
			a === void 0 && (a = 0);
			for (var o = this._first, h = this.labels, c; o;) o._start >= a && (o._start += r, o._end += r), o = o._next;
			if (s)
				for (c in h) h[c] >= a && (h[c] += r);
			return Ks(this)
		}, e.invalidate = function (r) {
			var s = this._first;
			for (this._lock = 0; s;) s.invalidate(r), s = s._next;
			return i.prototype.invalidate.call(this, r)
		}, e.clear = function (r) {
			r === void 0 && (r = !0);
			for (var s = this._first, a; s;) a = s._next, this.remove(s), s = a;
			return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), Ks(this)
		}, e.totalDuration = function (r) {
			var s = 0,
				a = this,
				o = a._last,
				h = bn,
				c, u, g;
			if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -r : r));
			if (a._dirty) {
				for (g = a.parent; o;) c = o._prev, o._dirty && o.totalDuration(), u = o._start, u > h && a._sort && o._ts && !a._lock ? (a._lock = 1, Kn(a, o, u - o._delay, 1)._lock = 0) : h = u, u < 0 && o._ts && (s -= u, (!g && !a._dp || g && g.smoothChildTiming) && (a._start += u / a._ts, a._time -= u, a._tTime -= u), a.shiftChildren(-u, !1, -1 / 0), h = 0), o._end > s && o._ts && (s = o._end), o = c;
				Ka(a, a === Ue && a._time > s ? a._time : s, 1, 1), a._dirty = 0
			}
			return a._tDur
		}, t.updateRoot = function (r) {
			if (Ue._ts && (Cg(Ue, uc(r, Ue)), Mg = Wi.frame), Wi.frame >= ug) {
				ug += qi.autoSleep || 120;
				var s = Ue._first;
				if ((!s || !s._ts) && qi.autoSleep && Wi._listeners.length < 2) {
					for (; s && !s._ts;) s = s._next;
					s || Wi.sleep()
				}
			}
		}, t
	}(Tl);
	Sn(bi.prototype, {
		_lock: 0,
		_hasPause: 0,
		_forcing: 0
	});
	var gS = function (t, e, n, r, s, a, o) {
			var h = new Li(this._pt, t, e, 0, 1, Op, null, s),
				c = 0,
				u = 0,
				g, p, _, b, y, w, f, S;
			for (h.b = n, h.e = r, n += "", r += "", (f = ~r.indexOf("random(")) && (r = Ja(r)), a && (S = [n, r], a(S, t, e), n = S[0], r = S[1]), p = n.match(np) || []; g = np.exec(r);) b = g[0], y = r.substring(c, g.index), _ ? _ = (_ + 1) % 5 : y.substr(-5) === "rgba(" && (_ = 1), b !== p[u++] && (w = parseFloat(p[u - 1]) || 0, h._pt = {
				_next: h._pt,
				p: y || u === 1 ? y : ",",
				s: w,
				c: b.charAt(1) === "=" ? ea(w, b) - w : parseFloat(b) - w,
				m: _ && _ < 4 ? Math.round : 0
			}, c = np.lastIndex);
			return h.c = c < r.length ? r.substring(c, r.length) : "", h.fp = o, (Ep.test(r) || f) && (h.e = 0), this._pt = h, h
		},
		Lp = function (t, e, n, r, s, a, o, h, c, u) {
			Xe(r) && (r = r(s || 0, t, a));
			var g = t[e],
				p = n !== "get" ? n : Xe(g) ? c ? t[e.indexOf("set") || !Xe(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : g,
				_ = Xe(g) ? c ? wS : Yg : Fp,
				b;
			if (ri(r) && (~r.indexOf("random(") && (r = Ja(r)), r.charAt(1) === "=" && (b = ea(p, r) + (_i(p) || 0), (b || b === 0) && (r = b))), !u || p !== r || yp) return !isNaN(p * r) && r !== "" ? (b = new Li(this._pt, t, e, +p || 0, r - (p || 0), typeof g == "boolean" ? ES : Kg, 0, _), c && (b.fp = c), o && b.modifier(o, this, t), this._pt = b) : (!g && !(e in t) && fc(e, r), gS.call(this, t, e, p, r, _, h || qi.stringFilter, c))
		},
		_S = function (t, e, n, r, s) {
			if (Xe(t) && (t = El(t, s, e, n, r)), !Zn(t) || t.style && t.nodeType || wi(t) || bg(t)) return ri(t) ? El(t, s, e, n, r) : t;
			var a = {},
				o;
			for (o in t) a[o] = El(t[o], s, e, n, r);
			return a
		},
		kp = function (t, e, n, r, s, a) {
			var o, h, c, u;
			if (Hi[t] && (o = new Hi[t]).init(s, o.rawVars ? e[t] : _S(e[t], r, s, a, n), n, r, a) !== !1 && (n._pt = h = new Li(n._pt, s, t, 0, 1, o.render, o, 0, o.priority), n !== ja))
				for (c = n._ptLookup[n._targets.indexOf(s)], u = o._props.length; u--;) c[o._props[u]] = h;
			return o
		},
		rs, yp, Rp = function i(t, e, n) {
			var r = t.vars,
				s = r.ease,
				a = r.startAt,
				o = r.immediateRender,
				h = r.lazy,
				c = r.onUpdate,
				u = r.onUpdateParams,
				g = r.callbackScope,
				p = r.runBackwards,
				_ = r.yoyoEase,
				b = r.keyframes,
				y = r.autoRevert,
				w = t._dur,
				f = t._startAt,
				S = t._targets,
				x = t.parent,
				M = x && x.data === "nested" ? x.vars.targets : S,
				T = t._overwrite === "auto" && !xp,
				I = t.timeline,
				L, F, k, G, j, U, z, $, W, O, B, A, D;
			if (I && (!b || !s) && (s = "none"), t._ease = Zs(s, Xa.ease), t._yEase = _ ? Wg(Zs(_ === !0 ? s : _, Xa.ease)) : 0, _ && t._yoyo && !t._repeat && (_ = t._yEase, t._yEase = t._ease, t._ease = _), t._from = !I && !!r.runBackwards, !I || b && !r.stagger) {
				if ($ = S[0] ? as(S[0]).harness : 0, A = $ && r[$.prop], L = cc(r, Cp), f && (f._zTime < 0 && f.progress(1), e < 0 && p && o && !y ? f.render(-1, !0) : f.revert(p && w ? rc : q1), f._lazy = 0), a) {
					if (os(t._startAt = Je.set(S, Sn({
							data: "isStart",
							overwrite: !1,
							parent: x,
							immediateRender: !0,
							lazy: !f && $i(h),
							startAt: null,
							delay: 0,
							onUpdate: c,
							onUpdateParams: u,
							callbackScope: g,
							stagger: 0
						}, a))), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (xi || !o && !y) && t._startAt.revert(rc), o && w && e <= 0 && n <= 0) {
						e && (t._zTime = e);
						return
					}
				} else if (p && w && !f) {
					if (e && (o = !1), k = Sn({
							overwrite: !1,
							data: "isFromStart",
							lazy: o && !f && $i(h),
							immediateRender: o,
							stagger: 0,
							parent: x
						}, L), A && (k[$.prop] = A), os(t._startAt = Je.set(S, k)), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (xi ? t._startAt.revert(rc) : t._startAt.render(-1, !0)), t._zTime = e, !o) i(t._startAt, Re, Re);
					else if (!e) return
				}
				for (t._pt = t._ptCache = 0, h = w && $i(h) || h && !w, F = 0; F < S.length; F++) {
					if (j = S[F], z = j._gsap || Pp(S)[F]._gsap, t._ptLookup[F] = O = {}, pp[z.id] && ss.length && hc(), B = M === S ? F : M.indexOf(j), $ && (W = new $).init(j, A || L, t, B, M) !== !1 && (t._pt = G = new Li(t._pt, j, W.name, 0, 1, W.render, W, 0, W.priority), W._props.forEach(function (H) {
							O[H] = G
						}), W.priority && (U = 1)), !$ || A)
						for (k in L) Hi[k] && (W = kp(k, L, t, B, j, M)) ? W.priority && (U = 1) : O[k] = G = Lp.call(t, j, k, "get", L[k], B, M, 0, r.stringFilter);
					t._op && t._op[F] && t.kill(j, t._op[F]), T && t._pt && (rs = t, Ue.killTweensOf(j, O, t.globalTime(e)), D = !t.parent, rs = 0), t._pt && h && (pp[z.id] = 1)
				}
				U && Vp(t), t._onInit && t._onInit(t)
			}
			t._onUpdate = c, t._initted = (!t._op || t._pt) && !D, b && e <= 0 && I.render(bn, !0, !0)
		},
		yS = function (t, e, n, r, s, a, o) {
			var h = (t._pt && t._ptCache || (t._ptCache = {}))[e],
				c, u, g, p;
			if (!h)
				for (h = t._ptCache[e] = [], g = t._ptLookup, p = t._targets.length; p--;) {
					if (c = g[p][e], c && c.d && c.d._pt)
						for (c = c.d._pt; c && c.p !== e && c.fp !== e;) c = c._next;
					if (!c) return yp = 1, t.vars[e] = "+=0", Rp(t, o), yp = 0, 1;
					h.push(c)
				}
			for (p = h.length; p--;) u = h[p], c = u._pt || u, c.s = (r || r === 0) && !s ? r : c.s + (r || 0) + a * c.c, c.c = n - c.s, u.e && (u.e = Ye(n) + _i(u.e)), u.b && (u.b = c.s + _i(u.b))
		},
		bS = function (t, e) {
			var n = t[0] ? as(t[0]).harness : 0,
				r = n && n.aliases,
				s, a, o, h;
			if (!r) return e;
			s = Qs({}, e);
			for (a in r)
				if (a in s)
					for (h = r[a].split(","), o = h.length; o--;) s[h[o]] = s[a];
			return s
		},
		xS = function (t, e, n, r) {
			var s = e.ease || r || "power1.inOut",
				a, o;
			if (wi(e)) o = n[t] || (n[t] = []), e.forEach(function (h, c) {
				return o.push({
					t: c / (e.length - 1) * 100,
					v: h,
					e: s
				})
			});
			else
				for (a in e) o = n[a] || (n[a] = []), a === "ease" || o.push({
					t: parseFloat(t),
					v: e[a],
					e: s
				})
		},
		El = function (t, e, n, r, s) {
			return Xe(t) ? t.call(e, n, r, s) : ri(t) && ~t.indexOf("random(") ? Ja(t) : t
		},
		jg = Tp + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
		Xg = {};
	Ii(jg + ",id,stagger,delay,duration,paused,scrollTrigger", function (i) {
		return Xg[i] = 1
	});
	var Je = function (i) {
		_g(t, i);

		function t(n, r, s, a) {
			var o;
			typeof r == "number" && (s.duration = r, r = s, s = null), o = i.call(this, a ? r : wl(r)) || this;
			var h = o.vars,
				c = h.duration,
				u = h.delay,
				g = h.immediateRender,
				p = h.stagger,
				_ = h.overwrite,
				b = h.keyframes,
				y = h.defaults,
				w = h.scrollTrigger,
				f = h.yoyoEase,
				S = r.parent || Ue,
				x = (wi(n) || bg(n) ? Mr(n[0]) : "length" in r) ? [n] : xn(n),
				M, T, I, L, F, k, G, j;
			if (o._targets = x.length ? Pp(x) : lc("GSAP target " + n + " not found. https://greensock.com", !qi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = _, b || p || nc(c) || nc(u)) {
				if (r = o.vars, M = o.timeline = new bi({
						data: "nested",
						defaults: y || {},
						targets: S && S.data === "nested" ? S.vars.targets : x
					}), M.kill(), M.parent = M._dp = Sr(o), M._start = 0, p || nc(c) || nc(u)) {
					if (L = x.length, G = p && Fg(p), Zn(p))
						for (F in p) ~jg.indexOf(F) && (j || (j = {}), j[F] = p[F]);
					for (T = 0; T < L; T++) I = cc(r, Xg), I.stagger = 0, f && (I.yoyoEase = f), j && Qs(I, j), k = x[T], I.duration = +El(c, Sr(o), T, k, x), I.delay = (+El(u, Sr(o), T, k, x) || 0) - o._delay, !p && L === 1 && I.delay && (o._delay = u = I.delay, o._start += u, I.delay = 0), M.to(k, I, G ? G(T, k, x) : 0), M._ease = ve.none;
					M.duration() ? c = u = 0 : o.timeline = 0
				} else if (b) {
					wl(Sn(M.vars.defaults, {
						ease: "none"
					})), M._ease = Zs(b.ease || r.ease || "none");
					var U = 0,
						z, $, W;
					if (wi(b)) b.forEach(function (O) {
						return M.to(x, O, ">")
					}), M.duration();
					else {
						I = {};
						for (F in b) F === "ease" || F === "easeEach" || xS(F, b[F], I, b.easeEach);
						for (F in I)
							for (z = I[F].sort(function (O, B) {
									return O.t - B.t
								}), U = 0, T = 0; T < z.length; T++) $ = z[T], W = {
								ease: $.e,
								duration: ($.t - (T ? z[T - 1].t : 0)) / 100 * c
							}, W[F] = $.v, M.to(x, W, U), U += W.duration;
						M.duration() < c && M.to({}, {
							duration: c - M.duration()
						})
					}
				}
				c || o.duration(c = M.duration())
			} else o.timeline = 0;
			return _ === !0 && !xp && (rs = Sr(o), Ue.killTweensOf(x), rs = 0), Kn(S, Sr(o), s), r.reversed && o.reverse(), r.paused && o.paused(!0), (g || !c && !b && o._start === gi(S._time) && $i(g) && J1(Sr(o)) && S.data !== "nested") && (o._tTime = -Re, o.render(Math.max(0, -u) || 0)), w && Ig(Sr(o), w), o
		}
		var e = t.prototype;
		return e.render = function (r, s, a) {
			var o = this._time,
				h = this._tDur,
				c = this._dur,
				u = r < 0,
				g = r > h - Re && !u ? h : r < Re ? 0 : r,
				p, _, b, y, w, f, S, x, M;
			if (!c) tS(this, r, s, a);
			else if (g !== this._tTime || !r || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
				if (p = g, x = this.timeline, this._repeat) {
					if (y = c + this._rDelay, this._repeat < -1 && u) return this.totalTime(y * 100 + r, s, a);
					if (p = gi(g % y), g === h ? (b = this._repeat, p = c) : (b = ~~(g / y), b && b === g / y && (p = c, b--), p > c && (p = c)), f = this._yoyo && b & 1, f && (M = this._yEase, p = c - p), w = Ya(this._tTime, y), p === o && !a && this._initted) return this._tTime = g, this;
					b !== w && (x && this._yEase && $g(x, f), this.vars.repeatRefresh && !f && !this._lock && (this._lock = a = 1, this.render(gi(y * b), !0).invalidate()._lock = 0))
				}
				if (!this._initted) {
					if (Lg(this, u ? r : p, a, s, g)) return this._tTime = 0, this;
					if (o !== this._time) return this;
					if (c !== this._dur) return this.render(r, s, a)
				}
				if (this._tTime = g, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = S = (M || this._ease)(p / c), this._from && (this.ratio = S = 1 - S), p && !o && !s && !b && (wn(this, "onStart"), this._tTime !== g)) return this;
				for (_ = this._pt; _;) _.r(S, _.d), _ = _._next;
				x && x.render(r < 0 ? r : !p && f ? -Re : x._dur * x._ease(p / this._dur), s, a) || this._startAt && (this._zTime = r), this._onUpdate && !s && (u && fp(this, r, s, a), wn(this, "onUpdate")), this._repeat && b !== w && this.vars.onRepeat && !s && this.parent && wn(this, "onRepeat"), (g === this._tDur || !g) && this._tTime === g && (u && !this._onUpdate && fp(this, r, !0, !0), (r || !c) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && os(this, 1), !s && !(u && !o) && (g || o || f) && (wn(this, g === h ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < h && this.timeScale() > 0) && this._prom()))
			}
			return this
		}, e.targets = function () {
			return this._targets
		}, e.invalidate = function (r) {
			return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), i.prototype.invalidate.call(this, r)
		}, e.resetTo = function (r, s, a, o) {
			Cl || Wi.wake(), this._ts || this.play();
			var h = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
				c;
			return this._initted || Rp(this, h), c = this._ease(h / this._dur), yS(this, r, s, a, o, c, h) ? this.resetTo(r, s, a, o) : (gc(this, 0), this.parent || Ag(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
		}, e.kill = function (r, s) {
			if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? bl(this) : this;
			if (this.timeline) {
				var a = this.timeline.totalDuration();
				return this.timeline.killTweensOf(r, s, rs && rs.vars.overwrite !== !0)._first || bl(this), this.parent && a !== this.timeline.totalDuration() && Ka(this, this._dur * this.timeline._tDur / a, 0, 1), this
			}
			var o = this._targets,
				h = r ? xn(r) : o,
				c = this._ptLookup,
				u = this._pt,
				g, p, _, b, y, w, f;
			if ((!s || s === "all") && K1(o, h)) return s === "all" && (this._pt = 0), bl(this);
			for (g = this._op = this._op || [], s !== "all" && (ri(s) && (y = {}, Ii(s, function (S) {
					return y[S] = 1
				}), s = y), s = bS(o, s)), f = o.length; f--;)
				if (~h.indexOf(o[f])) {
					p = c[f], s === "all" ? (g[f] = s, b = p, _ = {}) : (_ = g[f] = g[f] || {}, b = s);
					for (y in b) w = p && p[y], w && ((!("kill" in w.d) || w.d.kill(y) === !0) && mc(this, w, "_pt"), delete p[y]), _ !== "all" && (_[y] = 1)
				} return this._initted && !this._pt && u && bl(this), this
		}, t.to = function (r, s) {
			return new t(r, s, arguments[2])
		}, t.from = function (r, s) {
			return Sl(1, arguments)
		}, t.delayedCall = function (r, s, a, o) {
			return new t(s, 0, {
				immediateRender: !1,
				lazy: !1,
				overwrite: !1,
				delay: r,
				onComplete: s,
				onReverseComplete: s,
				onCompleteParams: a,
				onReverseCompleteParams: a,
				callbackScope: o
			})
		}, t.fromTo = function (r, s, a) {
			return Sl(2, arguments)
		}, t.set = function (r, s) {
			return s.duration = 0, s.repeatDelay || (s.repeat = 0), new t(r, s)
		}, t.killTweensOf = function (r, s, a) {
			return Ue.killTweensOf(r, s, a)
		}, t
	}(Tl);
	Sn(Je.prototype, {
		_targets: [],
		_lazy: 0,
		_startAt: 0,
		_op: 0,
		_onInit: 0
	});
	Ii("staggerTo,staggerFrom,staggerFromTo", function (i) {
		Je[i] = function () {
			var t = new bi,
				e = vp.call(arguments, 0);
			return e.splice(i === "staggerFromTo" ? 5 : 4, 0, 0), t[i].apply(t, e)
		}
	});
	var Fp = function (t, e, n) {
			return t[e] = n
		},
		Yg = function (t, e, n) {
			return t[e](n)
		},
		wS = function (t, e, n, r) {
			return t[e](r.fp, n)
		},
		SS = function (t, e, n) {
			return t.setAttribute(e, n)
		},
		_c = function (t, e) {
			return Xe(t[e]) ? Yg : pc(t[e]) && t.setAttribute ? SS : Fp
		},
		Kg = function (t, e) {
			return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e)
		},
		ES = function (t, e) {
			return e.set(e.t, e.p, !!(e.s + e.c * t), e)
		},
		Op = function (t, e) {
			var n = e._pt,
				r = "";
			if (!t && e.b) r = e.b;
			else if (t === 1 && e.e) r = e.e;
			else {
				for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round((n.s + n.c * t) * 1e4) / 1e4) + r, n = n._next;
				r += e.c
			}
			e.set(e.t, e.p, r, e)
		},
		Np = function (t, e) {
			for (var n = e._pt; n;) n.r(t, n.d), n = n._next
		},
		MS = function (t, e, n, r) {
			for (var s = this._pt, a; s;) a = s._next, s.p === r && s.modifier(t, e, n), s = a
		},
		CS = function (t) {
			for (var e = this._pt, n, r; e;) r = e._next, e.p === t && !e.op || e.op === t ? mc(this, e, "_pt") : e.dep || (n = 1), e = r;
			return !n
		},
		TS = function (t, e, n, r) {
			r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
		},
		Vp = function (t) {
			for (var e = t._pt, n, r, s, a; e;) {
				for (n = e._next, r = s; r && r.pr > e.pr;) r = r._next;
				(e._prev = r ? r._prev : a) ? e._prev._next = e: s = e, (e._next = r) ? r._prev = e : a = e, e = n
			}
			t._pt = s
		},
		Li = function () {
			function i(e, n, r, s, a, o, h, c, u) {
				this.t = n, this.s = s, this.c = a, this.p = r, this.r = o || Kg, this.d = h || this, this.set = c || Fp, this.pr = u || 0, this._next = e, e && (e._prev = this)
			}
			var t = i.prototype;
			return t.modifier = function (n, r, s) {
				this.mSet = this.mSet || this.set, this.set = TS, this.m = n, this.mt = s, this.tween = r
			}, i
		}();
	Ii(Tp + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (i) {
		return Cp[i] = 1
	});
	an.TweenMax = an.TweenLite = Je;
	an.TimelineLite = an.TimelineMax = bi;
	Ue = new bi({
		sortChildren: !1,
		defaults: Xa,
		autoRemoveChildren: !0,
		id: "root",
		smoothChildTiming: !0
	});
	qi.stringFilter = Dp;
	var Js = [],
		ac = {},
		PS = [],
		gg = 0,
		AS = 0,
		lp = function (t) {
			return (ac[t] || PS).map(function (e) {
				return e()
			})
		},
		bp = function () {
			var t = Date.now(),
				e = [];
			t - gg > 2 && (lp("matchMediaInit"), Js.forEach(function (n) {
				var r = n.queries,
					s = n.conditions,
					a, o, h, c;
				for (o in r) a = yn.matchMedia(r[o]).matches, a && (h = 1), a !== s[o] && (s[o] = a, c = 1);
				c && (n.revert(), h && e.push(n))
			}), lp("matchMediaRevert"), e.forEach(function (n) {
				return n.onMatch(n)
			}), gg = t, lp("matchMedia"))
		},
		Zg = function () {
			function i(e, n) {
				this.selector = n && gp(n), this.data = [], this._r = [], this.isReverted = !1, this.id = AS++, e && this.add(e)
			}
			var t = i.prototype;
			return t.add = function (n, r, s) {
				Xe(n) && (s = r, r = n, n = Xe);
				var a = this,
					o = function () {
						var c = je,
							u = a.selector,
							g;
						return c && c !== a && c.data.push(a), s && (a.selector = gp(s)), je = a, g = r.apply(a, arguments), Xe(g) && a._r.push(g), je = c, a.selector = u, a.isReverted = !1, g
					};
				return a.last = o, n === Xe ? o(a) : n ? a[n] = o : o
			}, t.ignore = function (n) {
				var r = je;
				je = null, n(this), je = r
			}, t.getTweens = function () {
				var n = [];
				return this.data.forEach(function (r) {
					return r instanceof i ? n.push.apply(n, r.getTweens()) : r instanceof Je && !(r.parent && r.parent.data === "nested") && n.push(r)
				}), n
			}, t.clear = function () {
				this._r.length = this.data.length = 0
			}, t.kill = function (n, r) {
				var s = this;
				if (n) {
					var a = this.getTweens();
					this.data.forEach(function (h) {
						h.data === "isFlip" && (h.revert(), h.getChildren(!0, !0, !1).forEach(function (c) {
							return a.splice(a.indexOf(c), 1)
						}))
					}), a.map(function (h) {
						return {
							g: h.globalTime(0),
							t: h
						}
					}).sort(function (h, c) {
						return c.g - h.g || -1 / 0
					}).forEach(function (h) {
						return h.t.revert(n)
					}), this.data.forEach(function (h) {
						return !(h instanceof Je) && h.revert && h.revert(n)
					}), this._r.forEach(function (h) {
						return h(n, s)
					}), this.isReverted = !0
				} else this.data.forEach(function (h) {
					return h.kill && h.kill()
				});
				if (this.clear(), r)
					for (var o = Js.length; o--;) Js[o].id === this.id && Js.splice(o, 1)
			}, t.revert = function (n) {
				this.kill(n || {})
			}, i
		}(),
		DS = function () {
			function i(e) {
				this.contexts = [], this.scope = e
			}
			var t = i.prototype;
			return t.add = function (n, r, s) {
				Zn(n) || (n = {
					matches: n
				});
				var a = new Zg(0, s || this.scope),
					o = a.conditions = {},
					h, c, u;
				je && !a.selector && (a.selector = je.selector), this.contexts.push(a), r = a.add("onMatch", r), a.queries = n;
				for (c in n) c === "all" ? u = 1 : (h = yn.matchMedia(n[c]), h && (Js.indexOf(a) < 0 && Js.push(a), (o[c] = h.matches) && (u = 1), h.addListener ? h.addListener(bp) : h.addEventListener("change", bp)));
				return u && r(a), this
			}, t.revert = function (n) {
				this.kill(n || {})
			}, t.kill = function (n) {
				this.contexts.forEach(function (r) {
					return r.kill(n, !0)
				})
			}, i
		}(),
		dc = {
			registerPlugin: function () {
				for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
				e.forEach(function (r) {
					return Ug(r)
				})
			},
			timeline: function (t) {
				return new bi(t)
			},
			getTweensOf: function (t, e) {
				return Ue.getTweensOf(t, e)
			},
			getProperty: function (t, e, n, r) {
				ri(t) && (t = xn(t)[0]);
				var s = as(t || {}).get,
					a = n ? Pg : Tg;
				return n === "native" && (n = ""), t && (e ? a((Hi[e] && Hi[e].get || s)(t, e, n, r)) : function (o, h, c) {
					return a((Hi[o] && Hi[o].get || s)(t, o, h, c))
				})
			},
			quickSetter: function (t, e, n) {
				if (t = xn(t), t.length > 1) {
					var r = t.map(function (u) {
							return si.quickSetter(u, e, n)
						}),
						s = r.length;
					return function (u) {
						for (var g = s; g--;) r[g](u)
					}
				}
				t = t[0] || {};
				var a = Hi[e],
					o = as(t),
					h = o.harness && (o.harness.aliases || {})[e] || e,
					c = a ? function (u) {
						var g = new a;
						ja._pt = 0, g.init(t, n ? u + n : u, ja, 0, [t]), g.render(1, g), ja._pt && Np(1, ja)
					} : o.set(t, h);
				return a ? c : function (u) {
					return c(t, h, n ? u + n : u, o, 1)
				}
			},
			quickTo: function (t, e, n) {
				var r, s = si.to(t, Qs((r = {}, r[e] = "+=0.1", r.paused = !0, r), n || {})),
					a = function (h, c, u) {
						return s.resetTo(e, h, c, u)
					};
				return a.tween = s, a
			},
			isTweening: function (t) {
				return Ue.getTweensOf(t, !0).length > 0
			},
			defaults: function (t) {
				return t && t.ease && (t.ease = Zs(t.ease, Xa.ease)), dg(Xa, t || {})
			},
			config: function (t) {
				return dg(qi, t || {})
			},
			registerEffect: function (t) {
				var e = t.name,
					n = t.effect,
					r = t.plugins,
					s = t.defaults,
					a = t.extendTimeline;
				(r || "").split(",").forEach(function (o) {
					return o && !Hi[o] && !an[o] && lc(e + " effect requires " + o + " plugin.")
				}), rp[e] = function (o, h, c) {
					return n(xn(o), Sn(h || {}, s), c)
				}, a && (bi.prototype[e] = function (o, h, c) {
					return this.add(rp[e](o, Zn(h) ? h : (c = h) && {}, this), c)
				})
			},
			registerEase: function (t, e) {
				ve[t] = Zs(e)
			},
			parseEase: function (t, e) {
				return arguments.length ? Zs(t, e) : ve
			},
			getById: function (t) {
				return Ue.getById(t)
			},
			exportRoot: function (t, e) {
				t === void 0 && (t = {});
				var n = new bi(t),
					r, s;
				for (n.smoothChildTiming = $i(t.smoothChildTiming), Ue.remove(n), n._dp = 0, n._time = n._tTime = Ue._time, r = Ue._first; r;) s = r._next, (e || !(!r._dur && r instanceof Je && r.vars.onComplete === r._targets[0])) && Kn(n, r, r._start - r._delay), r = s;
				return Kn(Ue, n, 0), n
			},
			context: function (t, e) {
				return t ? new Zg(t, e) : je
			},
			matchMedia: function (t) {
				return new DS(t)
			},
			matchMediaRefresh: function () {
				return Js.forEach(function (t) {
					var e = t.conditions,
						n, r;
					for (r in e) e[r] && (e[r] = !1, n = 1);
					n && t.revert()
				}) || bp()
			},
			addEventListener: function (t, e) {
				var n = ac[t] || (ac[t] = []);
				~n.indexOf(e) || n.push(e)
			},
			removeEventListener: function (t, e) {
				var n = ac[t],
					r = n && n.indexOf(e);
				r >= 0 && n.splice(r, 1)
			},
			utils: {
				wrap: lS,
				wrapYoyo: hS,
				distribute: Fg,
				random: Ng,
				snap: Og,
				normalize: oS,
				getUnit: _i,
				clamp: nS,
				splitColor: Gg,
				toArray: xn,
				selector: gp,
				mapRange: zg,
				pipe: sS,
				unitize: aS,
				interpolate: cS,
				shuffle: Rg
			},
			install: Sg,
			effects: rp,
			ticker: Wi,
			updateRoot: bi.updateRoot,
			plugins: Hi,
			globalTimeline: Ue,
			core: {
				PropTween: Li,
				globals: Eg,
				Tween: Je,
				Timeline: bi,
				Animation: Tl,
				getCache: as,
				_removeLinkedListItem: mc,
				reverting: function () {
					return xi
				},
				context: function (t) {
					return t && je && (je.data.push(t), t._ctx = je), je
				},
				suppressOverwrites: function (t) {
					return xp = t
				}
			}
		};
	Ii("to,from,fromTo,delayedCall,set,killTweensOf", function (i) {
		return dc[i] = Je[i]
	});
	Wi.add(bi.updateRoot);
	ja = dc.to({}, {
		duration: 0
	});
	var IS = function (t, e) {
			for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
			return n
		},
		LS = function (t, e) {
			var n = t._targets,
				r, s, a;
			for (r in e)
				for (s = n.length; s--;) a = t._ptLookup[s][r], a && (a = a.d) && (a._pt && (a = IS(a, r)), a && a.modifier && a.modifier(e[r], t, n[s], r))
		},
		hp = function (t, e) {
			return {
				name: t,
				rawVars: 1,
				init: function (r, s, a) {
					a._onInit = function (o) {
						var h, c;
						if (ri(s) && (h = {}, Ii(s, function (u) {
								return h[u] = 1
							}), s = h), e) {
							h = {};
							for (c in s) h[c] = e(s[c]);
							s = h
						}
						LS(o, s)
					}
				}
			}
		},
		si = dc.registerPlugin({
			name: "attr",
			init: function (t, e, n, r, s) {
				var a, o, h;
				this.tween = n;
				for (a in e) h = t.getAttribute(a) || "", o = this.add(t, "setAttribute", (h || 0) + "", e[a], r, s, 0, 0, a), o.op = a, o.b = h, this._props.push(a)
			},
			render: function (t, e) {
				for (var n = e._pt; n;) xi ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next
			}
		}, {
			name: "endArray",
			init: function (t, e) {
				for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
			}
		}, hp("roundProps", _p), hp("modifiers"), hp("snap", Og)) || dc;
	Je.version = bi.version = si.version = "3.12.2";
	wg = 1;
	wp() && Za();
	var kS = ve.Power0,
		RS = ve.Power1,
		FS = ve.Power2,
		OS = ve.Power3,
		NS = ve.Power4,
		VS = ve.Linear,
		zS = ve.Quad,
		BS = ve.Cubic,
		US = ve.Quart,
		GS = ve.Quint,
		HS = ve.Strong,
		WS = ve.Elastic,
		$S = ve.Back,
		qS = ve.SteppedEase,
		jS = ve.Bounce,
		XS = ve.Sine,
		zp = ve.Expo,
		YS = ve.Circ;
	var Jg, hs, to, qp, aa, KS, Qg, jp, ZS = function () {
			return typeof window != "undefined"
		},
		Tr = {},
		sa = 180 / Math.PI,
		eo = Math.PI / 180,
		Qa = Math.atan2,
		t0 = 1e8,
		Xp = /([A-Z])/g,
		JS = /(left|right|width|margin|padding|x)/i,
		QS = /[\s,\(]\S/,
		Jn = {
			autoAlpha: "opacity,visibility",
			scale: "scaleX,scaleY",
			alpha: "opacity"
		},
		Gp = function (t, e) {
			return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
		},
		tE = function (t, e) {
			return e.set(e.t, e.p, t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
		},
		eE = function (t, e) {
			return e.set(e.t, e.p, t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b, e)
		},
		iE = function (t, e) {
			var n = e.s + e.c * t;
			e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
		},
		o0 = function (t, e) {
			return e.set(e.t, e.p, t ? e.e : e.b, e)
		},
		l0 = function (t, e) {
			return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
		},
		nE = function (t, e, n) {
			return t.style[e] = n
		},
		rE = function (t, e, n) {
			return t.style.setProperty(e, n)
		},
		sE = function (t, e, n) {
			return t._gsap[e] = n
		},
		aE = function (t, e, n) {
			return t._gsap.scaleX = t._gsap.scaleY = n
		},
		oE = function (t, e, n, r, s) {
			var a = t._gsap;
			a.scaleX = a.scaleY = n, a.renderTransform(s, a)
		},
		lE = function (t, e, n, r, s) {
			var a = t._gsap;
			a[e] = n, a.renderTransform(s, a)
		},
		Ge = "transform",
		In = Ge + "Origin",
		hE = function i(t, e) {
			var n = this,
				r = this.target,
				s = r.style;
			if (t in Tr && s) {
				if (this.tfm = this.tfm || {}, t !== "transform") t = Jn[t] || t, ~t.indexOf(",") ? t.split(",").forEach(function (a) {
					return n.tfm[a] = Cr(r, a)
				}) : this.tfm[t] = r._gsap.x ? r._gsap[t] : Cr(r, t);
				else return Jn.transform.split(",").forEach(function (a) {
					return i.call(n, a, e)
				});
				if (this.props.indexOf(Ge) >= 0) return;
				r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(In, e, "")), t = Ge
			}(s || e) && this.props.push(t, e, s[t])
		},
		h0 = function (t) {
			t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
		},
		cE = function () {
			var t = this.props,
				e = this.target,
				n = e.style,
				r = e._gsap,
				s, a;
			for (s = 0; s < t.length; s += 3) t[s + 1] ? e[t[s]] = t[s + 2] : t[s + 2] ? n[t[s]] = t[s + 2] : n.removeProperty(t[s].substr(0, 2) === "--" ? t[s] : t[s].replace(Xp, "-$1").toLowerCase());
			if (this.tfm) {
				for (a in this.tfm) r[a] = this.tfm[a];
				r.svg && (r.renderTransform(), e.setAttribute("data-svg-origin", this.svgo || "")), s = jp(), (!s || !s.isStart) && !n[Ge] && (h0(n), r.uncache = 1)
			}
		},
		c0 = function (t, e) {
			var n = {
				target: t,
				props: [],
				revert: cE,
				save: hE
			};
			return t._gsap || si.core.getCache(t), e && e.split(",").forEach(function (r) {
				return n.save(r)
			}), n
		},
		u0, Hp = function (t, e) {
			var n = hs.createElementNS ? hs.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : hs.createElement(t);
			return n.style ? n : hs.createElement(t)
		},
		Qn = function i(t, e, n) {
			var r = getComputedStyle(t);
			return r[e] || r.getPropertyValue(e.replace(Xp, "-$1").toLowerCase()) || r.getPropertyValue(e) || !n && i(t, io(e) || e, 1) || ""
		},
		e0 = "O,Moz,ms,Ms,Webkit".split(","),
		io = function (t, e, n) {
			var r = e || aa,
				s = r.style,
				a = 5;
			if (t in s && !n) return t;
			for (t = t.charAt(0).toUpperCase() + t.substr(1); a-- && !(e0[a] + t in s););
			return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? e0[a] : "") + t
		},
		Wp = function () {
			ZS() && window.document && (Jg = window, hs = Jg.document, to = hs.documentElement, aa = Hp("div") || {
				style: {}
			}, KS = Hp("div"), Ge = io(Ge), In = Ge + "Origin", aa.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", u0 = !!io("perspective"), jp = si.core.reverting, qp = 1)
		},
		Bp = function i(t) {
			var e = Hp("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
				n = this.parentNode,
				r = this.nextSibling,
				s = this.style.cssText,
				a;
			if (to.appendChild(e), e.appendChild(this), this.style.display = "block", t) try {
				a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = i
			} catch (o) {} else this._gsapBBox && (a = this._gsapBBox());
			return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), to.removeChild(e), this.style.cssText = s, a
		},
		i0 = function (t, e) {
			for (var n = e.length; n--;)
				if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
		},
		d0 = function (t) {
			var e;
			try {
				e = t.getBBox()
			} catch (n) {
				e = Bp.call(t, !0)
			}
			return e && (e.width || e.height) || t.getBBox === Bp || (e = Bp.call(t, !0)), e && !e.width && !e.x && !e.y ? {
				x: +i0(t, ["x", "cx", "x1"]) || 0,
				y: +i0(t, ["y", "cy", "y1"]) || 0,
				width: 0,
				height: 0
			} : e
		},
		p0 = function (t) {
			return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && d0(t))
		},
		Dl = function (t, e) {
			if (e) {
				var n = t.style;
				e in Tr && e !== In && (e = Ge), n.removeProperty ? ((e.substr(0, 2) === "ms" || e.substr(0, 6) === "webkit") && (e = "-" + e), n.removeProperty(e.replace(Xp, "-$1").toLowerCase())) : n.removeAttribute(e)
			}
		},
		cs = function (t, e, n, r, s, a) {
			var o = new Li(t._pt, e, n, 0, 1, a ? l0 : o0);
			return t._pt = o, o.b = r, o.e = s, t._props.push(n), o
		},
		n0 = {
			deg: 1,
			rad: 1,
			turn: 1
		},
		uE = {
			grid: 1,
			flex: 1
		},
		us = function i(t, e, n, r) {
			var s = parseFloat(n) || 0,
				a = (n + "").trim().substr((s + "").length) || "px",
				o = aa.style,
				h = JS.test(e),
				c = t.tagName.toLowerCase() === "svg",
				u = (c ? "client" : "offset") + (h ? "Width" : "Height"),
				g = 100,
				p = r === "px",
				_ = r === "%",
				b, y, w, f;
			return r === a || !s || n0[r] || n0[a] ? s : (a !== "px" && !p && (s = i(t, e, n, "px")), f = t.getCTM && p0(t), (_ || a === "%") && (Tr[e] || ~e.indexOf("adius")) ? (b = f ? t.getBBox()[h ? "width" : "height"] : t[u], Ye(_ ? s / b * g : s / 100 * b)) : (o[h ? "width" : "height"] = g + (p ? a : r), y = ~e.indexOf("adius") || r === "em" && t.appendChild && !c ? t : t.parentNode, f && (y = (t.ownerSVGElement || {}).parentNode), (!y || y === hs || !y.appendChild) && (y = hs.body), w = y._gsap, w && _ && w.width && h && w.time === Wi.time && !w.uncache ? Ye(s / w.width * g) : ((_ || a === "%") && !uE[Qn(y, "display")] && (o.position = Qn(t, "position")), y === t && (o.position = "static"), y.appendChild(aa), b = aa[u], y.removeChild(aa), o.position = "absolute", h && _ && (w = as(y), w.time = Wi.time, w.width = y[u]), Ye(p ? b * s / g : b && s ? g / b * s : 0))))
		},
		Cr = function (t, e, n, r) {
			var s;
			return qp || Wp(), e in Jn && e !== "transform" && (e = Jn[e], ~e.indexOf(",") && (e = e.split(",")[0])), Tr[e] && e !== "transform" ? (s = Ll(t, r), s = e !== "transformOrigin" ? s[e] : s.svg ? s.origin : bc(Qn(t, In)) + " " + s.zOrigin + "px") : (s = t.style[e], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = yc[e] && yc[e](t, e, n) || Qn(t, e) || Ap(t, e) || (e === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? us(t, e, s, n) + n : s
		},
		dE = function (t, e, n, r) {
			if (!n || n === "none") {
				var s = io(e, t, 1),
					a = s && Qn(t, s, 1);
				a && a !== n ? (e = s, n = a) : e === "borderColor" && (n = Qn(t, "borderTopColor"))
			}
			var o = new Li(this._pt, t.style, e, 0, 1, Op),
				h = 0,
				c = 0,
				u, g, p, _, b, y, w, f, S, x, M, T;
			if (o.b = n, o.e = r, n += "", r += "", r === "auto" && (t.style[e] = r, r = Qn(t, e) || r, t.style[e] = n), u = [n, r], Dp(u), n = u[0], r = u[1], p = n.match(ta) || [], T = r.match(ta) || [], T.length) {
				for (; g = ta.exec(r);) w = g[0], S = r.substring(h, g.index), b ? b = (b + 1) % 5 : (S.substr(-5) === "rgba(" || S.substr(-5) === "hsla(") && (b = 1), w !== (y = p[c++] || "") && (_ = parseFloat(y) || 0, M = y.substr((_ + "").length), w.charAt(1) === "=" && (w = ea(_, w) + M), f = parseFloat(w), x = w.substr((f + "").length), h = ta.lastIndex - x.length, x || (x = x || qi.units[e] || M, h === r.length && (r += x, o.e += x)), M !== x && (_ = us(t, e, y, x) || 0), o._pt = {
					_next: o._pt,
					p: S || c === 1 ? S : ",",
					s: _,
					c: f - _,
					m: b && b < 4 || e === "zIndex" ? Math.round : 0
				});
				o.c = h < r.length ? r.substring(h, r.length) : ""
			} else o.r = e === "display" && r === "none" ? l0 : o0;
			return Ep.test(r) && (o.e = 0), this._pt = o, o
		},
		r0 = {
			top: "0%",
			bottom: "100%",
			left: "0%",
			right: "100%",
			center: "50%"
		},
		pE = function (t) {
			var e = t.split(" "),
				n = e[0],
				r = e[1] || "50%";
			return (n === "top" || n === "bottom" || r === "left" || r === "right") && (t = n, n = r, r = t), e[0] = r0[n] || n, e[1] = r0[r] || r, e.join(" ")
		},
		fE = function (t, e) {
			if (e.tween && e.tween._time === e.tween._dur) {
				var n = e.t,
					r = n.style,
					s = e.u,
					a = n._gsap,
					o, h, c;
				if (s === "all" || s === !0) r.cssText = "", h = 1;
				else
					for (s = s.split(","), c = s.length; --c > -1;) o = s[c], Tr[o] && (h = 1, o = o === "transformOrigin" ? In : Ge), Dl(n, o);
				h && (Dl(n, Ge), a && (a.svg && n.removeAttribute("transform"), Ll(n, 1), a.uncache = 1, h0(r)))
			}
		},
		yc = {
			clearProps: function (t, e, n, r, s) {
				if (s.data !== "isFromStart") {
					var a = t._pt = new Li(t._pt, e, n, 0, 0, fE);
					return a.u = r, a.pr = -10, a.tween = s, t._props.push(n), 1
				}
			}
		},
		Il = [1, 0, 0, 1, 0, 0],
		f0 = {},
		m0 = function (t) {
			return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
		},
		s0 = function (t) {
			var e = Qn(t, Ge);
			return m0(e) ? Il : e.substr(7).match(Sp).map(Ye)
		},
		Yp = function (t, e) {
			var n = t._gsap || as(t),
				r = t.style,
				s = s0(t),
				a, o, h, c;
			return n.svg && t.getAttribute("transform") ? (h = t.transform.baseVal.consolidate().matrix, s = [h.a, h.b, h.c, h.d, h.e, h.f], s.join(",") === "1,0,0,1,0,0" ? Il : s) : (s === Il && !t.offsetParent && t !== to && !n.svg && (h = r.display, r.display = "block", a = t.parentNode, (!a || !t.offsetParent) && (c = 1, o = t.nextElementSibling, to.appendChild(t)), s = s0(t), h ? r.display = h : Dl(t, "display"), c && (o ? a.insertBefore(t, o) : a ? a.appendChild(t) : to.removeChild(t))), e && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
		},
		$p = function (t, e, n, r, s, a) {
			var o = t._gsap,
				h = s || Yp(t, !0),
				c = o.xOrigin || 0,
				u = o.yOrigin || 0,
				g = o.xOffset || 0,
				p = o.yOffset || 0,
				_ = h[0],
				b = h[1],
				y = h[2],
				w = h[3],
				f = h[4],
				S = h[5],
				x = e.split(" "),
				M = parseFloat(x[0]) || 0,
				T = parseFloat(x[1]) || 0,
				I, L, F, k;
			n ? h !== Il && (L = _ * w - b * y) && (F = M * (w / L) + T * (-y / L) + (y * S - w * f) / L, k = M * (-b / L) + T * (_ / L) - (_ * S - b * f) / L, M = F, T = k) : (I = d0(t), M = I.x + (~x[0].indexOf("%") ? M / 100 * I.width : M), T = I.y + (~(x[1] || x[0]).indexOf("%") ? T / 100 * I.height : T)), r || r !== !1 && o.smooth ? (f = M - c, S = T - u, o.xOffset = g + (f * _ + S * y) - f, o.yOffset = p + (f * b + S * w) - S) : o.xOffset = o.yOffset = 0, o.xOrigin = M, o.yOrigin = T, o.smooth = !!r, o.origin = e, o.originIsAbsolute = !!n, t.style[In] = "0px 0px", a && (cs(a, o, "xOrigin", c, M), cs(a, o, "yOrigin", u, T), cs(a, o, "xOffset", g, o.xOffset), cs(a, o, "yOffset", p, o.yOffset)), t.setAttribute("data-svg-origin", M + " " + T)
		},
		Ll = function (t, e) {
			var n = t._gsap || new Ip(t);
			if ("x" in n && !e && !n.uncache) return n;
			var r = t.style,
				s = n.scaleX < 0,
				a = "px",
				o = "deg",
				h = getComputedStyle(t),
				c = Qn(t, In) || "0",
				u, g, p, _, b, y, w, f, S, x, M, T, I, L, F, k, G, j, U, z, $, W, O, B, A, D, H, q, Q, tt, nt, ut;
			return u = g = p = y = w = f = S = x = M = 0, _ = b = 1, n.svg = !!(t.getCTM && p0(t)), h.translate && ((h.translate !== "none" || h.scale !== "none" || h.rotate !== "none") && (r[Ge] = (h.translate !== "none" ? "translate3d(" + (h.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (h.rotate !== "none" ? "rotate(" + h.rotate + ") " : "") + (h.scale !== "none" ? "scale(" + h.scale.split(" ").join(",") + ") " : "") + (h[Ge] !== "none" ? h[Ge] : "")), r.scale = r.rotate = r.translate = "none"), L = Yp(t, n.svg), n.svg && (n.uncache ? (A = t.getBBox(), c = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px", B = "") : B = !e && t.getAttribute("data-svg-origin"), $p(t, B || c, !!B || n.originIsAbsolute, n.smooth !== !1, L)), T = n.xOrigin || 0, I = n.yOrigin || 0, L !== Il && (j = L[0], U = L[1], z = L[2], $ = L[3], u = W = L[4], g = O = L[5], L.length === 6 ? (_ = Math.sqrt(j * j + U * U), b = Math.sqrt($ * $ + z * z), y = j || U ? Qa(U, j) * sa : 0, S = z || $ ? Qa(z, $) * sa + y : 0, S && (b *= Math.abs(Math.cos(S * eo))), n.svg && (u -= T - (T * j + I * z), g -= I - (T * U + I * $))) : (ut = L[6], tt = L[7], H = L[8], q = L[9], Q = L[10], nt = L[11], u = L[12], g = L[13], p = L[14], F = Qa(ut, Q), w = F * sa, F && (k = Math.cos(-F), G = Math.sin(-F), B = W * k + H * G, A = O * k + q * G, D = ut * k + Q * G, H = W * -G + H * k, q = O * -G + q * k, Q = ut * -G + Q * k, nt = tt * -G + nt * k, W = B, O = A, ut = D), F = Qa(-z, Q), f = F * sa, F && (k = Math.cos(-F), G = Math.sin(-F), B = j * k - H * G, A = U * k - q * G, D = z * k - Q * G, nt = $ * G + nt * k, j = B, U = A, z = D), F = Qa(U, j), y = F * sa, F && (k = Math.cos(F), G = Math.sin(F), B = j * k + U * G, A = W * k + O * G, U = U * k - j * G, O = O * k - W * G, j = B, W = A), w && Math.abs(w) + Math.abs(y) > 359.9 && (w = y = 0, f = 180 - f), _ = Ye(Math.sqrt(j * j + U * U + z * z)), b = Ye(Math.sqrt(O * O + ut * ut)), F = Qa(W, O), S = Math.abs(F) > 2e-4 ? F * sa : 0, M = nt ? 1 / (nt < 0 ? -nt : nt) : 0), n.svg && (B = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !m0(Qn(t, Ge)), B && t.setAttribute("transform", B))), Math.abs(S) > 90 && Math.abs(S) < 270 && (s ? (_ *= -1, S += y <= 0 ? 180 : -180, y += y <= 0 ? 180 : -180) : (b *= -1, S += S <= 0 ? 180 : -180)), e = e || n.uncache, n.x = u - ((n.xPercent = u && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + a, n.y = g - ((n.yPercent = g && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-g) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + a, n.z = p + a, n.scaleX = Ye(_), n.scaleY = Ye(b), n.rotation = Ye(y) + o, n.rotationX = Ye(w) + o, n.rotationY = Ye(f) + o, n.skewX = S + o, n.skewY = x + o, n.transformPerspective = M + a, (n.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (r[In] = bc(c)), n.xOffset = n.yOffset = 0, n.force3D = qi.force3D, n.renderTransform = n.svg ? vE : u0 ? v0 : mE, n.uncache = 0, n
		},
		bc = function (t) {
			return (t = t.split(" "))[0] + " " + t[1]
		},
		Up = function (t, e, n) {
			var r = _i(e);
			return Ye(parseFloat(e) + parseFloat(us(t, "x", n + "px", r))) + r
		},
		mE = function (t, e) {
			e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, v0(t, e)
		},
		na = "0deg",
		Al = "0px",
		ra = ") ",
		v0 = function (t, e) {
			var n = e || this,
				r = n.xPercent,
				s = n.yPercent,
				a = n.x,
				o = n.y,
				h = n.z,
				c = n.rotation,
				u = n.rotationY,
				g = n.rotationX,
				p = n.skewX,
				_ = n.skewY,
				b = n.scaleX,
				y = n.scaleY,
				w = n.transformPerspective,
				f = n.force3D,
				S = n.target,
				x = n.zOrigin,
				M = "",
				T = f === "auto" && t && t !== 1 || f === !0;
			if (x && (g !== na || u !== na)) {
				var I = parseFloat(u) * eo,
					L = Math.sin(I),
					F = Math.cos(I),
					k;
				I = parseFloat(g) * eo, k = Math.cos(I), a = Up(S, a, L * k * -x), o = Up(S, o, -Math.sin(I) * -x), h = Up(S, h, F * k * -x + x)
			}
			w !== Al && (M += "perspective(" + w + ra), (r || s) && (M += "translate(" + r + "%, " + s + "%) "), (T || a !== Al || o !== Al || h !== Al) && (M += h !== Al || T ? "translate3d(" + a + ", " + o + ", " + h + ") " : "translate(" + a + ", " + o + ra), c !== na && (M += "rotate(" + c + ra), u !== na && (M += "rotateY(" + u + ra), g !== na && (M += "rotateX(" + g + ra), (p !== na || _ !== na) && (M += "skew(" + p + ", " + _ + ra), (b !== 1 || y !== 1) && (M += "scale(" + b + ", " + y + ra), S.style[Ge] = M || "translate(0, 0)"
		},
		vE = function (t, e) {
			var n = e || this,
				r = n.xPercent,
				s = n.yPercent,
				a = n.x,
				o = n.y,
				h = n.rotation,
				c = n.skewX,
				u = n.skewY,
				g = n.scaleX,
				p = n.scaleY,
				_ = n.target,
				b = n.xOrigin,
				y = n.yOrigin,
				w = n.xOffset,
				f = n.yOffset,
				S = n.forceCSS,
				x = parseFloat(a),
				M = parseFloat(o),
				T, I, L, F, k;
			h = parseFloat(h), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, h += u), h || c ? (h *= eo, c *= eo, T = Math.cos(h) * g, I = Math.sin(h) * g, L = Math.sin(h - c) * -p, F = Math.cos(h - c) * p, c && (u *= eo, k = Math.tan(c - u), k = Math.sqrt(1 + k * k), L *= k, F *= k, u && (k = Math.tan(u), k = Math.sqrt(1 + k * k), T *= k, I *= k)), T = Ye(T), I = Ye(I), L = Ye(L), F = Ye(F)) : (T = g, F = p, I = L = 0), (x && !~(a + "").indexOf("px") || M && !~(o + "").indexOf("px")) && (x = us(_, "x", a, "px"), M = us(_, "y", o, "px")), (b || y || w || f) && (x = Ye(x + b - (b * T + y * L) + w), M = Ye(M + y - (b * I + y * F) + f)), (r || s) && (k = _.getBBox(), x = Ye(x + r / 100 * k.width), M = Ye(M + s / 100 * k.height)), k = "matrix(" + T + "," + I + "," + L + "," + F + "," + x + "," + M + ")", _.setAttribute("transform", k), S && (_.style[Ge] = k)
		},
		gE = function (t, e, n, r, s) {
			var a = 360,
				o = ri(s),
				h = parseFloat(s) * (o && ~s.indexOf("rad") ? sa : 1),
				c = h - r,
				u = r + c + "deg",
				g, p;
			return o && (g = s.split("_")[1], g === "short" && (c %= a, c !== c % (a / 2) && (c += c < 0 ? a : -a)), g === "cw" && c < 0 ? c = (c + a * t0) % a - ~~(c / a) * a : g === "ccw" && c > 0 && (c = (c - a * t0) % a - ~~(c / a) * a)), t._pt = p = new Li(t._pt, e, n, r, c, tE), p.e = u, p.u = "deg", t._props.push(n), p
		},
		a0 = function (t, e) {
			for (var n in e) t[n] = e[n];
			return t
		},
		_E = function (t, e, n) {
			var r = a0({}, n._gsap),
				s = "perspective,force3D,transformOrigin,svgOrigin",
				a = n.style,
				o, h, c, u, g, p, _, b;
			r.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), a[Ge] = e, o = Ll(n, 1), Dl(n, Ge), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[Ge], a[Ge] = e, o = Ll(n, 1), a[Ge] = c);
			for (h in Tr) c = r[h], u = o[h], c !== u && s.indexOf(h) < 0 && (_ = _i(c), b = _i(u), g = _ !== b ? us(n, h, c, b) : parseFloat(c), p = parseFloat(u), t._pt = new Li(t._pt, o, h, g, p - g, Gp), t._pt.u = b || 0, t._props.push(h));
			a0(o, r)
		};
	Ii("padding,margin,Width,Radius", function (i, t) {
		var e = "Top",
			n = "Right",
			r = "Bottom",
			s = "Left",
			a = (t < 3 ? [e, n, r, s] : [e + s, e + n, r + n, r + s]).map(function (o) {
				return t < 2 ? i + o : "border" + o + i
			});
		yc[t > 1 ? "border" + i : i] = function (o, h, c, u, g) {
			var p, _;
			if (arguments.length < 4) return p = a.map(function (b) {
				return Cr(o, b, c)
			}), _ = p.join(" "), _.split(p[0]).length === 5 ? p[0] : _;
			p = (u + "").split(" "), _ = {}, a.forEach(function (b, y) {
				return _[b] = p[y] = p[y] || p[(y - 1) / 2 | 0]
			}), o.init(h, _, g)
		}
	});
	var kl = {
		name: "css",
		register: Wp,
		targetTest: function (t) {
			return t.style && t.nodeType
		},
		init: function (t, e, n, r, s) {
			var a = this._props,
				o = t.style,
				h = n.vars.startAt,
				c, u, g, p, _, b, y, w, f, S, x, M, T, I, L, F;
			qp || Wp(), this.styles = this.styles || c0(t), F = this.styles.props, this.tween = n;
			for (y in e)
				if (y !== "autoRound" && (u = e[y], !(Hi[y] && kp(y, e, n, r, t, s)))) {
					if (_ = typeof u, b = yc[y], _ === "function" && (u = u.call(n, r, t, s), _ = typeof u), _ === "string" && ~u.indexOf("random(") && (u = Ja(u)), b) b(this, t, y, u, n) && (L = 1);
					else if (y.substr(0, 2) === "--") c = (getComputedStyle(t).getPropertyValue(y) + "").trim(), u += "", Er.lastIndex = 0, Er.test(c) || (w = _i(c), f = _i(u)), f ? w !== f && (c = us(t, y, c, f) + f) : w && (u += w), this.add(o, "setProperty", c, u, r, s, 0, 0, y), a.push(y), F.push(y, 0, o[y]);
					else if (_ !== "undefined") {
						if (h && y in h ? (c = typeof h[y] == "function" ? h[y].call(n, r, t, s) : h[y], ri(c) && ~c.indexOf("random(") && (c = Ja(c)), _i(c + "") || (c += qi.units[y] || _i(Cr(t, y)) || ""), (c + "").charAt(1) === "=" && (c = Cr(t, y))) : c = Cr(t, y), p = parseFloat(c), S = _ === "string" && u.charAt(1) === "=" && u.substr(0, 2), S && (u = u.substr(2)), g = parseFloat(u), y in Jn && (y === "autoAlpha" && (p === 1 && Cr(t, "visibility") === "hidden" && g && (p = 0), F.push("visibility", 0, o.visibility), cs(this, o, "visibility", p ? "inherit" : "hidden", g ? "inherit" : "hidden", !g)), y !== "scale" && y !== "transform" && (y = Jn[y], ~y.indexOf(",") && (y = y.split(",")[0]))), x = y in Tr, x) {
							if (this.styles.save(y), M || (T = t._gsap, T.renderTransform && !e.parseTransform || Ll(t, e.parseTransform), I = e.smoothOrigin !== !1 && T.smooth, M = this._pt = new Li(this._pt, o, Ge, 0, 1, T.renderTransform, T, 0, -1), M.dep = 1), y === "scale") this._pt = new Li(this._pt, T, "scaleY", T.scaleY, (S ? ea(T.scaleY, S + g) : g) - T.scaleY || 0, Gp), this._pt.u = 0, a.push("scaleY", y), y += "X";
							else if (y === "transformOrigin") {
								F.push(In, 0, o[In]), u = pE(u), T.svg ? $p(t, u, 0, I, 0, this) : (f = parseFloat(u.split(" ")[2]) || 0, f !== T.zOrigin && cs(this, T, "zOrigin", T.zOrigin, f), cs(this, o, y, bc(c), bc(u)));
								continue
							} else if (y === "svgOrigin") {
								$p(t, u, 1, I, 0, this);
								continue
							} else if (y in f0) {
								gE(this, T, y, p, S ? ea(p, S + u) : u);
								continue
							} else if (y === "smoothOrigin") {
								cs(this, T, "smooth", T.smooth, u);
								continue
							} else if (y === "force3D") {
								T[y] = u;
								continue
							} else if (y === "transform") {
								_E(this, u, t);
								continue
							}
						} else y in o || (y = io(y) || y);
						if (x || (g || g === 0) && (p || p === 0) && !QS.test(u) && y in o) w = (c + "").substr((p + "").length), g || (g = 0), f = _i(u) || (y in qi.units ? qi.units[y] : w), w !== f && (p = us(t, y, c, f)), this._pt = new Li(this._pt, x ? T : o, y, p, (S ? ea(p, S + g) : g) - p, !x && (f === "px" || y === "zIndex") && e.autoRound !== !1 ? iE : Gp), this._pt.u = f || 0, w !== f && f !== "%" && (this._pt.b = c, this._pt.r = eE);
						else if (y in o) dE.call(this, t, y, c, S ? S + u : u);
						else if (y in t) this.add(t, y, c || t[y], S ? S + u : u, r, s);
						else if (y !== "parseTransform") {
							fc(y, u);
							continue
						}
						x || (y in o ? F.push(y, 0, o[y]) : F.push(y, 1, c || t[y])), a.push(y)
					}
				} L && Vp(this)
		},
		render: function (t, e) {
			if (e.tween._time || !jp())
				for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
			else e.styles.revert()
		},
		get: Cr,
		aliases: Jn,
		getSetter: function (t, e, n) {
			var r = Jn[e];
			return r && r.indexOf(",") < 0 && (e = r), e in Tr && e !== In && (t._gsap.x || Cr(t, "x")) ? n && Qg === n ? e === "scale" ? aE : sE : (Qg = n || {}) && (e === "scale" ? oE : lE) : t.style && !pc(t.style[e]) ? nE : ~e.indexOf("-") ? rE : _c(t, e)
		},
		core: {
			_removeProperty: Dl,
			_getMatrix: Yp
		}
	};
	si.utils.checkPrefix = io;
	si.core.getStyleSaver = c0;
	(function (i, t, e, n) {
		var r = Ii(i + "," + t + "," + e, function (s) {
			Tr[s] = 1
		});
		Ii(t, function (s) {
			qi.units[s] = "deg", f0[s] = 1
		}), Jn[r[13]] = i + "," + t, Ii(n, function (s) {
			var a = s.split(":");
			Jn[a[1]] = r[a[0]]
		})
	})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
	Ii("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (i) {
		qi.units[i] = "px"
	});
	si.registerPlugin(kl);
	var g0 = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

	function Kp(i) {
		var t = i.nodeType,
			e = "";
		if (t === 1 || t === 9 || t === 11) {
			if (typeof i.textContent == "string") return i.textContent;
			for (i = i.firstChild; i; i = i.nextSibling) e += Kp(i)
		} else if (t === 3 || t === 4) return i.nodeValue;
		return e
	}
	var no, Jp, b0, Rl, x0, xc, yE = /(?:\r|\n|\t\t)/g,
		bE = /(?:\s\s+)/g,
		w0 = function (t) {
			no = document, Jp = window, Rl = Rl || t || Jp.gsap || console.warn("Please gsap.registerPlugin(SplitText)"), Rl && (xc = Rl.utils.toArray, x0 = Rl.core.context || function () {}, b0 = 1)
		},
		xE = 1,
		S0 = function (t) {
			return Jp.getComputedStyle(t)
		},
		Qp = function (t) {
			return t.position === "absolute" || t.absolute === !0
		},
		wE = function (t, e) {
			for (var n = e.length, r; --n > -1;)
				if (r = e[n], t.substr(0, r.length) === r) return r.length
		},
		SE = " style='position:relative;display:inline-block;'",
		_0 = function (t, e) {
			t === void 0 && (t = "");
			var n = ~t.indexOf("++"),
				r = 1;
			return n && (t = t.split("++").join("")),
				function () {
					return "<" + e + SE + (t ? " class='" + t + (n ? r++ : "") + "'>" : ">")
				}
		},
		E0 = function i(t, e, n) {
			var r = t.nodeType;
			if (r === 1 || r === 9 || r === 11)
				for (t = t.firstChild; t; t = t.nextSibling) i(t, e, n);
			else(r === 3 || r === 4) && (t.nodeValue = t.nodeValue.split(e).join(n))
		},
		Zp = function (t, e) {
			for (var n = e.length; --n > -1;) t.push(e[n])
		},
		y0 = function (t, e, n) {
			for (var r; t && t !== e;) {
				if (r = t._next || t.nextSibling, r) return r.textContent.charAt(0) === n;
				t = t.parentNode || t._parent
			}
		},
		EE = function i(t) {
			var e = xc(t.childNodes),
				n = e.length,
				r, s;
			for (r = 0; r < n; r++) s = e[r], s._isSplit ? i(s) : r && s.previousSibling && s.previousSibling.nodeType === 3 ? (s.previousSibling.nodeValue += s.nodeType === 3 ? s.nodeValue : s.firstChild.nodeValue, t.removeChild(s)) : s.nodeType !== 3 && (t.insertBefore(s.firstChild, s), t.removeChild(s))
		},
		tr = function (t, e) {
			return parseFloat(e[t]) || 0
		},
		ME = function (t, e, n, r, s, a, o) {
			var h = S0(t),
				c = tr("paddingLeft", h),
				u = -999,
				g = tr("borderBottomWidth", h) + tr("borderTopWidth", h),
				p = tr("borderLeftWidth", h) + tr("borderRightWidth", h),
				_ = tr("paddingTop", h) + tr("paddingBottom", h),
				b = tr("paddingLeft", h) + tr("paddingRight", h),
				y = tr("fontSize", h) * (e.lineThreshold || .2),
				w = h.textAlign,
				f = [],
				S = [],
				x = [],
				M = e.wordDelimiter || " ",
				T = e.tag ? e.tag : e.span ? "span" : "div",
				I = e.type || e.split || "chars,words,lines",
				L = s && ~I.indexOf("lines") ? [] : null,
				F = ~I.indexOf("words"),
				k = ~I.indexOf("chars"),
				G = Qp(e),
				j = e.linesClass,
				U = ~(j || "").indexOf("++"),
				z = [],
				$ = h.display === "flex",
				W = t.style.display,
				O, B, A, D, H, q, Q, tt, nt, ut, et, it;
			for (U && (j = j.split("++").join("")), $ && (t.style.display = "block"), B = t.getElementsByTagName("*"), A = B.length, H = [], O = 0; O < A; O++) H[O] = B[O];
			if (L || G)
				for (O = 0; O < A; O++) D = H[O], q = D.parentNode === t, (q || G || k && !F) && (it = D.offsetTop, L && q && Math.abs(it - u) > y && (D.nodeName !== "BR" || O === 0) && (Q = [], L.push(Q), u = it), G && (D._x = D.offsetLeft, D._y = it, D._w = D.offsetWidth, D._h = D.offsetHeight), L && ((D._isSplit && q || !k && q || F && q || !F && D.parentNode.parentNode === t && !D.parentNode._isSplit) && (Q.push(D), D._x -= c, y0(D, t, M) && (D._wordEnd = !0)), D.nodeName === "BR" && (D.nextSibling && D.nextSibling.nodeName === "BR" || O === 0) && L.push([])));
			for (O = 0; O < A; O++) {
				if (D = H[O], q = D.parentNode === t, D.nodeName === "BR") {
					L || G ? (D.parentNode && D.parentNode.removeChild(D), H.splice(O--, 1), A--) : F || t.appendChild(D);
					continue
				}
				if (G && (nt = D.style, !F && !q && (D._x += D.parentNode._x, D._y += D.parentNode._y), nt.left = D._x + "px", nt.top = D._y + "px", nt.position = "absolute", nt.display = "block", nt.width = D._w + 1 + "px", nt.height = D._h + "px"), !F && k)
					if (D._isSplit)
						for (D._next = B = D.nextSibling, D.parentNode.appendChild(D); B && B.nodeType === 3 && B.textContent === " ";) D._next = B.nextSibling, D.parentNode.appendChild(B), B = B.nextSibling;
					else D.parentNode._isSplit ? (D._parent = D.parentNode, !D.previousSibling && D.firstChild && (D.firstChild._isFirst = !0), D.nextSibling && D.nextSibling.textContent === " " && !D.nextSibling.nextSibling && z.push(D.nextSibling), D._next = D.nextSibling && D.nextSibling._isFirst ? null : D.nextSibling, D.parentNode.removeChild(D), H.splice(O--, 1), A--) : q || (it = !D.nextSibling && y0(D.parentNode, t, M), D.parentNode._parent && D.parentNode._parent.appendChild(D), it && D.parentNode.appendChild(no.createTextNode(" ")), T === "span" && (D.style.display = "inline"), f.push(D));
				else D.parentNode._isSplit && !D._isSplit && D.innerHTML !== "" ? S.push(D) : k && !D._isSplit && (T === "span" && (D.style.display = "inline"), f.push(D))
			}
			for (O = z.length; --O > -1;) z[O].parentNode.removeChild(z[O]);
			if (L) {
				for (G && (ut = no.createElement(T), t.appendChild(ut), et = ut.offsetWidth + "px", it = ut.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(ut)), nt = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
				for (tt = M === " " && (!G || !F && !k), O = 0; O < L.length; O++) {
					for (Q = L[O], ut = no.createElement(T), ut.style.cssText = "display:block;text-align:" + w + ";position:" + (G ? "absolute;" : "relative;"), j && (ut.className = j + (U ? O + 1 : "")), x.push(ut), A = Q.length, B = 0; B < A; B++) Q[B].nodeName !== "BR" && (D = Q[B], ut.appendChild(D), tt && D._wordEnd && ut.appendChild(no.createTextNode(" ")), G && (B === 0 && (ut.style.top = D._y + "px", ut.style.left = c + it + "px"), D.style.top = "0px", it && (D.style.left = D._x - it + "px")));
					A === 0 ? ut.innerHTML = "&nbsp;" : !F && !k && (EE(ut), E0(ut, String.fromCharCode(160), " ")), G && (ut.style.width = et, ut.style.height = D._h + "px"), t.appendChild(ut)
				}
				t.style.cssText = nt
			}
			G && (o > t.clientHeight && (t.style.height = o - _ + "px", t.clientHeight < o && (t.style.height = o + g + "px")), a > t.clientWidth && (t.style.width = a - b + "px", t.clientWidth < a && (t.style.width = a + p + "px"))), $ && (W ? t.style.display = W : t.style.removeProperty("display")), Zp(n, f), F && Zp(r, S), Zp(s, x)
		},
		CE = function (t, e, n, r) {
			var s = e.tag ? e.tag : e.span ? "span" : "div",
				a = e.type || e.split || "chars,words,lines",
				o = ~a.indexOf("chars"),
				h = Qp(e),
				c = e.wordDelimiter || " ",
				u = c !== " " ? "" : h ? "&#173; " : " ",
				g = "</" + s + ">",
				p = 1,
				_ = e.specialChars ? typeof e.specialChars == "function" ? e.specialChars : wE : null,
				b, y, w, f, S, x, M, T, I = no.createElement("div"),
				L = t.parentNode;
			for (L.insertBefore(I, t), I.textContent = t.nodeValue, L.removeChild(t), t = I, b = Kp(t), M = b.indexOf("<") !== -1, e.reduceWhiteSpace !== !1 && (b = b.replace(bE, " ").replace(yE, "")), M && (b = b.split("<").join("{{LT}}")), S = b.length, y = (b.charAt(0) === " " ? u : "") + n(), w = 0; w < S; w++)
				if (x = b.charAt(w), _ && (T = _(b.substr(w), e.specialChars))) x = b.substr(w, T || 1), y += o && x !== " " ? r() + x + "</" + s + ">" : x, w += T - 1;
				else if (x === c && b.charAt(w - 1) !== c && w) {
				for (y += p ? g : "", p = 0; b.charAt(w + 1) === c;) y += u, w++;
				w === S - 1 ? y += u : b.charAt(w + 1) !== ")" && (y += u + n(), p = 1)
			} else x === "{" && b.substr(w, 6) === "{{LT}}" ? (y += o ? r() + "{{LT}}</" + s + ">" : "{{LT}}", w += 5) : x.charCodeAt(0) >= 55296 && x.charCodeAt(0) <= 56319 || b.charCodeAt(w + 1) >= 65024 && b.charCodeAt(w + 1) <= 65039 ? (f = ((b.substr(w, 12).split(g0) || [])[1] || "").length || 2, y += o && x !== " " ? r() + b.substr(w, f) + "</" + s + ">" : b.substr(w, f), w += f - 1) : y += o && x !== " " ? r() + x + "</" + s + ">" : x;
			t.outerHTML = y + (p ? g : ""), M && E0(L, "{{LT}}", "<")
		},
		TE = function i(t, e, n, r) {
			var s = xc(t.childNodes),
				a = s.length,
				o = Qp(e),
				h, c;
			if (t.nodeType !== 3 || a > 1) {
				for (e.absolute = !1, h = 0; h < a; h++) c = s[h], c._next = c._isFirst = c._parent = c._wordEnd = null, (c.nodeType !== 3 || /\S+/.test(c.nodeValue)) && (o && c.nodeType !== 3 && S0(c).display === "inline" && (c.style.display = "inline-block", c.style.position = "relative"), c._isSplit = !0, i(c, e, n, r));
				e.absolute = o, t._isSplit = !0;
				return
			}
			CE(t, e, n, r)
		},
		ds = function () {
			function i(e, n) {
				b0 || w0(), this.elements = xc(e), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = n || {}, x0(this), xE && this.split(n)
			}
			var t = i.prototype;
			return t.split = function (n) {
				this.isSplit && this.revert(), this.vars = n = n || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
				for (var r = this.elements.length, s = n.tag ? n.tag : n.span ? "span" : "div", a = _0(n.wordsClass, s), o = _0(n.charsClass, s), h, c, u; --r > -1;) u = this.elements[r], this._originals[r] = u.innerHTML, h = u.clientHeight, c = u.clientWidth, TE(u, n, a, o), ME(u, n, this.chars, this.words, this.lines, c, h);
				return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
			}, t.revert = function () {
				var n = this._originals;
				if (!n) throw "revert() call wasn't scoped properly.";
				return this.elements.forEach(function (r, s) {
					return r.innerHTML = n[s]
				}), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
			}, i.create = function (n, r) {
				return new i(n, r)
			}, i
		}();
	ds.version = "3.12.2";
	ds.register = w0;
	var ne = si.registerPlugin(kl) || si,
		uL = ne.core.Tween;
	var PE = si.registerPlugin(kl) || si,
		zL = PE.core.Tween;
	ne.registerPlugin(ds);
	var Ln = class extends pe {
		static get settings() {
			return {
				CLASSNAME: "o-anim-text",
				VISIBLE_CLASS: "is-inview",
				SPLIT_TYPES: {
					block: {
						splitType: !1,
						class: "-block"
					},
					chars: {
						splitType: "lines, words, chars",
						class: "-chars"
					},
					lines: {
						splitType: "lines, words",
						class: "-lines"
					}
				}
			}
		}
		constructor(t) {
			super(t), this.$el = this.el, this.$inner = this.$("inner")[0];
			let e = this.getData("type") || "lines";
			this.splitTag = this.getData("inline") !== void 0 ? "span" : "div", ie.IS_MOBILE && e == "chars" && (e = "lines"), this.TYPE = Ln.settings.SPLIT_TYPES[e]
		}
		init() {
			ie.REDUCED_MOTION || (this.$el.classList.add(Ln.settings.CLASSNAME), this.isActive = !0, this.splitType = this.TYPE.splitType, this.$el.classList.add(this.TYPE.class), ns(Yn.EAGER).then(() => {
				this.initSplits(), window.addEventListener(Ce.RESIZE_END, this.onResize = () => this.resize())
			}))
		}
		initSplits() {
			if (!this.splitType) return;
			this.split = new ds(this.$inner, {
				tag: this.splitTag,
				type: this.splitType,
				linesClass: `${Ln.settings.CLASSNAME}_line`,
				wordsClass: `${Ln.settings.CLASSNAME}_word`,
				charsClass: `${Ln.settings.CLASSNAME}_char`
			});
			let t = this.split.lines.length;
			t > 0 && (this.$el.style.setProperty("--anim-text-line-count", t), this.split.lines.forEach((n, r) => n.style.setProperty("--anim-text-line-index", r)));
			let e = this.split.chars.length;
			e > 0 && (this.$el.style.setProperty("--anim-text-char-count", e), this.split.chars.forEach((n, r) => n.style.setProperty("--anim-text-char-index", r)))
		}
		revertSplits() {
			this.splitType && this.split.revert()
		}
		resize() {
			this.isActive && this.splitType && (this.revertSplits(), this.initSplits())
		}
		endReveal() {
			this.isActive = !1, setTimeout(() => {
				this.revertSplits(), window.removeEventListener(Ce.RESIZE_END, this.onResize)
			}, 2e3)
		}
		destroy() {
			this.isActive && window.removeEventListener(Ce.RESIZE_END, this.onResize)
		}
	};
	var wc = class extends pe {
		constructor(i) {
			super(i), this.$el = this.el, this.$text = this.$("text")[0]
		}
		init() {
			ie.REDUCED_MOTION || ns(Yn.EAGER).then(() => {
				this.initSplits(), window.addEventListener(Ce.RESIZE_END, this.onResize = () => this.resize())
			})
		}
		initSplits() {
			this.split = new ds(this.$text, {
				type: "words, chars"
			}), this.split.chars.forEach(i => {
				ne.set(i, {
					willChange: "opacity"
				})
			}), this.tl = ne.timeline({
				paused: !0
			}), this.tl.from(this.split.chars, {
				opacity: .3,
				stagger: .02
			})
		}
		revertSplits() {
			var i;
			(i = this.split) == null || i.revert(), this.tl.kill()
		}
		resize() {
			this.revertSplits(), this.initSplits()
		}
		onScrollProgress(i) {
			var t, e;
			(e = (t = this.tl) == null ? void 0 : t.progress) == null || e.call(t, i || 0)
		}
		destroy() {
			ie.REDUCED_MOTION || window.removeEventListener(Ce.RESIZE_END, this.onResize)
		}
	};
	var R0 = "opt-in",
		Fl = "opt-out",
		F0 = "show--consent",
		O0 = "show--preferences",
		M0 = "disable--interaction",
		Mc = "data-category",
		Se = "div",
		kn = "button",
		Rn = "aria-hidden",
		Ol = "btn-group",
		Si = "click",
		so = "data-role",
		cf = "consentModal",
		uf = "preferencesModal",
		af = class {
			constructor() {
				this.t = {
					mode: R0,
					revision: 0,
					autoShow: !0,
					lazyHtmlGeneration: !0,
					autoClearCookies: !0,
					manageScriptTags: !0,
					hideFromBots: !0,
					cookie: {
						name: "cc_cookie",
						expiresAfterDays: 182,
						domain: "",
						path: "/",
						sameSite: "Lax"
					}
				}, this.o = {
					i: {},
					l: "",
					_: {},
					u: {},
					p: {},
					m: [],
					v: !1,
					h: null,
					C: null,
					S: null,
					M: "",
					D: !0,
					T: !1,
					k: !1,
					A: !1,
					N: !1,
					H: [],
					V: !1,
					I: !0,
					L: [],
					j: !1,
					F: "",
					P: !1,
					O: [],
					R: [],
					B: [],
					G: [],
					J: !1,
					U: !1,
					$: !1,
					q: [],
					K: [],
					W: [],
					X: {},
					Y: {},
					Z: {},
					ee: {},
					te: {},
					ne: []
				}, this.oe = {
					se: {},
					ae: {}
				}, this.ce = {}, this.re = {
					ie: "cc:onFirstConsent",
					le: "cc:onConsent",
					de: "cc:onChange",
					fe: "cc:onModalShow",
					_e: "cc:onModalHide",
					ue: "cc:onModalReady"
				}
			}
		},
		bt = new af,
		N0 = (i, t) => i.indexOf(t),
		De = (i, t) => N0(i, t) !== -1,
		Tc = i => Array.isArray(i),
		ao = i => typeof i == "string",
		of = i => !!i && typeof i == "object" && !Tc(i),
		Pr = i => typeof i == "function",
		oa = i => Object.keys(i),
		V0 = i => Array.from(new Set(i)),
		Cc = () => document.activeElement,
		ro = i => i.preventDefault(),
		df = (i, t) => i.querySelectorAll(t);
	var Ft = i => {
			let t = document.createElement(i);
			return i === kn && (t.type = i), t
		},
		Qt = (i, t, e) => i.setAttribute(t, e),
		tf = (i, t, e) => {
			i.removeAttribute(e ? "data-" + t : t)
		},
		Sc = (i, t, e) => i.getAttribute(e ? "data-" + t : t),
		Rt = (i, t) => i.appendChild(t),
		Fe = (i, t) => i.classList.add(t),
		ki = (i, t) => Fe(i, "cm__" + t),
		_e = (i, t) => Fe(i, "pm__" + t),
		fs = (i, t) => i.classList.remove(t),
		ps = i => {
			if (typeof i != "object") return i;
			if (i instanceof Date) return new Date(i.getTime());
			let t = Array.isArray(i) ? [] : {};
			for (let e in i) {
				let n = i[e];
				t[e] = ps(n)
			}
			return t
		};
	var C0 = (i, t) => dispatchEvent(new CustomEvent(i, {
			detail: t
		})),
		He = (i, t, e, n) => {
			i.addEventListener(t, e), n && bt.o.m.push({
				pe: i,
				me: t,
				ge: e
			})
		},
		T0 = () => {
			let i = bt.t.cookie.expiresAfterDays;
			return Pr(i) ? i(bt.o.F) : i
		},
		ef = (i, t) => {
			let e = i || [],
				n = t || [];
			return e.filter(r => !De(n, r)).concat(n.filter(r => !De(e, r)))
		},
		z0 = i => {
			bt.o.R = V0(i), bt.o.F = (() => {
				let t = "custom",
					{
						R: e,
						O: n,
						B: r
					} = bt.o,
					s = e.length;
				return s === n.length ? t = "all" : s === r.length && (t = "necessary"), t
			})()
		},
		B0 = (i, t, e, n) => {
			let r = "accept-",
				{
					show: s,
					showPreferences: a,
					hide: o,
					hidePreferences: h,
					acceptCategory: c
				} = t,
				u = i || document,
				g = x => df(u, `[data-cc="${x}"]`),
				p = (x, M) => {
					ro(x), c(M), h(), o()
				},
				_ = g("show-preferencesModal"),
				b = g("show-consentModal"),
				y = g(r + "all"),
				w = g(r + "necessary"),
				f = g(r + "custom"),
				S = bt.t.lazyHtmlGeneration;
			for (let x of _) Qt(x, "aria-haspopup", "dialog"), He(x, Si, M => {
				ro(M), a()
			}), S && (He(x, "mouseenter", M => {
				ro(M), bt.o.N || e(t, n)
			}, !0), He(x, "focus", () => {
				bt.o.N || e(t, n)
			}));
			for (let x of b) Qt(x, "aria-haspopup", "dialog"), He(x, Si, M => {
				ro(M), s(!0)
			}, !0);
			for (let x of y) He(x, Si, M => {
				p(M, "all")
			}, !0);
			for (let x of f) He(x, Si, M => {
				p(M)
			}, !0);
			for (let x of w) He(x, Si, M => {
				p(M, [])
			}, !0)
		},
		er = (i, t) => {
			i && (t && (i.tabIndex = -1), i.focus(), t && i.removeAttribute("tabindex"))
		},
		U0 = (i, t) => {
			let e = n => {
				n.target.removeEventListener("transitionend", e), n.propertyName === "opacity" && getComputedStyle(i).opacity === "1" && er((r => r === 1 ? bt.oe.be : bt.oe.ve)(t))
			};
			He(i, "transitionend", e)
		},
		P0, G0 = i => {
			clearTimeout(P0), i ? Fe(bt.oe.ye, M0) : P0 = setTimeout(() => {
				fs(bt.oe.ye, M0)
			}, 500)
		},
		AE = ["M 19.5 4.5 L 4.5 19.5 M 4.5 4.501 L 19.5 19.5", "M 3.572 13.406 L 8.281 18.115 L 20.428 5.885", "M 21.999 6.94 L 11.639 17.18 L 2.001 6.82 "],
		Vl = (i = 0, t = 1.5) => `<svg viewBox="0 0 24 24" stroke-width="${t}"><path d="${AE[i]}"/></svg>`,
		H0 = i => {
			let t = bt.oe,
				e = bt.o;
			(n => {
				let r = n === t.he,
					s = e.i.disablePageInteraction ? t.ye : r ? t.Ce : t.ye;
				He(s, "keydown", a => {
					if (a.key !== "Tab" || !(r ? e.k && !e.A : e.A)) return;
					let o = Cc(),
						h = r ? e.q : e.K;
					h.length !== 0 && (a.shiftKey ? o !== h[0] && n.contains(o) || (ro(a), er(h[1])) : o !== h[1] && n.contains(o) || (ro(a), er(h[0])))
				}, !0)
			})(i)
		},
		DE = ["[href]", kn, "input", "details", "[tabindex]"].map(i => i + ':not([tabindex="-1"])').join(","),
		W0 = i => {
			let {
				o: t,
				oe: e
			} = bt, n = (r, s) => {
				let a = df(r, DE);
				s[0] = a[0], s[1] = a[a.length - 1]
			};
			i === 1 && t.T && n(e.he, t.q), i === 2 && t.N && n(e.we, t.K)
		},
		ir = (i, t, e) => {
			let {
				de: n,
				le: r,
				ie: s,
				_e: a,
				ue: o,
				fe: h
			} = bt.ce, c = bt.re;
			if (t) {
				let g = {
					modalName: t
				};
				return i === c.fe ? Pr(h) && h(g) : i === c._e ? Pr(a) && a(g) : (g.modal = e, Pr(o) && o(g)), C0(i, g)
			}
			let u = {
				cookie: bt.o.p
			};
			i === c.ie ? Pr(s) && s(ps(u)) : i === c.le ? Pr(r) && r(ps(u)) : (u.changedCategories = bt.o.L, u.changedServices = bt.o.ee, Pr(n) && n(ps(u))), C0(i, ps(u))
		},
		zl = (i, t) => {
			try {
				return i()
			} catch (e) {
				return !t && console.warn("CookieConsent:", e), !1
			}
		},
		lf = i => {
			let {
				Y: t,
				ee: e,
				O: n,
				X: r,
				ne: s,
				p: a,
				L: o
			} = bt.o;
			for (let g of n) {
				let p = e[g] || t[g] || [];
				for (let _ of p) {
					let b = r[g][_];
					if (!b) continue;
					let {
						onAccept: y,
						onReject: w
					} = b;
					!b.Se && De(t[g], _) && Pr(y) ? (b.Se = !0, y()) : b.Se && !De(t[g], _) && Pr(w) && (b.Se = !1, w())
				}
			}
			if (!bt.t.manageScriptTags) return;
			let h = s,
				c = i || a.categories || [],
				u = (g, p) => {
					if (p >= g.length) return;
					let _ = s[p];
					if (_.xe) return u(g, p + 1);
					let b = _.Me,
						y = _.De,
						w = _.Te,
						f = De(c, y),
						S = !!w && De(t[y], w);
					if (!w && !_.ke && f || !w && _.ke && !f && De(o, y) || w && !_.ke && S || w && _.ke && !S && De(e[y] || [], w)) {
						_.xe = !0;
						let x = Sc(b, "type", !0);
						tf(b, "type", !!x), tf(b, Mc);
						let M = Sc(b, "src", !0);
						M && tf(b, "src", !0);
						let T = Ft("script");
						T.textContent = b.innerHTML;
						for (let {
								nodeName: L
							} of b.attributes) Qt(T, L, b[L] || Sc(b, L));
						x && (T.type = x), M ? T.src = M : M = b.src;
						let I = !!M && (!x || ["text/javascript", "module"].includes(x));
						if (I && (T.onload = T.onerror = () => {
								u(g, ++p)
							}), b.replaceWith(T), I) return
					}
					u(g, ++p)
				};
			u(h, 0)
		},
		Ec = "bottom",
		hf = "left",
		$0 = "center",
		pf = "right",
		nf = "inline",
		q0 = "wide",
		j0 = "pm--",
		rf = ["middle", "top", Ec],
		A0 = [hf, $0, pf],
		IE = {
			box: {
				Ae: [q0, nf],
				Ee: rf,
				Ne: A0,
				He: Ec,
				Ve: pf
			},
			cloud: {
				Ae: [nf],
				Ee: rf,
				Ne: A0,
				He: Ec,
				Ve: $0
			},
			bar: {
				Ae: [nf],
				Ee: rf.slice(1),
				Ne: [],
				He: Ec,
				Ve: ""
			}
		},
		LE = {
			box: {
				Ae: [],
				Ee: [],
				Ne: [],
				He: "",
				Ve: ""
			},
			bar: {
				Ae: [q0],
				Ee: [],
				Ne: [hf, pf],
				He: "",
				Ve: hf
			}
		},
		X0 = i => {
			let t = bt.o.i.guiOptions,
				e = t && t.consentModal,
				n = t && t.preferencesModal;
			i === 0 && D0(bt.oe.he, IE, e, "cm--", "box", "cm"), i === 1 && D0(bt.oe.we, LE, n, j0, "box", "pm")
		},
		D0 = (i, t, e, n, r, s) => {
			i.className = s;
			let a = e && e.layout,
				o = e && e.position,
				h = e && e.flipButtons,
				c = !e || e.equalWeightButtons !== !1,
				u = a && a.split(" ") || [],
				g = u[0],
				p = u[1],
				_ = g in t ? g : r,
				b = t[_],
				y = De(b.Ae, p) && p,
				w = o && o.split(" ") || [],
				f = w[0],
				S = n === j0 ? w[0] : w[1],
				x = De(b.Ee, f) ? f : b.He,
				M = De(b.Ne, S) ? S : b.Ve,
				T = L => {
					L && Fe(i, n + L)
				};
			T(_), T(y), T(x), T(M), h && T("flip");
			let I = s + "__btn--secondary";
			if (s === "cm") {
				let {
					Ie: L,
					Le: F
				} = bt.oe;
				L && (c ? fs(L, I) : Fe(L, I)), F && (c ? fs(F, I) : Fe(F, I))
			} else {
				let {
					je: L
				} = bt.oe;
				L && (c ? fs(L, I) : Fe(L, I))
			}
		},
		Bl = (i, t) => {
			let e = bt.o,
				n = bt.oe,
				{
					hide: r,
					hidePreferences: s,
					acceptCategory: a
				} = i,
				o = M => {
					a(M), s(), r()
				},
				h = e.u && e.u.preferencesModal;
			if (!h) return;
			let c = h.title,
				u = h.closeIconLabel,
				g = h.acceptAllBtn,
				p = h.acceptNecessaryBtn,
				_ = h.savePreferencesBtn,
				b = h.sections || [],
				y = g || p || _;
			if (n.Fe) n.Pe = Ft(Se), _e(n.Pe, "body");
			else {
				n.Fe = Ft(Se), Fe(n.Fe, "pm-wrapper");
				let M = Ft("div");
				Fe(M, "pm-overlay"), Rt(n.Fe, M), He(M, Si, s), n.we = Ft(Se), Fe(n.we, "pm"), Qt(n.we, "role", "dialog"), Qt(n.we, Rn, !0), Qt(n.we, "aria-modal", !0), Qt(n.we, "aria-labelledby", "pm__title"), He(n.ye, "keydown", T => {
					T.keyCode === 27 && s()
				}, !0), n.Oe = Ft(Se), _e(n.Oe, "header"), n.Re = Ft("h2"), _e(n.Re, "title"), n.Re.id = "pm__title", n.Be = Ft(kn), _e(n.Be, "close-btn"), Qt(n.Be, "aria-label", h.closeIconLabel || ""), He(n.Be, Si, s), n.Ge = Ft("span"), n.Ge.innerHTML = Vl(), Rt(n.Be, n.Ge), n.Je = Ft(Se), _e(n.Je, "body"), n.Ue = Ft(Se), _e(n.Ue, "footer");
				var w = Ft(Se);
				Fe(w, "btns");
				var f = Ft(Se),
					S = Ft(Se);
				_e(f, Ol), _e(S, Ol), Rt(n.Ue, f), Rt(n.Ue, S), Rt(n.Oe, n.Re), Rt(n.Oe, n.Be), n.ve = Ft(Se), Qt(n.ve, "tabIndex", -1), Rt(n.we, n.ve), Rt(n.we, n.Oe), Rt(n.we, n.Je), y && Rt(n.we, n.Ue), Rt(n.Fe, n.we)
			}
			let x;
			c && (n.Re.innerHTML = c, u && Qt(n.Be, "aria-label", u)), b.forEach((M, T) => {
				let I = M.title,
					L = M.description,
					F = M.linkedCategory,
					k = F && e.P[F],
					G = M.cookieTable,
					j = G && G.body,
					U = G && G.caption,
					z = j && j.length > 0,
					$ = !!k,
					W = $ && e.X[F],
					O = of (W) && oa(W) || [],
					B = $ && (!!L || !!z || oa(W).length > 0);
				var A = Ft(Se);
				if (_e(A, "section"), B || L) {
					var D = Ft(Se);
					_e(D, "section-desc-wrapper")
				}
				let H = O.length;
				if (B && H > 0) {
					let et = Ft(Se);
					_e(et, "section-services");
					for (let it of O) {
						let Et = W[it],
							wt = Et && Et.label || it,
							yt = Ft(Se),
							At = Ft(Se),
							Vt = Ft(Se),
							lt = Ft(Se);
						_e(yt, "service"), _e(lt, "service-title"), _e(At, "service-header"), _e(Vt, "service-icon");
						let dt = I0(wt, it, k, !0, F);
						lt.innerHTML = wt, Rt(At, Vt), Rt(At, lt), Rt(yt, At), Rt(yt, dt), Rt(et, yt)
					}
					Rt(D, et)
				}
				if (I) {
					var q = Ft(Se),
						Q = Ft($ ? kn : Se);
					if (_e(q, "section-title-wrapper"), _e(Q, "section-title"), Q.innerHTML = I, Rt(q, Q), $) {
						let et = Ft("span");
						et.innerHTML = Vl(2, 3.5), _e(et, "section-arrow"), Rt(q, et), A.className += "--toggle";
						let it = I0(I, F, k),
							Et = h.serviceCounterLabel;
						if (H > 0 && ao(Et)) {
							let wt = Ft("span");
							_e(wt, "badge"), _e(wt, "service-counter"), Qt(wt, Rn, !0), Qt(wt, "data-servicecounter", H), Et && (Et = Et.split("|"), Et = Et.length > 1 && H > 1 ? Et[1] : Et[0], Qt(wt, "data-counterlabel", Et)), wt.innerHTML = H + (Et ? " " + Et : ""), Rt(Q, wt)
						}
						if (B) {
							_e(A, "section--expandable");
							var tt = F + "-desc";
							Qt(Q, "aria-expanded", !1), Qt(Q, "aria-controls", tt)
						}
						Rt(q, it)
					} else Qt(Q, "role", "heading"), Qt(Q, "aria-level", "3");
					Rt(A, q)
				}
				if (L) {
					var nt = Ft("p");
					_e(nt, "section-desc"), nt.innerHTML = L, Rt(D, nt)
				}
				if (B && (Qt(D, Rn, "true"), D.id = tt, ((et, it, Et) => {
						He(Q, Si, () => {
							it.classList.contains("is-expanded") ? (fs(it, "is-expanded"), Qt(Et, "aria-expanded", "false"), Qt(et, Rn, "true")) : (Fe(it, "is-expanded"), Qt(Et, "aria-expanded", "true"), Qt(et, Rn, "false"))
						})
					})(D, A, Q), z)) {
					let et = Ft("table"),
						it = Ft("thead"),
						Et = Ft("tbody");
					if (U) {
						let dt = Ft("caption");
						_e(dt, "table-caption"), dt.innerHTML = U, et.appendChild(dt)
					}
					_e(et, "section-table"), _e(it, "table-head"), _e(Et, "table-body");
					let wt = G.headers,
						yt = oa(wt),
						At = n.$e.createDocumentFragment(),
						Vt = Ft("tr");
					for (let dt of yt) {
						let qt = wt[dt],
							Zt = Ft("th");
						Zt.id = "cc__row-" + qt + T, Qt(Zt, "scope", "col"), _e(Zt, "table-th"), Zt.innerHTML = qt, Rt(At, Zt)
					}
					Rt(Vt, At), Rt(it, Vt);
					let lt = n.$e.createDocumentFragment();
					for (let dt of j) {
						let qt = Ft("tr");
						_e(qt, "table-tr");
						for (let Zt of yt) {
							let re = wt[Zt],
								de = dt[Zt],
								Xt = Ft("td"),
								le = Ft(Se);
							_e(Xt, "table-td"), Qt(Xt, "data-column", re), Qt(Xt, "headers", "cc__row-" + re + T), le.insertAdjacentHTML("beforeend", de), Rt(Xt, le), Rt(qt, Xt)
						}
						Rt(lt, qt)
					}
					Rt(Et, lt), Rt(et, it), Rt(et, Et), Rt(D, et)
				}(B || L) && Rt(A, D);
				let ut = n.Pe || n.Je;
				$ ? (x || (x = Ft(Se), _e(x, "section-toggles")), x.appendChild(A)) : x = null, Rt(ut, x || A)
			}), g && (n.ze || (n.ze = Ft(kn), _e(n.ze, "btn"), Qt(n.ze, so, "all"), Rt(f, n.ze), He(n.ze, Si, () => o("all"))), n.ze.innerHTML = g), p && (n.je || (n.je = Ft(kn), _e(n.je, "btn"), Qt(n.je, so, "necessary"), Rt(f, n.je), He(n.je, Si, () => o([]))), n.je.innerHTML = p), _ && (n.qe || (n.qe = Ft(kn), _e(n.qe, "btn"), _e(n.qe, "btn--secondary"), Qt(n.qe, so, "save"), Rt(S, n.qe), He(n.qe, Si, () => o())), n.qe.innerHTML = _), n.Pe && (n.we.replaceChild(n.Pe, n.Je), n.Je = n.Pe), X0(1), e.N || (e.N = !0, ir(bt.re.ue, uf, n.we), t(i), Rt(n.Ce, n.Fe), H0(n.we), setTimeout(() => Fe(n.Fe, "cc--anim"), 100)), W0(2)
		};

	function I0(i, t, e, n, r) {
		let s = bt.o,
			a = bt.oe,
			o = Ft("label"),
			h = Ft("input"),
			c = Ft("span"),
			u = Ft("span"),
			g = Ft("span"),
			p = Ft("span"),
			_ = Ft("span");
		if (p.innerHTML = Vl(1, 3), _.innerHTML = Vl(0, 3), h.type = "checkbox", Fe(o, "section__toggle-wrapper"), Fe(h, "section__toggle"), Fe(p, "toggle__icon-on"), Fe(_, "toggle__icon-off"), Fe(c, "toggle__icon"), Fe(u, "toggle__icon-circle"), Fe(g, "toggle__label"), Qt(c, Rn, "true"), n ? (Fe(o, "toggle-service"), Qt(h, Mc, r), a.ae[r][t] = h) : a.se[t] = h, n ? (b => {
				He(h, "change", () => {
					let y = a.ae[b],
						w = a.se[b];
					s.Z[b] = [];
					for (let f in y) {
						let S = y[f];
						S.checked && s.Z[b].push(S.value)
					}
					w.checked = s.Z[b].length > 0
				})
			})(r) : (b => {
				He(h, Si, () => {
					let y = a.ae[b],
						w = h.checked;
					s.Z[b] = [];
					for (let f in y) y[f].checked = w, w && s.Z[b].push(f)
				})
			})(t), h.value = t, g.textContent = i.replace(/<.*>.*<\/.*>/gm, ""), Rt(u, _), Rt(u, p), Rt(c, u), s.D)(e.readOnly || e.enabled) && (h.checked = !0);
		else if (n) {
			let b = s.Y[r];
			h.checked = e.readOnly || De(b, t)
		} else De(s.R, t) && (h.checked = !0);
		return e.readOnly && (h.disabled = !0), Rt(o, h), Rt(o, c), Rt(o, g), o
	}
	var sf = () => {
			let i = Ft("span");
			return bt.oe.Ke || (bt.oe.Ke = i), i
		},
		Y0 = (i, t) => {
			let e = bt.o,
				n = bt.oe,
				{
					hide: r,
					showPreferences: s,
					acceptCategory: a
				} = i,
				o = e.u && e.u.consentModal;
			if (!o) return;
			let h = o.acceptAllBtn,
				c = o.acceptNecessaryBtn,
				u = o.showPreferencesBtn,
				g = o.closeIconLabel,
				p = o.footer,
				_ = o.label,
				b = o.title,
				y = f => {
					r(), a(f)
				};
			if (!n.Qe) {
				n.Qe = Ft(Se), n.he = Ft(Se), n.We = Ft(Se), n.Xe = Ft(Se), n.Ye = Ft(Se), Fe(n.Qe, "cm-wrapper"), Fe(n.he, "cm"), ki(n.We, "body"), ki(n.Xe, "texts"), ki(n.Ye, "btns"), Qt(n.he, "role", "dialog"), Qt(n.he, "aria-modal", "true"), Qt(n.he, Rn, "false"), Qt(n.he, "aria-describedby", "cm__desc"), _ ? Qt(n.he, "aria-label", _) : b && Qt(n.he, "aria-labelledby", "cm__title");
				let f = "box",
					S = e.i.guiOptions,
					x = S && S.consentModal,
					M = (x && x.layout || f).split(" ")[0] === f;
				b && g && M && (n.Le || (n.Le = Ft(kn), n.Le.innerHTML = Vl(), ki(n.Le, "btn"), ki(n.Le, "btn--close"), He(n.Le, Si, () => {
					y([])
				}), Rt(n.We, n.Le)), Qt(n.Le, "aria-label", g)), Rt(n.We, n.Xe), (h || c || u) && Rt(n.We, n.Ye), n.be = Ft(Se), Qt(n.be, "tabIndex", -1), Rt(n.he, n.be), Rt(n.he, n.We), Rt(n.Qe, n.he)
			}
			b && (n.Ze || (n.Ze = Ft("h2"), n.Ze.className = n.Ze.id = "cm__title", Rt(n.Xe, n.Ze)), n.Ze.innerHTML = b);
			let w = o.description;
			if (w && (e.V && (w = w.replace("{{revisionMessage}}", e.I ? "" : o.revisionMessage || "")), n.et || (n.et = Ft("p"), n.et.className = n.et.id = "cm__desc", Rt(n.Xe, n.et)), n.et.innerHTML = w), h && (n.tt || (n.tt = Ft(kn), Rt(n.tt, sf()), ki(n.tt, "btn"), Qt(n.tt, so, "all"), He(n.tt, Si, () => {
					y("all")
				})), n.tt.firstElementChild.innerHTML = h), c && (n.Ie || (n.Ie = Ft(kn), Rt(n.Ie, sf()), ki(n.Ie, "btn"), Qt(n.Ie, so, "necessary"), He(n.Ie, Si, () => {
					y([])
				})), n.Ie.firstElementChild.innerHTML = c), u && (n.nt || (n.nt = Ft(kn), Rt(n.nt, sf()), ki(n.nt, "btn"), ki(n.nt, "btn--secondary"), Qt(n.nt, so, "show"), He(n.nt, "mouseenter", () => {
					e.N || Bl(i, t)
				}), He(n.nt, Si, s)), n.nt.firstElementChild.innerHTML = u), n.ot || (n.ot = Ft(Se), ki(n.ot, Ol), h && Rt(n.ot, n.tt), c && Rt(n.ot, n.Ie), (h || c) && Rt(n.We, n.ot), Rt(n.Ye, n.ot)), n.nt && !n.st && (n.st = Ft(Se), n.Ie && n.tt ? (ki(n.st, Ol), Rt(n.st, n.nt), Rt(n.Ye, n.st)) : (Rt(n.ot, n.nt), ki(n.ot, Ol + "--uneven"))), p) {
				if (!n.ct) {
					let f = Ft(Se),
						S = Ft(Se);
					n.ct = Ft(Se), ki(f, "footer"), ki(S, "links"), ki(n.ct, "link-group"), Rt(S, n.ct), Rt(f, S), Rt(n.he, f)
				}
				n.ct.innerHTML = p
			}
			X0(0), e.T || (e.T = !0, ir(bt.re.ue, cf, n.he), t(i), Rt(n.Ce, n.Qe), H0(n.he), setTimeout(() => Fe(n.Qe, "cc--anim"), 100)), W0(1), B0(n.We, i, Bl, t)
		},
		K0 = i => {
			if (!ao(i)) return null;
			if (i in bt.o._) return i;
			let t = i.slice(0, 2);
			return t in bt.o._ ? t : null
		},
		Z0 = () => bt.o.l || bt.o.i.language.default,
		J0 = i => {
			i && (bt.o.l = i)
		},
		kE = i => Di(void 0, null, function* () {
			let t = bt.o,
				e = K0(i) ? i : Z0(),
				n = t._[e];
			if (!n) return !1;
			if (ao(n)) {
				let r = yield(s => Di(void 0, null, function* () {
					try {
						return yield(yield fetch(s)).json()
					} catch (a) {
						return console.error(a), !1
					}
				}))(n);
				if (!r) return !1;
				n = r
			}
			return t.u = n, J0(e), !0
		}),
		RE = () => {
			let i = bt.o.i.language.rtl,
				t = bt.oe.Ce;
			i && t && (Tc(i) || (i = [i]), De(i, bt.o.l) ? Fe(t, "cc--rtl") : fs(t, "cc--rtl"))
		},
		Nl = () => {
			let i = bt.oe;
			if (i.Ce) return;
			i.Ce = Ft(Se), i.Ce.id = "cc-main", i.Ce.setAttribute("data-nosnippet", ""), RE();
			let t = bt.o.i.root;
			t && ao(t) && (t = document.querySelector(t)), (t || i.$e.body).appendChild(i.Ce)
		},
		FE = i => zl(() => localStorage.removeItem(i)),
		L0 = (i, t) => {
			if (t instanceof RegExp) return i.filter(e => t.test(e)); {
				let e = N0(i, t);
				return e > -1 ? [i[e]] : []
			}
		},
		OE = i => {
			let {
				hostname: t,
				protocol: e
			} = location, {
				name: n,
				path: r,
				domain: s,
				sameSite: a,
				useLocalStorage: o
			} = bt.t.cookie, h = i ? (() => {
				let p = bt.o.S,
					_ = p ? new Date - p : 0;
				return 864e5 * T0() - _
			})() : 864e5 * T0(), c = new Date;
			c.setTime(c.getTime() + h), bt.o.p.expirationTime = c.getTime();
			let u = JSON.stringify(bt.o.p),
				g = n + "=" + encodeURIComponent(u) + (h !== 0 ? "; expires=" + c.toUTCString() : "") + "; Path=" + r + "; SameSite=" + a;
			De(t, ".") && (g += "; Domain=" + s), e === "https:" && (g += "; Secure"), o ? ((p, _) => {
				zl(() => localStorage.setItem(p, _))
			})(n, u) : document.cookie = g, bt.o.p
		},
		k0 = (i, t, e) => {
			if (i.length === 0) return;
			let n = e || bt.t.cookie.domain,
				r = t || bt.t.cookie.path,
				s = n.slice(0, 4) === "www.",
				a = s && n.substring(4),
				o = (h, c) => {
					document.cookie = h + "=; path=" + r + (c ? "; domain=." + c : "") + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;"
				};
			for (let h of i) o(h), o(h, n), s && o(h, a)
		},
		NE = i => {
			let t = i || bt.t.cookie.name,
				e = bt.t.cookie.useLocalStorage;
			return ((r, s) => {
				let a;
				return a = zl(() => JSON.parse(s ? r : decodeURIComponent(r)), !0) || {}, a
			})(e ? (n = t, zl(() => localStorage.getItem(n)) || "") : VE(t, !0), e);
			var n
		},
		VE = (i, t) => {
			let e = document.cookie.match("(^|;)\\s*" + i + "\\s*=\\s*([^;]+)");
			return e ? t ? e.pop() : i : ""
		},
		zE = i => {
			let t = document.cookie.split(/;\s*/),
				e = [];
			for (let n of t) {
				let r = n.split("=")[0];
				i ? zl(() => {
					i.test(r) && e.push(r)
				}) : e.push(r)
			}
			return e
		},
		BE = (i, t = []) => {
			((e, n) => {
				let {
					O: r,
					R: s,
					B: a,
					N: o,
					Z: h,
					X: c
				} = bt.o, u = [];
				if (e) {
					Tc(e) ? u.push(...e) : ao(e) && (u = e === "all" ? r : [e]);
					for (let g of r) h[g] = De(u, g) ? oa(c[g]) : []
				} else u = s, o && (u = (() => {
					let g = bt.oe.se;
					if (!g) return [];
					let p = [];
					for (let _ in g) g[_].checked && p.push(_);
					return p
				})());
				u = u.filter(g => !De(r, g) || !De(n, g)), u.push(...a), z0(u)
			})(i, t), (e => {
				let n = bt.o,
					{
						Z: r,
						B: s,
						Y: a,
						X: o,
						O: h
					} = n,
					c = h;
				n.te = ps(a);
				for (let u of c) {
					let g = o[u],
						p = oa(g),
						_ = r[u] && r[u].length > 0,
						b = De(s, u);
					if (p.length !== 0) {
						if (a[u] = [], b) a[u].push(...p);
						else if (_) {
							let y = r[u];
							a[u].push(...y)
						} else a[u] = [];
						a[u] = V0(a[u])
					}
				}
			})(), (() => {
				let e = bt.o;
				e.L = bt.t.mode === Fl && e.D ? ef(e.G, e.R) : ef(e.R, e.p.categories);
				let n = e.L.length > 0,
					r = !1;
				for (let h of e.O) e.ee[h] = ef(e.Y[h], e.te[h]), e.ee[h].length > 0 && (r = !0);
				let s = bt.oe.se;
				for (let h in s) s[h].checked = De(e.R, h);
				for (let h of e.O) {
					let c = bt.oe.ae[h],
						u = e.Y[h];
					for (let g in c) c[g].checked = De(u, g)
				}
				e.C || (e.C = new Date), e.M || (e.M = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, h => (h ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> h / 4).toString(16))), e.p = {
					categories: ps(e.R),
					revision: bt.t.revision,
					data: e.h,
					consentTimestamp: e.C.toISOString(),
					consentId: e.M,
					services: ps(e.Y)
				};
				let a = !1,
					o = n || r;
				(e.D || o) && (e.D && (e.D = !1, a = !0), e.S = e.S ? new Date : e.C, e.p.lastConsentTimestamp = e.S.toISOString(), OE(), bt.t.autoClearCookies && (a || o) && (h => {
					let c = bt.o,
						u = zE(),
						g = (p => {
							let _ = bt.o;
							return (p ? _.O : _.L).filter(b => {
								let y = _.P[b];
								return !!y && !y.readOnly && !!y.autoClear
							})
						})(h);
					for (let p in c.ee)
						for (let _ of c.ee[p]) {
							let b = c.X[p][_].cookies;
							if (!De(c.Y[p], _) && b)
								for (let y of b) {
									let w = L0(u, y.name);
									k0(w, y.path, y.domain)
								}
						}
					for (let p of g) {
						let _ = c.P[p].autoClear,
							b = _ && _.cookies || [],
							y = De(c.L, p),
							w = !De(c.R, p),
							f = y && w;
						if (h ? w : f) {
							_.reloadPage && f && (c.j = !0);
							for (let S of b) {
								let x = L0(u, S.name);
								k0(x, S.path, S.domain)
							}
						}
					}
				})(a), lf()), a && (ir(bt.re.ie), ir(bt.re.le), bt.t.mode === R0) || (o && ir(bt.re.de), e.j && (e.j = !1, location.reload()))
			})()
		},
		UE = i => {
			let t = bt.o.D ? [] : bt.o.R;
			return De(t, i)
		};
	var GE = (i, t) => {
		let e = bt.o.D ? [] : bt.o.Y[t];
		return De(e, i)
	};
	var Q0 = i => {
			let {
				oe: t,
				o: e
			} = bt;
			if (!e.k) {
				if (!e.T) {
					if (!i) return;
					Y0(ff, Nl)
				}
				e.k = !0, e.U = Cc(), e.v && G0(!0), U0(t.he, 1), Fe(t.ye, F0), Qt(t.he, Rn, "false"), setTimeout(() => {
					er(bt.oe.be)
				}, 100), ir(bt.re.fe, cf)
			}
		},
		Pc = () => {
			let {
				oe: i,
				o: t,
				re: e
			} = bt;
			t.k && (t.k = !1, t.v && G0(), er(i.Ke, !0), fs(i.ye, F0), Qt(i.he, Rn, "true"), er(t.U), t.U = null, ir(e._e, cf))
		},
		Ac = () => {
			let i = bt.o;
			i.A || (i.N || Bl(ff, Nl), i.A = !0, i.k ? i.$ = Cc() : i.U = Cc(), U0(bt.oe.we, 2), Fe(bt.oe.ye, O0), Qt(bt.oe.we, Rn, "false"), setTimeout(() => {
				er(bt.oe.ve)
			}, 100), ir(bt.re.fe, uf))
		},
		Dc = () => {
			let i = bt.o;
			i.A && (i.A = !1, (() => {
				let t = t_(),
					e = bt.o.P,
					n = bt.oe.se,
					r = bt.oe.ae,
					s = a => De(bt.o.G, a);
				for (let a in n) {
					let o = !!e[a].readOnly;
					n[a].checked = o || (t ? UE(a) : s(a));
					for (let h in r[a]) r[a][h].checked = o || (t ? GE(h, a) : s(a))
				}
			})(), er(bt.oe.Ge, !0), fs(bt.oe.ye, O0), Qt(bt.oe.we, Rn, "true"), i.k ? (er(i.$), i.$ = null) : (er(i.U), i.U = null), ir(bt.re._e, uf))
		},
		ff = {
			show: Q0,
			hide: Pc,
			showPreferences: Ac,
			hidePreferences: Dc,
			acceptCategory: BE
		};
	var t_ = () => !bt.o.D,
		e_ = i => Di(void 0, null, function* () {
			let {
				o: t,
				t: e,
				re: n
			} = bt, r = window;
			if (!r._ccRun) {
				if (r._ccRun = !0, (o => {
						let {
							oe: h,
							t: c,
							o: u
						} = bt, g = c, p = u, {
							cookie: _
						} = g, b = bt.ce, y = o.cookie, w = o.categories, f = oa(w) || [], S = navigator, x = document;
						h.$e = x, h.ye = x.documentElement, _.domain = location.hostname, p.i = o, p.P = w, p.O = f, p._ = o.language.translations, p.v = !!o.disablePageInteraction, b.ie = o.onFirstConsent, b.le = o.onConsent, b.de = o.onChange, b._e = o.onModalHide, b.fe = o.onModalShow, b.ue = o.onModalReady;
						let {
							mode: M,
							autoShow: T,
							lazyHtmlGeneration: I,
							autoClearCookies: L,
							revision: F,
							manageScriptTags: k,
							hideFromBots: G
						} = o;
						M === Fl && (g.mode = M), typeof L == "boolean" && (g.autoClearCookies = L), typeof k == "boolean" && (g.manageScriptTags = k), typeof F == "number" && F >= 0 && (g.revision = F, p.V = !0), typeof T == "boolean" && (g.autoShow = T), typeof I == "boolean" && (g.lazyHtmlGeneration = I), G === !1 && (g.hideFromBots = !1), g.hideFromBots === !0 && S && (p.J = S.userAgent && /bot|crawl|spider|slurp|teoma/i.test(S.userAgent) || S.webdriver), of (y) && (g.cookie = gn(gn({}, _), y)), g.autoClearCookies, p.V, g.manageScriptTags, (j => {
							let {
								P: U,
								X: z,
								Y: $,
								Z: W,
								B: O
							} = bt.o;
							for (let B of j) {
								let A = U[B],
									D = A.services || {},
									H = of (D) && oa(D) || [];
								z[B] = {}, $[B] = [], W[B] = [], A.readOnly && (O.push(B), $[B] = H), bt.oe.ae[B] = {};
								for (let q of H) {
									let Q = D[q];
									Q.Se = !1, z[B][q] = Q
								}
							}
						})(f), (() => {
							if (!bt.t.manageScriptTags) return;
							let j = bt.o,
								U = df(document, "script[" + Mc + "]");
							for (let z of U) {
								let $ = Sc(z, Mc),
									W = z.dataset.service || "",
									O = !1;
								if ($ && $.charAt(0) === "!" && ($ = $.slice(1), O = !0), W.charAt(0) === "!" && (W = W.slice(1), O = !0), De(j.O, $) && (j.ne.push({
										Me: z,
										xe: !1,
										ke: O,
										De: $,
										Te: W
									}), W)) {
									let B = j.X[$];
									B[W] || (B[W] = {
										Se: !1
									})
								}
							}
						})(), J0((() => {
							let j = bt.o.i.language.autoDetect;
							if (j) {
								let U = {
										browser: navigator.language,
										document: document.documentElement.lang
									},
									z = K0(U[j]);
								if (z) return z
							}
							return Z0()
						})())
					})(i), t.J) return;
				(() => {
					let o = bt.o,
						h = bt.t,
						c = NE(),
						{
							categories: u,
							services: g,
							consentId: p,
							consentTimestamp: _,
							lastConsentTimestamp: b,
							data: y,
							revision: w
						} = c,
						f = Tc(u);
					o.p = c, o.M = p;
					let S = !!p && ao(p);
					o.C = _, o.C && (o.C = new Date(_)), o.S = b, o.S && (o.S = new Date(b)), o.h = y !== void 0 ? y : null, o.V && S && w !== h.revision && (o.I = !1), o.D = !(S && o.I && o.C && o.S && f), h.cookie.useLocalStorage && !o.D && (o.D = new Date().getTime() > (c.expirationTime || 0), o.D && FE(h.cookie.name)), o.D, (() => {
						let x = bt.o;
						for (let M of x.O) {
							let T = x.P[M];
							if (T.readOnly || T.enabled && x.i.mode === Fl) {
								x.G.push(M);
								let I = x.X[M] || {};
								for (let L in I) x.Y[M].push(L)
							}
						}
					})(), o.D ? h.mode === Fl && (o.R = [...o.G]) : (o.Y = gn(gn({}, o.Y), g), z0([...o.B, ...u])), o.Z = gn({}, o.Y)
				})();
				let a = t_();
				if (!(yield kE())) return !1;
				if (B0(null, s = ff, Bl, Nl), bt.o.D && Y0(s, Nl), bt.t.lazyHtmlGeneration || Bl(s, Nl), e.autoShow && !a && Q0(!0), a) return lf(), ir(n.le);
				e.mode === Fl && lf(t.G)
			}
			var s
		});
	var Ic = class extends pe {
		constructor(i) {
			super(i);
			try {
				this.config = JSON.parse(this.getData("config"))
			} catch (t) {
				console.warn(t.message)
			}
			this.events = {
				click: {
					hide: "hideModal",
					"show-preferences": "showPreferences"
				}
			}
		}
		init() {
			if (!this.config.categories || Object.keys(this.config.categories).length === 0) {
				console.warn("[CookieConsent]", "No categories configured.");
				return
			}
			this.config.categories = this.prepareCategories(this.config.categories), window.addEventListener(Ce.READY, this.onReady = () => {
				e_(Object.assign({}, this.config))
			}), document.addEventListener("click", i => {
				let t = i.target;
				for (; t && t !== document;) {
					if (t.matches("a")) {
						t.getAttribute("href") === "#show-cookie-preferences" ? (i.preventDefault(), i.stopPropagation(), Ac()) : t.getAttribute("data-cookie-consent") === "hide" && (Dc(), Pc());
						break
					}
					t = t.parentNode
				}
			}, !1)
		}
		prepareCategories(i) {
			var t;
			for (let [e, n] of Object.entries(i))(t = n == null ? void 0 : n.autoClear) != null && t.cookies && Array.isArray(n.autoClear.cookies) && n.autoClear.cookies.length > 0 && (n.autoClear.cookies.map(r => {
				if (r != null && r.name && typeof r.name == "string") {
					let s = r.name.match(/^\/(.+)\/([a-z]+)?$/);
					s && (r.name = new RegExp(s[1], s[2]))
				}
				return r
			}), i[e].autoClear.cookies = n.autoClear.cookies);
			return i
		}
		showPreferences() {
			Ac()
		}
		hideModal() {
			Dc(), Pc()
		}
	};
	var Lc = class extends pe {
		constructor(i) {
			super(i)
		}
		init() {
			ns(Yn.EAGER).then(i => this.onFontsLoaded(i))
		}
		onFontsLoaded(i) {
			console.log("Example: Eager Fonts Loaded!", i)
		}
	};
	var ms = class extends pe {
		static get settings() {
			return {
				CLASS_ACTIVE: "is-active"
			}
		}
		constructor(t) {
			super(t), this.$el = this.el;
			let e = this.$("link");
			this.$elements = e.length > 0 ? Array.from(e) : Array.from(this.$("button")), this.transition = this.getData("transition") || null, this.$activeFilter = this.$elements.find(n => n.classList.contains("is-active")), this.events = {
				click: {
					link: "handleLink",
					button: "handleButton"
				}
			}
		}
		init() {}
		handleLink(t) {
			t.stopPropagation(), t.preventDefault();
			let e = t.curTarget;
			if (e === this.$activeFilter) return;
			let n = e.href,
				r = this.transition;
			this.setActive(e), this.call("goTo", {
				url: n,
				transition: r
			}, "Load")
		}
		handleButton(t) {
			let e = t.curTarget;
			e !== this.$activeFilter && (this.setActive(e), this.call("update", e.dataset.id, "TeamList"))
		}
		setActive(t) {
			this.$activeFilter !== null && this.$activeFilter.classList.remove(ms.settings.CLASS_ACTIVE), t.classList.add(ms.settings.CLASS_ACTIVE), this.$activeFilter = t
		}
	};
	var i_ = yl(mf(), 1);
	var la = class extends pe {
		static get settings() {
			return {
				CLASS_REDUCED: "is-reduced"
			}
		}
		constructor(t) {
			super(t), this.$el = this.el, this.$name = this.$("name")[0], this.$areasOpener = this.$("areasOpener")[0], this.$menuOpener = this.$("menuOpener")[0], this.$icon = this.$("icon")[0], this.$menuToggler = this.$("menuToggler")[0], this.isOpen = !1, this.isReduced = !1, this.reduceIsLocked = !1, this.events = {
				click: {
					overlay: "close",
					menuOpener: "openMenu",
					menuToggler: "toggleMenu",
					areasOpener: "openAreas"
				}
			}
		}
		init() {
			ie.REDUCED_MOTION || (this.iconAnimation = i_.default.loadAnimation({
				container: this.$icon,
				path: "/assets/lottie/icon.json",
				renderer: "svg",
				loop: !0,
				autoplay: !1
			}), ne.set(this.$icon, {
				opacity: 0
			}), window.addEventListener(Ce.READY, this.onReady = () => {
				this.iconAnimation.play(), ne.to(this.$icon, {
					opacity: 1,
					duration: .2,
					ease: "power2.out",
					delay: 1
				})
			}))
		}
		openMenu() {
			this.call("open", null, "ModalMenu")
		}
		onMenuOpen() {
			this.$menuToggler.setAttribute("aria-label", "Close main menu"), this.$name.setAttribute("tabindex", "-1"), this.$areasOpener.setAttribute("tabindex", "-1"), this.$menuOpener.setAttribute("tabindex", "-1"), this.$menuOpener.setAttribute("aria-expanded", "true"), this.lockReduced()
		}
		onMenuClose() {
			this.$menuToggler.setAttribute("aria-label", "Open main menu"), this.$name.removeAttribute("tabindex"), this.$areasOpener.removeAttribute("tabindex"), this.$menuOpener.removeAttribute("tabindex"), this.$menuOpener.setAttribute("aria-expanded", "false"), this.unlockReduced()
		}
		toggleMenu() {
			this.call("toggle", null, "ModalMenu")
		}
		openAreas() {
			this.call("open", null, "ModalAreas"), this.$areasOpener.setAttribute("aria-expanded", "true"), this.lockReduced()
		}
		closeAreas() {
			this.$areasOpener.setAttribute("aria-expanded", "false"), this.unlockReduced()
		}
		setReduced(t = !0) {
			this.reduceIsLocked || this.isReduced === t || (this.$el.classList.toggle(la.settings.CLASS_REDUCED, t), this.isReduced = t)
		}
		lockReduced(t = !1) {
			this.setReduced(t), this.reduceIsLocked = !0
		}
		unlockReduced() {
			this.reduceIsLocked = !1
		}
		destroy() {
			ie.REDUCED_MOTION || window.removeEventListener(Ce.READY, this.onReady), window.removeEventListener(Ce.RESIZE_END, this.onResize)
		}
	};

	function WE(i, t) {
		if (!(i instanceof t)) throw new TypeError("Cannot call a class as a function")
	}

	function n_(i, t) {
		for (var e = 0; e < t.length; e++) {
			var n = t[e];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n)
		}
	}

	function $E(i, t, e) {
		return t && n_(i.prototype, t), e && n_(i, e), i
	}

	function qE(i, t) {
		return jE(i) || XE(i, t) || YE(i, t) || KE()
	}

	function jE(i) {
		if (Array.isArray(i)) return i
	}

	function XE(i, t) {
		var e = i == null ? null : typeof Symbol != "undefined" && i[Symbol.iterator] || i["@@iterator"];
		if (e != null) {
			var n = [],
				r = !0,
				s = !1,
				a, o;
			try {
				for (e = e.call(i); !(r = (a = e.next()).done) && (n.push(a.value), !(t && n.length === t)); r = !0);
			} catch (h) {
				s = !0, o = h
			} finally {
				try {
					!r && e.return != null && e.return()
				} finally {
					if (s) throw o
				}
			}
			return n
		}
	}

	function YE(i, t) {
		if (i) {
			if (typeof i == "string") return r_(i, t);
			var e = Object.prototype.toString.call(i).slice(8, -1);
			if (e === "Object" && i.constructor && (e = i.constructor.name), e === "Map" || e === "Set") return Array.from(i);
			if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return r_(i, t)
		}
	}

	function r_(i, t) {
		(t == null || t > i.length) && (t = i.length);
		for (var e = 0, n = new Array(t); e < t; e++) n[e] = i[e];
		return n
	}

	function KE() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	var ZE = function () {
			function i(t) {
				WE(this, i), this.defaults = {
					name: "load",
					loadingClass: "is-loading",
					loadedClass: "is-loaded",
					readyClass: "is-ready",
					transitionsPrefix: "is-",
					transitionsHistory: !0,
					enterDelay: 0,
					exitDelay: 0,
					loadedDelay: 0,
					isLoaded: !1,
					isEntered: !1,
					isUrl: !1,
					transitionContainer: null,
					popstateIgnore: !1
				}, Object.assign(this, this.defaults, t), this.options = t, this.namespace = "modular", this.html = document.documentElement, this.href = window.location.href, this.container = "data-" + this.name + "-container", this.subContainer = !1, this.prevTransition = null, this.loadAttributes = ["src", "srcset", "style", "href"], this.isInserted = !1, this.isLoading = !1, this.enterTimeout = !1, this.controller = new AbortController, this.classContainer = this.html, this.isChrome = navigator.userAgent.indexOf("Chrome") != -1, this.init()
			}
			return $E(i, [{
				key: "init",
				value: function () {
					var e = this;
					window.addEventListener("popstate", function (n) {
						return e.checkState(n)
					}, !1), this.html.addEventListener("click", function (n) {
						return e.checkClick(n)
					}, !1), this.loadEls(document)
				}
			}, {
				key: "checkClick",
				value: function (e) {
					if (!e.ctrlKey && !e.metaKey)
						for (var n = e.target; n && n !== document;) {
							if (n.matches("a") && n.getAttribute("download") == null) {
								var r = n.getAttribute("href");
								!r.startsWith("#") && !r.startsWith("mailto:") && !r.startsWith("tel:") && (e.preventDefault(), this.reset(), this.getClickOptions(n));
								break
							}
							n = n.parentNode
						}
				}
			}, {
				key: "checkState",
				value: function () {
					typeof this.popstateIgnore == "string" && window.location.href.indexOf(this.popstateIgnore) > -1 || (this.reset(), this.getStateOptions())
				}
			}, {
				key: "reset",
				value: function () {
					this.isLoading && (this.controller.abort(), this.isLoading = !1, this.controller = new AbortController), window.clearTimeout(this.enterTimeout), this.isInserted && this.removeContainer(), this.classContainer = this.html, Object.assign(this, this.defaults, this.options)
				}
			}, {
				key: "getClickOptions",
				value: function (e) {
					this.transition = e.getAttribute("data-" + this.name), this.isUrl = e.getAttribute("data-" + this.name + "-url");
					var n = e.getAttribute("href"),
						r = e.getAttribute("target");
					if (r == "_blank") {
						window.open(n, "_blank");
						return
					}
					if (this.transition == "false") {
						window.location = n;
						return
					}
					this.setOptions(n, !0)
				}
			}, {
				key: "getStateOptions",
				value: function () {
					this.transitionsHistory ? this.transition = history.state : this.transition = !1;
					var e = window.location.href;
					this.setOptions(e)
				}
			}, {
				key: "goTo",
				value: function (e, n, r) {
					this.reset(), this.transition = n, this.isUrl = r, this.setOptions(e, !0)
				}
			}, {
				key: "setOptions",
				value: function (e, n) {
					var r = "[" + this.container + "]",
						s;
					this.transition && this.transition != "true" && (this.transitionContainer = "[" + this.container + '="' + this.transition + '"]', this.loadingClass = this.transitions[this.transition].loadingClass || this.loadingClass, this.loadedClass = this.transitions[this.transition].loadedClass || this.loadedClass, this.readyClass = this.transitions[this.transition].readyClass || this.readyClass, this.transitionsPrefix = this.transitions[this.transition].transitionsPrefix || this.transitionsPrefix, this.enterDelay = this.transitions[this.transition].enterDelay || this.enterDelay, this.exitDelay = this.transitions[this.transition].exitDelay || this.exitDelay, this.loadedDelay = this.transitions[this.transition].loadedDelay || this.loadedDelay, s = document.querySelector(this.transitionContainer)), s ? (r = this.transitionContainer, this.oldContainer = s, this.classContainer = this.oldContainer.parentNode, this.subContainer || history.replaceState(this.transition, null, this.href), this.subContainer = !0) : (this.oldContainer = document.querySelector(r), this.subContainer && history.replaceState(this.prevTransition, null, this.href), this.subContainer = !1), this.href = e, this.parentContainer = this.oldContainer.parentNode, this.isUrl === "" || this.isUrl != null && this.isUrl != "false" && this.isUrl != !1 ? history.pushState(this.transition, null, e) : (this.oldContainer.classList.add("is-old"), this.setLoading(), this.startEnterDelay(), this.loadHref(e, r, n))
				}
			}, {
				key: "setLoading",
				value: function () {
					this.classContainer.classList.remove(this.loadedClass, this.readyClass), this.classContainer.classList.add(this.loadingClass), this.classContainer.classList.remove(this.transitionsPrefix + this.prevTransition), this.transition && this.classContainer.classList.add(this.transitionsPrefix + this.transition), this.subContainer || (this.prevTransition = this.transition);
					var e = new Event(this.namespace + "loading");
					window.dispatchEvent(e)
				}
			}, {
				key: "startEnterDelay",
				value: function () {
					var e = this;
					this.enterTimeout = window.setTimeout(function () {
						e.isEntered = !0, e.isLoaded && e.transitionContainers()
					}, this.enterDelay)
				}
			}, {
				key: "loadHref",
				value: function (e, n, r) {
					var s = this;
					this.isLoading = !0;
					var a = this.controller.signal;
					fetch(e, {
						signal: a
					}).then(function (o) {
						return o.text()
					}).then(function (o) {
						r && history.pushState(s.transition, null, e);
						var h = new DOMParser;
						s.data = h.parseFromString(o, "text/html"), s.newContainer = s.data.querySelector(n), s.newContainer.classList.add("is-new"), s.parentNewContainer = s.newContainer.parentNode, s.hideContainer(), s.parentContainer.insertBefore(s.newContainer, s.oldContainer), s.isInserted = !0, s.setSvgs(), s.isLoaded = !0, s.isEntered && s.transitionContainers(), s.loadEls(s.newContainer), s.isLoading = !1
					}).catch(function (o) {
						window.location = e
					})
				}
			}, {
				key: "transitionContainers",
				value: function () {
					var e = this;
					this.setAttributes(), this.showContainer(), this.setLoaded(), setTimeout(function () {
						e.removeContainer(), e.setReady()
					}, this.exitDelay)
				}
			}, {
				key: "setSvgs",
				value: function () {
					if (this.isChrome) {
						var e = this.newContainer.querySelectorAll("use");
						e.length && e.forEach(function (n) {
							var r = n.getAttribute("xlink:href");
							if (r) n.parentNode.innerHTML = '<use xlink:href="' + r + '"></use>';
							else {
								var s = n.getAttribute("href");
								s && (n.parentNode.innerHTML = '<use href="' + s + '"></use>')
							}
						})
					}
				}
			}, {
				key: "setAttributes",
				value: function () {
					var e = this,
						n = this.data.getElementsByTagName("title")[0],
						r = this.data.head.querySelector('meta[name="description"]'),
						s = document.head.querySelector('meta[name="description"]'),
						a, o;
					this.subContainer ? (o = this.parentNewContainer, a = document.querySelector(this.transitionContainer).parentNode) : (o = this.data.querySelector("html"), a = document.querySelector("html"));
					var h = Object.assign({}, o.dataset);
					n && (document.title = n.innerText), s && r && s.setAttribute("content", r.getAttribute("content")), h && Object.entries(h).forEach(function (c) {
						var u = qE(c, 2),
							g = u[0],
							p = u[1];
						a.setAttribute("data-" + e.toDash(g), p)
					})
				}
			}, {
				key: "toDash",
				value: function (e) {
					return e.split(/(?=[A-Z])/).join("-").toLowerCase()
				}
			}, {
				key: "hideContainer",
				value: function () {
					this.newContainer.style.visibility = "hidden", this.newContainer.style.height = 0, this.newContainer.style.overflow = "hidden"
				}
			}, {
				key: "showContainer",
				value: function () {
					this.newContainer.style.visibility = "", this.newContainer.style.height = "", this.newContainer.style.overflow = ""
				}
			}, {
				key: "loadEls",
				value: function (e) {
					var n = this,
						r = [];
					this.loadAttributes.forEach(function (s) {
						var a = "data-" + n.name + "-" + s,
							o = e.querySelectorAll("[" + a + "]");
						o.length && o.forEach(function (h) {
							var c = h.getAttribute(a);
							if (h.setAttribute(s, c), s == "src" || s == "srcset") {
								var u = new Promise(function (g) {
									h.onload = function () {
										return g(h)
									}
								});
								r.push(u)
							}
						})
					}), Promise.all(r).then(function (s) {
						var a = new Event(n.namespace + "images");
						window.dispatchEvent(a)
					})
				}
			}, {
				key: "setLoaded",
				value: function () {
					var e = this;
					this.classContainer.classList.remove(this.loadingClass), setTimeout(function () {
						e.classContainer.classList.add(e.loadedClass)
					}, this.loadedDelay);
					var n = new Event(this.namespace + "loaded");
					window.dispatchEvent(n)
				}
			}, {
				key: "removeContainer",
				value: function () {
					this.parentContainer.removeChild(this.oldContainer), this.newContainer.classList.remove("is-new"), this.isInserted = !1
				}
			}, {
				key: "setReady",
				value: function () {
					this.classContainer.classList.add(this.readyClass);
					var e = new Event(this.namespace + "ready");
					window.dispatchEvent(e)
				}
			}, {
				key: "on",
				value: function (e, n) {
					var r = this;
					window.addEventListener(this.namespace + e, function () {
						switch (e) {
							case "loading":
								return n(r.transition, r.oldContainer);
							case "loaded":
								return n(r.transition, r.oldContainer, r.newContainer);
							case "ready":
								return n(r.transition, r.newContainer);
							default:
								return n()
						}
					}, !1)
				}
			}]), i
		}(),
		s_ = ZE;
	var Ul = (i, t) => {
		for (Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (e) {
				for (var n = (this.document || this.ownerDocument).querySelectorAll(e), r = n.length; --r >= 0 && n.item(r) !== this;);
				return r > -1
			}); i && i !== document; i = i.parentNode)
			if (i.matches(t)) return i;
		return null
	};
	var a_ = i => {
			let t = i.currentTarget,
				e = Ul(t, `.${ti.LAZY_CONTAINER}`);
			requestAnimationFrame(() => {
				e && (e.classList.remove(ti.LAZY_LOADING), e.classList.add(ti.LAZY_LOADED)), t.classList.add(ti.LAZY_LOADED)
			})
		},
		o_ = i => {
			let t = i.currentTarget,
				e = Ul(t, `.${ti.LAZY_CONTAINER}`);
			requestAnimationFrame(() => {
				e && (e.classList.remove(ti.LAZY_LOADING), e.classList.add(ti.LAZY_ERROR))
			})
		},
		kc = i => {
			let t = i || document.querySelectorAll('[loading="lazy"]');
			if ("loading" in HTMLImageElement.prototype)
				for (let e of t) {
					let n = Ul(e, `.${ti.LAZY_CONTAINER}`);
					e.complete ? (n.classList.add(ti.LAZY_LOADED), e.classList.add(ti.LAZY_LOADED)) : (n == null || n.classList.add(ti.LAZY_LOADING), e.addEventListener("load", a_, {
						once: !0
					}), e.addEventListener("error", o_, {
						once: !0
					}))
				} else
					for (let e of t) Ul(e, `.${ti.LAZY_CONTAINER}`).classList.add(ti.LAZY_LOADED)
		},
		l_ = () => {
			if ("loading" in HTMLImageElement.prototype) {
				let i = document.querySelectorAll('[loading="lazy"]');
				for (let t of i) t.removeEventListener("load", a_, {
					once: !0
				}), t.removeEventListener("error", o_, {
					once: !0
				})
			}
		};
	var Rc = class extends pe {
		constructor(i) {
			super(i)
		}
		init() {
			var t, e;
			this.load = new s_({
				enterDelay: 250,
				transitions: {
					listing: {
						loadingClass: "is-loading-transition-listing",
						enterDelay: 250
					}
				}
			});
			let i = new CustomEvent(Ce.READY);
			if ((t = this.load) == null || t.on("loaded", (n, r, s) => {
					this.call("destroy", r, "app"), this.call("update", s, "app"), window.dispatchEvent(i), n === "listing" && (this.call("addScrollElements", s, "Scroll"), setTimeout(() => {
						var h;
						let o = document.querySelector(".c-filters");
						this.call("update", null, "Scroll"), this.call("scrollTo", {
							target: o,
							offset: -120,
							duration: .5
						}, "Scroll"), (h = s.querySelector(".c-thumb_link")) == null || h.focus(), setTimeout(() => {
							this.call("unlockReduced", null, "Header")
						}, .5 * 1e3)
					}, 100)), kc()
				}), (e = this.load) == null || e.on("loading", (n, r) => {
					l_(), n === "listing" ? (this.call("removeScrollElements", r, "Scroll"), this.call("lockReduced", !0, "Header")) : this.call("start", null, "Loader")
				}), !ie.IS_TOUCH) {
				let n = !1,
					r = !1;
				document.addEventListener("keydown", s => {
					["ShiftLeft", "AltLeft"].includes(s.code) ? n = !0 : s.code == "Tab" && (r = !0)
				}), document.addEventListener("keyup", s => {
					["ShiftLeft", "AltLeft"].includes(s.code) ? n = !1 : s.code == "Tab" && (r = !1)
				}), document.addEventListener("focusin", () => {
					if (n && r) {
						let s = document.activeElement;
						(s == null ? void 0 : s.getBoundingClientRect().top) < di.headerHeight && requestAnimationFrame(() => {
							this.call("scrollTo", {
								target: s,
								immediate: !0
							}, "Scroll")
						})
					}
				}, !0)
			}
		}
		goTo(i) {
			var t;
			(t = this.load) == null || t.goTo(i.url, i.transition)
		}
	};
	var h_ = yl(mf(), 1);
	var vs = class extends pe {
		static get settings() {
			return {
				CLASS_HIDDEN: "is-hidden"
			}
		}
		constructor(t) {
			super(t), this.$el = this.el, this.$icon = this.$("icon")[0]
		}
		init() {
			ie.REDUCED_MOTION || (this.iconAnimation = h_.default.loadAnimation({
				container: this.$icon,
				path: "/assets/lottie/icon.json",
				renderer: "svg",
				loop: !0,
				autoplay: !1
			})), this.start(), window.addEventListener(Ce.READY, this.onReady = () => this.stop())
		}
		start() {
			var t;
			this.$el.classList.remove(vs.settings.CLASS_HIDDEN), (t = this.iconAnimation) == null || t.play()
		}
		stop() {
			var t;
			this.$el.classList.add(vs.settings.CLASS_HIDDEN), (t = this.iconAnimation) == null || t.pause()
		}
	};
	var u_ = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"],
		Fc = u_.join(","),
		d_ = typeof Element == "undefined",
		ha = d_ ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector,
		Oc = !d_ && Element.prototype.getRootNode ? function (i) {
			var t;
			return i == null || (t = i.getRootNode) === null || t === void 0 ? void 0 : t.call(i)
		} : function (i) {
			return i == null ? void 0 : i.ownerDocument
		},
		Nc = function i(t, e) {
			var n;
			e === void 0 && (e = !0);
			var r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "inert"),
				s = r === "" || r === "true",
				a = s || e && t && i(t.parentNode);
			return a
		},
		JE = function (t) {
			var e, n = t == null || (e = t.getAttribute) === null || e === void 0 ? void 0 : e.call(t, "contenteditable");
			return n === "" || n === "true"
		},
		p_ = function (t, e, n) {
			if (Nc(t)) return [];
			var r = Array.prototype.slice.apply(t.querySelectorAll(Fc));
			return e && ha.call(t, Fc) && r.unshift(t), r = r.filter(n), r
		},
		f_ = function i(t, e, n) {
			for (var r = [], s = Array.from(t); s.length;) {
				var a = s.shift();
				if (!Nc(a, !1))
					if (a.tagName === "SLOT") {
						var o = a.assignedElements(),
							h = o.length ? o : a.children,
							c = i(h, !0, n);
						n.flatten ? r.push.apply(r, c) : r.push({
							scopeParent: a,
							candidates: c
						})
					} else {
						var u = ha.call(a, Fc);
						u && n.filter(a) && (e || !t.includes(a)) && r.push(a);
						var g = a.shadowRoot || typeof n.getShadowRoot == "function" && n.getShadowRoot(a),
							p = !Nc(g, !1) && (!n.shadowRootFilter || n.shadowRootFilter(a));
						if (g && p) {
							var _ = i(g === !0 ? a.children : g.children, !0, n);
							n.flatten ? r.push.apply(r, _) : r.push({
								scopeParent: a,
								candidates: _
							})
						} else s.unshift.apply(s, a.children)
					}
			}
			return r
		},
		m_ = function (t) {
			return !isNaN(parseInt(t.getAttribute("tabindex"), 10))
		},
		gs = function (t) {
			if (!t) throw new Error("No node provided");
			return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || JE(t)) && !m_(t) ? 0 : t.tabIndex
		},
		QE = function (t, e) {
			var n = gs(t);
			return n < 0 && e && !m_(t) ? 0 : n
		},
		tM = function (t, e) {
			return t.tabIndex === e.tabIndex ? t.documentOrder - e.documentOrder : t.tabIndex - e.tabIndex
		},
		v_ = function (t) {
			return t.tagName === "INPUT"
		},
		eM = function (t) {
			return v_(t) && t.type === "hidden"
		},
		iM = function (t) {
			var e = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function (n) {
				return n.tagName === "SUMMARY"
			});
			return e
		},
		nM = function (t, e) {
			for (var n = 0; n < t.length; n++)
				if (t[n].checked && t[n].form === e) return t[n]
		},
		rM = function (t) {
			if (!t.name) return !0;
			var e = t.form || Oc(t),
				n = function (o) {
					return e.querySelectorAll('input[type="radio"][name="' + o + '"]')
				},
				r;
			if (typeof window != "undefined" && typeof window.CSS != "undefined" && typeof window.CSS.escape == "function") r = n(window.CSS.escape(t.name));
			else try {
				r = n(t.name)
			} catch (a) {
				return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1
			}
			var s = nM(r, t.form);
			return !s || s === t
		},
		sM = function (t) {
			return v_(t) && t.type === "radio"
		},
		aM = function (t) {
			return sM(t) && !rM(t)
		},
		oM = function (t) {
			var e, n = t && Oc(t),
				r = (e = n) === null || e === void 0 ? void 0 : e.host,
				s = !1;
			if (n && n !== t) {
				var a, o, h;
				for (s = !!((a = r) !== null && a !== void 0 && (o = a.ownerDocument) !== null && o !== void 0 && o.contains(r) || t != null && (h = t.ownerDocument) !== null && h !== void 0 && h.contains(t)); !s && r;) {
					var c, u, g;
					n = Oc(r), r = (c = n) === null || c === void 0 ? void 0 : c.host, s = !!((u = r) !== null && u !== void 0 && (g = u.ownerDocument) !== null && g !== void 0 && g.contains(r))
				}
			}
			return s
		},
		c_ = function (t) {
			var e = t.getBoundingClientRect(),
				n = e.width,
				r = e.height;
			return n === 0 && r === 0
		},
		lM = function (t, e) {
			var n = e.displayCheck,
				r = e.getShadowRoot;
			if (getComputedStyle(t).visibility === "hidden") return !0;
			var s = ha.call(t, "details>summary:first-of-type"),
				a = s ? t.parentElement : t;
			if (ha.call(a, "details:not([open]) *")) return !0;
			if (!n || n === "full" || n === "legacy-full") {
				if (typeof r == "function") {
					for (var o = t; t;) {
						var h = t.parentElement,
							c = Oc(t);
						if (h && !h.shadowRoot && r(h) === !0) return c_(t);
						t.assignedSlot ? t = t.assignedSlot : !h && c !== t.ownerDocument ? t = c.host : t = h
					}
					t = o
				}
				if (oM(t)) return !t.getClientRects().length;
				if (n !== "legacy-full") return !0
			} else if (n === "non-zero-area") return c_(t);
			return !1
		},
		hM = function (t) {
			if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
				for (var e = t.parentElement; e;) {
					if (e.tagName === "FIELDSET" && e.disabled) {
						for (var n = 0; n < e.children.length; n++) {
							var r = e.children.item(n);
							if (r.tagName === "LEGEND") return ha.call(e, "fieldset[disabled] *") ? !0 : !r.contains(t)
						}
						return !0
					}
					e = e.parentElement
				}
			return !1
		},
		Vc = function (t, e) {
			return !(e.disabled || Nc(e) || eM(e) || lM(e, t) || iM(e) || hM(e))
		},
		vf = function (t, e) {
			return !(aM(e) || gs(e) < 0 || !Vc(t, e))
		},
		cM = function (t) {
			var e = parseInt(t.getAttribute("tabindex"), 10);
			return !!(isNaN(e) || e >= 0)
		},
		uM = function i(t) {
			var e = [],
				n = [];
			return t.forEach(function (r, s) {
				var a = !!r.scopeParent,
					o = a ? r.scopeParent : r,
					h = QE(o, a),
					c = a ? i(r.candidates) : o;
				h === 0 ? a ? e.push.apply(e, c) : e.push(o) : n.push({
					documentOrder: s,
					tabIndex: h,
					item: r,
					isScope: a,
					content: c
				})
			}), n.sort(tM).reduce(function (r, s) {
				return s.isScope ? r.push.apply(r, s.content) : r.push(s.content), r
			}, []).concat(e)
		},
		g_ = function (t, e) {
			e = e || {};
			var n;
			return e.getShadowRoot ? n = f_([t], e.includeContainer, {
				filter: vf.bind(null, e),
				flatten: !1,
				getShadowRoot: e.getShadowRoot,
				shadowRootFilter: cM
			}) : n = p_(t, e.includeContainer, vf.bind(null, e)), uM(n)
		},
		__ = function (t, e) {
			e = e || {};
			var n;
			return e.getShadowRoot ? n = f_([t], e.includeContainer, {
				filter: Vc.bind(null, e),
				flatten: !0,
				getShadowRoot: e.getShadowRoot
			}) : n = p_(t, e.includeContainer, Vc.bind(null, e)), n
		},
		ca = function (t, e) {
			if (e = e || {}, !t) throw new Error("No node provided");
			return ha.call(t, Fc) === !1 ? !1 : vf(e, t)
		},
		dM = u_.concat("iframe").join(","),
		zc = function (t, e) {
			if (e = e || {}, !t) throw new Error("No node provided");
			return ha.call(t, dM) === !1 ? !1 : Vc(e, t)
		};

	function y_(i, t) {
		var e = Object.keys(i);
		if (Object.getOwnPropertySymbols) {
			var n = Object.getOwnPropertySymbols(i);
			t && (n = n.filter(function (r) {
				return Object.getOwnPropertyDescriptor(i, r).enumerable
			})), e.push.apply(e, n)
		}
		return e
	}

	function b_(i) {
		for (var t = 1; t < arguments.length; t++) {
			var e = arguments[t] != null ? arguments[t] : {};
			t % 2 ? y_(Object(e), !0).forEach(function (n) {
				pM(i, n, e[n])
			}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : y_(Object(e)).forEach(function (n) {
				Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
			})
		}
		return i
	}

	function pM(i, t, e) {
		return t = mM(t), t in i ? Object.defineProperty(i, t, {
			value: e,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : i[t] = e, i
	}

	function fM(i, t) {
		if (typeof i != "object" || i === null) return i;
		var e = i[Symbol.toPrimitive];
		if (e !== void 0) {
			var n = e.call(i, t || "default");
			if (typeof n != "object") return n;
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(i)
	}

	function mM(i) {
		var t = fM(i, "string");
		return typeof t == "symbol" ? t : String(t)
	}
	var x_ = {
			activateTrap: function (t, e) {
				if (t.length > 0) {
					var n = t[t.length - 1];
					n !== e && n.pause()
				}
				var r = t.indexOf(e);
				r === -1 || t.splice(r, 1), t.push(e)
			},
			deactivateTrap: function (t, e) {
				var n = t.indexOf(e);
				n !== -1 && t.splice(n, 1), t.length > 0 && t[t.length - 1].unpause()
			}
		},
		vM = function (t) {
			return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function"
		},
		gM = function (t) {
			return (t == null ? void 0 : t.key) === "Escape" || (t == null ? void 0 : t.key) === "Esc" || (t == null ? void 0 : t.keyCode) === 27
		},
		Hl = function (t) {
			return (t == null ? void 0 : t.key) === "Tab" || (t == null ? void 0 : t.keyCode) === 9
		},
		_M = function (t) {
			return Hl(t) && !t.shiftKey
		},
		yM = function (t) {
			return Hl(t) && t.shiftKey
		},
		w_ = function (t) {
			return setTimeout(t, 0)
		},
		S_ = function (t, e) {
			var n = -1;
			return t.every(function (r, s) {
				return e(r) ? (n = s, !1) : !0
			}), n
		},
		Gl = function (t) {
			for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
			return typeof t == "function" ? t.apply(void 0, n) : t
		},
		Bc = function (t) {
			return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target
		},
		bM = [],
		E_ = function (t, e) {
			var n = (e == null ? void 0 : e.document) || document,
				r = (e == null ? void 0 : e.trapStack) || bM,
				s = b_({
					returnFocusOnDeactivate: !0,
					escapeDeactivates: !0,
					delayInitialFocus: !0,
					isKeyForward: _M,
					isKeyBackward: yM
				}, e),
				a = {
					containers: [],
					containerGroups: [],
					tabbableGroups: [],
					nodeFocusedBeforeActivation: null,
					mostRecentlyFocusedNode: null,
					active: !1,
					paused: !1,
					delayInitialFocusTimer: void 0,
					recentNavEvent: void 0
				},
				o, h = function (U, z, $) {
					return U && U[z] !== void 0 ? U[z] : s[$ || z]
				},
				c = function (U, z) {
					var $ = typeof (z == null ? void 0 : z.composedPath) == "function" ? z.composedPath() : void 0;
					return a.containerGroups.findIndex(function (W) {
						var O = W.container,
							B = W.tabbableNodes;
						return O.contains(U) || ($ == null ? void 0 : $.includes(O)) || B.find(function (A) {
							return A === U
						})
					})
				},
				u = function (U) {
					var z = s[U];
					if (typeof z == "function") {
						for (var $ = arguments.length, W = new Array($ > 1 ? $ - 1 : 0), O = 1; O < $; O++) W[O - 1] = arguments[O];
						z = z.apply(void 0, W)
					}
					if (z === !0 && (z = void 0), !z) {
						if (z === void 0 || z === !1) return z;
						throw new Error("`".concat(U, "` was specified but was not a node, or did not return a node"))
					}
					var B = z;
					if (typeof z == "string" && (B = n.querySelector(z), !B)) throw new Error("`".concat(U, "` as selector refers to no known node"));
					return B
				},
				g = function () {
					var U = u("initialFocus");
					if (U === !1) return !1;
					if (U === void 0 || !zc(U, s.tabbableOptions))
						if (c(n.activeElement) >= 0) U = n.activeElement;
						else {
							var z = a.tabbableGroups[0],
								$ = z && z.firstTabbableNode;
							U = $ || u("fallbackFocus")
						} if (!U) throw new Error("Your focus-trap needs to have at least one focusable element");
					return U
				},
				p = function () {
					if (a.containerGroups = a.containers.map(function (U) {
							var z = g_(U, s.tabbableOptions),
								$ = __(U, s.tabbableOptions),
								W = z.length > 0 ? z[0] : void 0,
								O = z.length > 0 ? z[z.length - 1] : void 0,
								B = $.find(function (H) {
									return ca(H)
								}),
								A = $.slice().reverse().find(function (H) {
									return ca(H)
								}),
								D = !!z.find(function (H) {
									return gs(H) > 0
								});
							return {
								container: U,
								tabbableNodes: z,
								focusableNodes: $,
								posTabIndexesFound: D,
								firstTabbableNode: W,
								lastTabbableNode: O,
								firstDomTabbableNode: B,
								lastDomTabbableNode: A,
								nextTabbableNode: function (q) {
									var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
										tt = z.indexOf(q);
									return tt < 0 ? Q ? $.slice($.indexOf(q) + 1).find(function (nt) {
										return ca(nt)
									}) : $.slice(0, $.indexOf(q)).reverse().find(function (nt) {
										return ca(nt)
									}) : z[tt + (Q ? 1 : -1)]
								}
							}
						}), a.tabbableGroups = a.containerGroups.filter(function (U) {
							return U.tabbableNodes.length > 0
						}), a.tabbableGroups.length <= 0 && !u("fallbackFocus")) throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
					if (a.containerGroups.find(function (U) {
							return U.posTabIndexesFound
						}) && a.containerGroups.length > 1) throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")
				},
				_ = function j(U) {
					var z = U.activeElement;
					if (z) return z.shadowRoot && z.shadowRoot.activeElement !== null ? j(z.shadowRoot) : z
				},
				b = function j(U) {
					if (U !== !1 && U !== _(document)) {
						if (!U || !U.focus) {
							j(g());
							return
						}
						U.focus({
							preventScroll: !!s.preventScroll
						}), a.mostRecentlyFocusedNode = U, vM(U) && U.select()
					}
				},
				y = function (U) {
					var z = u("setReturnFocus", U);
					return z || (z === !1 ? !1 : U)
				},
				w = function (U) {
					var z = U.target,
						$ = U.event,
						W = U.isBackward,
						O = W === void 0 ? !1 : W;
					z = z || Bc($), p();
					var B = null;
					if (a.tabbableGroups.length > 0) {
						var A = c(z, $),
							D = A >= 0 ? a.containerGroups[A] : void 0;
						if (A < 0) O ? B = a.tabbableGroups[a.tabbableGroups.length - 1].lastTabbableNode : B = a.tabbableGroups[0].firstTabbableNode;
						else if (O) {
							var H = S_(a.tabbableGroups, function (et) {
								var it = et.firstTabbableNode;
								return z === it
							});
							if (H < 0 && (D.container === z || zc(z, s.tabbableOptions) && !ca(z, s.tabbableOptions) && !D.nextTabbableNode(z, !1)) && (H = A), H >= 0) {
								var q = H === 0 ? a.tabbableGroups.length - 1 : H - 1,
									Q = a.tabbableGroups[q];
								B = gs(z) >= 0 ? Q.lastTabbableNode : Q.lastDomTabbableNode
							} else Hl($) || (B = D.nextTabbableNode(z, !1))
						} else {
							var tt = S_(a.tabbableGroups, function (et) {
								var it = et.lastTabbableNode;
								return z === it
							});
							if (tt < 0 && (D.container === z || zc(z, s.tabbableOptions) && !ca(z, s.tabbableOptions) && !D.nextTabbableNode(z)) && (tt = A), tt >= 0) {
								var nt = tt === a.tabbableGroups.length - 1 ? 0 : tt + 1,
									ut = a.tabbableGroups[nt];
								B = gs(z) >= 0 ? ut.firstTabbableNode : ut.firstDomTabbableNode
							} else Hl($) || (B = D.nextTabbableNode(z))
						}
					} else B = u("fallbackFocus");
					return B
				},
				f = function (U) {
					var z = Bc(U);
					if (!(c(z, U) >= 0)) {
						if (Gl(s.clickOutsideDeactivates, U)) {
							o.deactivate({
								returnFocus: s.returnFocusOnDeactivate
							});
							return
						}
						Gl(s.allowOutsideClick, U) || U.preventDefault()
					}
				},
				S = function (U) {
					var z = Bc(U),
						$ = c(z, U) >= 0;
					if ($ || z instanceof Document) $ && (a.mostRecentlyFocusedNode = z);
					else {
						U.stopImmediatePropagation();
						var W, O = !0;
						if (a.mostRecentlyFocusedNode)
							if (gs(a.mostRecentlyFocusedNode) > 0) {
								var B = c(a.mostRecentlyFocusedNode),
									A = a.containerGroups[B].tabbableNodes;
								if (A.length > 0) {
									var D = A.findIndex(function (H) {
										return H === a.mostRecentlyFocusedNode
									});
									D >= 0 && (s.isKeyForward(a.recentNavEvent) ? D + 1 < A.length && (W = A[D + 1], O = !1) : D - 1 >= 0 && (W = A[D - 1], O = !1))
								}
							} else a.containerGroups.some(function (H) {
								return H.tabbableNodes.some(function (q) {
									return gs(q) > 0
								})
							}) || (O = !1);
						else O = !1;
						O && (W = w({
							target: a.mostRecentlyFocusedNode,
							isBackward: s.isKeyBackward(a.recentNavEvent)
						})), b(W || a.mostRecentlyFocusedNode || g())
					}
					a.recentNavEvent = void 0
				},
				x = function (U) {
					var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
					a.recentNavEvent = U;
					var $ = w({
						event: U,
						isBackward: z
					});
					$ && (Hl(U) && U.preventDefault(), b($))
				},
				M = function (U) {
					if (gM(U) && Gl(s.escapeDeactivates, U) !== !1) {
						U.preventDefault(), o.deactivate();
						return
					}(s.isKeyForward(U) || s.isKeyBackward(U)) && x(U, s.isKeyBackward(U))
				},
				T = function (U) {
					var z = Bc(U);
					c(z, U) >= 0 || Gl(s.clickOutsideDeactivates, U) || Gl(s.allowOutsideClick, U) || (U.preventDefault(), U.stopImmediatePropagation())
				},
				I = function () {
					if (a.active) return x_.activateTrap(r, o), a.delayInitialFocusTimer = s.delayInitialFocus ? w_(function () {
						b(g())
					}) : b(g()), n.addEventListener("focusin", S, !0), n.addEventListener("mousedown", f, {
						capture: !0,
						passive: !1
					}), n.addEventListener("touchstart", f, {
						capture: !0,
						passive: !1
					}), n.addEventListener("click", T, {
						capture: !0,
						passive: !1
					}), n.addEventListener("keydown", M, {
						capture: !0,
						passive: !1
					}), o
				},
				L = function () {
					if (a.active) return n.removeEventListener("focusin", S, !0), n.removeEventListener("mousedown", f, !0), n.removeEventListener("touchstart", f, !0), n.removeEventListener("click", T, !0), n.removeEventListener("keydown", M, !0), o
				},
				F = function (U) {
					var z = U.some(function ($) {
						var W = Array.from($.removedNodes);
						return W.some(function (O) {
							return O === a.mostRecentlyFocusedNode
						})
					});
					z && b(g())
				},
				k = typeof window != "undefined" && "MutationObserver" in window ? new MutationObserver(F) : void 0,
				G = function () {
					k && (k.disconnect(), a.active && !a.paused && a.containers.map(function (U) {
						k.observe(U, {
							subtree: !0,
							childList: !0
						})
					}))
				};
			return o = {
				get active() {
					return a.active
				},
				get paused() {
					return a.paused
				},
				activate: function (U) {
					if (a.active) return this;
					var z = h(U, "onActivate"),
						$ = h(U, "onPostActivate"),
						W = h(U, "checkCanFocusTrap");
					W || p(), a.active = !0, a.paused = !1, a.nodeFocusedBeforeActivation = n.activeElement, z == null || z();
					var O = function () {
						W && p(), I(), G(), $ == null || $()
					};
					return W ? (W(a.containers.concat()).then(O, O), this) : (O(), this)
				},
				deactivate: function (U) {
					if (!a.active) return this;
					var z = b_({
						onDeactivate: s.onDeactivate,
						onPostDeactivate: s.onPostDeactivate,
						checkCanReturnFocus: s.checkCanReturnFocus
					}, U);
					clearTimeout(a.delayInitialFocusTimer), a.delayInitialFocusTimer = void 0, L(), a.active = !1, a.paused = !1, G(), x_.deactivateTrap(r, o);
					var $ = h(z, "onDeactivate"),
						W = h(z, "onPostDeactivate"),
						O = h(z, "checkCanReturnFocus"),
						B = h(z, "returnFocus", "returnFocusOnDeactivate");
					$ == null || $();
					var A = function () {
						w_(function () {
							B && b(y(a.nodeFocusedBeforeActivation)), W == null || W()
						})
					};
					return B && O ? (O(y(a.nodeFocusedBeforeActivation)).then(A, A), this) : (A(), this)
				},
				pause: function (U) {
					if (a.paused || !a.active) return this;
					var z = h(U, "onPause"),
						$ = h(U, "onPostPause");
					return a.paused = !0, z == null || z(), L(), G(), $ == null || $(), this
				},
				unpause: function (U) {
					if (!a.paused || !a.active) return this;
					var z = h(U, "onUnpause"),
						$ = h(U, "onPostUnpause");
					return a.paused = !1, z == null || z(), p(), I(), G(), $ == null || $(), this
				},
				updateContainerElements: function (U) {
					var z = [].concat(U).filter(Boolean);
					return a.containers = z.map(function ($) {
						return typeof $ == "string" ? n.querySelector($) : $
					}), a.active && p(), G(), this
				}
			}, o.updateContainerElements(t), o
		};
	var ji = class extends pe {
		static get settings() {
			return {
				ACTIVE_CLASS: "is-open"
			}
		}
		constructor(t) {
			var e;
			super(t), this.moduleName = t.name, this.$el = this.el, this.$close = (e = this.$("close")) == null ? void 0 : e[0], this.events = {
				click: {
					close: "close"
				}
			}, this.closeBind = n => {
				n.key === "Escape" && this.close()
			}, this.toggler = null, this.focusTrapOptions = {
				checkCanFocusTrap: n => {
					let r = n.map(s => new Promise(a => {
						let o = setInterval(() => {
							getComputedStyle(s).visibility !== "hidden" && (a(), clearInterval(o))
						}, 5)
					}));
					return Promise.all(r)
				},
				onActivate: () => {
					this.$el.classList.add(ji.settings.ACTIVE_CLASS), this.$el.setAttribute("aria-hidden", !1), setTimeout(() => {
						var n;
						(n = this.$close) == null || n.focus()
					}, 300)
				},
				onPostActivate: () => {
					this.toggler && this.toggler.setAttribute("aria-expanded", !0)
				},
				onDeactivate: () => {
					this.$el.classList.remove(ji.settings.ACTIVE_CLASS), this.$el.setAttribute("aria-hidden", !0)
				},
				onPostDeactivate: () => {
					this.toggler && (this.toggler.setAttribute("aria-expanded", !1), this.toggler = null)
				}
			}, this.isOpen = !1
		}
		init() {
			var e;
			let t = this.$focusTrapContainer || this.$el;
			this.focusTrap = E_(t, this.focusTrapOptions), (e = this.onInit) == null || e.call(this)
		}
		toggle(t) {
			t && (this.toggler = t), this.isOpen ? this.close() : this.open()
		}
		open(t) {
			var e, n, r;
			this.isOpen || (this.isOpen = !0, (n = (e = this.focusTrap) == null ? void 0 : e.activate) == null || n.call(e), document.addEventListener("keyup", this.closeBind), this.call("lock", !0, "Scroll"), this.call("setFocusable", !1, "SkipLink"), (r = this.onOpen) == null || r.call(this, t))
		}
		close(t) {
			var e, n, r;
			this.isOpen && (this.isOpen = !1, (n = (e = this.focusTrap) == null ? void 0 : e.deactivate) == null || n.call(e), document.removeEventListener("keyup", this.closeBind), this.call("lock", !1, "Scroll"), this.call("setFocusable", !0, "SkipLink"), (r = this.onClose) == null || r.call(this, t))
		}
		destroy() {
			var t, e, n;
			(e = (t = this.focusTrap) == null ? void 0 : t.deactivate) == null || e.call(t, {
				returnFocus: !1
			}), this.close(), (n = this.onDestroy) == null || n.call(this), super.destroy()
		}
	};
	var Wl = class extends ji {
		constructor(t) {
			super(t), this.events = {
				click: {
					open: "open",
					close: "close"
				}
			}
		}
		onClose() {
			this.call("closeAreas", null, "Header")
		}
	};
	var Xi = document.documentElement,
		Uk = document.body,
		M_ = document.getElementById("header"),
		Gk = document.getElementById("loader"),
		Hk = document.getElementById("loader-intro");
	var nr = class extends ji {
		static get settings() {
			return {
				CLASS_OPEN: "has-menu-open",
				CLASS_ITEM_ACTIVE: "is-active"
			}
		}
		constructor(t) {
			super(t), this.$items = Array.from(this.$("item")), this.$focusTrapContainer = M_, this.activeMenuItemIndex = 0, this.events = {
				click: {
					open: "open",
					close: "close"
				},
				mouseenter: {
					item: "onItemHover"
				}
			}
		}
		onInit() {
			window.addEventListener(Ce.RESIZE_END, this.onResize = () => this.close())
		}
		onOpen() {
			Xi.classList.add(nr.settings.CLASS_OPEN), this.setItem(this.activeMenuItemIndex, !0), this.call("onMenuOpen", null, "Header")
		}
		onClose() {
			Xi.classList.remove(nr.settings.CLASS_OPEN), this.call("animate", -1, "SceneMenu"), this.call("onMenuClose", null, "Header")
		}
		toggle() {
			this.isOpen ? this.close() : this.open()
		}
		onItemHover(t) {
			let e = this.$items.findIndex(n => n === t.curTarget);
			e >= 0 && this.setItem(e)
		}
		setItem(t, e = !1) {
			var n, r;
			this.activeMenuItemIndex === t && !e || (this.activeMenuItemIndex >= 0 && ((n = this.$items[this.activeMenuItemIndex]) == null || n.classList.remove(nr.settings.CLASS_ITEM_ACTIVE)), (r = this.$items[t]) == null || r.classList.add(nr.settings.CLASS_ITEM_ACTIVE), this.call("animate", t, "SceneMenu"), this.activeMenuItemIndex = t)
		}
	};
	var $l = class extends ji {
		constructor(t) {
			super(t), this.$el = this.el, this.$image = this.$("image")[0], this.$title = this.$("title")[0], this.$position = this.$("position")[0], this.$tags = this.$("tags")[0], this.$content = this.$("content")[0], this.MEMBERS = JSON.parse(this.getData("json")), this.events = {
				click: {
					close: "close"
				}
			}
		}
		onOpen(t = null) {
			let e = this.MEMBERS.find(r => r.id === t);
			if (typeof e == "undefined") return;
			let n = e.image;
			if (typeof n.src != "undefined")
				for (let r in n) this.$image.setAttribute(r, n[r]);
			for (let r of e.categories) this.$tags.innerHTML += `
                <li class="o-tag-list_item">
                    <span class="o-tag | o-text-small">
                        ${r.title}
                    </span>
                </li>
            `;
			this.$title.innerHTML = e.title, this.$position.innerHTML = e.position, this.$content.innerHTML = e.content
		}
		onClose() {
			this.$image.src = "", this.$title.innerHTML = "", this.$position.innerHTML = "", this.$tags.innerHTML = "", this.$content.innerHTML = ""
		}
	};
	var Uc = class extends pe {
		constructor(i) {
			super(i), this.id = this.getData("id"), getComputedStyle(this.el).getPropertyValue("--modal-team-trigger-enabled") === "true" && (this.events = {
				click: {
					toggler: "open"
				}
			})
		}
		open(i) {
			i.preventDefault(), this.call("open", this.id, "ModalTeam")
		}
	};
	var ql = class extends ji {
		constructor(t) {
			super(t), this.$el = this.el, this.$video = this.$("video")[0], this.events = {
				click: {
					close: "close"
				}
			}
		}
		onOpen(t) {
			this.emptyTimeout && clearTimeout(this.emptyTimeout), this.appendDelay = setTimeout(() => {
				var e;
				switch (t.host) {
					case "youtube":
						this.$video.innerHTML = `<iframe src="https://www.youtube.com/embed/${t.id}?&autoplay=1" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
						break;
					case "vimeo":
						this.$video.innerHTML = `<iframe src="https://player.vimeo.com/video/${t.id}?autoplay=1&loop=1&autopause=0" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
						break;
					case "mp4":
						this.$video.innerHTML = `<video src="${t.id}" autoplay controls></video>`;
						break;
					default:
						break
				}(e = this.focusTrap) == null || e.updateContainerElements(this.$el)
			}, 300)
		}
		onClose() {
			clearTimeout(this.appendDelay), this.$video.innerHTML = ""
		}
	};
	var Gc = class extends pe {
		constructor(i) {
			super(i), this.data = {
				id: this.getData("id"),
				host: this.getData("host")
			}, this.events = {
				click: {
					toggler: "open"
				}
			}
		}
		open(i) {
			i.preventDefault(), this.call("open", this.data, "ModalVideo")
		}
	};
	var Hc = class extends pe {
		constructor(i) {
			super(i), this.$rail = this.el, this.$railInner = this.$("inner")[0], this.$railContent = this.$("content")[0], this.isRolling = !1
		}
		init() {
			ie.REDUCED_MOTION || (this.set(), ns(Yn.EAGER).then(() => this.set()), window.addEventListener(Ce.RESIZE_END, this.onResize = () => this.set()))
		}
		set() {
			let i = this.$rail.offsetWidth,
				t = this.$railContent.offsetWidth,
				e = t;
			for (; this.$railInner.children.length > 1;) this.$railInner.removeChild(this.$railInner.lastChild);
			let n;
			for (; e < 4 * i;) n = this.$railContent.cloneNode(!0), this.$railInner.appendChild(n), e += t;
			let r = 0;
			for (; r < i;) r += t;
			this.tl = ne.fromTo(this.$railInner, {
				x: 0
			}, {
				x: -r,
				duration: r / 100,
				ease: "none",
				repeat: -1,
				paused: !0
			}), this.tl.progress(.5)
		}
		updateVelocity(i) {
			ie.REDUCED_MOTION || i <= 0 || !this.isRolling || (i = .4 * i + 1, this.tl.timeScale(i))
		}
		toggle(i) {
			var t, e;
			ie.REDUCED_MOTION || (this.isRolling = i.way === "enter", this.tl && (this.isRolling ? (t = this.tl) == null || t.play() : (e = this.tl) == null || e.pause()))
		}
		destroy() {
			ie.REDUCED_MOTION || window.removeEventListener(Ce.RESIZE_END, this.onResize)
		}
	};
	var Mm = "151";
	var xM = 0,
		C_ = 1,
		wM = 2;
	var Yy = 1,
		SM = 2,
		Zl = 3,
		Es = 0,
		Zi = 1,
		Or = 2;
	var Ss = 0,
		Co = 1,
		T_ = 2,
		P_ = 3,
		A_ = 4,
		EM = 5,
		Eo = 100,
		MM = 101,
		CM = 102,
		D_ = 103,
		I_ = 104,
		TM = 200,
		PM = 201,
		AM = 202,
		DM = 203,
		Ky = 204,
		Zy = 205,
		IM = 206,
		LM = 207,
		kM = 208,
		RM = 209,
		FM = 210,
		OM = 0,
		NM = 1,
		VM = 2,
		Xf = 3,
		zM = 4,
		BM = 5,
		UM = 6,
		GM = 7,
		Jy = 0,
		HM = 1,
		WM = 2,
		Vr = 0,
		$M = 1,
		qM = 2,
		jM = 3,
		XM = 4,
		YM = 5,
		Qy = 300,
		Do = 301,
		Io = 302,
		Yf = 303,
		Kf = 304,
		Ou = 306,
		Zf = 1e3,
		Vn = 1001,
		Jf = 1002,
		Fi = 1003,
		L_ = 1004;
	var gf = 1005;
	var Mn = 1006,
		KM = 1007;
	var th = 1008;
	var ya = 1009,
		ZM = 1010,
		JM = 1011,
		tb = 1012,
		QM = 1013,
		va = 1014,
		ga = 1015,
		eh = 1016,
		tC = 1017,
		eC = 1018,
		To = 1020,
		iC = 1021,
		zn = 1023,
		nC = 1024,
		rC = 1025,
		_a = 1026,
		Lo = 1027,
		sC = 1028,
		aC = 1029,
		oC = 1030,
		lC = 1031,
		hC = 1033,
		_f = 33776,
		yf = 33777,
		bf = 33778,
		xf = 33779,
		k_ = 35840,
		R_ = 35841,
		F_ = 35842,
		O_ = 35843,
		cC = 36196,
		N_ = 37492,
		V_ = 37496,
		z_ = 37808,
		B_ = 37809,
		U_ = 37810,
		G_ = 37811,
		H_ = 37812,
		W_ = 37813,
		$_ = 37814,
		q_ = 37815,
		j_ = 37816,
		X_ = 37817,
		Y_ = 37818,
		K_ = 37819,
		Z_ = 37820,
		J_ = 37821,
		wf = 36492,
		uC = 36283,
		Q_ = 36284,
		ty = 36285,
		ey = 36286;
	var gu = 2300,
		_u = 2301,
		Sf = 2302,
		iy = 2400,
		ny = 2401,
		ry = 2402;
	var ba = 3e3,
		ze = 3001,
		dC = 3200,
		pC = 3201,
		fC = 0,
		mC = 1;
	var sr = "srgb",
		ih = "srgb-linear",
		eb = "display-p3";
	var Ef = 7680;
	var vC = 519,
		sy = 35044;
	var ay = "300 es",
		Qf = 1035,
		Ms = class {
			addEventListener(t, e) {
				this._listeners === void 0 && (this._listeners = {});
				let n = this._listeners;
				n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e)
			}
			hasEventListener(t, e) {
				if (this._listeners === void 0) return !1;
				let n = this._listeners;
				return n[t] !== void 0 && n[t].indexOf(e) !== -1
			}
			removeEventListener(t, e) {
				if (this._listeners === void 0) return;
				let r = this._listeners[t];
				if (r !== void 0) {
					let s = r.indexOf(e);
					s !== -1 && r.splice(s, 1)
				}
			}
			dispatchEvent(t) {
				if (this._listeners === void 0) return;
				let n = this._listeners[t.type];
				if (n !== void 0) {
					t.target = this;
					let r = n.slice(0);
					for (let s = 0, a = r.length; s < a; s++) r[s].call(this, t);
					t.target = null
				}
			}
		},
		Ei = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
	var vu = Math.PI / 180,
		tm = 180 / Math.PI;

	function oh() {
		let i = Math.random() * 4294967295 | 0,
			t = Math.random() * 4294967295 | 0,
			e = Math.random() * 4294967295 | 0,
			n = Math.random() * 4294967295 | 0;
		return (Ei[i & 255] + Ei[i >> 8 & 255] + Ei[i >> 16 & 255] + Ei[i >> 24 & 255] + "-" + Ei[t & 255] + Ei[t >> 8 & 255] + "-" + Ei[t >> 16 & 15 | 64] + Ei[t >> 24 & 255] + "-" + Ei[e & 63 | 128] + Ei[e >> 8 & 255] + "-" + Ei[e >> 16 & 255] + Ei[e >> 24 & 255] + Ei[n & 255] + Ei[n >> 8 & 255] + Ei[n >> 16 & 255] + Ei[n >> 24 & 255]).toLowerCase()
	}

	function Yi(i, t, e) {
		return Math.max(t, Math.min(e, i))
	}

	function gC(i, t) {
		return (i % t + t) % t
	}

	function Mf(i, t, e) {
		return (1 - e) * i + e * t
	}

	function oy(i) {
		return (i & i - 1) === 0 && i !== 0
	}

	function _C(i) {
		return Math.pow(2, Math.floor(Math.log(i) / Math.LN2))
	}

	function Wc(i, t) {
		switch (t.constructor) {
			case Float32Array:
				return i;
			case Uint16Array:
				return i / 65535;
			case Uint8Array:
				return i / 255;
			case Int16Array:
				return Math.max(i / 32767, -1);
			case Int8Array:
				return Math.max(i / 127, -1);
			default:
				throw new Error("Invalid component type.")
		}
	}

	function on(i, t) {
		switch (t.constructor) {
			case Float32Array:
				return i;
			case Uint16Array:
				return Math.round(i * 65535);
			case Uint8Array:
				return Math.round(i * 255);
			case Int16Array:
				return Math.round(i * 32767);
			case Int8Array:
				return Math.round(i * 127);
			default:
				throw new Error("Invalid component type.")
		}
	}
	var Oe = class {
			constructor(t = 0, e = 0) {
				Oe.prototype.isVector2 = !0, this.x = t, this.y = e
			}
			get width() {
				return this.x
			}
			set width(t) {
				this.x = t
			}
			get height() {
				return this.y
			}
			set height(t) {
				this.y = t
			}
			set(t, e) {
				return this.x = t, this.y = e, this
			}
			setScalar(t) {
				return this.x = t, this.y = t, this
			}
			setX(t) {
				return this.x = t, this
			}
			setY(t) {
				return this.y = t, this
			}
			setComponent(t, e) {
				switch (t) {
					case 0:
						this.x = e;
						break;
					case 1:
						this.y = e;
						break;
					default:
						throw new Error("index is out of range: " + t)
				}
				return this
			}
			getComponent(t) {
				switch (t) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					default:
						throw new Error("index is out of range: " + t)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y)
			}
			copy(t) {
				return this.x = t.x, this.y = t.y, this
			}
			add(t) {
				return this.x += t.x, this.y += t.y, this
			}
			addScalar(t) {
				return this.x += t, this.y += t, this
			}
			addVectors(t, e) {
				return this.x = t.x + e.x, this.y = t.y + e.y, this
			}
			addScaledVector(t, e) {
				return this.x += t.x * e, this.y += t.y * e, this
			}
			sub(t) {
				return this.x -= t.x, this.y -= t.y, this
			}
			subScalar(t) {
				return this.x -= t, this.y -= t, this
			}
			subVectors(t, e) {
				return this.x = t.x - e.x, this.y = t.y - e.y, this
			}
			multiply(t) {
				return this.x *= t.x, this.y *= t.y, this
			}
			multiplyScalar(t) {
				return this.x *= t, this.y *= t, this
			}
			divide(t) {
				return this.x /= t.x, this.y /= t.y, this
			}
			divideScalar(t) {
				return this.multiplyScalar(1 / t)
			}
			applyMatrix3(t) {
				let e = this.x,
					n = this.y,
					r = t.elements;
				return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
			}
			min(t) {
				return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
			}
			max(t) {
				return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
			}
			clamp(t, e) {
				return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
			}
			clampScalar(t, e) {
				return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
			}
			clampLength(t, e) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this
			}
			dot(t) {
				return this.x * t.x + this.y * t.y
			}
			cross(t) {
				return this.x * t.y - this.y * t.x
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			angle() {
				return Math.atan2(-this.y, -this.x) + Math.PI
			}
			angleTo(t) {
				let e = Math.sqrt(this.lengthSq() * t.lengthSq());
				if (e === 0) return Math.PI / 2;
				let n = this.dot(t) / e;
				return Math.acos(Yi(n, -1, 1))
			}
			distanceTo(t) {
				return Math.sqrt(this.distanceToSquared(t))
			}
			distanceToSquared(t) {
				let e = this.x - t.x,
					n = this.y - t.y;
				return e * e + n * n
			}
			manhattanDistanceTo(t) {
				return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
			}
			setLength(t) {
				return this.normalize().multiplyScalar(t)
			}
			lerp(t, e) {
				return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
			}
			lerpVectors(t, e, n) {
				return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
			}
			equals(t) {
				return t.x === this.x && t.y === this.y
			}
			fromArray(t, e = 0) {
				return this.x = t[e], this.y = t[e + 1], this
			}
			toArray(t = [], e = 0) {
				return t[e] = this.x, t[e + 1] = this.y, t
			}
			fromBufferAttribute(t, e) {
				return this.x = t.getX(e), this.y = t.getY(e), this
			}
			rotateAround(t, e) {
				let n = Math.cos(e),
					r = Math.sin(e),
					s = this.x - t.x,
					a = this.y - t.y;
				return this.x = s * n - a * r + t.x, this.y = s * r + a * n + t.y, this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y
			}
		},
		ue = class {
			constructor() {
				ue.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
			}
			set(t, e, n, r, s, a, o, h, c) {
				let u = this.elements;
				return u[0] = t, u[1] = r, u[2] = o, u[3] = e, u[4] = s, u[5] = h, u[6] = n, u[7] = a, u[8] = c, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
			}
			copy(t) {
				let e = this.elements,
					n = t.elements;
				return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
			}
			extractBasis(t, e, n) {
				return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
			}
			setFromMatrix4(t) {
				let e = t.elements;
				return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
			}
			multiply(t) {
				return this.multiplyMatrices(this, t)
			}
			premultiply(t) {
				return this.multiplyMatrices(t, this)
			}
			multiplyMatrices(t, e) {
				let n = t.elements,
					r = e.elements,
					s = this.elements,
					a = n[0],
					o = n[3],
					h = n[6],
					c = n[1],
					u = n[4],
					g = n[7],
					p = n[2],
					_ = n[5],
					b = n[8],
					y = r[0],
					w = r[3],
					f = r[6],
					S = r[1],
					x = r[4],
					M = r[7],
					T = r[2],
					I = r[5],
					L = r[8];
				return s[0] = a * y + o * S + h * T, s[3] = a * w + o * x + h * I, s[6] = a * f + o * M + h * L, s[1] = c * y + u * S + g * T, s[4] = c * w + u * x + g * I, s[7] = c * f + u * M + g * L, s[2] = p * y + _ * S + b * T, s[5] = p * w + _ * x + b * I, s[8] = p * f + _ * M + b * L, this
			}
			multiplyScalar(t) {
				let e = this.elements;
				return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
			}
			determinant() {
				let t = this.elements,
					e = t[0],
					n = t[1],
					r = t[2],
					s = t[3],
					a = t[4],
					o = t[5],
					h = t[6],
					c = t[7],
					u = t[8];
				return e * a * u - e * o * c - n * s * u + n * o * h + r * s * c - r * a * h
			}
			invert() {
				let t = this.elements,
					e = t[0],
					n = t[1],
					r = t[2],
					s = t[3],
					a = t[4],
					o = t[5],
					h = t[6],
					c = t[7],
					u = t[8],
					g = u * a - o * c,
					p = o * h - u * s,
					_ = c * s - a * h,
					b = e * g + n * p + r * _;
				if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let y = 1 / b;
				return t[0] = g * y, t[1] = (r * c - u * n) * y, t[2] = (o * n - r * a) * y, t[3] = p * y, t[4] = (u * e - r * h) * y, t[5] = (r * s - o * e) * y, t[6] = _ * y, t[7] = (n * h - c * e) * y, t[8] = (a * e - n * s) * y, this
			}
			transpose() {
				let t, e = this.elements;
				return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
			}
			getNormalMatrix(t) {
				return this.setFromMatrix4(t).invert().transpose()
			}
			transposeIntoArray(t) {
				let e = this.elements;
				return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
			}
			setUvTransform(t, e, n, r, s, a, o) {
				let h = Math.cos(s),
					c = Math.sin(s);
				return this.set(n * h, n * c, -n * (h * a + c * o) + a + t, -r * c, r * h, -r * (-c * a + h * o) + o + e, 0, 0, 1), this
			}
			scale(t, e) {
				return this.premultiply(Cf.makeScale(t, e)), this
			}
			rotate(t) {
				return this.premultiply(Cf.makeRotation(-t)), this
			}
			translate(t, e) {
				return this.premultiply(Cf.makeTranslation(t, e)), this
			}
			makeTranslation(t, e) {
				return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
			}
			makeRotation(t) {
				let e = Math.cos(t),
					n = Math.sin(t);
				return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
			}
			makeScale(t, e) {
				return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
			}
			equals(t) {
				let e = this.elements,
					n = t.elements;
				for (let r = 0; r < 9; r++)
					if (e[r] !== n[r]) return !1;
				return !0
			}
			fromArray(t, e = 0) {
				for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
				return this
			}
			toArray(t = [], e = 0) {
				let n = this.elements;
				return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
			}
			clone() {
				return new this.constructor().fromArray(this.elements)
			}
		},
		Cf = new ue;

	function ib(i) {
		for (let t = i.length - 1; t >= 0; --t)
			if (i[t] >= 65535) return !0;
		return !1
	}

	function yu(i) {
		return document.createElementNS("http://www.w3.org/1999/xhtml", i)
	}

	function Po(i) {
		return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4)
	}

	function Tf(i) {
		return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055
	}
	var yC = new ue().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
		bC = new ue().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);

	function xC(i) {
		return i.convertSRGBToLinear().applyMatrix3(bC)
	}

	function wC(i) {
		return i.applyMatrix3(yC).convertLinearToSRGB()
	}
	var SC = {
			[ih]: i => i,
			[sr]: i => i.convertSRGBToLinear(),
			[eb]: xC
		},
		EC = {
			[ih]: i => i,
			[sr]: i => i.convertLinearToSRGB(),
			[eb]: wC
		},
		ln = {
			enabled: !1,
			get legacyMode() {
				return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
			},
			set legacyMode(i) {
				console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !i
			},
			get workingColorSpace() {
				return ih
			},
			set workingColorSpace(i) {
				console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
			},
			convert: function (i, t, e) {
				if (this.enabled === !1 || t === e || !t || !e) return i;
				let n = SC[t],
					r = EC[e];
				if (n === void 0 || r === void 0) throw new Error(`Unsupported color space conversion, "${t}" to "${e}".`);
				return r(n(i))
			},
			fromWorkingColorSpace: function (i, t) {
				return this.convert(i, this.workingColorSpace, t)
			},
			toWorkingColorSpace: function (i, t) {
				return this.convert(i, t, this.workingColorSpace)
			}
		},
		oo, bu = class {
			static getDataURL(t) {
				if (/^data:/i.test(t.src) || typeof HTMLCanvasElement == "undefined") return t.src;
				let e;
				if (t instanceof HTMLCanvasElement) e = t;
				else {
					oo === void 0 && (oo = yu("canvas")), oo.width = t.width, oo.height = t.height;
					let n = oo.getContext("2d");
					t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = oo
				}
				return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
			}
			static sRGBToLinear(t) {
				if (typeof HTMLImageElement != "undefined" && t instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t instanceof ImageBitmap) {
					let e = yu("canvas");
					e.width = t.width, e.height = t.height;
					let n = e.getContext("2d");
					n.drawImage(t, 0, 0, t.width, t.height);
					let r = n.getImageData(0, 0, t.width, t.height),
						s = r.data;
					for (let a = 0; a < s.length; a++) s[a] = Po(s[a] / 255) * 255;
					return n.putImageData(r, 0, 0), e
				} else if (t.data) {
					let e = t.data.slice(0);
					for (let n = 0; n < e.length; n++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(Po(e[n] / 255) * 255) : e[n] = Po(e[n]);
					return {
						data: e,
						width: t.width,
						height: t.height
					}
				} else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
			}
		},
		xu = class {
			constructor(t = null) {
				this.isSource = !0, this.uuid = oh(), this.data = t, this.version = 0
			}
			set needsUpdate(t) {
				t === !0 && this.version++
			}
			toJSON(t) {
				let e = t === void 0 || typeof t == "string";
				if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
				let n = {
						uuid: this.uuid,
						url: ""
					},
					r = this.data;
				if (r !== null) {
					let s;
					if (Array.isArray(r)) {
						s = [];
						for (let a = 0, o = r.length; a < o; a++) r[a].isDataTexture ? s.push(Pf(r[a].image)) : s.push(Pf(r[a]))
					} else s = Pf(r);
					n.url = s
				}
				return e || (t.images[this.uuid] = n), n
			}
		};

	function Pf(i) {
		return typeof HTMLImageElement != "undefined" && i instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && i instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && i instanceof ImageBitmap ? bu.getDataURL(i) : i.data ? {
			data: Array.from(i.data),
			width: i.width,
			height: i.height,
			type: i.data.constructor.name
		} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
	}
	var MC = 0,
		Ni = class extends Ms {
			constructor(t = Ni.DEFAULT_IMAGE, e = Ni.DEFAULT_MAPPING, n = Vn, r = Vn, s = Mn, a = th, o = zn, h = ya, c = Ni.DEFAULT_ANISOTROPY, u = ba) {
				super(), this.isTexture = !0, Object.defineProperty(this, "id", {
					value: MC++
				}), this.uuid = oh(), this.name = "", this.source = new xu(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = h, this.offset = new Oe(0, 0), this.repeat = new Oe(1, 1), this.center = new Oe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ue, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
			}
			get image() {
				return this.source.data
			}
			set image(t = null) {
				this.source.data = t
			}
			updateMatrix() {
				this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
			}
			toJSON(t) {
				let e = t === void 0 || typeof t == "string";
				if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
				let n = {
					metadata: {
						version: 4.5,
						type: "Texture",
						generator: "Texture.toJSON"
					},
					uuid: this.uuid,
					name: this.name,
					image: this.source.toJSON(t).uuid,
					mapping: this.mapping,
					channel: this.channel,
					repeat: [this.repeat.x, this.repeat.y],
					offset: [this.offset.x, this.offset.y],
					center: [this.center.x, this.center.y],
					rotation: this.rotation,
					wrap: [this.wrapS, this.wrapT],
					format: this.format,
					internalFormat: this.internalFormat,
					type: this.type,
					encoding: this.encoding,
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
					flipY: this.flipY,
					generateMipmaps: this.generateMipmaps,
					premultiplyAlpha: this.premultiplyAlpha,
					unpackAlignment: this.unpackAlignment
				};
				return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			transformUv(t) {
				if (this.mapping !== Qy) return t;
				if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
					case Zf:
						t.x = t.x - Math.floor(t.x);
						break;
					case Vn:
						t.x = t.x < 0 ? 0 : 1;
						break;
					case Jf:
						Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
						break
				}
				if (t.y < 0 || t.y > 1) switch (this.wrapT) {
					case Zf:
						t.y = t.y - Math.floor(t.y);
						break;
					case Vn:
						t.y = t.y < 0 ? 0 : 1;
						break;
					case Jf:
						Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
						break
				}
				return this.flipY && (t.y = 1 - t.y), t
			}
			set needsUpdate(t) {
				t === !0 && (this.version++, this.source.needsUpdate = !0)
			}
		};
	Ni.DEFAULT_IMAGE = null;
	Ni.DEFAULT_MAPPING = Qy;
	Ni.DEFAULT_ANISOTROPY = 1;
	var ai = class {
			constructor(t = 0, e = 0, n = 0, r = 1) {
				ai.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r
			}
			get width() {
				return this.z
			}
			set width(t) {
				this.z = t
			}
			get height() {
				return this.w
			}
			set height(t) {
				this.w = t
			}
			set(t, e, n, r) {
				return this.x = t, this.y = e, this.z = n, this.w = r, this
			}
			setScalar(t) {
				return this.x = t, this.y = t, this.z = t, this.w = t, this
			}
			setX(t) {
				return this.x = t, this
			}
			setY(t) {
				return this.y = t, this
			}
			setZ(t) {
				return this.z = t, this
			}
			setW(t) {
				return this.w = t, this
			}
			setComponent(t, e) {
				switch (t) {
					case 0:
						this.x = e;
						break;
					case 1:
						this.y = e;
						break;
					case 2:
						this.z = e;
						break;
					case 3:
						this.w = e;
						break;
					default:
						throw new Error("index is out of range: " + t)
				}
				return this
			}
			getComponent(t) {
				switch (t) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					case 3:
						return this.w;
					default:
						throw new Error("index is out of range: " + t)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z, this.w)
			}
			copy(t) {
				return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this
			}
			add(t) {
				return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
			}
			addScalar(t) {
				return this.x += t, this.y += t, this.z += t, this.w += t, this
			}
			addVectors(t, e) {
				return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
			}
			addScaledVector(t, e) {
				return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
			}
			sub(t) {
				return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
			}
			subScalar(t) {
				return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
			}
			subVectors(t, e) {
				return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
			}
			multiply(t) {
				return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
			}
			multiplyScalar(t) {
				return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
			}
			applyMatrix4(t) {
				let e = this.x,
					n = this.y,
					r = this.z,
					s = this.w,
					a = t.elements;
				return this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * s, this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * s, this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * s, this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * s, this
			}
			divideScalar(t) {
				return this.multiplyScalar(1 / t)
			}
			setAxisAngleFromQuaternion(t) {
				this.w = 2 * Math.acos(t.w);
				let e = Math.sqrt(1 - t.w * t.w);
				return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
			}
			setAxisAngleFromRotationMatrix(t) {
				let e, n, r, s, h = t.elements,
					c = h[0],
					u = h[4],
					g = h[8],
					p = h[1],
					_ = h[5],
					b = h[9],
					y = h[2],
					w = h[6],
					f = h[10];
				if (Math.abs(u - p) < .01 && Math.abs(g - y) < .01 && Math.abs(b - w) < .01) {
					if (Math.abs(u + p) < .1 && Math.abs(g + y) < .1 && Math.abs(b + w) < .1 && Math.abs(c + _ + f - 3) < .1) return this.set(1, 0, 0, 0), this;
					e = Math.PI;
					let x = (c + 1) / 2,
						M = (_ + 1) / 2,
						T = (f + 1) / 2,
						I = (u + p) / 4,
						L = (g + y) / 4,
						F = (b + w) / 4;
					return x > M && x > T ? x < .01 ? (n = 0, r = .707106781, s = .707106781) : (n = Math.sqrt(x), r = I / n, s = L / n) : M > T ? M < .01 ? (n = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(M), n = I / r, s = F / r) : T < .01 ? (n = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(T), n = L / s, r = F / s), this.set(n, r, s, e), this
				}
				let S = Math.sqrt((w - b) * (w - b) + (g - y) * (g - y) + (p - u) * (p - u));
				return Math.abs(S) < .001 && (S = 1), this.x = (w - b) / S, this.y = (g - y) / S, this.z = (p - u) / S, this.w = Math.acos((c + _ + f - 1) / 2), this
			}
			min(t) {
				return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
			}
			max(t) {
				return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
			}
			clamp(t, e) {
				return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
			}
			clampScalar(t, e) {
				return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
			}
			clampLength(t, e) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
			}
			dot(t) {
				return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(t) {
				return this.normalize().multiplyScalar(t)
			}
			lerp(t, e) {
				return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
			}
			lerpVectors(t, e, n) {
				return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
			}
			equals(t) {
				return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
			}
			fromArray(t, e = 0) {
				return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
			}
			toArray(t = [], e = 0) {
				return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
			}
			fromBufferAttribute(t, e) {
				return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z, yield this.w
			}
		},
		zr = class extends Ms {
			constructor(t = 1, e = 1, n = {}) {
				super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new ai(0, 0, t, e), this.scissorTest = !1, this.viewport = new ai(0, 0, t, e);
				let r = {
					width: t,
					height: e,
					depth: 1
				};
				this.texture = new Ni(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Mn, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0
			}
			setSize(t, e, n = 1) {
				(this.width !== t || this.height !== e || this.depth !== n) && (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
				let e = Object.assign({}, t.texture.image);
				return this.texture.source = new xu(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		wu = class extends Ni {
			constructor(t = null, e = 1, n = 1, r = 1) {
				super(null), this.isDataArrayTexture = !0, this.image = {
					data: t,
					width: e,
					height: n,
					depth: r
				}, this.magFilter = Fi, this.minFilter = Fi, this.wrapR = Vn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}
		};
	var em = class extends Ni {
		constructor(t = null, e = 1, n = 1, r = 1) {
			super(null), this.isData3DTexture = !0, this.image = {
				data: t,
				width: e,
				height: n,
				depth: r
			}, this.magFilter = Fi, this.minFilter = Fi, this.wrapR = Vn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
		}
	};
	var lr = class {
			constructor(t = 0, e = 0, n = 0, r = 1) {
				this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r
			}
			static slerpFlat(t, e, n, r, s, a, o) {
				let h = n[r + 0],
					c = n[r + 1],
					u = n[r + 2],
					g = n[r + 3],
					p = s[a + 0],
					_ = s[a + 1],
					b = s[a + 2],
					y = s[a + 3];
				if (o === 0) {
					t[e + 0] = h, t[e + 1] = c, t[e + 2] = u, t[e + 3] = g;
					return
				}
				if (o === 1) {
					t[e + 0] = p, t[e + 1] = _, t[e + 2] = b, t[e + 3] = y;
					return
				}
				if (g !== y || h !== p || c !== _ || u !== b) {
					let w = 1 - o,
						f = h * p + c * _ + u * b + g * y,
						S = f >= 0 ? 1 : -1,
						x = 1 - f * f;
					if (x > Number.EPSILON) {
						let T = Math.sqrt(x),
							I = Math.atan2(T, f * S);
						w = Math.sin(w * I) / T, o = Math.sin(o * I) / T
					}
					let M = o * S;
					if (h = h * w + p * M, c = c * w + _ * M, u = u * w + b * M, g = g * w + y * M, w === 1 - o) {
						let T = 1 / Math.sqrt(h * h + c * c + u * u + g * g);
						h *= T, c *= T, u *= T, g *= T
					}
				}
				t[e] = h, t[e + 1] = c, t[e + 2] = u, t[e + 3] = g
			}
			static multiplyQuaternionsFlat(t, e, n, r, s, a) {
				let o = n[r],
					h = n[r + 1],
					c = n[r + 2],
					u = n[r + 3],
					g = s[a],
					p = s[a + 1],
					_ = s[a + 2],
					b = s[a + 3];
				return t[e] = o * b + u * g + h * _ - c * p, t[e + 1] = h * b + u * p + c * g - o * _, t[e + 2] = c * b + u * _ + o * p - h * g, t[e + 3] = u * b - o * g - h * p - c * _, t
			}
			get x() {
				return this._x
			}
			set x(t) {
				this._x = t, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(t) {
				this._y = t, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(t) {
				this._z = t, this._onChangeCallback()
			}
			get w() {
				return this._w
			}
			set w(t) {
				this._w = t, this._onChangeCallback()
			}
			set(t, e, n, r) {
				return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._w)
			}
			copy(t) {
				return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
			}
			setFromEuler(t, e) {
				let n = t._x,
					r = t._y,
					s = t._z,
					a = t._order,
					o = Math.cos,
					h = Math.sin,
					c = o(n / 2),
					u = o(r / 2),
					g = o(s / 2),
					p = h(n / 2),
					_ = h(r / 2),
					b = h(s / 2);
				switch (a) {
					case "XYZ":
						this._x = p * u * g + c * _ * b, this._y = c * _ * g - p * u * b, this._z = c * u * b + p * _ * g, this._w = c * u * g - p * _ * b;
						break;
					case "YXZ":
						this._x = p * u * g + c * _ * b, this._y = c * _ * g - p * u * b, this._z = c * u * b - p * _ * g, this._w = c * u * g + p * _ * b;
						break;
					case "ZXY":
						this._x = p * u * g - c * _ * b, this._y = c * _ * g + p * u * b, this._z = c * u * b + p * _ * g, this._w = c * u * g - p * _ * b;
						break;
					case "ZYX":
						this._x = p * u * g - c * _ * b, this._y = c * _ * g + p * u * b, this._z = c * u * b - p * _ * g, this._w = c * u * g + p * _ * b;
						break;
					case "YZX":
						this._x = p * u * g + c * _ * b, this._y = c * _ * g + p * u * b, this._z = c * u * b - p * _ * g, this._w = c * u * g - p * _ * b;
						break;
					case "XZY":
						this._x = p * u * g - c * _ * b, this._y = c * _ * g - p * u * b, this._z = c * u * b + p * _ * g, this._w = c * u * g + p * _ * b;
						break;
					default:
						console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
				}
				return e !== !1 && this._onChangeCallback(), this
			}
			setFromAxisAngle(t, e) {
				let n = e / 2,
					r = Math.sin(n);
				return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
			}
			setFromRotationMatrix(t) {
				let e = t.elements,
					n = e[0],
					r = e[4],
					s = e[8],
					a = e[1],
					o = e[5],
					h = e[9],
					c = e[2],
					u = e[6],
					g = e[10],
					p = n + o + g;
				if (p > 0) {
					let _ = .5 / Math.sqrt(p + 1);
					this._w = .25 / _, this._x = (u - h) * _, this._y = (s - c) * _, this._z = (a - r) * _
				} else if (n > o && n > g) {
					let _ = 2 * Math.sqrt(1 + n - o - g);
					this._w = (u - h) / _, this._x = .25 * _, this._y = (r + a) / _, this._z = (s + c) / _
				} else if (o > g) {
					let _ = 2 * Math.sqrt(1 + o - n - g);
					this._w = (s - c) / _, this._x = (r + a) / _, this._y = .25 * _, this._z = (h + u) / _
				} else {
					let _ = 2 * Math.sqrt(1 + g - n - o);
					this._w = (a - r) / _, this._x = (s + c) / _, this._y = (h + u) / _, this._z = .25 * _
				}
				return this._onChangeCallback(), this
			}
			setFromUnitVectors(t, e) {
				let n = t.dot(e) + 1;
				return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
			}
			angleTo(t) {
				return 2 * Math.acos(Math.abs(Yi(this.dot(t), -1, 1)))
			}
			rotateTowards(t, e) {
				let n = this.angleTo(t);
				if (n === 0) return this;
				let r = Math.min(1, e / n);
				return this.slerp(t, r), this
			}
			identity() {
				return this.set(0, 0, 0, 1)
			}
			invert() {
				return this.conjugate()
			}
			conjugate() {
				return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
			}
			dot(t) {
				return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
			}
			lengthSq() {
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
			}
			length() {
				return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
			}
			normalize() {
				let t = this.length();
				return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
			}
			multiply(t) {
				return this.multiplyQuaternions(this, t)
			}
			premultiply(t) {
				return this.multiplyQuaternions(t, this)
			}
			multiplyQuaternions(t, e) {
				let n = t._x,
					r = t._y,
					s = t._z,
					a = t._w,
					o = e._x,
					h = e._y,
					c = e._z,
					u = e._w;
				return this._x = n * u + a * o + r * c - s * h, this._y = r * u + a * h + s * o - n * c, this._z = s * u + a * c + n * h - r * o, this._w = a * u - n * o - r * h - s * c, this._onChangeCallback(), this
			}
			slerp(t, e) {
				if (e === 0) return this;
				if (e === 1) return this.copy(t);
				let n = this._x,
					r = this._y,
					s = this._z,
					a = this._w,
					o = a * t._w + n * t._x + r * t._y + s * t._z;
				if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = s, this;
				let h = 1 - o * o;
				if (h <= Number.EPSILON) {
					let _ = 1 - e;
					return this._w = _ * a + e * this._w, this._x = _ * n + e * this._x, this._y = _ * r + e * this._y, this._z = _ * s + e * this._z, this.normalize(), this._onChangeCallback(), this
				}
				let c = Math.sqrt(h),
					u = Math.atan2(c, o),
					g = Math.sin((1 - e) * u) / c,
					p = Math.sin(e * u) / c;
				return this._w = a * g + this._w * p, this._x = n * g + this._x * p, this._y = r * g + this._y * p, this._z = s * g + this._z * p, this._onChangeCallback(), this
			}
			slerpQuaternions(t, e, n) {
				return this.copy(t).slerp(e, n)
			}
			random() {
				let t = Math.random(),
					e = Math.sqrt(1 - t),
					n = Math.sqrt(t),
					r = 2 * Math.PI * Math.random(),
					s = 2 * Math.PI * Math.random();
				return this.set(e * Math.cos(r), n * Math.sin(s), n * Math.cos(s), e * Math.sin(r))
			}
			equals(t) {
				return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
			}
			fromArray(t, e = 0) {
				return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
			}
			toArray(t = [], e = 0) {
				return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
			}
			fromBufferAttribute(t, e) {
				return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
			}
			toJSON() {
				return this.toArray()
			}
			_onChange(t) {
				return this._onChangeCallback = t, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._w
			}
		},
		ht = class {
			constructor(t = 0, e = 0, n = 0) {
				ht.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
			}
			set(t, e, n) {
				return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this
			}
			setScalar(t) {
				return this.x = t, this.y = t, this.z = t, this
			}
			setX(t) {
				return this.x = t, this
			}
			setY(t) {
				return this.y = t, this
			}
			setZ(t) {
				return this.z = t, this
			}
			setComponent(t, e) {
				switch (t) {
					case 0:
						this.x = e;
						break;
					case 1:
						this.y = e;
						break;
					case 2:
						this.z = e;
						break;
					default:
						throw new Error("index is out of range: " + t)
				}
				return this
			}
			getComponent(t) {
				switch (t) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					default:
						throw new Error("index is out of range: " + t)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z)
			}
			copy(t) {
				return this.x = t.x, this.y = t.y, this.z = t.z, this
			}
			add(t) {
				return this.x += t.x, this.y += t.y, this.z += t.z, this
			}
			addScalar(t) {
				return this.x += t, this.y += t, this.z += t, this
			}
			addVectors(t, e) {
				return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
			}
			addScaledVector(t, e) {
				return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
			}
			sub(t) {
				return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
			}
			subScalar(t) {
				return this.x -= t, this.y -= t, this.z -= t, this
			}
			subVectors(t, e) {
				return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
			}
			multiply(t) {
				return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
			}
			multiplyScalar(t) {
				return this.x *= t, this.y *= t, this.z *= t, this
			}
			multiplyVectors(t, e) {
				return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
			}
			applyEuler(t) {
				return this.applyQuaternion(ly.setFromEuler(t))
			}
			applyAxisAngle(t, e) {
				return this.applyQuaternion(ly.setFromAxisAngle(t, e))
			}
			applyMatrix3(t) {
				let e = this.x,
					n = this.y,
					r = this.z,
					s = t.elements;
				return this.x = s[0] * e + s[3] * n + s[6] * r, this.y = s[1] * e + s[4] * n + s[7] * r, this.z = s[2] * e + s[5] * n + s[8] * r, this
			}
			applyNormalMatrix(t) {
				return this.applyMatrix3(t).normalize()
			}
			applyMatrix4(t) {
				let e = this.x,
					n = this.y,
					r = this.z,
					s = t.elements,
					a = 1 / (s[3] * e + s[7] * n + s[11] * r + s[15]);
				return this.x = (s[0] * e + s[4] * n + s[8] * r + s[12]) * a, this.y = (s[1] * e + s[5] * n + s[9] * r + s[13]) * a, this.z = (s[2] * e + s[6] * n + s[10] * r + s[14]) * a, this
			}
			applyQuaternion(t) {
				let e = this.x,
					n = this.y,
					r = this.z,
					s = t.x,
					a = t.y,
					o = t.z,
					h = t.w,
					c = h * e + a * r - o * n,
					u = h * n + o * e - s * r,
					g = h * r + s * n - a * e,
					p = -s * e - a * n - o * r;
				return this.x = c * h + p * -s + u * -o - g * -a, this.y = u * h + p * -a + g * -s - c * -o, this.z = g * h + p * -o + c * -a - u * -s, this
			}
			project(t) {
				return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
			}
			unproject(t) {
				return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
			}
			transformDirection(t) {
				let e = this.x,
					n = this.y,
					r = this.z,
					s = t.elements;
				return this.x = s[0] * e + s[4] * n + s[8] * r, this.y = s[1] * e + s[5] * n + s[9] * r, this.z = s[2] * e + s[6] * n + s[10] * r, this.normalize()
			}
			divide(t) {
				return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
			}
			divideScalar(t) {
				return this.multiplyScalar(1 / t)
			}
			min(t) {
				return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
			}
			max(t) {
				return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
			}
			clamp(t, e) {
				return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
			}
			clampScalar(t, e) {
				return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
			}
			clampLength(t, e) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
			}
			dot(t) {
				return this.x * t.x + this.y * t.y + this.z * t.z
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(t) {
				return this.normalize().multiplyScalar(t)
			}
			lerp(t, e) {
				return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
			}
			lerpVectors(t, e, n) {
				return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
			}
			cross(t) {
				return this.crossVectors(this, t)
			}
			crossVectors(t, e) {
				let n = t.x,
					r = t.y,
					s = t.z,
					a = e.x,
					o = e.y,
					h = e.z;
				return this.x = r * h - s * o, this.y = s * a - n * h, this.z = n * o - r * a, this
			}
			projectOnVector(t) {
				let e = t.lengthSq();
				if (e === 0) return this.set(0, 0, 0);
				let n = t.dot(this) / e;
				return this.copy(t).multiplyScalar(n)
			}
			projectOnPlane(t) {
				return Af.copy(this).projectOnVector(t), this.sub(Af)
			}
			reflect(t) {
				return this.sub(Af.copy(t).multiplyScalar(2 * this.dot(t)))
			}
			angleTo(t) {
				let e = Math.sqrt(this.lengthSq() * t.lengthSq());
				if (e === 0) return Math.PI / 2;
				let n = this.dot(t) / e;
				return Math.acos(Yi(n, -1, 1))
			}
			distanceTo(t) {
				return Math.sqrt(this.distanceToSquared(t))
			}
			distanceToSquared(t) {
				let e = this.x - t.x,
					n = this.y - t.y,
					r = this.z - t.z;
				return e * e + n * n + r * r
			}
			manhattanDistanceTo(t) {
				return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
			}
			setFromSpherical(t) {
				return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
			}
			setFromSphericalCoords(t, e, n) {
				let r = Math.sin(e) * t;
				return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
			}
			setFromCylindrical(t) {
				return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
			}
			setFromCylindricalCoords(t, e, n) {
				return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
			}
			setFromMatrixPosition(t) {
				let e = t.elements;
				return this.x = e[12], this.y = e[13], this.z = e[14], this
			}
			setFromMatrixScale(t) {
				let e = this.setFromMatrixColumn(t, 0).length(),
					n = this.setFromMatrixColumn(t, 1).length(),
					r = this.setFromMatrixColumn(t, 2).length();
				return this.x = e, this.y = n, this.z = r, this
			}
			setFromMatrixColumn(t, e) {
				return this.fromArray(t.elements, e * 4)
			}
			setFromMatrix3Column(t, e) {
				return this.fromArray(t.elements, e * 3)
			}
			setFromEuler(t) {
				return this.x = t._x, this.y = t._y, this.z = t._z, this
			}
			setFromColor(t) {
				return this.x = t.r, this.y = t.g, this.z = t.b, this
			}
			equals(t) {
				return t.x === this.x && t.y === this.y && t.z === this.z
			}
			fromArray(t, e = 0) {
				return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
			}
			toArray(t = [], e = 0) {
				return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
			}
			fromBufferAttribute(t, e) {
				return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
			}
			randomDirection() {
				let t = (Math.random() - .5) * 2,
					e = Math.random() * Math.PI * 2,
					n = Math.sqrt(1 - tp(t, 2));
				return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z
			}
		},
		Af = new ht,
		ly = new lr,
		xa = class {
			constructor(t = new ht(1 / 0, 1 / 0, 1 / 0), e = new ht(-1 / 0, -1 / 0, -1 / 0)) {
				this.isBox3 = !0, this.min = t, this.max = e
			}
			set(t, e) {
				return this.min.copy(t), this.max.copy(e), this
			}
			setFromArray(t) {
				this.makeEmpty();
				for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(Dr.fromArray(t, e));
				return this
			}
			setFromBufferAttribute(t) {
				this.makeEmpty();
				for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(Dr.fromBufferAttribute(t, e));
				return this
			}
			setFromPoints(t) {
				this.makeEmpty();
				for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
				return this
			}
			setFromCenterAndSize(t, e) {
				let n = Dr.copy(e).multiplyScalar(.5);
				return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
			}
			setFromObject(t, e = !1) {
				return this.makeEmpty(), this.expandByObject(t, e)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				return this.min.copy(t.min), this.max.copy(t.max), this
			}
			makeEmpty() {
				return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
			}
			isEmpty() {
				return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
			}
			getCenter(t) {
				return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
			}
			getSize(t) {
				return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
			}
			expandByPoint(t) {
				return this.min.min(t), this.max.max(t), this
			}
			expandByVector(t) {
				return this.min.sub(t), this.max.add(t), this
			}
			expandByScalar(t) {
				return this.min.addScalar(-t), this.max.addScalar(t), this
			}
			expandByObject(t, e = !1) {
				if (t.updateWorldMatrix(!1, !1), t.boundingBox !== void 0) t.boundingBox === null && t.computeBoundingBox(), lo.copy(t.boundingBox), lo.applyMatrix4(t.matrixWorld), this.union(lo);
				else {
					let r = t.geometry;
					if (r !== void 0)
						if (e && r.attributes !== void 0 && r.attributes.position !== void 0) {
							let s = r.attributes.position;
							for (let a = 0, o = s.count; a < o; a++) Dr.fromBufferAttribute(s, a).applyMatrix4(t.matrixWorld), this.expandByPoint(Dr)
						} else r.boundingBox === null && r.computeBoundingBox(), lo.copy(r.boundingBox), lo.applyMatrix4(t.matrixWorld), this.union(lo)
				}
				let n = t.children;
				for (let r = 0, s = n.length; r < s; r++) this.expandByObject(n[r], e);
				return this
			}
			containsPoint(t) {
				return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
			}
			containsBox(t) {
				return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
			}
			getParameter(t, e) {
				return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
			}
			intersectsBox(t) {
				return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
			}
			intersectsSphere(t) {
				return this.clampPoint(t.center, Dr), Dr.distanceToSquared(t.center) <= t.radius * t.radius
			}
			intersectsPlane(t) {
				let e, n;
				return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
			}
			intersectsTriangle(t) {
				if (this.isEmpty()) return !1;
				this.getCenter(jl), $c.subVectors(this.max, jl), ho.subVectors(t.a, jl), co.subVectors(t.b, jl), uo.subVectors(t.c, jl), _s.subVectors(co, ho), ys.subVectors(uo, co), ua.subVectors(ho, uo);
				let e = [0, -_s.z, _s.y, 0, -ys.z, ys.y, 0, -ua.z, ua.y, _s.z, 0, -_s.x, ys.z, 0, -ys.x, ua.z, 0, -ua.x, -_s.y, _s.x, 0, -ys.y, ys.x, 0, -ua.y, ua.x, 0];
				return !Df(e, ho, co, uo, $c) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Df(e, ho, co, uo, $c)) ? !1 : (qc.crossVectors(_s, ys), e = [qc.x, qc.y, qc.z], Df(e, ho, co, uo, $c))
			}
			clampPoint(t, e) {
				return e.copy(t).clamp(this.min, this.max)
			}
			distanceToPoint(t) {
				return this.clampPoint(t, Dr).distanceTo(t)
			}
			getBoundingSphere(t) {
				return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(Dr).length() * .5), t
			}
			intersect(t) {
				return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
			}
			union(t) {
				return this.min.min(t.min), this.max.max(t.max), this
			}
			applyMatrix4(t) {
				return this.isEmpty() ? this : (Ar[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ar[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ar[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ar[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ar[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ar[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ar[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ar[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ar), this)
			}
			translate(t) {
				return this.min.add(t), this.max.add(t), this
			}
			equals(t) {
				return t.min.equals(this.min) && t.max.equals(this.max)
			}
		},
		Ar = [new ht, new ht, new ht, new ht, new ht, new ht, new ht, new ht],
		Dr = new ht,
		lo = new xa,
		ho = new ht,
		co = new ht,
		uo = new ht,
		_s = new ht,
		ys = new ht,
		ua = new ht,
		jl = new ht,
		$c = new ht,
		qc = new ht,
		da = new ht;

	function Df(i, t, e, n, r) {
		for (let s = 0, a = i.length - 3; s <= a; s += 3) {
			da.fromArray(i, s);
			let o = r.x * Math.abs(da.x) + r.y * Math.abs(da.y) + r.z * Math.abs(da.z),
				h = t.dot(da),
				c = e.dot(da),
				u = n.dot(da);
			if (Math.max(-Math.max(h, c, u), Math.min(h, c, u)) > o) return !1
		}
		return !0
	}
	var CC = new xa,
		Xl = new ht,
		If = new ht,
		ko = class {
			constructor(t = new ht, e = -1) {
				this.center = t, this.radius = e
			}
			set(t, e) {
				return this.center.copy(t), this.radius = e, this
			}
			setFromPoints(t, e) {
				let n = this.center;
				e !== void 0 ? n.copy(e) : CC.setFromPoints(t).getCenter(n);
				let r = 0;
				for (let s = 0, a = t.length; s < a; s++) r = Math.max(r, n.distanceToSquared(t[s]));
				return this.radius = Math.sqrt(r), this
			}
			copy(t) {
				return this.center.copy(t.center), this.radius = t.radius, this
			}
			isEmpty() {
				return this.radius < 0
			}
			makeEmpty() {
				return this.center.set(0, 0, 0), this.radius = -1, this
			}
			containsPoint(t) {
				return t.distanceToSquared(this.center) <= this.radius * this.radius
			}
			distanceToPoint(t) {
				return t.distanceTo(this.center) - this.radius
			}
			intersectsSphere(t) {
				let e = this.radius + t.radius;
				return t.center.distanceToSquared(this.center) <= e * e
			}
			intersectsBox(t) {
				return t.intersectsSphere(this)
			}
			intersectsPlane(t) {
				return Math.abs(t.distanceToPoint(this.center)) <= this.radius
			}
			clampPoint(t, e) {
				let n = this.center.distanceToSquared(t);
				return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
			}
			getBoundingBox(t) {
				return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
			}
			applyMatrix4(t) {
				return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
			}
			translate(t) {
				return this.center.add(t), this
			}
			expandByPoint(t) {
				if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
				Xl.subVectors(t, this.center);
				let e = Xl.lengthSq();
				if (e > this.radius * this.radius) {
					let n = Math.sqrt(e),
						r = (n - this.radius) * .5;
					this.center.addScaledVector(Xl, r / n), this.radius += r
				}
				return this
			}
			union(t) {
				return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (If.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Xl.copy(t.center).add(If)), this.expandByPoint(Xl.copy(t.center).sub(If))), this)
			}
			equals(t) {
				return t.center.equals(this.center) && t.radius === this.radius
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		Ir = new ht,
		Lf = new ht,
		jc = new ht,
		bs = new ht,
		kf = new ht,
		Xc = new ht,
		Rf = new ht,
		Su = class {
			constructor(t = new ht, e = new ht(0, 0, -1)) {
				this.origin = t, this.direction = e
			}
			set(t, e) {
				return this.origin.copy(t), this.direction.copy(e), this
			}
			copy(t) {
				return this.origin.copy(t.origin), this.direction.copy(t.direction), this
			}
			at(t, e) {
				return e.copy(this.origin).addScaledVector(this.direction, t)
			}
			lookAt(t) {
				return this.direction.copy(t).sub(this.origin).normalize(), this
			}
			recast(t) {
				return this.origin.copy(this.at(t, Ir)), this
			}
			closestPointToPoint(t, e) {
				e.subVectors(t, this.origin);
				let n = e.dot(this.direction);
				return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
			}
			distanceToPoint(t) {
				return Math.sqrt(this.distanceSqToPoint(t))
			}
			distanceSqToPoint(t) {
				let e = Ir.subVectors(t, this.origin).dot(this.direction);
				return e < 0 ? this.origin.distanceToSquared(t) : (Ir.copy(this.origin).addScaledVector(this.direction, e), Ir.distanceToSquared(t))
			}
			distanceSqToSegment(t, e, n, r) {
				Lf.copy(t).add(e).multiplyScalar(.5), jc.copy(e).sub(t).normalize(), bs.copy(this.origin).sub(Lf);
				let s = t.distanceTo(e) * .5,
					a = -this.direction.dot(jc),
					o = bs.dot(this.direction),
					h = -bs.dot(jc),
					c = bs.lengthSq(),
					u = Math.abs(1 - a * a),
					g, p, _, b;
				if (u > 0)
					if (g = a * h - o, p = a * o - h, b = s * u, g >= 0)
						if (p >= -b)
							if (p <= b) {
								let y = 1 / u;
								g *= y, p *= y, _ = g * (g + a * p + 2 * o) + p * (a * g + p + 2 * h) + c
							} else p = s, g = Math.max(0, -(a * p + o)), _ = -g * g + p * (p + 2 * h) + c;
				else p = -s, g = Math.max(0, -(a * p + o)), _ = -g * g + p * (p + 2 * h) + c;
				else p <= -b ? (g = Math.max(0, -(-a * s + o)), p = g > 0 ? -s : Math.min(Math.max(-s, -h), s), _ = -g * g + p * (p + 2 * h) + c) : p <= b ? (g = 0, p = Math.min(Math.max(-s, -h), s), _ = p * (p + 2 * h) + c) : (g = Math.max(0, -(a * s + o)), p = g > 0 ? s : Math.min(Math.max(-s, -h), s), _ = -g * g + p * (p + 2 * h) + c);
				else p = a > 0 ? -s : s, g = Math.max(0, -(a * p + o)), _ = -g * g + p * (p + 2 * h) + c;
				return n && n.copy(this.origin).addScaledVector(this.direction, g), r && r.copy(Lf).addScaledVector(jc, p), _
			}
			intersectSphere(t, e) {
				Ir.subVectors(t.center, this.origin);
				let n = Ir.dot(this.direction),
					r = Ir.dot(Ir) - n * n,
					s = t.radius * t.radius;
				if (r > s) return null;
				let a = Math.sqrt(s - r),
					o = n - a,
					h = n + a;
				return h < 0 ? null : o < 0 ? this.at(h, e) : this.at(o, e)
			}
			intersectsSphere(t) {
				return this.distanceSqToPoint(t.center) <= t.radius * t.radius
			}
			distanceToPlane(t) {
				let e = t.normal.dot(this.direction);
				if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
				let n = -(this.origin.dot(t.normal) + t.constant) / e;
				return n >= 0 ? n : null
			}
			intersectPlane(t, e) {
				let n = this.distanceToPlane(t);
				return n === null ? null : this.at(n, e)
			}
			intersectsPlane(t) {
				let e = t.distanceToPoint(this.origin);
				return e === 0 || t.normal.dot(this.direction) * e < 0
			}
			intersectBox(t, e) {
				let n, r, s, a, o, h, c = 1 / this.direction.x,
					u = 1 / this.direction.y,
					g = 1 / this.direction.z,
					p = this.origin;
				return c >= 0 ? (n = (t.min.x - p.x) * c, r = (t.max.x - p.x) * c) : (n = (t.max.x - p.x) * c, r = (t.min.x - p.x) * c), u >= 0 ? (s = (t.min.y - p.y) * u, a = (t.max.y - p.y) * u) : (s = (t.max.y - p.y) * u, a = (t.min.y - p.y) * u), n > a || s > r || ((s > n || isNaN(n)) && (n = s), (a < r || isNaN(r)) && (r = a), g >= 0 ? (o = (t.min.z - p.z) * g, h = (t.max.z - p.z) * g) : (o = (t.max.z - p.z) * g, h = (t.min.z - p.z) * g), n > h || o > r) || ((o > n || n !== n) && (n = o), (h < r || r !== r) && (r = h), r < 0) ? null : this.at(n >= 0 ? n : r, e)
			}
			intersectsBox(t) {
				return this.intersectBox(t, Ir) !== null
			}
			intersectTriangle(t, e, n, r, s) {
				kf.subVectors(e, t), Xc.subVectors(n, t), Rf.crossVectors(kf, Xc);
				let a = this.direction.dot(Rf),
					o;
				if (a > 0) {
					if (r) return null;
					o = 1
				} else if (a < 0) o = -1, a = -a;
				else return null;
				bs.subVectors(this.origin, t);
				let h = o * this.direction.dot(Xc.crossVectors(bs, Xc));
				if (h < 0) return null;
				let c = o * this.direction.dot(kf.cross(bs));
				if (c < 0 || h + c > a) return null;
				let u = -o * bs.dot(Rf);
				return u < 0 ? null : this.at(u / a, s)
			}
			applyMatrix4(t) {
				return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
			}
			equals(t) {
				return t.origin.equals(this.origin) && t.direction.equals(this.direction)
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		ii = class {
			constructor() {
				ii.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
			}
			set(t, e, n, r, s, a, o, h, c, u, g, p, _, b, y, w) {
				let f = this.elements;
				return f[0] = t, f[4] = e, f[8] = n, f[12] = r, f[1] = s, f[5] = a, f[9] = o, f[13] = h, f[2] = c, f[6] = u, f[10] = g, f[14] = p, f[3] = _, f[7] = b, f[11] = y, f[15] = w, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			clone() {
				return new ii().fromArray(this.elements)
			}
			copy(t) {
				let e = this.elements,
					n = t.elements;
				return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
			}
			copyPosition(t) {
				let e = this.elements,
					n = t.elements;
				return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
			}
			setFromMatrix3(t) {
				let e = t.elements;
				return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
			}
			extractBasis(t, e, n) {
				return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
			}
			makeBasis(t, e, n) {
				return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
			}
			extractRotation(t) {
				let e = this.elements,
					n = t.elements,
					r = 1 / po.setFromMatrixColumn(t, 0).length(),
					s = 1 / po.setFromMatrixColumn(t, 1).length(),
					a = 1 / po.setFromMatrixColumn(t, 2).length();
				return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
			}
			makeRotationFromEuler(t) {
				let e = this.elements,
					n = t.x,
					r = t.y,
					s = t.z,
					a = Math.cos(n),
					o = Math.sin(n),
					h = Math.cos(r),
					c = Math.sin(r),
					u = Math.cos(s),
					g = Math.sin(s);
				if (t.order === "XYZ") {
					let p = a * u,
						_ = a * g,
						b = o * u,
						y = o * g;
					e[0] = h * u, e[4] = -h * g, e[8] = c, e[1] = _ + b * c, e[5] = p - y * c, e[9] = -o * h, e[2] = y - p * c, e[6] = b + _ * c, e[10] = a * h
				} else if (t.order === "YXZ") {
					let p = h * u,
						_ = h * g,
						b = c * u,
						y = c * g;
					e[0] = p + y * o, e[4] = b * o - _, e[8] = a * c, e[1] = a * g, e[5] = a * u, e[9] = -o, e[2] = _ * o - b, e[6] = y + p * o, e[10] = a * h
				} else if (t.order === "ZXY") {
					let p = h * u,
						_ = h * g,
						b = c * u,
						y = c * g;
					e[0] = p - y * o, e[4] = -a * g, e[8] = b + _ * o, e[1] = _ + b * o, e[5] = a * u, e[9] = y - p * o, e[2] = -a * c, e[6] = o, e[10] = a * h
				} else if (t.order === "ZYX") {
					let p = a * u,
						_ = a * g,
						b = o * u,
						y = o * g;
					e[0] = h * u, e[4] = b * c - _, e[8] = p * c + y, e[1] = h * g, e[5] = y * c + p, e[9] = _ * c - b, e[2] = -c, e[6] = o * h, e[10] = a * h
				} else if (t.order === "YZX") {
					let p = a * h,
						_ = a * c,
						b = o * h,
						y = o * c;
					e[0] = h * u, e[4] = y - p * g, e[8] = b * g + _, e[1] = g, e[5] = a * u, e[9] = -o * u, e[2] = -c * u, e[6] = _ * g + b, e[10] = p - y * g
				} else if (t.order === "XZY") {
					let p = a * h,
						_ = a * c,
						b = o * h,
						y = o * c;
					e[0] = h * u, e[4] = -g, e[8] = c * u, e[1] = p * g + y, e[5] = a * u, e[9] = _ * g - b, e[2] = b * g - _, e[6] = o * u, e[10] = y * g + p
				}
				return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
			}
			makeRotationFromQuaternion(t) {
				return this.compose(TC, t, PC)
			}
			lookAt(t, e, n) {
				let r = this.elements;
				return hn.subVectors(t, e), hn.lengthSq() === 0 && (hn.z = 1), hn.normalize(), xs.crossVectors(n, hn), xs.lengthSq() === 0 && (Math.abs(n.z) === 1 ? hn.x += 1e-4 : hn.z += 1e-4, hn.normalize(), xs.crossVectors(n, hn)), xs.normalize(), Yc.crossVectors(hn, xs), r[0] = xs.x, r[4] = Yc.x, r[8] = hn.x, r[1] = xs.y, r[5] = Yc.y, r[9] = hn.y, r[2] = xs.z, r[6] = Yc.z, r[10] = hn.z, this
			}
			multiply(t) {
				return this.multiplyMatrices(this, t)
			}
			premultiply(t) {
				return this.multiplyMatrices(t, this)
			}
			multiplyMatrices(t, e) {
				let n = t.elements,
					r = e.elements,
					s = this.elements,
					a = n[0],
					o = n[4],
					h = n[8],
					c = n[12],
					u = n[1],
					g = n[5],
					p = n[9],
					_ = n[13],
					b = n[2],
					y = n[6],
					w = n[10],
					f = n[14],
					S = n[3],
					x = n[7],
					M = n[11],
					T = n[15],
					I = r[0],
					L = r[4],
					F = r[8],
					k = r[12],
					G = r[1],
					j = r[5],
					U = r[9],
					z = r[13],
					$ = r[2],
					W = r[6],
					O = r[10],
					B = r[14],
					A = r[3],
					D = r[7],
					H = r[11],
					q = r[15];
				return s[0] = a * I + o * G + h * $ + c * A, s[4] = a * L + o * j + h * W + c * D, s[8] = a * F + o * U + h * O + c * H, s[12] = a * k + o * z + h * B + c * q, s[1] = u * I + g * G + p * $ + _ * A, s[5] = u * L + g * j + p * W + _ * D, s[9] = u * F + g * U + p * O + _ * H, s[13] = u * k + g * z + p * B + _ * q, s[2] = b * I + y * G + w * $ + f * A, s[6] = b * L + y * j + w * W + f * D, s[10] = b * F + y * U + w * O + f * H, s[14] = b * k + y * z + w * B + f * q, s[3] = S * I + x * G + M * $ + T * A, s[7] = S * L + x * j + M * W + T * D, s[11] = S * F + x * U + M * O + T * H, s[15] = S * k + x * z + M * B + T * q, this
			}
			multiplyScalar(t) {
				let e = this.elements;
				return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
			}
			determinant() {
				let t = this.elements,
					e = t[0],
					n = t[4],
					r = t[8],
					s = t[12],
					a = t[1],
					o = t[5],
					h = t[9],
					c = t[13],
					u = t[2],
					g = t[6],
					p = t[10],
					_ = t[14],
					b = t[3],
					y = t[7],
					w = t[11],
					f = t[15];
				return b * (+s * h * g - r * c * g - s * o * p + n * c * p + r * o * _ - n * h * _) + y * (+e * h * _ - e * c * p + s * a * p - r * a * _ + r * c * u - s * h * u) + w * (+e * c * g - e * o * _ - s * a * g + n * a * _ + s * o * u - n * c * u) + f * (-r * o * u - e * h * g + e * o * p + r * a * g - n * a * p + n * h * u)
			}
			transpose() {
				let t = this.elements,
					e;
				return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
			}
			setPosition(t, e, n) {
				let r = this.elements;
				return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
			}
			invert() {
				let t = this.elements,
					e = t[0],
					n = t[1],
					r = t[2],
					s = t[3],
					a = t[4],
					o = t[5],
					h = t[6],
					c = t[7],
					u = t[8],
					g = t[9],
					p = t[10],
					_ = t[11],
					b = t[12],
					y = t[13],
					w = t[14],
					f = t[15],
					S = g * w * c - y * p * c + y * h * _ - o * w * _ - g * h * f + o * p * f,
					x = b * p * c - u * w * c - b * h * _ + a * w * _ + u * h * f - a * p * f,
					M = u * y * c - b * g * c + b * o * _ - a * y * _ - u * o * f + a * g * f,
					T = b * g * h - u * y * h - b * o * p + a * y * p + u * o * w - a * g * w,
					I = e * S + n * x + r * M + s * T;
				if (I === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				let L = 1 / I;
				return t[0] = S * L, t[1] = (y * p * s - g * w * s - y * r * _ + n * w * _ + g * r * f - n * p * f) * L, t[2] = (o * w * s - y * h * s + y * r * c - n * w * c - o * r * f + n * h * f) * L, t[3] = (g * h * s - o * p * s - g * r * c + n * p * c + o * r * _ - n * h * _) * L, t[4] = x * L, t[5] = (u * w * s - b * p * s + b * r * _ - e * w * _ - u * r * f + e * p * f) * L, t[6] = (b * h * s - a * w * s - b * r * c + e * w * c + a * r * f - e * h * f) * L, t[7] = (a * p * s - u * h * s + u * r * c - e * p * c - a * r * _ + e * h * _) * L, t[8] = M * L, t[9] = (b * g * s - u * y * s - b * n * _ + e * y * _ + u * n * f - e * g * f) * L, t[10] = (a * y * s - b * o * s + b * n * c - e * y * c - a * n * f + e * o * f) * L, t[11] = (u * o * s - a * g * s - u * n * c + e * g * c + a * n * _ - e * o * _) * L, t[12] = T * L, t[13] = (u * y * r - b * g * r + b * n * p - e * y * p - u * n * w + e * g * w) * L, t[14] = (b * o * r - a * y * r - b * n * h + e * y * h + a * n * w - e * o * w) * L, t[15] = (a * g * r - u * o * r + u * n * h - e * g * h - a * n * p + e * o * p) * L, this
			}
			scale(t) {
				let e = this.elements,
					n = t.x,
					r = t.y,
					s = t.z;
				return e[0] *= n, e[4] *= r, e[8] *= s, e[1] *= n, e[5] *= r, e[9] *= s, e[2] *= n, e[6] *= r, e[10] *= s, e[3] *= n, e[7] *= r, e[11] *= s, this
			}
			getMaxScaleOnAxis() {
				let t = this.elements,
					e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
					n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
					r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
				return Math.sqrt(Math.max(e, n, r))
			}
			makeTranslation(t, e, n) {
				return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
			}
			makeRotationX(t) {
				let e = Math.cos(t),
					n = Math.sin(t);
				return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
			}
			makeRotationY(t) {
				let e = Math.cos(t),
					n = Math.sin(t);
				return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
			}
			makeRotationZ(t) {
				let e = Math.cos(t),
					n = Math.sin(t);
				return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			makeRotationAxis(t, e) {
				let n = Math.cos(e),
					r = Math.sin(e),
					s = 1 - n,
					a = t.x,
					o = t.y,
					h = t.z,
					c = s * a,
					u = s * o;
				return this.set(c * a + n, c * o - r * h, c * h + r * o, 0, c * o + r * h, u * o + n, u * h - r * a, 0, c * h - r * o, u * h + r * a, s * h * h + n, 0, 0, 0, 0, 1), this
			}
			makeScale(t, e, n) {
				return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
			}
			makeShear(t, e, n, r, s, a) {
				return this.set(1, n, s, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this
			}
			compose(t, e, n) {
				let r = this.elements,
					s = e._x,
					a = e._y,
					o = e._z,
					h = e._w,
					c = s + s,
					u = a + a,
					g = o + o,
					p = s * c,
					_ = s * u,
					b = s * g,
					y = a * u,
					w = a * g,
					f = o * g,
					S = h * c,
					x = h * u,
					M = h * g,
					T = n.x,
					I = n.y,
					L = n.z;
				return r[0] = (1 - (y + f)) * T, r[1] = (_ + M) * T, r[2] = (b - x) * T, r[3] = 0, r[4] = (_ - M) * I, r[5] = (1 - (p + f)) * I, r[6] = (w + S) * I, r[7] = 0, r[8] = (b + x) * L, r[9] = (w - S) * L, r[10] = (1 - (p + y)) * L, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
			}
			decompose(t, e, n) {
				let r = this.elements,
					s = po.set(r[0], r[1], r[2]).length(),
					a = po.set(r[4], r[5], r[6]).length(),
					o = po.set(r[8], r[9], r[10]).length();
				this.determinant() < 0 && (s = -s), t.x = r[12], t.y = r[13], t.z = r[14], Fn.copy(this);
				let c = 1 / s,
					u = 1 / a,
					g = 1 / o;
				return Fn.elements[0] *= c, Fn.elements[1] *= c, Fn.elements[2] *= c, Fn.elements[4] *= u, Fn.elements[5] *= u, Fn.elements[6] *= u, Fn.elements[8] *= g, Fn.elements[9] *= g, Fn.elements[10] *= g, e.setFromRotationMatrix(Fn), n.x = s, n.y = a, n.z = o, this
			}
			makePerspective(t, e, n, r, s, a) {
				let o = this.elements,
					h = 2 * s / (e - t),
					c = 2 * s / (n - r),
					u = (e + t) / (e - t),
					g = (n + r) / (n - r),
					p = -(a + s) / (a - s),
					_ = -2 * a * s / (a - s);
				return o[0] = h, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = c, o[9] = g, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = p, o[14] = _, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
			}
			makeOrthographic(t, e, n, r, s, a) {
				let o = this.elements,
					h = 1 / (e - t),
					c = 1 / (n - r),
					u = 1 / (a - s),
					g = (e + t) * h,
					p = (n + r) * c,
					_ = (a + s) * u;
				return o[0] = 2 * h, o[4] = 0, o[8] = 0, o[12] = -g, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -p, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -_, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
			}
			equals(t) {
				let e = this.elements,
					n = t.elements;
				for (let r = 0; r < 16; r++)
					if (e[r] !== n[r]) return !1;
				return !0
			}
			fromArray(t, e = 0) {
				for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
				return this
			}
			toArray(t = [], e = 0) {
				let n = this.elements;
				return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
			}
		},
		po = new ht,
		Fn = new ii,
		TC = new ht(0, 0, 0),
		PC = new ht(1, 1, 1),
		xs = new ht,
		Yc = new ht,
		hn = new ht,
		hy = new ii,
		cy = new lr,
		Ro = class {
			constructor(t = 0, e = 0, n = 0, r = Ro.DEFAULT_ORDER) {
				this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r
			}
			get x() {
				return this._x
			}
			set x(t) {
				this._x = t, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(t) {
				this._y = t, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(t) {
				this._z = t, this._onChangeCallback()
			}
			get order() {
				return this._order
			}
			set order(t) {
				this._order = t, this._onChangeCallback()
			}
			set(t, e, n, r = this._order) {
				return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._order)
			}
			copy(t) {
				return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
			}
			setFromRotationMatrix(t, e = this._order, n = !0) {
				let r = t.elements,
					s = r[0],
					a = r[4],
					o = r[8],
					h = r[1],
					c = r[5],
					u = r[9],
					g = r[2],
					p = r[6],
					_ = r[10];
				switch (e) {
					case "XYZ":
						this._y = Math.asin(Yi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, _), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(p, c), this._z = 0);
						break;
					case "YXZ":
						this._x = Math.asin(-Yi(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, _), this._z = Math.atan2(h, c)) : (this._y = Math.atan2(-g, s), this._z = 0);
						break;
					case "ZXY":
						this._x = Math.asin(Yi(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-g, _), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(h, s));
						break;
					case "ZYX":
						this._y = Math.asin(-Yi(g, -1, 1)), Math.abs(g) < .9999999 ? (this._x = Math.atan2(p, _), this._z = Math.atan2(h, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
						break;
					case "YZX":
						this._z = Math.asin(Yi(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-g, s)) : (this._x = 0, this._y = Math.atan2(o, _));
						break;
					case "XZY":
						this._z = Math.asin(-Yi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-u, _), this._y = 0);
						break;
					default:
						console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
				}
				return this._order = e, n === !0 && this._onChangeCallback(), this
			}
			setFromQuaternion(t, e, n) {
				return hy.makeRotationFromQuaternion(t), this.setFromRotationMatrix(hy, e, n)
			}
			setFromVector3(t, e = this._order) {
				return this.set(t.x, t.y, t.z, e)
			}
			reorder(t) {
				return cy.setFromEuler(this), this.setFromQuaternion(cy, t)
			}
			equals(t) {
				return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
			}
			fromArray(t) {
				return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this
			}
			toArray(t = [], e = 0) {
				return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
			}
			_onChange(t) {
				return this._onChangeCallback = t, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._order
			}
		};
	Ro.DEFAULT_ORDER = "XYZ";
	var Eu = class {
			constructor() {
				this.mask = 1
			}
			set(t) {
				this.mask = (1 << t | 0) >>> 0
			}
			enable(t) {
				this.mask |= 1 << t | 0
			}
			enableAll() {
				this.mask = -1
			}
			toggle(t) {
				this.mask ^= 1 << t | 0
			}
			disable(t) {
				this.mask &= ~(1 << t | 0)
			}
			disableAll() {
				this.mask = 0
			}
			test(t) {
				return (this.mask & t.mask) !== 0
			}
			isEnabled(t) {
				return (this.mask & (1 << t | 0)) !== 0
			}
		},
		AC = 0,
		uy = new ht,
		fo = new lr,
		Lr = new ii,
		Kc = new ht,
		Yl = new ht,
		DC = new ht,
		IC = new lr,
		dy = new ht(1, 0, 0),
		py = new ht(0, 1, 0),
		fy = new ht(0, 0, 1),
		LC = {
			type: "added"
		},
		my = {
			type: "removed"
		},
		fi = class extends Ms {
			constructor() {
				super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
					value: AC++
				}), this.uuid = oh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fi.DEFAULT_UP.clone();
				let t = new ht,
					e = new Ro,
					n = new lr,
					r = new ht(1, 1, 1);

				function s() {
					n.setFromEuler(e, !1)
				}

				function a() {
					e.setFromQuaternion(n, void 0, !1)
				}
				e._onChange(s), n._onChange(a), Object.defineProperties(this, {
					position: {
						configurable: !0,
						enumerable: !0,
						value: t
					},
					rotation: {
						configurable: !0,
						enumerable: !0,
						value: e
					},
					quaternion: {
						configurable: !0,
						enumerable: !0,
						value: n
					},
					scale: {
						configurable: !0,
						enumerable: !0,
						value: r
					},
					modelViewMatrix: {
						value: new ii
					},
					normalMatrix: {
						value: new ue
					}
				}), this.matrix = new ii, this.matrixWorld = new ii, this.matrixAutoUpdate = fi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Eu, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
			}
			onBeforeRender() {}
			onAfterRender() {}
			applyMatrix4(t) {
				this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
			}
			applyQuaternion(t) {
				return this.quaternion.premultiply(t), this
			}
			setRotationFromAxisAngle(t, e) {
				this.quaternion.setFromAxisAngle(t, e)
			}
			setRotationFromEuler(t) {
				this.quaternion.setFromEuler(t, !0)
			}
			setRotationFromMatrix(t) {
				this.quaternion.setFromRotationMatrix(t)
			}
			setRotationFromQuaternion(t) {
				this.quaternion.copy(t)
			}
			rotateOnAxis(t, e) {
				return fo.setFromAxisAngle(t, e), this.quaternion.multiply(fo), this
			}
			rotateOnWorldAxis(t, e) {
				return fo.setFromAxisAngle(t, e), this.quaternion.premultiply(fo), this
			}
			rotateX(t) {
				return this.rotateOnAxis(dy, t)
			}
			rotateY(t) {
				return this.rotateOnAxis(py, t)
			}
			rotateZ(t) {
				return this.rotateOnAxis(fy, t)
			}
			translateOnAxis(t, e) {
				return uy.copy(t).applyQuaternion(this.quaternion), this.position.add(uy.multiplyScalar(e)), this
			}
			translateX(t) {
				return this.translateOnAxis(dy, t)
			}
			translateY(t) {
				return this.translateOnAxis(py, t)
			}
			translateZ(t) {
				return this.translateOnAxis(fy, t)
			}
			localToWorld(t) {
				return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
			}
			worldToLocal(t) {
				return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Lr.copy(this.matrixWorld).invert())
			}
			lookAt(t, e, n) {
				t.isVector3 ? Kc.copy(t) : Kc.set(t, e, n);
				let r = this.parent;
				this.updateWorldMatrix(!0, !1), Yl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Lr.lookAt(Yl, Kc, this.up) : Lr.lookAt(Kc, Yl, this.up), this.quaternion.setFromRotationMatrix(Lr), r && (Lr.extractRotation(r.matrixWorld), fo.setFromRotationMatrix(Lr), this.quaternion.premultiply(fo.invert()))
			}
			add(t) {
				if (arguments.length > 1) {
					for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
					return this
				}
				return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(LC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
			}
			remove(t) {
				if (arguments.length > 1) {
					for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
					return this
				}
				let e = this.children.indexOf(t);
				return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(my)), this
			}
			removeFromParent() {
				let t = this.parent;
				return t !== null && t.remove(this), this
			}
			clear() {
				for (let t = 0; t < this.children.length; t++) {
					let e = this.children[t];
					e.parent = null, e.dispatchEvent(my)
				}
				return this.children.length = 0, this
			}
			attach(t) {
				return this.updateWorldMatrix(!0, !1), Lr.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Lr.multiply(t.parent.matrixWorld)), t.applyMatrix4(Lr), this.add(t), t.updateWorldMatrix(!1, !0), this
			}
			getObjectById(t) {
				return this.getObjectByProperty("id", t)
			}
			getObjectByName(t) {
				return this.getObjectByProperty("name", t)
			}
			getObjectByProperty(t, e) {
				if (this[t] === e) return this;
				for (let n = 0, r = this.children.length; n < r; n++) {
					let a = this.children[n].getObjectByProperty(t, e);
					if (a !== void 0) return a
				}
			}
			getObjectsByProperty(t, e) {
				let n = [];
				this[t] === e && n.push(this);
				for (let r = 0, s = this.children.length; r < s; r++) {
					let a = this.children[r].getObjectsByProperty(t, e);
					a.length > 0 && (n = n.concat(a))
				}
				return n
			}
			getWorldPosition(t) {
				return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
			}
			getWorldQuaternion(t) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yl, t, DC), t
			}
			getWorldScale(t) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yl, IC, t), t
			}
			getWorldDirection(t) {
				this.updateWorldMatrix(!0, !1);
				let e = this.matrixWorld.elements;
				return t.set(e[8], e[9], e[10]).normalize()
			}
			raycast() {}
			traverse(t) {
				t(this);
				let e = this.children;
				for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
			}
			traverseVisible(t) {
				if (this.visible === !1) return;
				t(this);
				let e = this.children;
				for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
			}
			traverseAncestors(t) {
				let e = this.parent;
				e !== null && (t(e), e.traverseAncestors(t))
			}
			updateMatrix() {
				this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
			}
			updateMatrixWorld(t) {
				this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
				let e = this.children;
				for (let n = 0, r = e.length; n < r; n++) {
					let s = e[n];
					(s.matrixWorldAutoUpdate === !0 || t === !0) && s.updateMatrixWorld(t)
				}
			}
			updateWorldMatrix(t, e) {
				let n = this.parent;
				if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
					let r = this.children;
					for (let s = 0, a = r.length; s < a; s++) {
						let o = r[s];
						o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0)
					}
				}
			}
			toJSON(t) {
				let e = t === void 0 || typeof t == "string",
					n = {};
				e && (t = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				}, n.metadata = {
					version: 4.5,
					type: "Object",
					generator: "Object3D.toJSON"
				});
				let r = {};
				r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));

				function s(o, h) {
					return o[h.uuid] === void 0 && (o[h.uuid] = h.toJSON(t)), h.uuid
				}
				if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(t).uuid);
				else if (this.isMesh || this.isLine || this.isPoints) {
					r.geometry = s(t.geometries, this.geometry);
					let o = this.geometry.parameters;
					if (o !== void 0 && o.shapes !== void 0) {
						let h = o.shapes;
						if (Array.isArray(h))
							for (let c = 0, u = h.length; c < u; c++) {
								let g = h[c];
								s(t.shapes, g)
							} else s(t.shapes, h)
					}
				}
				if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
					if (Array.isArray(this.material)) {
						let o = [];
						for (let h = 0, c = this.material.length; h < c; h++) o.push(s(t.materials, this.material[h]));
						r.material = o
					} else r.material = s(t.materials, this.material);
				if (this.children.length > 0) {
					r.children = [];
					for (let o = 0; o < this.children.length; o++) r.children.push(this.children[o].toJSON(t).object)
				}
				if (this.animations.length > 0) {
					r.animations = [];
					for (let o = 0; o < this.animations.length; o++) {
						let h = this.animations[o];
						r.animations.push(s(t.animations, h))
					}
				}
				if (e) {
					let o = a(t.geometries),
						h = a(t.materials),
						c = a(t.textures),
						u = a(t.images),
						g = a(t.shapes),
						p = a(t.skeletons),
						_ = a(t.animations),
						b = a(t.nodes);
					o.length > 0 && (n.geometries = o), h.length > 0 && (n.materials = h), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), g.length > 0 && (n.shapes = g), p.length > 0 && (n.skeletons = p), _.length > 0 && (n.animations = _), b.length > 0 && (n.nodes = b)
				}
				return n.object = r, n;

				function a(o) {
					let h = [];
					for (let c in o) {
						let u = o[c];
						delete u.metadata, h.push(u)
					}
					return h
				}
			}
			clone(t) {
				return new this.constructor().copy(this, t)
			}
			copy(t, e = !0) {
				if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
					for (let n = 0; n < t.children.length; n++) {
						let r = t.children[n];
						this.add(r.clone())
					}
				return this
			}
		};
	fi.DEFAULT_UP = new ht(0, 1, 0);
	fi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
	fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
	var On = new ht,
		kr = new ht,
		Ff = new ht,
		Rr = new ht,
		mo = new ht,
		vo = new ht,
		vy = new ht,
		Of = new ht,
		Nf = new ht,
		Vf = new ht,
		Zc = !1,
		Ki = class {
			constructor(t = new ht, e = new ht, n = new ht) {
				this.a = t, this.b = e, this.c = n
			}
			static getNormal(t, e, n, r) {
				r.subVectors(n, e), On.subVectors(t, e), r.cross(On);
				let s = r.lengthSq();
				return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
			}
			static getBarycoord(t, e, n, r, s) {
				On.subVectors(r, e), kr.subVectors(n, e), Ff.subVectors(t, e);
				let a = On.dot(On),
					o = On.dot(kr),
					h = On.dot(Ff),
					c = kr.dot(kr),
					u = kr.dot(Ff),
					g = a * c - o * o;
				if (g === 0) return s.set(-2, -1, -1);
				let p = 1 / g,
					_ = (c * h - o * u) * p,
					b = (a * u - o * h) * p;
				return s.set(1 - _ - b, b, _)
			}
			static containsPoint(t, e, n, r) {
				return this.getBarycoord(t, e, n, r, Rr), Rr.x >= 0 && Rr.y >= 0 && Rr.x + Rr.y <= 1
			}
			static getUV(t, e, n, r, s, a, o, h) {
				return Zc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Zc = !0), this.getInterpolation(t, e, n, r, s, a, o, h)
			}
			static getInterpolation(t, e, n, r, s, a, o, h) {
				return this.getBarycoord(t, e, n, r, Rr), h.setScalar(0), h.addScaledVector(s, Rr.x), h.addScaledVector(a, Rr.y), h.addScaledVector(o, Rr.z), h
			}
			static isFrontFacing(t, e, n, r) {
				return On.subVectors(n, e), kr.subVectors(t, e), On.cross(kr).dot(r) < 0
			}
			set(t, e, n) {
				return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
			}
			setFromPointsAndIndices(t, e, n, r) {
				return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
			}
			setFromAttributeAndIndices(t, e, n, r) {
				return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
			}
			getArea() {
				return On.subVectors(this.c, this.b), kr.subVectors(this.a, this.b), On.cross(kr).length() * .5
			}
			getMidpoint(t) {
				return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
			}
			getNormal(t) {
				return Ki.getNormal(this.a, this.b, this.c, t)
			}
			getPlane(t) {
				return t.setFromCoplanarPoints(this.a, this.b, this.c)
			}
			getBarycoord(t, e) {
				return Ki.getBarycoord(t, this.a, this.b, this.c, e)
			}
			getUV(t, e, n, r, s) {
				return Zc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Zc = !0), Ki.getInterpolation(t, this.a, this.b, this.c, e, n, r, s)
			}
			getInterpolation(t, e, n, r, s) {
				return Ki.getInterpolation(t, this.a, this.b, this.c, e, n, r, s)
			}
			containsPoint(t) {
				return Ki.containsPoint(t, this.a, this.b, this.c)
			}
			isFrontFacing(t) {
				return Ki.isFrontFacing(this.a, this.b, this.c, t)
			}
			intersectsBox(t) {
				return t.intersectsTriangle(this)
			}
			closestPointToPoint(t, e) {
				let n = this.a,
					r = this.b,
					s = this.c,
					a, o;
				mo.subVectors(r, n), vo.subVectors(s, n), Of.subVectors(t, n);
				let h = mo.dot(Of),
					c = vo.dot(Of);
				if (h <= 0 && c <= 0) return e.copy(n);
				Nf.subVectors(t, r);
				let u = mo.dot(Nf),
					g = vo.dot(Nf);
				if (u >= 0 && g <= u) return e.copy(r);
				let p = h * g - u * c;
				if (p <= 0 && h >= 0 && u <= 0) return a = h / (h - u), e.copy(n).addScaledVector(mo, a);
				Vf.subVectors(t, s);
				let _ = mo.dot(Vf),
					b = vo.dot(Vf);
				if (b >= 0 && _ <= b) return e.copy(s);
				let y = _ * c - h * b;
				if (y <= 0 && c >= 0 && b <= 0) return o = c / (c - b), e.copy(n).addScaledVector(vo, o);
				let w = u * b - _ * g;
				if (w <= 0 && g - u >= 0 && _ - b >= 0) return vy.subVectors(s, r), o = (g - u) / (g - u + (_ - b)), e.copy(r).addScaledVector(vy, o);
				let f = 1 / (w + y + p);
				return a = y * f, o = p * f, e.copy(n).addScaledVector(mo, a).addScaledVector(vo, o)
			}
			equals(t) {
				return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
			}
		},
		kC = 0,
		wa = class extends Ms {
			constructor() {
				super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
					value: kC++
				}), this.uuid = oh(), this.name = "", this.type = "Material", this.blending = Co, this.side = Es, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Ky, this.blendDst = Zy, this.blendEquation = Eo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Xf, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = vC, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ef, this.stencilZFail = Ef, this.stencilZPass = Ef, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
			}
			get alphaTest() {
				return this._alphaTest
			}
			set alphaTest(t) {
				this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
			}
			onBuild() {}
			onBeforeRender() {}
			onBeforeCompile() {}
			customProgramCacheKey() {
				return this.onBeforeCompile.toString()
			}
			setValues(t) {
				if (t !== void 0)
					for (let e in t) {
						let n = t[e];
						if (n === void 0) {
							console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
							continue
						}
						let r = this[e];
						if (r === void 0) {
							console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
							continue
						}
						r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n
					}
			}
			toJSON(t) {
				let e = t === void 0 || typeof t == "string";
				e && (t = {
					textures: {},
					images: {}
				});
				let n = {
					metadata: {
						version: 4.5,
						type: "Material",
						generator: "Material.toJSON"
					}
				};
				n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Co && (n.blending = this.blending), this.side !== Es && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

				function r(s) {
					let a = [];
					for (let o in s) {
						let h = s[o];
						delete h.metadata, a.push(h)
					}
					return a
				}
				if (e) {
					let s = r(t.textures),
						a = r(t.images);
					s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a)
				}
				return n
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
				let e = t.clippingPlanes,
					n = null;
				if (e !== null) {
					let r = e.length;
					n = new Array(r);
					for (let s = 0; s !== r; ++s) n[s] = e[s].clone()
				}
				return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			set needsUpdate(t) {
				t === !0 && this.version++
			}
		},
		nb = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		},
		Nn = {
			h: 0,
			s: 0,
			l: 0
		},
		Jc = {
			h: 0,
			s: 0,
			l: 0
		};

	function zf(i, t, e) {
		return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (t - i) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i + (t - i) * 6 * (2 / 3 - e) : i
	}
	var Pe = class {
			constructor(t, e, n) {
				return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n)
			}
			set(t) {
				return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this
			}
			setScalar(t) {
				return this.r = t, this.g = t, this.b = t, this
			}
			setHex(t, e = sr) {
				return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, ln.toWorkingColorSpace(this, e), this
			}
			setRGB(t, e, n, r = ln.workingColorSpace) {
				return this.r = t, this.g = e, this.b = n, ln.toWorkingColorSpace(this, r), this
			}
			setHSL(t, e, n, r = ln.workingColorSpace) {
				if (t = gC(t, 1), e = Yi(e, 0, 1), n = Yi(n, 0, 1), e === 0) this.r = this.g = this.b = n;
				else {
					let s = n <= .5 ? n * (1 + e) : n + e - n * e,
						a = 2 * n - s;
					this.r = zf(a, s, t + 1 / 3), this.g = zf(a, s, t), this.b = zf(a, s, t - 1 / 3)
				}
				return ln.toWorkingColorSpace(this, r), this
			}
			setStyle(t, e = sr) {
				function n(s) {
					s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
				}
				let r;
				if (r = /^(\w+)\(([^\)]*)\)/.exec(t)) {
					let s, a = r[1],
						o = r[2];
					switch (a) {
						case "rgb":
						case "rgba":
							if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, ln.toWorkingColorSpace(this, e), n(s[4]), this;
							if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, ln.toWorkingColorSpace(this, e), n(s[4]), this;
							break;
						case "hsl":
						case "hsla":
							if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
								let h = parseFloat(s[1]) / 360,
									c = parseFloat(s[2]) / 100,
									u = parseFloat(s[3]) / 100;
								return n(s[4]), this.setHSL(h, c, u, e)
							}
							break;
						default:
							console.warn("THREE.Color: Unknown color model " + t)
					}
				} else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
					let s = r[1],
						a = s.length;
					if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, e);
					if (a === 6) return this.setHex(parseInt(s, 16), e);
					console.warn("THREE.Color: Invalid hex color " + t)
				} else if (t && t.length > 0) return this.setColorName(t, e);
				return this
			}
			setColorName(t, e = sr) {
				let n = nb[t.toLowerCase()];
				return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
			}
			clone() {
				return new this.constructor(this.r, this.g, this.b)
			}
			copy(t) {
				return this.r = t.r, this.g = t.g, this.b = t.b, this
			}
			copySRGBToLinear(t) {
				return this.r = Po(t.r), this.g = Po(t.g), this.b = Po(t.b), this
			}
			copyLinearToSRGB(t) {
				return this.r = Tf(t.r), this.g = Tf(t.g), this.b = Tf(t.b), this
			}
			convertSRGBToLinear() {
				return this.copySRGBToLinear(this), this
			}
			convertLinearToSRGB() {
				return this.copyLinearToSRGB(this), this
			}
			getHex(t = sr) {
				return ln.fromWorkingColorSpace(Mi.copy(this), t), Yi(Mi.r * 255, 0, 255) << 16 ^ Yi(Mi.g * 255, 0, 255) << 8 ^ Yi(Mi.b * 255, 0, 255) << 0
			}
			getHexString(t = sr) {
				return ("FF8500" + this.getHex(t).toString(16)).slice(-6)
			}
			getHSL(t, e = ln.workingColorSpace) {
				ln.fromWorkingColorSpace(Mi.copy(this), e);
				let n = Mi.r,
					r = Mi.g,
					s = Mi.b,
					a = Math.max(n, r, s),
					o = Math.min(n, r, s),
					h, c, u = (o + a) / 2;
				if (o === a) h = 0, c = 0;
				else {
					let g = a - o;
					switch (c = u <= .5 ? g / (a + o) : g / (2 - a - o), a) {
						case n:
							h = (r - s) / g + (r < s ? 6 : 0);
							break;
						case r:
							h = (s - n) / g + 2;
							break;
						case s:
							h = (n - r) / g + 4;
							break
					}
					h /= 6
				}
				return t.h = h, t.s = c, t.l = u, t
			}
			getRGB(t, e = ln.workingColorSpace) {
				return ln.fromWorkingColorSpace(Mi.copy(this), e), t.r = Mi.r, t.g = Mi.g, t.b = Mi.b, t
			}
			getStyle(t = sr) {
				ln.fromWorkingColorSpace(Mi.copy(this), t);
				let e = Mi.r,
					n = Mi.g,
					r = Mi.b;
				return t !== sr ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${e*255|0},${n*255|0},${r*255|0})`
			}
			offsetHSL(t, e, n) {
				return this.getHSL(Nn), Nn.h += t, Nn.s += e, Nn.l += n, this.setHSL(Nn.h, Nn.s, Nn.l), this
			}
			add(t) {
				return this.r += t.r, this.g += t.g, this.b += t.b, this
			}
			addColors(t, e) {
				return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
			}
			addScalar(t) {
				return this.r += t, this.g += t, this.b += t, this
			}
			sub(t) {
				return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
			}
			multiply(t) {
				return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
			}
			multiplyScalar(t) {
				return this.r *= t, this.g *= t, this.b *= t, this
			}
			lerp(t, e) {
				return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
			}
			lerpColors(t, e, n) {
				return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
			}
			lerpHSL(t, e) {
				this.getHSL(Nn), t.getHSL(Jc);
				let n = Mf(Nn.h, Jc.h, e),
					r = Mf(Nn.s, Jc.s, e),
					s = Mf(Nn.l, Jc.l, e);
				return this.setHSL(n, r, s), this
			}
			setFromVector3(t) {
				return this.r = t.x, this.g = t.y, this.b = t.z, this
			}
			applyMatrix3(t) {
				let e = this.r,
					n = this.g,
					r = this.b,
					s = t.elements;
				return this.r = s[0] * e + s[3] * n + s[6] * r, this.g = s[1] * e + s[4] * n + s[7] * r, this.b = s[2] * e + s[5] * n + s[8] * r, this
			}
			equals(t) {
				return t.r === this.r && t.g === this.g && t.b === this.b
			}
			fromArray(t, e = 0) {
				return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
			}
			toArray(t = [], e = 0) {
				return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
			}
			fromBufferAttribute(t, e) {
				return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
			}
			toJSON() {
				return this.getHex()
			}*[Symbol.iterator]() {
				yield this.r, yield this.g, yield this.b
			}
		},
		Mi = new Pe;
	Pe.NAMES = nb;
	var Mu = class extends wa {
		constructor(t) {
			super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Pe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Jy, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
		}
		copy(t) {
			return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
		}
	};
	var ei = new ht,
		Qc = new Oe,
		Ji = class {
			constructor(t, e, n = !1) {
				if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
				this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = sy, this.updateRange = {
					offset: 0,
					count: -1
				}, this.version = 0
			}
			onUploadCallback() {}
			set needsUpdate(t) {
				t === !0 && this.version++
			}
			setUsage(t) {
				return this.usage = t, this
			}
			copy(t) {
				return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
			}
			copyAt(t, e, n) {
				t *= this.itemSize, n *= e.itemSize;
				for (let r = 0, s = this.itemSize; r < s; r++) this.array[t + r] = e.array[n + r];
				return this
			}
			copyArray(t) {
				return this.array.set(t), this
			}
			applyMatrix3(t) {
				if (this.itemSize === 2)
					for (let e = 0, n = this.count; e < n; e++) Qc.fromBufferAttribute(this, e), Qc.applyMatrix3(t), this.setXY(e, Qc.x, Qc.y);
				else if (this.itemSize === 3)
					for (let e = 0, n = this.count; e < n; e++) ei.fromBufferAttribute(this, e), ei.applyMatrix3(t), this.setXYZ(e, ei.x, ei.y, ei.z);
				return this
			}
			applyMatrix4(t) {
				for (let e = 0, n = this.count; e < n; e++) ei.fromBufferAttribute(this, e), ei.applyMatrix4(t), this.setXYZ(e, ei.x, ei.y, ei.z);
				return this
			}
			applyNormalMatrix(t) {
				for (let e = 0, n = this.count; e < n; e++) ei.fromBufferAttribute(this, e), ei.applyNormalMatrix(t), this.setXYZ(e, ei.x, ei.y, ei.z);
				return this
			}
			transformDirection(t) {
				for (let e = 0, n = this.count; e < n; e++) ei.fromBufferAttribute(this, e), ei.transformDirection(t), this.setXYZ(e, ei.x, ei.y, ei.z);
				return this
			}
			set(t, e = 0) {
				return this.array.set(t, e), this
			}
			getX(t) {
				let e = this.array[t * this.itemSize];
				return this.normalized && (e = Wc(e, this.array)), e
			}
			setX(t, e) {
				return this.normalized && (e = on(e, this.array)), this.array[t * this.itemSize] = e, this
			}
			getY(t) {
				let e = this.array[t * this.itemSize + 1];
				return this.normalized && (e = Wc(e, this.array)), e
			}
			setY(t, e) {
				return this.normalized && (e = on(e, this.array)), this.array[t * this.itemSize + 1] = e, this
			}
			getZ(t) {
				let e = this.array[t * this.itemSize + 2];
				return this.normalized && (e = Wc(e, this.array)), e
			}
			setZ(t, e) {
				return this.normalized && (e = on(e, this.array)), this.array[t * this.itemSize + 2] = e, this
			}
			getW(t) {
				let e = this.array[t * this.itemSize + 3];
				return this.normalized && (e = Wc(e, this.array)), e
			}
			setW(t, e) {
				return this.normalized && (e = on(e, this.array)), this.array[t * this.itemSize + 3] = e, this
			}
			setXY(t, e, n) {
				return t *= this.itemSize, this.normalized && (e = on(e, this.array), n = on(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
			}
			setXYZ(t, e, n, r) {
				return t *= this.itemSize, this.normalized && (e = on(e, this.array), n = on(n, this.array), r = on(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
			}
			setXYZW(t, e, n, r, s) {
				return t *= this.itemSize, this.normalized && (e = on(e, this.array), n = on(n, this.array), r = on(r, this.array), s = on(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = s, this
			}
			onUpload(t) {
				return this.onUploadCallback = t, this
			}
			clone() {
				return new this.constructor(this.array, this.itemSize).copy(this)
			}
			toJSON() {
				let t = {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: Array.from(this.array),
					normalized: this.normalized
				};
				return this.name !== "" && (t.name = this.name), this.usage !== sy && (t.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (t.updateRange = this.updateRange), t
			}
			copyColorsArray() {
				console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
			}
			copyVector2sArray() {
				console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
			}
			copyVector3sArray() {
				console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
			}
			copyVector4sArray() {
				console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
			}
		};
	var Cu = class extends Ji {
		constructor(t, e, n) {
			super(new Uint16Array(t), e, n)
		}
	};
	var Tu = class extends Ji {
		constructor(t, e, n) {
			super(new Uint32Array(t), e, n)
		}
	};
	var Qi = class extends Ji {
		constructor(t, e, n) {
			super(new Float32Array(t), e, n)
		}
	};
	var RC = 0,
		En = new ii,
		Bf = new fi,
		go = new ht,
		cn = new xa,
		Kl = new xa,
		pi = new ht,
		tn = class extends Ms {
			constructor() {
				super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
					value: RC++
				}), this.uuid = oh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
					start: 0,
					count: 1 / 0
				}, this.userData = {}
			}
			getIndex() {
				return this.index
			}
			setIndex(t) {
				return Array.isArray(t) ? this.index = new(ib(t) ? Tu : Cu)(t, 1) : this.index = t, this
			}
			getAttribute(t) {
				return this.attributes[t]
			}
			setAttribute(t, e) {
				return this.attributes[t] = e, this
			}
			deleteAttribute(t) {
				return delete this.attributes[t], this
			}
			hasAttribute(t) {
				return this.attributes[t] !== void 0
			}
			addGroup(t, e, n = 0) {
				this.groups.push({
					start: t,
					count: e,
					materialIndex: n
				})
			}
			clearGroups() {
				this.groups = []
			}
			setDrawRange(t, e) {
				this.drawRange.start = t, this.drawRange.count = e
			}
			applyMatrix4(t) {
				let e = this.attributes.position;
				e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
				let n = this.attributes.normal;
				if (n !== void 0) {
					let s = new ue().getNormalMatrix(t);
					n.applyNormalMatrix(s), n.needsUpdate = !0
				}
				let r = this.attributes.tangent;
				return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
			}
			applyQuaternion(t) {
				return En.makeRotationFromQuaternion(t), this.applyMatrix4(En), this
			}
			rotateX(t) {
				return En.makeRotationX(t), this.applyMatrix4(En), this
			}
			rotateY(t) {
				return En.makeRotationY(t), this.applyMatrix4(En), this
			}
			rotateZ(t) {
				return En.makeRotationZ(t), this.applyMatrix4(En), this
			}
			translate(t, e, n) {
				return En.makeTranslation(t, e, n), this.applyMatrix4(En), this
			}
			scale(t, e, n) {
				return En.makeScale(t, e, n), this.applyMatrix4(En), this
			}
			lookAt(t) {
				return Bf.lookAt(t), Bf.updateMatrix(), this.applyMatrix4(Bf.matrix), this
			}
			center() {
				return this.computeBoundingBox(), this.boundingBox.getCenter(go).negate(), this.translate(go.x, go.y, go.z), this
			}
			setFromPoints(t) {
				let e = [];
				for (let n = 0, r = t.length; n < r; n++) {
					let s = t[n];
					e.push(s.x, s.y, s.z || 0)
				}
				return this.setAttribute("position", new Qi(e, 3)), this
			}
			computeBoundingBox() {
				this.boundingBox === null && (this.boundingBox = new xa);
				let t = this.attributes.position,
					e = this.morphAttributes.position;
				if (t && t.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new ht(-1 / 0, -1 / 0, -1 / 0), new ht(1 / 0, 1 / 0, 1 / 0));
					return
				}
				if (t !== void 0) {
					if (this.boundingBox.setFromBufferAttribute(t), e)
						for (let n = 0, r = e.length; n < r; n++) {
							let s = e[n];
							cn.setFromBufferAttribute(s), this.morphTargetsRelative ? (pi.addVectors(this.boundingBox.min, cn.min), this.boundingBox.expandByPoint(pi), pi.addVectors(this.boundingBox.max, cn.max), this.boundingBox.expandByPoint(pi)) : (this.boundingBox.expandByPoint(cn.min), this.boundingBox.expandByPoint(cn.max))
						}
				} else this.boundingBox.makeEmpty();
				(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
			}
			computeBoundingSphere() {
				this.boundingSphere === null && (this.boundingSphere = new ko);
				let t = this.attributes.position,
					e = this.morphAttributes.position;
				if (t && t.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new ht, 1 / 0);
					return
				}
				if (t) {
					let n = this.boundingSphere.center;
					if (cn.setFromBufferAttribute(t), e)
						for (let s = 0, a = e.length; s < a; s++) {
							let o = e[s];
							Kl.setFromBufferAttribute(o), this.morphTargetsRelative ? (pi.addVectors(cn.min, Kl.min), cn.expandByPoint(pi), pi.addVectors(cn.max, Kl.max), cn.expandByPoint(pi)) : (cn.expandByPoint(Kl.min), cn.expandByPoint(Kl.max))
						}
					cn.getCenter(n);
					let r = 0;
					for (let s = 0, a = t.count; s < a; s++) pi.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(pi));
					if (e)
						for (let s = 0, a = e.length; s < a; s++) {
							let o = e[s],
								h = this.morphTargetsRelative;
							for (let c = 0, u = o.count; c < u; c++) pi.fromBufferAttribute(o, c), h && (go.fromBufferAttribute(t, c), pi.add(go)), r = Math.max(r, n.distanceToSquared(pi))
						}
					this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
				}
			}
			computeTangents() {
				let t = this.index,
					e = this.attributes;
				if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
					console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
					return
				}
				let n = t.array,
					r = e.position.array,
					s = e.normal.array,
					a = e.uv.array,
					o = r.length / 3;
				this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ji(new Float32Array(4 * o), 4));
				let h = this.getAttribute("tangent").array,
					c = [],
					u = [];
				for (let G = 0; G < o; G++) c[G] = new ht, u[G] = new ht;
				let g = new ht,
					p = new ht,
					_ = new ht,
					b = new Oe,
					y = new Oe,
					w = new Oe,
					f = new ht,
					S = new ht;

				function x(G, j, U) {
					g.fromArray(r, G * 3), p.fromArray(r, j * 3), _.fromArray(r, U * 3), b.fromArray(a, G * 2), y.fromArray(a, j * 2), w.fromArray(a, U * 2), p.sub(g), _.sub(g), y.sub(b), w.sub(b);
					let z = 1 / (y.x * w.y - w.x * y.y);
					isFinite(z) && (f.copy(p).multiplyScalar(w.y).addScaledVector(_, -y.y).multiplyScalar(z), S.copy(_).multiplyScalar(y.x).addScaledVector(p, -w.x).multiplyScalar(z), c[G].add(f), c[j].add(f), c[U].add(f), u[G].add(S), u[j].add(S), u[U].add(S))
				}
				let M = this.groups;
				M.length === 0 && (M = [{
					start: 0,
					count: n.length
				}]);
				for (let G = 0, j = M.length; G < j; ++G) {
					let U = M[G],
						z = U.start,
						$ = U.count;
					for (let W = z, O = z + $; W < O; W += 3) x(n[W + 0], n[W + 1], n[W + 2])
				}
				let T = new ht,
					I = new ht,
					L = new ht,
					F = new ht;

				function k(G) {
					L.fromArray(s, G * 3), F.copy(L);
					let j = c[G];
					T.copy(j), T.sub(L.multiplyScalar(L.dot(j))).normalize(), I.crossVectors(F, j);
					let z = I.dot(u[G]) < 0 ? -1 : 1;
					h[G * 4] = T.x, h[G * 4 + 1] = T.y, h[G * 4 + 2] = T.z, h[G * 4 + 3] = z
				}
				for (let G = 0, j = M.length; G < j; ++G) {
					let U = M[G],
						z = U.start,
						$ = U.count;
					for (let W = z, O = z + $; W < O; W += 3) k(n[W + 0]), k(n[W + 1]), k(n[W + 2])
				}
			}
			computeVertexNormals() {
				let t = this.index,
					e = this.getAttribute("position");
				if (e !== void 0) {
					let n = this.getAttribute("normal");
					if (n === void 0) n = new Ji(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
					else
						for (let p = 0, _ = n.count; p < _; p++) n.setXYZ(p, 0, 0, 0);
					let r = new ht,
						s = new ht,
						a = new ht,
						o = new ht,
						h = new ht,
						c = new ht,
						u = new ht,
						g = new ht;
					if (t)
						for (let p = 0, _ = t.count; p < _; p += 3) {
							let b = t.getX(p + 0),
								y = t.getX(p + 1),
								w = t.getX(p + 2);
							r.fromBufferAttribute(e, b), s.fromBufferAttribute(e, y), a.fromBufferAttribute(e, w), u.subVectors(a, s), g.subVectors(r, s), u.cross(g), o.fromBufferAttribute(n, b), h.fromBufferAttribute(n, y), c.fromBufferAttribute(n, w), o.add(u), h.add(u), c.add(u), n.setXYZ(b, o.x, o.y, o.z), n.setXYZ(y, h.x, h.y, h.z), n.setXYZ(w, c.x, c.y, c.z)
						} else
							for (let p = 0, _ = e.count; p < _; p += 3) r.fromBufferAttribute(e, p + 0), s.fromBufferAttribute(e, p + 1), a.fromBufferAttribute(e, p + 2), u.subVectors(a, s), g.subVectors(r, s), u.cross(g), n.setXYZ(p + 0, u.x, u.y, u.z), n.setXYZ(p + 1, u.x, u.y, u.z), n.setXYZ(p + 2, u.x, u.y, u.z);
					this.normalizeNormals(), n.needsUpdate = !0
				}
			}
			merge() {
				return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."), this
			}
			normalizeNormals() {
				let t = this.attributes.normal;
				for (let e = 0, n = t.count; e < n; e++) pi.fromBufferAttribute(t, e), pi.normalize(), t.setXYZ(e, pi.x, pi.y, pi.z)
			}
			toNonIndexed() {
				function t(o, h) {
					let c = o.array,
						u = o.itemSize,
						g = o.normalized,
						p = new c.constructor(h.length * u),
						_ = 0,
						b = 0;
					for (let y = 0, w = h.length; y < w; y++) {
						o.isInterleavedBufferAttribute ? _ = h[y] * o.data.stride + o.offset : _ = h[y] * u;
						for (let f = 0; f < u; f++) p[b++] = c[_++]
					}
					return new Ji(p, u, g)
				}
				if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
				let e = new tn,
					n = this.index.array,
					r = this.attributes;
				for (let o in r) {
					let h = r[o],
						c = t(h, n);
					e.setAttribute(o, c)
				}
				let s = this.morphAttributes;
				for (let o in s) {
					let h = [],
						c = s[o];
					for (let u = 0, g = c.length; u < g; u++) {
						let p = c[u],
							_ = t(p, n);
						h.push(_)
					}
					e.morphAttributes[o] = h
				}
				e.morphTargetsRelative = this.morphTargetsRelative;
				let a = this.groups;
				for (let o = 0, h = a.length; o < h; o++) {
					let c = a[o];
					e.addGroup(c.start, c.count, c.materialIndex)
				}
				return e
			}
			toJSON() {
				let t = {
					metadata: {
						version: 4.5,
						type: "BufferGeometry",
						generator: "BufferGeometry.toJSON"
					}
				};
				if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
					let h = this.parameters;
					for (let c in h) h[c] !== void 0 && (t[c] = h[c]);
					return t
				}
				t.data = {
					attributes: {}
				};
				let e = this.index;
				e !== null && (t.data.index = {
					type: e.array.constructor.name,
					array: Array.prototype.slice.call(e.array)
				});
				let n = this.attributes;
				for (let h in n) {
					let c = n[h];
					t.data.attributes[h] = c.toJSON(t.data)
				}
				let r = {},
					s = !1;
				for (let h in this.morphAttributes) {
					let c = this.morphAttributes[h],
						u = [];
					for (let g = 0, p = c.length; g < p; g++) {
						let _ = c[g];
						u.push(_.toJSON(t.data))
					}
					u.length > 0 && (r[h] = u, s = !0)
				}
				s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
				let a = this.groups;
				a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
				let o = this.boundingSphere;
				return o !== null && (t.data.boundingSphere = {
					center: o.center.toArray(),
					radius: o.radius
				}), t
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(t) {
				this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
				let e = {};
				this.name = t.name;
				let n = t.index;
				n !== null && this.setIndex(n.clone(e));
				let r = t.attributes;
				for (let c in r) {
					let u = r[c];
					this.setAttribute(c, u.clone(e))
				}
				let s = t.morphAttributes;
				for (let c in s) {
					let u = [],
						g = s[c];
					for (let p = 0, _ = g.length; p < _; p++) u.push(g[p].clone(e));
					this.morphAttributes[c] = u
				}
				this.morphTargetsRelative = t.morphTargetsRelative;
				let a = t.groups;
				for (let c = 0, u = a.length; c < u; c++) {
					let g = a[c];
					this.addGroup(g.start, g.count, g.materialIndex)
				}
				let o = t.boundingBox;
				o !== null && (this.boundingBox = o.clone());
				let h = t.boundingSphere;
				return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		gy = new ii,
		rr = new Su,
		tu = new ko,
		_y = new ht,
		_o = new ht,
		yo = new ht,
		bo = new ht,
		Uf = new ht,
		eu = new ht,
		iu = new Oe,
		nu = new Oe,
		ru = new Oe,
		yy = new ht,
		by = new ht,
		xy = new ht,
		su = new ht,
		au = new ht,
		or = class extends fi {
			constructor(t = new tn, e = new Mu) {
				super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
			}
			copy(t, e) {
				return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
			}
			updateMorphTargets() {
				let e = this.geometry.morphAttributes,
					n = Object.keys(e);
				if (n.length > 0) {
					let r = e[n[0]];
					if (r !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, a = r.length; s < a; s++) {
							let o = r[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
						}
					}
				}
			}
			getVertexPosition(t, e) {
				let n = this.geometry,
					r = n.attributes.position,
					s = n.morphAttributes.position,
					a = n.morphTargetsRelative;
				e.fromBufferAttribute(r, t);
				let o = this.morphTargetInfluences;
				if (s && o) {
					eu.set(0, 0, 0);
					for (let h = 0, c = s.length; h < c; h++) {
						let u = o[h],
							g = s[h];
						u !== 0 && (Uf.fromBufferAttribute(g, t), a ? eu.addScaledVector(Uf, u) : eu.addScaledVector(Uf.sub(e), u))
					}
					e.add(eu)
				}
				return this.isSkinnedMesh && this.applyBoneTransform(t, e), e
			}
			raycast(t, e) {
				let n = this.geometry,
					r = this.material,
					s = this.matrixWorld;
				if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), tu.copy(n.boundingSphere), tu.applyMatrix4(s), rr.copy(t.ray).recast(t.near), tu.containsPoint(rr.origin) === !1 && (rr.intersectSphere(tu, _y) === null || rr.origin.distanceToSquared(_y) > tp(t.far - t.near, 2))) || (gy.copy(s).invert(), rr.copy(t.ray).applyMatrix4(gy), n.boundingBox !== null && rr.intersectsBox(n.boundingBox) === !1)) return;
				let a, o = n.index,
					h = n.attributes.position,
					c = n.attributes.uv,
					u = n.attributes.uv2,
					g = n.attributes.normal,
					p = n.groups,
					_ = n.drawRange;
				if (o !== null)
					if (Array.isArray(r))
						for (let b = 0, y = p.length; b < y; b++) {
							let w = p[b],
								f = r[w.materialIndex],
								S = Math.max(w.start, _.start),
								x = Math.min(o.count, Math.min(w.start + w.count, _.start + _.count));
							for (let M = S, T = x; M < T; M += 3) {
								let I = o.getX(M),
									L = o.getX(M + 1),
									F = o.getX(M + 2);
								a = ou(this, f, t, rr, c, u, g, I, L, F), a && (a.faceIndex = Math.floor(M / 3), a.face.materialIndex = w.materialIndex, e.push(a))
							}
						} else {
							let b = Math.max(0, _.start),
								y = Math.min(o.count, _.start + _.count);
							for (let w = b, f = y; w < f; w += 3) {
								let S = o.getX(w),
									x = o.getX(w + 1),
									M = o.getX(w + 2);
								a = ou(this, r, t, rr, c, u, g, S, x, M), a && (a.faceIndex = Math.floor(w / 3), e.push(a))
							}
						} else if (h !== void 0)
							if (Array.isArray(r))
								for (let b = 0, y = p.length; b < y; b++) {
									let w = p[b],
										f = r[w.materialIndex],
										S = Math.max(w.start, _.start),
										x = Math.min(h.count, Math.min(w.start + w.count, _.start + _.count));
									for (let M = S, T = x; M < T; M += 3) {
										let I = M,
											L = M + 1,
											F = M + 2;
										a = ou(this, f, t, rr, c, u, g, I, L, F), a && (a.faceIndex = Math.floor(M / 3), a.face.materialIndex = w.materialIndex, e.push(a))
									}
								} else {
									let b = Math.max(0, _.start),
										y = Math.min(h.count, _.start + _.count);
									for (let w = b, f = y; w < f; w += 3) {
										let S = w,
											x = w + 1,
											M = w + 2;
										a = ou(this, r, t, rr, c, u, g, S, x, M), a && (a.faceIndex = Math.floor(w / 3), e.push(a))
									}
								}
			}
		};

	function FC(i, t, e, n, r, s, a, o) {
		let h;
		if (t.side === Zi ? h = n.intersectTriangle(a, s, r, !0, o) : h = n.intersectTriangle(r, s, a, t.side === Es, o), h === null) return null;
		au.copy(o), au.applyMatrix4(i.matrixWorld);
		let c = e.ray.origin.distanceTo(au);
		return c < e.near || c > e.far ? null : {
			distance: c,
			point: au.clone(),
			object: i
		}
	}

	function ou(i, t, e, n, r, s, a, o, h, c) {
		i.getVertexPosition(o, _o), i.getVertexPosition(h, yo), i.getVertexPosition(c, bo);
		let u = FC(i, t, e, n, _o, yo, bo, su);
		if (u) {
			r && (iu.fromBufferAttribute(r, o), nu.fromBufferAttribute(r, h), ru.fromBufferAttribute(r, c), u.uv = Ki.getInterpolation(su, _o, yo, bo, iu, nu, ru, new Oe)), s && (iu.fromBufferAttribute(s, o), nu.fromBufferAttribute(s, h), ru.fromBufferAttribute(s, c), u.uv2 = Ki.getInterpolation(su, _o, yo, bo, iu, nu, ru, new Oe)), a && (yy.fromBufferAttribute(a, o), by.fromBufferAttribute(a, h), xy.fromBufferAttribute(a, c), u.normal = Ki.getInterpolation(su, _o, yo, bo, yy, by, xy, new ht), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
			let g = {
				a: o,
				b: h,
				c,
				normal: new ht,
				materialIndex: 0
			};
			Ki.getNormal(_o, yo, bo, g.normal), u.face = g
		}
		return u
	}
	var Sa = class extends tn {
		constructor(t = 1, e = 1, n = 1, r = 1, s = 1, a = 1) {
			super(), this.type = "BoxGeometry", this.parameters = {
				width: t,
				height: e,
				depth: n,
				widthSegments: r,
				heightSegments: s,
				depthSegments: a
			};
			let o = this;
			r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
			let h = [],
				c = [],
				u = [],
				g = [],
				p = 0,
				_ = 0;
			b("z", "y", "x", -1, -1, n, e, t, a, s, 0), b("z", "y", "x", 1, -1, n, e, -t, a, s, 1), b("x", "z", "y", 1, 1, t, n, e, r, a, 2), b("x", "z", "y", 1, -1, t, n, -e, r, a, 3), b("x", "y", "z", 1, -1, t, e, n, r, s, 4), b("x", "y", "z", -1, -1, t, e, -n, r, s, 5), this.setIndex(h), this.setAttribute("position", new Qi(c, 3)), this.setAttribute("normal", new Qi(u, 3)), this.setAttribute("uv", new Qi(g, 2));

			function b(y, w, f, S, x, M, T, I, L, F, k) {
				let G = M / L,
					j = T / F,
					U = M / 2,
					z = T / 2,
					$ = I / 2,
					W = L + 1,
					O = F + 1,
					B = 0,
					A = 0,
					D = new ht;
				for (let H = 0; H < O; H++) {
					let q = H * j - z;
					for (let Q = 0; Q < W; Q++) {
						let tt = Q * G - U;
						D[y] = tt * S, D[w] = q * x, D[f] = $, c.push(D.x, D.y, D.z), D[y] = 0, D[w] = 0, D[f] = I > 0 ? 1 : -1, u.push(D.x, D.y, D.z), g.push(Q / L), g.push(1 - H / F), B += 1
					}
				}
				for (let H = 0; H < F; H++)
					for (let q = 0; q < L; q++) {
						let Q = p + q + W * H,
							tt = p + q + W * (H + 1),
							nt = p + (q + 1) + W * (H + 1),
							ut = p + (q + 1) + W * H;
						h.push(Q, tt, ut), h.push(tt, nt, ut), A += 6
					}
				o.addGroup(_, A, k), _ += A, p += B
			}
		}
		copy(t) {
			return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
		}
		static fromJSON(t) {
			return new Sa(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
		}
	};

	function Fo(i) {
		let t = {};
		for (let e in i) {
			t[e] = {};
			for (let n in i[e]) {
				let r = i[e][n];
				r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = r.clone() : Array.isArray(r) ? t[e][n] = r.slice() : t[e][n] = r
			}
		}
		return t
	}

	function Ri(i) {
		let t = {};
		for (let e = 0; e < i.length; e++) {
			let n = Fo(i[e]);
			for (let r in n) t[r] = n[r]
		}
		return t
	}

	function OC(i) {
		let t = [];
		for (let e = 0; e < i.length; e++) t.push(i[e].clone());
		return t
	}

	function rb(i) {
		return i.getRenderTarget() === null && i.outputEncoding === ze ? sr : ih
	}
	var NC = {
			clone: Fo,
			merge: Ri
		},
		VC = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
		zC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
		Bn = class extends wa {
			constructor(t) {
				super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = VC, this.fragmentShader = zC, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1
				}, this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv2: [0, 0]
				}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t)
			}
			copy(t) {
				return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Fo(t.uniforms), this.uniformsGroups = OC(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
			}
			toJSON(t) {
				let e = super.toJSON(t);
				e.glslVersion = this.glslVersion, e.uniforms = {};
				for (let r in this.uniforms) {
					let a = this.uniforms[r].value;
					a && a.isTexture ? e.uniforms[r] = {
						type: "t",
						value: a.toJSON(t).uuid
					} : a && a.isColor ? e.uniforms[r] = {
						type: "c",
						value: a.getHex()
					} : a && a.isVector2 ? e.uniforms[r] = {
						type: "v2",
						value: a.toArray()
					} : a && a.isVector3 ? e.uniforms[r] = {
						type: "v3",
						value: a.toArray()
					} : a && a.isVector4 ? e.uniforms[r] = {
						type: "v4",
						value: a.toArray()
					} : a && a.isMatrix3 ? e.uniforms[r] = {
						type: "m3",
						value: a.toArray()
					} : a && a.isMatrix4 ? e.uniforms[r] = {
						type: "m4",
						value: a.toArray()
					} : e.uniforms[r] = {
						value: a
					}
				}
				Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
				let n = {};
				for (let r in this.extensions) this.extensions[r] === !0 && (n[r] = !0);
				return Object.keys(n).length > 0 && (e.extensions = n), e
			}
		},
		Pu = class extends fi {
			constructor() {
				super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ii, this.projectionMatrix = new ii, this.projectionMatrixInverse = new ii
			}
			copy(t, e) {
				return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
			}
			getWorldDirection(t) {
				this.updateWorldMatrix(!0, !1);
				let e = this.matrixWorld.elements;
				return t.set(-e[8], -e[9], -e[10]).normalize()
			}
			updateMatrixWorld(t) {
				super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
			}
			updateWorldMatrix(t, e) {
				super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		Oi = class extends Pu {
			constructor(t = 50, e = 1, n = .1, r = 2e3) {
				super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
			}
			copy(t, e) {
				return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
			}
			setFocalLength(t) {
				let e = .5 * this.getFilmHeight() / t;
				this.fov = tm * 2 * Math.atan(e), this.updateProjectionMatrix()
			}
			getFocalLength() {
				let t = Math.tan(vu * .5 * this.fov);
				return .5 * this.getFilmHeight() / t
			}
			getEffectiveFOV() {
				return tm * 2 * Math.atan(Math.tan(vu * .5 * this.fov) / this.zoom)
			}
			getFilmWidth() {
				return this.filmGauge * Math.min(this.aspect, 1)
			}
			getFilmHeight() {
				return this.filmGauge / Math.max(this.aspect, 1)
			}
			setViewOffset(t, e, n, r, s, a) {
				this.aspect = t / e, this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let t = this.near,
					e = t * Math.tan(vu * .5 * this.fov) / this.zoom,
					n = 2 * e,
					r = this.aspect * n,
					s = -.5 * r,
					a = this.view;
				if (this.view !== null && this.view.enabled) {
					let h = a.fullWidth,
						c = a.fullHeight;
					s += a.offsetX * r / h, e -= a.offsetY * n / c, r *= a.width / h, n *= a.height / c
				}
				let o = this.filmOffset;
				o !== 0 && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
			}
			toJSON(t) {
				let e = super.toJSON(t);
				return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
			}
		},
		xo = -90,
		wo = 1,
		im = class extends fi {
			constructor(t, e, n) {
				super(), this.type = "CubeCamera", this.renderTarget = n;
				let r = new Oi(xo, wo, t, e);
				r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r);
				let s = new Oi(xo, wo, t, e);
				s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
				let a = new Oi(xo, wo, t, e);
				a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(0, 1, 0), this.add(a);
				let o = new Oi(xo, wo, t, e);
				o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(0, -1, 0), this.add(o);
				let h = new Oi(xo, wo, t, e);
				h.layers = this.layers, h.up.set(0, 1, 0), h.lookAt(0, 0, 1), this.add(h);
				let c = new Oi(xo, wo, t, e);
				c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c)
			}
			update(t, e) {
				this.parent === null && this.updateMatrixWorld();
				let n = this.renderTarget,
					[r, s, a, o, h, c] = this.children,
					u = t.getRenderTarget(),
					g = t.toneMapping,
					p = t.xr.enabled;
				t.toneMapping = Vr, t.xr.enabled = !1;
				let _ = n.texture.generateMipmaps;
				n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, h), n.texture.generateMipmaps = _, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.toneMapping = g, t.xr.enabled = p, n.texture.needsPMREMUpdate = !0
			}
		},
		Au = class extends Ni {
			constructor(t, e, n, r, s, a, o, h, c, u) {
				t = t !== void 0 ? t : [], e = e !== void 0 ? e : Do, super(t, e, n, r, s, a, o, h, c, u), this.isCubeTexture = !0, this.flipY = !1
			}
			get images() {
				return this.image
			}
			set images(t) {
				this.image = t
			}
		},
		nm = class extends zr {
			constructor(t = 1, e = {}) {
				super(t, t, e), this.isWebGLCubeRenderTarget = !0;
				let n = {
						width: t,
						height: t,
						depth: 1
					},
					r = [n, n, n, n, n, n];
				this.texture = new Au(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Mn
			}
			fromEquirectangularTexture(t, e) {
				this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
				let n = {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
						fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
					},
					r = new Sa(5, 5, 5),
					s = new Bn({
						name: "CubemapFromEquirect",
						uniforms: Fo(n.uniforms),
						vertexShader: n.vertexShader,
						fragmentShader: n.fragmentShader,
						side: Zi,
						blending: Ss
					});
				s.uniforms.tEquirect.value = e;
				let a = new or(r, s),
					o = e.minFilter;
				return e.minFilter === th && (e.minFilter = Mn), new im(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this
			}
			clear(t, e, n, r) {
				let s = t.getRenderTarget();
				for (let a = 0; a < 6; a++) t.setRenderTarget(this, a), t.clear(e, n, r);
				t.setRenderTarget(s)
			}
		},
		Gf = new ht,
		BC = new ht,
		UC = new ue,
		Fr = class {
			constructor(t = new ht(1, 0, 0), e = 0) {
				this.isPlane = !0, this.normal = t, this.constant = e
			}
			set(t, e) {
				return this.normal.copy(t), this.constant = e, this
			}
			setComponents(t, e, n, r) {
				return this.normal.set(t, e, n), this.constant = r, this
			}
			setFromNormalAndCoplanarPoint(t, e) {
				return this.normal.copy(t), this.constant = -e.dot(this.normal), this
			}
			setFromCoplanarPoints(t, e, n) {
				let r = Gf.subVectors(n, e).cross(BC.subVectors(t, e)).normalize();
				return this.setFromNormalAndCoplanarPoint(r, t), this
			}
			copy(t) {
				return this.normal.copy(t.normal), this.constant = t.constant, this
			}
			normalize() {
				let t = 1 / this.normal.length();
				return this.normal.multiplyScalar(t), this.constant *= t, this
			}
			negate() {
				return this.constant *= -1, this.normal.negate(), this
			}
			distanceToPoint(t) {
				return this.normal.dot(t) + this.constant
			}
			distanceToSphere(t) {
				return this.distanceToPoint(t.center) - t.radius
			}
			projectPoint(t, e) {
				return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
			}
			intersectLine(t, e) {
				let n = t.delta(Gf),
					r = this.normal.dot(n);
				if (r === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
				let s = -(t.start.dot(this.normal) + this.constant) / r;
				return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s)
			}
			intersectsLine(t) {
				let e = this.distanceToPoint(t.start),
					n = this.distanceToPoint(t.end);
				return e < 0 && n > 0 || n < 0 && e > 0
			}
			intersectsBox(t) {
				return t.intersectsPlane(this)
			}
			intersectsSphere(t) {
				return t.intersectsPlane(this)
			}
			coplanarPoint(t) {
				return t.copy(this.normal).multiplyScalar(-this.constant)
			}
			applyMatrix4(t, e) {
				let n = e || UC.getNormalMatrix(t),
					r = this.coplanarPoint(Gf).applyMatrix4(t),
					s = this.normal.applyMatrix3(n).normalize();
				return this.constant = -r.dot(s), this
			}
			translate(t) {
				return this.constant -= t.dot(this.normal), this
			}
			equals(t) {
				return t.normal.equals(this.normal) && t.constant === this.constant
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		pa = new ko,
		lu = new ht,
		Du = class {
			constructor(t = new Fr, e = new Fr, n = new Fr, r = new Fr, s = new Fr, a = new Fr) {
				this.planes = [t, e, n, r, s, a]
			}
			set(t, e, n, r, s, a) {
				let o = this.planes;
				return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(s), o[5].copy(a), this
			}
			copy(t) {
				let e = this.planes;
				for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
				return this
			}
			setFromProjectionMatrix(t) {
				let e = this.planes,
					n = t.elements,
					r = n[0],
					s = n[1],
					a = n[2],
					o = n[3],
					h = n[4],
					c = n[5],
					u = n[6],
					g = n[7],
					p = n[8],
					_ = n[9],
					b = n[10],
					y = n[11],
					w = n[12],
					f = n[13],
					S = n[14],
					x = n[15];
				return e[0].setComponents(o - r, g - h, y - p, x - w).normalize(), e[1].setComponents(o + r, g + h, y + p, x + w).normalize(), e[2].setComponents(o + s, g + c, y + _, x + f).normalize(), e[3].setComponents(o - s, g - c, y - _, x - f).normalize(), e[4].setComponents(o - a, g - u, y - b, x - S).normalize(), e[5].setComponents(o + a, g + u, y + b, x + S).normalize(), this
			}
			intersectsObject(t) {
				if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), pa.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
				else {
					let e = t.geometry;
					e.boundingSphere === null && e.computeBoundingSphere(), pa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
				}
				return this.intersectsSphere(pa)
			}
			intersectsSprite(t) {
				return pa.center.set(0, 0, 0), pa.radius = .7071067811865476, pa.applyMatrix4(t.matrixWorld), this.intersectsSphere(pa)
			}
			intersectsSphere(t) {
				let e = this.planes,
					n = t.center,
					r = -t.radius;
				for (let s = 0; s < 6; s++)
					if (e[s].distanceToPoint(n) < r) return !1;
				return !0
			}
			intersectsBox(t) {
				let e = this.planes;
				for (let n = 0; n < 6; n++) {
					let r = e[n];
					if (lu.x = r.normal.x > 0 ? t.max.x : t.min.x, lu.y = r.normal.y > 0 ? t.max.y : t.min.y, lu.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(lu) < 0) return !1
				}
				return !0
			}
			containsPoint(t) {
				let e = this.planes;
				for (let n = 0; n < 6; n++)
					if (e[n].distanceToPoint(t) < 0) return !1;
				return !0
			}
			clone() {
				return new this.constructor().copy(this)
			}
		};

	function sb() {
		let i = null,
			t = !1,
			e = null,
			n = null;

		function r(s, a) {
			e(s, a), n = i.requestAnimationFrame(r)
		}
		return {
			start: function () {
				t !== !0 && e !== null && (n = i.requestAnimationFrame(r), t = !0)
			},
			stop: function () {
				i.cancelAnimationFrame(n), t = !1
			},
			setAnimationLoop: function (s) {
				e = s
			},
			setContext: function (s) {
				i = s
			}
		}
	}

	function GC(i, t) {
		let e = t.isWebGL2,
			n = new WeakMap;

		function r(c, u) {
			let g = c.array,
				p = c.usage,
				_ = i.createBuffer();
			i.bindBuffer(u, _), i.bufferData(u, g, p), c.onUploadCallback();
			let b;
			if (g instanceof Float32Array) b = 5126;
			else if (g instanceof Uint16Array)
				if (c.isFloat16BufferAttribute)
					if (e) b = 5131;
					else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
			else b = 5123;
			else if (g instanceof Int16Array) b = 5122;
			else if (g instanceof Uint32Array) b = 5125;
			else if (g instanceof Int32Array) b = 5124;
			else if (g instanceof Int8Array) b = 5120;
			else if (g instanceof Uint8Array) b = 5121;
			else if (g instanceof Uint8ClampedArray) b = 5121;
			else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + g);
			return {
				buffer: _,
				type: b,
				bytesPerElement: g.BYTES_PER_ELEMENT,
				version: c.version
			}
		}

		function s(c, u, g) {
			let p = u.array,
				_ = u.updateRange;
			i.bindBuffer(g, c), _.count === -1 ? i.bufferSubData(g, 0, p) : (e ? i.bufferSubData(g, _.offset * p.BYTES_PER_ELEMENT, p, _.offset, _.count) : i.bufferSubData(g, _.offset * p.BYTES_PER_ELEMENT, p.subarray(_.offset, _.offset + _.count)), _.count = -1), u.onUploadCallback()
		}

		function a(c) {
			return c.isInterleavedBufferAttribute && (c = c.data), n.get(c)
		}

		function o(c) {
			c.isInterleavedBufferAttribute && (c = c.data);
			let u = n.get(c);
			u && (i.deleteBuffer(u.buffer), n.delete(c))
		}

		function h(c, u) {
			if (c.isGLBufferAttribute) {
				let p = n.get(c);
				(!p || p.version < c.version) && n.set(c, {
					buffer: c.buffer,
					type: c.type,
					bytesPerElement: c.elementSize,
					version: c.version
				});
				return
			}
			c.isInterleavedBufferAttribute && (c = c.data);
			let g = n.get(c);
			g === void 0 ? n.set(c, r(c, u)) : g.version < c.version && (s(g.buffer, c, u), g.version = c.version)
		}
		return {
			get: a,
			remove: o,
			update: h
		}
	}
	var Ea = class extends tn {
			constructor(t = 1, e = 1, n = 1, r = 1) {
				super(), this.type = "PlaneGeometry", this.parameters = {
					width: t,
					height: e,
					widthSegments: n,
					heightSegments: r
				};
				let s = t / 2,
					a = e / 2,
					o = Math.floor(n),
					h = Math.floor(r),
					c = o + 1,
					u = h + 1,
					g = t / o,
					p = e / h,
					_ = [],
					b = [],
					y = [],
					w = [];
				for (let f = 0; f < u; f++) {
					let S = f * p - a;
					for (let x = 0; x < c; x++) {
						let M = x * g - s;
						b.push(M, -S, 0), y.push(0, 0, 1), w.push(x / o), w.push(1 - f / h)
					}
				}
				for (let f = 0; f < h; f++)
					for (let S = 0; S < o; S++) {
						let x = S + c * f,
							M = S + c * (f + 1),
							T = S + 1 + c * (f + 1),
							I = S + 1 + c * f;
						_.push(x, M, I), _.push(M, T, I)
					}
				this.setIndex(_), this.setAttribute("position", new Qi(b, 3)), this.setAttribute("normal", new Qi(y, 3)), this.setAttribute("uv", new Qi(w, 2))
			}
			copy(t) {
				return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
			}
			static fromJSON(t) {
				return new Ea(t.width, t.height, t.widthSegments, t.heightSegments)
			}
		},
		HC = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
		WC = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		$C = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
		qC = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
		jC = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
		XC = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
		YC = "vec3 transformed = vec3( position );",
		KC = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
		ZC = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
		JC = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
		QC = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
		tT = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
		eT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
		iT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
		nT = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
		rT = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
		sT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
		aT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
		oT = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
		lT = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
		hT = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
		cT = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
		uT = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
		dT = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
		pT = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
		fT = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
		mT = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
		vT = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
		gT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
		_T = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
		yT = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
		bT = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
		xT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
		wT = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
		ST = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
		ET = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
		MT = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
		CT = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
		TT = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
		PT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
		AT = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
		DT = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
		IT = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
		LT = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
		kT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
		RT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
		FT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
		OT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
		NT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`,
		VT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
		zT = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
		BT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
		UT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
		GT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
		HT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
		WT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
		$T = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
		qT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
		jT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
		XT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
		YT = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		KT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
		ZT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
		JT = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
		QT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
		tP = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
		eP = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
		iP = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
		nP = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
		rP = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		sP = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		aP = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
		oP = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
		lP = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
		hP = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
		cP = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
		uP = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
		dP = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
		pP = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
		fP = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
		mP = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
		vP = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
		gP = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
		_P = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
		yP = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
		bP = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
		xP = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
		wP = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
		SP = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
		EP = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
		MP = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
		CP = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
		TP = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
		PP = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
		AP = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
		DP = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
		IP = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
		LP = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
		kP = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
		RP = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		FP = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_UV2
	attribute vec2 uv2;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		OP = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
		NP = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
		VP = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
		zP = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		BP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		UP = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		GP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		HP = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		WP = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
		$P = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
		qP = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
		jP = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
		XP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
		YP = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		KP = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		ZP = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		JP = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
		QP = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		tA = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		eA = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		iA = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
		nA = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		rA = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
		sA = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
		aA = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		oA = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		lA = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
		hA = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		cA = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		uA = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		dA = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
		pA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		fA = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		mA = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
		vA = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		gA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
		he = {
			alphamap_fragment: HC,
			alphamap_pars_fragment: WC,
			alphatest_fragment: $C,
			alphatest_pars_fragment: qC,
			aomap_fragment: jC,
			aomap_pars_fragment: XC,
			begin_vertex: YC,
			beginnormal_vertex: KC,
			bsdfs: ZC,
			iridescence_fragment: JC,
			bumpmap_pars_fragment: QC,
			clipping_planes_fragment: tT,
			clipping_planes_pars_fragment: eT,
			clipping_planes_pars_vertex: iT,
			clipping_planes_vertex: nT,
			color_fragment: rT,
			color_pars_fragment: sT,
			color_pars_vertex: aT,
			color_vertex: oT,
			common: lT,
			cube_uv_reflection_fragment: hT,
			defaultnormal_vertex: cT,
			displacementmap_pars_vertex: uT,
			displacementmap_vertex: dT,
			emissivemap_fragment: pT,
			emissivemap_pars_fragment: fT,
			encodings_fragment: mT,
			encodings_pars_fragment: vT,
			envmap_fragment: gT,
			envmap_common_pars_fragment: _T,
			envmap_pars_fragment: yT,
			envmap_pars_vertex: bT,
			envmap_physical_pars_fragment: LT,
			envmap_vertex: xT,
			fog_vertex: wT,
			fog_pars_vertex: ST,
			fog_fragment: ET,
			fog_pars_fragment: MT,
			gradientmap_pars_fragment: CT,
			lightmap_fragment: TT,
			lightmap_pars_fragment: PT,
			lights_lambert_fragment: AT,
			lights_lambert_pars_fragment: DT,
			lights_pars_begin: IT,
			lights_toon_fragment: kT,
			lights_toon_pars_fragment: RT,
			lights_phong_fragment: FT,
			lights_phong_pars_fragment: OT,
			lights_physical_fragment: NT,
			lights_physical_pars_fragment: VT,
			lights_fragment_begin: zT,
			lights_fragment_maps: BT,
			lights_fragment_end: UT,
			logdepthbuf_fragment: GT,
			logdepthbuf_pars_fragment: HT,
			logdepthbuf_pars_vertex: WT,
			logdepthbuf_vertex: $T,
			map_fragment: qT,
			map_pars_fragment: jT,
			map_particle_fragment: XT,
			map_particle_pars_fragment: YT,
			metalnessmap_fragment: KT,
			metalnessmap_pars_fragment: ZT,
			morphcolor_vertex: JT,
			morphnormal_vertex: QT,
			morphtarget_pars_vertex: tP,
			morphtarget_vertex: eP,
			normal_fragment_begin: iP,
			normal_fragment_maps: nP,
			normal_pars_fragment: rP,
			normal_pars_vertex: sP,
			normal_vertex: aP,
			normalmap_pars_fragment: oP,
			clearcoat_normal_fragment_begin: lP,
			clearcoat_normal_fragment_maps: hP,
			clearcoat_pars_fragment: cP,
			iridescence_pars_fragment: uP,
			output_fragment: dP,
			packing: pP,
			premultiplied_alpha_fragment: fP,
			project_vertex: mP,
			dithering_fragment: vP,
			dithering_pars_fragment: gP,
			roughnessmap_fragment: _P,
			roughnessmap_pars_fragment: yP,
			shadowmap_pars_fragment: bP,
			shadowmap_pars_vertex: xP,
			shadowmap_vertex: wP,
			shadowmask_pars_fragment: SP,
			skinbase_vertex: EP,
			skinning_pars_vertex: MP,
			skinning_vertex: CP,
			skinnormal_vertex: TP,
			specularmap_fragment: PP,
			specularmap_pars_fragment: AP,
			tonemapping_fragment: DP,
			tonemapping_pars_fragment: IP,
			transmission_fragment: LP,
			transmission_pars_fragment: kP,
			uv_pars_fragment: RP,
			uv_pars_vertex: FP,
			uv_vertex: OP,
			worldpos_vertex: NP,
			background_vert: VP,
			background_frag: zP,
			backgroundCube_vert: BP,
			backgroundCube_frag: UP,
			cube_vert: GP,
			cube_frag: HP,
			depth_vert: WP,
			depth_frag: $P,
			distanceRGBA_vert: qP,
			distanceRGBA_frag: jP,
			equirect_vert: XP,
			equirect_frag: YP,
			linedashed_vert: KP,
			linedashed_frag: ZP,
			meshbasic_vert: JP,
			meshbasic_frag: QP,
			meshlambert_vert: tA,
			meshlambert_frag: eA,
			meshmatcap_vert: iA,
			meshmatcap_frag: nA,
			meshnormal_vert: rA,
			meshnormal_frag: sA,
			meshphong_vert: aA,
			meshphong_frag: oA,
			meshphysical_vert: lA,
			meshphysical_frag: hA,
			meshtoon_vert: cA,
			meshtoon_frag: uA,
			points_vert: dA,
			points_frag: pA,
			shadow_vert: fA,
			shadow_frag: mA,
			sprite_vert: vA,
			sprite_frag: gA
		},
		Dt = {
			common: {
				diffuse: {
					value: new Pe(16777215)
				},
				opacity: {
					value: 1
				},
				map: {
					value: null
				},
				mapTransform: {
					value: new ue
				},
				alphaMap: {
					value: null
				},
				alphaMapTransform: {
					value: new ue
				},
				alphaTest: {
					value: 0
				}
			},
			specularmap: {
				specularMap: {
					value: null
				},
				specularMapTransform: {
					value: new ue
				}
			},
			envmap: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				reflectivity: {
					value: 1
				},
				ior: {
					value: 1.5
				},
				refractionRatio: {
					value: .98
				}
			},
			aomap: {
				aoMap: {
					value: null
				},
				aoMapIntensity: {
					value: 1
				},
				aoMapTransform: {
					value: new ue
				}
			},
			lightmap: {
				lightMap: {
					value: null
				},
				lightMapIntensity: {
					value: 1
				},
				lightMapTransform: {
					value: new ue
				}
			},
			bumpmap: {
				bumpMap: {
					value: null
				},
				bumpMapTransform: {
					value: new ue
				},
				bumpScale: {
					value: 1
				}
			},
			normalmap: {
				normalMap: {
					value: null
				},
				normalMapTransform: {
					value: new ue
				},
				normalScale: {
					value: new Oe(1, 1)
				}
			},
			displacementmap: {
				displacementMap: {
					value: null
				},
				displacementMapTransform: {
					value: new ue
				},
				displacementScale: {
					value: 1
				},
				displacementBias: {
					value: 0
				}
			},
			emissivemap: {
				emissiveMap: {
					value: null
				},
				emissiveMapTransform: {
					value: new ue
				}
			},
			metalnessmap: {
				metalnessMap: {
					value: null
				},
				metalnessMapTransform: {
					value: new ue
				}
			},
			roughnessmap: {
				roughnessMap: {
					value: null
				},
				roughnessMapTransform: {
					value: new ue
				}
			},
			gradientmap: {
				gradientMap: {
					value: null
				}
			},
			fog: {
				fogDensity: {
					value: 25e-5
				},
				fogNear: {
					value: 1
				},
				fogFar: {
					value: 2e3
				},
				fogColor: {
					value: new Pe(16777215)
				}
			},
			lights: {
				ambientLightColor: {
					value: []
				},
				lightProbe: {
					value: []
				},
				directionalLights: {
					value: [],
					properties: {
						direction: {},
						color: {}
					}
				},
				directionalLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				directionalShadowMap: {
					value: []
				},
				directionalShadowMatrix: {
					value: []
				},
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {}
					}
				},
				spotLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				spotLightMap: {
					value: []
				},
				spotShadowMap: {
					value: []
				},
				spotLightMatrix: {
					value: []
				},
				pointLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						decay: {},
						distance: {}
					}
				},
				pointLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					}
				},
				pointShadowMap: {
					value: []
				},
				pointShadowMatrix: {
					value: []
				},
				hemisphereLights: {
					value: [],
					properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					}
				},
				rectAreaLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					}
				},
				ltc_1: {
					value: null
				},
				ltc_2: {
					value: null
				}
			},
			points: {
				diffuse: {
					value: new Pe(16777215)
				},
				opacity: {
					value: 1
				},
				size: {
					value: 1
				},
				scale: {
					value: 1
				},
				map: {
					value: null
				},
				alphaMap: {
					value: null
				},
				alphaTest: {
					value: 0
				},
				uvTransform: {
					value: new ue
				}
			},
			sprite: {
				diffuse: {
					value: new Pe(16777215)
				},
				opacity: {
					value: 1
				},
				center: {
					value: new Oe(.5, .5)
				},
				rotation: {
					value: 0
				},
				map: {
					value: null
				},
				mapTransform: {
					value: new ue
				},
				alphaMap: {
					value: null
				},
				alphaTest: {
					value: 0
				}
			}
		},
		ar = {
			basic: {
				uniforms: Ri([Dt.common, Dt.specularmap, Dt.envmap, Dt.aomap, Dt.lightmap, Dt.fog]),
				vertexShader: he.meshbasic_vert,
				fragmentShader: he.meshbasic_frag
			},
			lambert: {
				uniforms: Ri([Dt.common, Dt.specularmap, Dt.envmap, Dt.aomap, Dt.lightmap, Dt.emissivemap, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, Dt.fog, Dt.lights, {
					emissive: {
						value: new Pe(0)
					}
				}]),
				vertexShader: he.meshlambert_vert,
				fragmentShader: he.meshlambert_frag
			},
			phong: {
				uniforms: Ri([Dt.common, Dt.specularmap, Dt.envmap, Dt.aomap, Dt.lightmap, Dt.emissivemap, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, Dt.fog, Dt.lights, {
					emissive: {
						value: new Pe(0)
					},
					specular: {
						value: new Pe(1118481)
					},
					shininess: {
						value: 30
					}
				}]),
				vertexShader: he.meshphong_vert,
				fragmentShader: he.meshphong_frag
			},
			standard: {
				uniforms: Ri([Dt.common, Dt.envmap, Dt.aomap, Dt.lightmap, Dt.emissivemap, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, Dt.roughnessmap, Dt.metalnessmap, Dt.fog, Dt.lights, {
					emissive: {
						value: new Pe(0)
					},
					roughness: {
						value: 1
					},
					metalness: {
						value: 0
					},
					envMapIntensity: {
						value: 1
					}
				}]),
				vertexShader: he.meshphysical_vert,
				fragmentShader: he.meshphysical_frag
			},
			toon: {
				uniforms: Ri([Dt.common, Dt.aomap, Dt.lightmap, Dt.emissivemap, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, Dt.gradientmap, Dt.fog, Dt.lights, {
					emissive: {
						value: new Pe(0)
					}
				}]),
				vertexShader: he.meshtoon_vert,
				fragmentShader: he.meshtoon_frag
			},
			matcap: {
				uniforms: Ri([Dt.common, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, Dt.fog, {
					matcap: {
						value: null
					}
				}]),
				vertexShader: he.meshmatcap_vert,
				fragmentShader: he.meshmatcap_frag
			},
			points: {
				uniforms: Ri([Dt.points, Dt.fog]),
				vertexShader: he.points_vert,
				fragmentShader: he.points_frag
			},
			dashed: {
				uniforms: Ri([Dt.common, Dt.fog, {
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}]),
				vertexShader: he.linedashed_vert,
				fragmentShader: he.linedashed_frag
			},
			depth: {
				uniforms: Ri([Dt.common, Dt.displacementmap]),
				vertexShader: he.depth_vert,
				fragmentShader: he.depth_frag
			},
			normal: {
				uniforms: Ri([Dt.common, Dt.bumpmap, Dt.normalmap, Dt.displacementmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: he.meshnormal_vert,
				fragmentShader: he.meshnormal_frag
			},
			sprite: {
				uniforms: Ri([Dt.sprite, Dt.fog]),
				vertexShader: he.sprite_vert,
				fragmentShader: he.sprite_frag
			},
			background: {
				uniforms: {
					uvTransform: {
						value: new ue
					},
					t2D: {
						value: null
					},
					backgroundIntensity: {
						value: 1
					}
				},
				vertexShader: he.background_vert,
				fragmentShader: he.background_frag
			},
			backgroundCube: {
				uniforms: {
					envMap: {
						value: null
					},
					flipEnvMap: {
						value: -1
					},
					backgroundBlurriness: {
						value: 0
					},
					backgroundIntensity: {
						value: 1
					}
				},
				vertexShader: he.backgroundCube_vert,
				fragmentShader: he.backgroundCube_frag
			},
			cube: {
				uniforms: {
					tCube: {
						value: null
					},
					tFlip: {
						value: -1
					},
					opacity: {
						value: 1
					}
				},
				vertexShader: he.cube_vert,
				fragmentShader: he.cube_frag
			},
			equirect: {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: he.equirect_vert,
				fragmentShader: he.equirect_frag
			},
			distanceRGBA: {
				uniforms: Ri([Dt.common, Dt.displacementmap, {
					referencePosition: {
						value: new ht
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1e3
					}
				}]),
				vertexShader: he.distanceRGBA_vert,
				fragmentShader: he.distanceRGBA_frag
			},
			shadow: {
				uniforms: Ri([Dt.lights, Dt.fog, {
					color: {
						value: new Pe(0)
					},
					opacity: {
						value: 1
					}
				}]),
				vertexShader: he.shadow_vert,
				fragmentShader: he.shadow_frag
			}
		};
	ar.physical = {
		uniforms: Ri([ar.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatMapTransform: {
				value: new ue
			},
			clearcoatNormalMap: {
				value: null
			},
			clearcoatNormalMapTransform: {
				value: new ue
			},
			clearcoatNormalScale: {
				value: new Oe(1, 1)
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatRoughnessMapTransform: {
				value: new ue
			},
			iridescence: {
				value: 0
			},
			iridescenceMap: {
				value: null
			},
			iridescenceMapTransform: {
				value: new ue
			},
			iridescenceIOR: {
				value: 1.3
			},
			iridescenceThicknessMinimum: {
				value: 100
			},
			iridescenceThicknessMaximum: {
				value: 400
			},
			iridescenceThicknessMap: {
				value: null
			},
			iridescenceThicknessMapTransform: {
				value: new ue
			},
			sheen: {
				value: 0
			},
			sheenColor: {
				value: new Pe(0)
			},
			sheenColorMap: {
				value: null
			},
			sheenColorMapTransform: {
				value: new ue
			},
			sheenRoughness: {
				value: 1
			},
			sheenRoughnessMap: {
				value: null
			},
			sheenRoughnessMapTransform: {
				value: new ue
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionMapTransform: {
				value: new ue
			},
			transmissionSamplerSize: {
				value: new Oe
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			thicknessMapTransform: {
				value: new ue
			},
			attenuationDistance: {
				value: 0
			},
			attenuationColor: {
				value: new Pe(0)
			},
			specularColor: {
				value: new Pe(1, 1, 1)
			},
			specularColorMap: {
				value: null
			},
			specularColorMapTransform: {
				value: new ue
			},
			specularIntensity: {
				value: 1
			},
			specularIntensityMap: {
				value: null
			},
			specularIntensityMapTransform: {
				value: new ue
			}
		}]),
		vertexShader: he.meshphysical_vert,
		fragmentShader: he.meshphysical_frag
	};
	var hu = {
		r: 0,
		b: 0,
		g: 0
	};

	function _A(i, t, e, n, r, s, a) {
		let o = new Pe(0),
			h = s === !0 ? 0 : 1,
			c, u, g = null,
			p = 0,
			_ = null;

		function b(w, f) {
			let S = !1,
				x = f.isScene === !0 ? f.background : null;
			x && x.isTexture && (x = (f.backgroundBlurriness > 0 ? e : t).get(x));
			let M = i.xr,
				T = M.getSession && M.getSession();
			T && T.environmentBlendMode === "additive" && (x = null), x === null ? y(o, h) : x && x.isColor && (y(x, 1), S = !0), (i.autoClear || S) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), x && (x.isCubeTexture || x.mapping === Ou) ? (u === void 0 && (u = new or(new Sa(1, 1, 1), new Bn({
				name: "BackgroundCubeMaterial",
				uniforms: Fo(ar.backgroundCube.uniforms),
				vertexShader: ar.backgroundCube.vertexShader,
				fragmentShader: ar.backgroundCube.fragmentShader,
				side: Zi,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (I, L, F) {
				this.matrixWorld.copyPosition(F.matrixWorld)
			}, Object.defineProperty(u.material, "envMap", {
				get: function () {
					return this.uniforms.envMap.value
				}
			}), r.update(u)), u.material.uniforms.envMap.value = x, u.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = f.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, u.material.toneMapped = x.encoding !== ze, (g !== x || p !== x.version || _ !== i.toneMapping) && (u.material.needsUpdate = !0, g = x, p = x.version, _ = i.toneMapping), u.layers.enableAll(), w.unshift(u, u.geometry, u.material, 0, 0, null)) : x && x.isTexture && (c === void 0 && (c = new or(new Ea(2, 2), new Bn({
				name: "BackgroundMaterial",
				uniforms: Fo(ar.background.uniforms),
				vertexShader: ar.background.vertexShader,
				fragmentShader: ar.background.fragmentShader,
				side: Es,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
				get: function () {
					return this.uniforms.t2D.value
				}
			}), r.update(c)), c.material.uniforms.t2D.value = x, c.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, c.material.toneMapped = x.encoding !== ze, x.matrixAutoUpdate === !0 && x.updateMatrix(), c.material.uniforms.uvTransform.value.copy(x.matrix), (g !== x || p !== x.version || _ !== i.toneMapping) && (c.material.needsUpdate = !0, g = x, p = x.version, _ = i.toneMapping), c.layers.enableAll(), w.unshift(c, c.geometry, c.material, 0, 0, null))
		}

		function y(w, f) {
			w.getRGB(hu, rb(i)), n.buffers.color.setClear(hu.r, hu.g, hu.b, f, a)
		}
		return {
			getClearColor: function () {
				return o
			},
			setClearColor: function (w, f = 1) {
				o.set(w), h = f, y(o, h)
			},
			getClearAlpha: function () {
				return h
			},
			setClearAlpha: function (w) {
				h = w, y(o, h)
			},
			render: b
		}
	}

	function yA(i, t, e, n) {
		let r = i.getParameter(34921),
			s = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
			a = n.isWebGL2 || s !== null,
			o = {},
			h = w(null),
			c = h,
			u = !1;

		function g($, W, O, B, A) {
			let D = !1;
			if (a) {
				let H = y(B, O, W);
				c !== H && (c = H, _(c.object)), D = f($, B, O, A), D && S($, B, O, A)
			} else {
				let H = W.wireframe === !0;
				(c.geometry !== B.id || c.program !== O.id || c.wireframe !== H) && (c.geometry = B.id, c.program = O.id, c.wireframe = H, D = !0)
			}
			A !== null && e.update(A, 34963), (D || u) && (u = !1, F($, W, O, B), A !== null && i.bindBuffer(34963, e.get(A).buffer))
		}

		function p() {
			return n.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES()
		}

		function _($) {
			return n.isWebGL2 ? i.bindVertexArray($) : s.bindVertexArrayOES($)
		}

		function b($) {
			return n.isWebGL2 ? i.deleteVertexArray($) : s.deleteVertexArrayOES($)
		}

		function y($, W, O) {
			let B = O.wireframe === !0,
				A = o[$.id];
			A === void 0 && (A = {}, o[$.id] = A);
			let D = A[W.id];
			D === void 0 && (D = {}, A[W.id] = D);
			let H = D[B];
			return H === void 0 && (H = w(p()), D[B] = H), H
		}

		function w($) {
			let W = [],
				O = [],
				B = [];
			for (let A = 0; A < r; A++) W[A] = 0, O[A] = 0, B[A] = 0;
			return {
				geometry: null,
				program: null,
				wireframe: !1,
				newAttributes: W,
				enabledAttributes: O,
				attributeDivisors: B,
				object: $,
				attributes: {},
				index: null
			}
		}

		function f($, W, O, B) {
			let A = c.attributes,
				D = W.attributes,
				H = 0,
				q = O.getAttributes();
			for (let Q in q)
				if (q[Q].location >= 0) {
					let nt = A[Q],
						ut = D[Q];
					if (ut === void 0 && (Q === "instanceMatrix" && $.instanceMatrix && (ut = $.instanceMatrix), Q === "instanceColor" && $.instanceColor && (ut = $.instanceColor)), nt === void 0 || nt.attribute !== ut || ut && nt.data !== ut.data) return !0;
					H++
				} return c.attributesNum !== H || c.index !== B
		}

		function S($, W, O, B) {
			let A = {},
				D = W.attributes,
				H = 0,
				q = O.getAttributes();
			for (let Q in q)
				if (q[Q].location >= 0) {
					let nt = D[Q];
					nt === void 0 && (Q === "instanceMatrix" && $.instanceMatrix && (nt = $.instanceMatrix), Q === "instanceColor" && $.instanceColor && (nt = $.instanceColor));
					let ut = {};
					ut.attribute = nt, nt && nt.data && (ut.data = nt.data), A[Q] = ut, H++
				} c.attributes = A, c.attributesNum = H, c.index = B
		}

		function x() {
			let $ = c.newAttributes;
			for (let W = 0, O = $.length; W < O; W++) $[W] = 0
		}

		function M($) {
			T($, 0)
		}

		function T($, W) {
			let O = c.newAttributes,
				B = c.enabledAttributes,
				A = c.attributeDivisors;
			O[$] = 1, B[$] === 0 && (i.enableVertexAttribArray($), B[$] = 1), A[$] !== W && ((n.isWebGL2 ? i : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"]($, W), A[$] = W)
		}

		function I() {
			let $ = c.newAttributes,
				W = c.enabledAttributes;
			for (let O = 0, B = W.length; O < B; O++) W[O] !== $[O] && (i.disableVertexAttribArray(O), W[O] = 0)
		}

		function L($, W, O, B, A, D) {
			n.isWebGL2 === !0 && (O === 5124 || O === 5125) ? i.vertexAttribIPointer($, W, O, A, D) : i.vertexAttribPointer($, W, O, B, A, D)
		}

		function F($, W, O, B) {
			if (n.isWebGL2 === !1 && ($.isInstancedMesh || B.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null) return;
			x();
			let A = B.attributes,
				D = O.getAttributes(),
				H = W.defaultAttributeValues;
			for (let q in D) {
				let Q = D[q];
				if (Q.location >= 0) {
					let tt = A[q];
					if (tt === void 0 && (q === "instanceMatrix" && $.instanceMatrix && (tt = $.instanceMatrix), q === "instanceColor" && $.instanceColor && (tt = $.instanceColor)), tt !== void 0) {
						let nt = tt.normalized,
							ut = tt.itemSize,
							et = e.get(tt);
						if (et === void 0) continue;
						let it = et.buffer,
							Et = et.type,
							wt = et.bytesPerElement;
						if (tt.isInterleavedBufferAttribute) {
							let yt = tt.data,
								At = yt.stride,
								Vt = tt.offset;
							if (yt.isInstancedInterleavedBuffer) {
								for (let lt = 0; lt < Q.locationSize; lt++) T(Q.location + lt, yt.meshPerAttribute);
								$.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = yt.meshPerAttribute * yt.count)
							} else
								for (let lt = 0; lt < Q.locationSize; lt++) M(Q.location + lt);
							i.bindBuffer(34962, it);
							for (let lt = 0; lt < Q.locationSize; lt++) L(Q.location + lt, ut / Q.locationSize, Et, nt, At * wt, (Vt + ut / Q.locationSize * lt) * wt)
						} else {
							if (tt.isInstancedBufferAttribute) {
								for (let yt = 0; yt < Q.locationSize; yt++) T(Q.location + yt, tt.meshPerAttribute);
								$.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = tt.meshPerAttribute * tt.count)
							} else
								for (let yt = 0; yt < Q.locationSize; yt++) M(Q.location + yt);
							i.bindBuffer(34962, it);
							for (let yt = 0; yt < Q.locationSize; yt++) L(Q.location + yt, ut / Q.locationSize, Et, nt, ut * wt, ut / Q.locationSize * yt * wt)
						}
					} else if (H !== void 0) {
						let nt = H[q];
						if (nt !== void 0) switch (nt.length) {
							case 2:
								i.vertexAttrib2fv(Q.location, nt);
								break;
							case 3:
								i.vertexAttrib3fv(Q.location, nt);
								break;
							case 4:
								i.vertexAttrib4fv(Q.location, nt);
								break;
							default:
								i.vertexAttrib1fv(Q.location, nt)
						}
					}
				}
			}
			I()
		}

		function k() {
			U();
			for (let $ in o) {
				let W = o[$];
				for (let O in W) {
					let B = W[O];
					for (let A in B) b(B[A].object), delete B[A];
					delete W[O]
				}
				delete o[$]
			}
		}

		function G($) {
			if (o[$.id] === void 0) return;
			let W = o[$.id];
			for (let O in W) {
				let B = W[O];
				for (let A in B) b(B[A].object), delete B[A];
				delete W[O]
			}
			delete o[$.id]
		}

		function j($) {
			for (let W in o) {
				let O = o[W];
				if (O[$.id] === void 0) continue;
				let B = O[$.id];
				for (let A in B) b(B[A].object), delete B[A];
				delete O[$.id]
			}
		}

		function U() {
			z(), u = !0, c !== h && (c = h, _(c.object))
		}

		function z() {
			h.geometry = null, h.program = null, h.wireframe = !1
		}
		return {
			setup: g,
			reset: U,
			resetDefaultState: z,
			dispose: k,
			releaseStatesOfGeometry: G,
			releaseStatesOfProgram: j,
			initAttributes: x,
			enableAttribute: M,
			disableUnusedAttributes: I
		}
	}

	function bA(i, t, e, n) {
		let r = n.isWebGL2,
			s;

		function a(c) {
			s = c
		}

		function o(c, u) {
			i.drawArrays(s, c, u), e.update(u, s, 1)
		}

		function h(c, u, g) {
			if (g === 0) return;
			let p, _;
			if (r) p = i, _ = "drawArraysInstanced";
			else if (p = t.get("ANGLE_instanced_arrays"), _ = "drawArraysInstancedANGLE", p === null) {
				console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			p[_](s, c, u, g), e.update(u, s, g)
		}
		this.setMode = a, this.render = o, this.renderInstances = h
	}

	function xA(i, t, e) {
		let n;

		function r() {
			if (n !== void 0) return n;
			if (t.has("EXT_texture_filter_anisotropic") === !0) {
				let L = t.get("EXT_texture_filter_anisotropic");
				n = i.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
			} else n = 0;
			return n
		}

		function s(L) {
			if (L === "highp") {
				if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
				L = "mediump"
			}
			return L === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
		}
		let a = typeof WebGL2RenderingContext != "undefined" && i.constructor.name === "WebGL2RenderingContext",
			o = e.precision !== void 0 ? e.precision : "highp",
			h = s(o);
		h !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", h, "instead."), o = h);
		let c = a || t.has("WEBGL_draw_buffers"),
			u = e.logarithmicDepthBuffer === !0,
			g = i.getParameter(34930),
			p = i.getParameter(35660),
			_ = i.getParameter(3379),
			b = i.getParameter(34076),
			y = i.getParameter(34921),
			w = i.getParameter(36347),
			f = i.getParameter(36348),
			S = i.getParameter(36349),
			x = p > 0,
			M = a || t.has("OES_texture_float"),
			T = x && M,
			I = a ? i.getParameter(36183) : 0;
		return {
			isWebGL2: a,
			drawBuffers: c,
			getMaxAnisotropy: r,
			getMaxPrecision: s,
			precision: o,
			logarithmicDepthBuffer: u,
			maxTextures: g,
			maxVertexTextures: p,
			maxTextureSize: _,
			maxCubemapSize: b,
			maxAttributes: y,
			maxVertexUniforms: w,
			maxVaryings: f,
			maxFragmentUniforms: S,
			vertexTextures: x,
			floatFragmentTextures: M,
			floatVertexTextures: T,
			maxSamples: I
		}
	}

	function wA(i) {
		let t = this,
			e = null,
			n = 0,
			r = !1,
			s = !1,
			a = new Fr,
			o = new ue,
			h = {
				value: null,
				needsUpdate: !1
			};
		this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function (g, p) {
			let _ = g.length !== 0 || p || n !== 0 || r;
			return r = p, n = g.length, _
		}, this.beginShadows = function () {
			s = !0, u(null)
		}, this.endShadows = function () {
			s = !1
		}, this.setGlobalState = function (g, p) {
			e = u(g, p, 0)
		}, this.setState = function (g, p, _) {
			let b = g.clippingPlanes,
				y = g.clipIntersection,
				w = g.clipShadows,
				f = i.get(g);
			if (!r || b === null || b.length === 0 || s && !w) s ? u(null) : c();
			else {
				let S = s ? 0 : n,
					x = S * 4,
					M = f.clippingState || null;
				h.value = M, M = u(b, p, x, _);
				for (let T = 0; T !== x; ++T) M[T] = e[T];
				f.clippingState = M, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += S
			}
		};

		function c() {
			h.value !== e && (h.value = e, h.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
		}

		function u(g, p, _, b) {
			let y = g !== null ? g.length : 0,
				w = null;
			if (y !== 0) {
				if (w = h.value, b !== !0 || w === null) {
					let f = _ + y * 4,
						S = p.matrixWorldInverse;
					o.getNormalMatrix(S), (w === null || w.length < f) && (w = new Float32Array(f));
					for (let x = 0, M = _; x !== y; ++x, M += 4) a.copy(g[x]).applyMatrix4(S, o), a.normal.toArray(w, M), w[M + 3] = a.constant
				}
				h.value = w, h.needsUpdate = !0
			}
			return t.numPlanes = y, t.numIntersection = 0, w
		}
	}

	function SA(i) {
		let t = new WeakMap;

		function e(a, o) {
			return o === Yf ? a.mapping = Do : o === Kf && (a.mapping = Io), a
		}

		function n(a) {
			if (a && a.isTexture && a.isRenderTargetTexture === !1) {
				let o = a.mapping;
				if (o === Yf || o === Kf)
					if (t.has(a)) {
						let h = t.get(a).texture;
						return e(h, a.mapping)
					} else {
						let h = a.image;
						if (h && h.height > 0) {
							let c = new nm(h.height / 2);
							return c.fromEquirectangularTexture(i, a), t.set(a, c), a.addEventListener("dispose", r), e(c.texture, a.mapping)
						} else return null
					}
			}
			return a
		}

		function r(a) {
			let o = a.target;
			o.removeEventListener("dispose", r);
			let h = t.get(o);
			h !== void 0 && (t.delete(o), h.dispose())
		}

		function s() {
			t = new WeakMap
		}
		return {
			get: n,
			dispose: s
		}
	}
	var rm = class extends Pu {
			constructor(t = -1, e = 1, n = 1, r = -1, s = .1, a = 2e3) {
				super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix()
			}
			copy(t, e) {
				return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this
			}
			setViewOffset(t, e, n, r, s, a) {
				this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let t = (this.right - this.left) / (2 * this.zoom),
					e = (this.top - this.bottom) / (2 * this.zoom),
					n = (this.right + this.left) / 2,
					r = (this.top + this.bottom) / 2,
					s = n - t,
					a = n + t,
					o = r + e,
					h = r - e;
				if (this.view !== null && this.view.enabled) {
					let c = (this.right - this.left) / this.view.fullWidth / this.zoom,
						u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
					s += c * this.view.offsetX, a = s + c * this.view.width, o -= u * this.view.offsetY, h = o - u * this.view.height
				}
				this.projectionMatrix.makeOrthographic(s, a, o, h, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
			}
			toJSON(t) {
				let e = super.toJSON(t);
				return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e
			}
		},
		Mo = 4,
		wy = [.125, .215, .35, .446, .526, .582],
		ma = 20,
		Hf = new rm,
		Sy = new Pe,
		Wf = null,
		fa = (1 + Math.sqrt(5)) / 2,
		So = 1 / fa,
		Ey = [new ht(1, 1, 1), new ht(-1, 1, 1), new ht(1, 1, -1), new ht(-1, 1, -1), new ht(0, fa, So), new ht(0, fa, -So), new ht(So, 0, fa), new ht(-So, 0, fa), new ht(fa, So, 0), new ht(-fa, So, 0)],
		Iu = class {
			constructor(t) {
				this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
			}
			fromScene(t, e = 0, n = .1, r = 100) {
				Wf = this._renderer.getRenderTarget(), this._setSize(256);
				let s = this._allocateTargets();
				return s.depthBuffer = !0, this._sceneToCubeUV(t, n, r, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s
			}
			fromEquirectangular(t, e = null) {
				return this._fromTexture(t, e)
			}
			fromCubemap(t, e = null) {
				return this._fromTexture(t, e)
			}
			compileCubemapShader() {
				this._cubemapMaterial === null && (this._cubemapMaterial = Ty(), this._compileMaterial(this._cubemapMaterial))
			}
			compileEquirectangularShader() {
				this._equirectMaterial === null && (this._equirectMaterial = Cy(), this._compileMaterial(this._equirectMaterial))
			}
			dispose() {
				this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
			}
			_setSize(t) {
				this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
			}
			_dispose() {
				this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
				for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
			}
			_cleanup(t) {
				this._renderer.setRenderTarget(Wf), t.scissorTest = !1, cu(t, 0, 0, t.width, t.height)
			}
			_fromTexture(t, e) {
				t.mapping === Do || t.mapping === Io ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Wf = this._renderer.getRenderTarget();
				let n = e || this._allocateTargets();
				return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
			}
			_allocateTargets() {
				let t = 3 * Math.max(this._cubeSize, 112),
					e = 4 * this._cubeSize,
					n = {
						magFilter: Mn,
						minFilter: Mn,
						generateMipmaps: !1,
						type: eh,
						format: zn,
						encoding: ba,
						depthBuffer: !1
					},
					r = My(t, e, n);
				if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
					this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = My(t, e, n);
					let {
						_lodMax: s
					} = this;
					({
						sizeLods: this._sizeLods,
						lodPlanes: this._lodPlanes,
						sigmas: this._sigmas
					} = EA(s)), this._blurMaterial = MA(s, t, e)
				}
				return r
			}
			_compileMaterial(t) {
				let e = new or(this._lodPlanes[0], t);
				this._renderer.compile(e, Hf)
			}
			_sceneToCubeUV(t, e, n, r) {
				let o = new Oi(90, 1, e, n),
					h = [1, -1, 1, 1, 1, 1],
					c = [1, 1, 1, -1, -1, -1],
					u = this._renderer,
					g = u.autoClear,
					p = u.toneMapping;
				u.getClearColor(Sy), u.toneMapping = Vr, u.autoClear = !1;
				let _ = new Mu({
						name: "PMREM.Background",
						side: Zi,
						depthWrite: !1,
						depthTest: !1
					}),
					b = new or(new Sa, _),
					y = !1,
					w = t.background;
				w ? w.isColor && (_.color.copy(w), t.background = null, y = !0) : (_.color.copy(Sy), y = !0);
				for (let f = 0; f < 6; f++) {
					let S = f % 3;
					S === 0 ? (o.up.set(0, h[f], 0), o.lookAt(c[f], 0, 0)) : S === 1 ? (o.up.set(0, 0, h[f]), o.lookAt(0, c[f], 0)) : (o.up.set(0, h[f], 0), o.lookAt(0, 0, c[f]));
					let x = this._cubeSize;
					cu(r, S * x, f > 2 ? x : 0, x, x), u.setRenderTarget(r), y && u.render(b, o), u.render(t, o)
				}
				b.geometry.dispose(), b.material.dispose(), u.toneMapping = p, u.autoClear = g, t.background = w
			}
			_textureToCubeUV(t, e) {
				let n = this._renderer,
					r = t.mapping === Do || t.mapping === Io;
				r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ty()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Cy());
				let s = r ? this._cubemapMaterial : this._equirectMaterial,
					a = new or(this._lodPlanes[0], s),
					o = s.uniforms;
				o.envMap.value = t;
				let h = this._cubeSize;
				cu(e, 0, 0, 3 * h, 2 * h), n.setRenderTarget(e), n.render(a, Hf)
			}
			_applyPMREM(t) {
				let e = this._renderer,
					n = e.autoClear;
				e.autoClear = !1;
				for (let r = 1; r < this._lodPlanes.length; r++) {
					let s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
						a = Ey[(r - 1) % Ey.length];
					this._blur(t, r - 1, r, s, a)
				}
				e.autoClear = n
			}
			_blur(t, e, n, r, s) {
				let a = this._pingPongRenderTarget;
				this._halfBlur(t, a, e, n, r, "latitudinal", s), this._halfBlur(a, t, n, n, r, "longitudinal", s)
			}
			_halfBlur(t, e, n, r, s, a, o) {
				let h = this._renderer,
					c = this._blurMaterial;
				a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
				let u = 3,
					g = new or(this._lodPlanes[r], c),
					p = c.uniforms,
					_ = this._sizeLods[n] - 1,
					b = isFinite(s) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * ma - 1),
					y = s / b,
					w = isFinite(s) ? 1 + Math.floor(u * y) : ma;
				w > ma && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${ma}`);
				let f = [],
					S = 0;
				for (let L = 0; L < ma; ++L) {
					let F = L / y,
						k = Math.exp(-F * F / 2);
					f.push(k), L === 0 ? S += k : L < w && (S += 2 * k)
				}
				for (let L = 0; L < f.length; L++) f[L] = f[L] / S;
				p.envMap.value = t.texture, p.samples.value = w, p.weights.value = f, p.latitudinal.value = a === "latitudinal", o && (p.poleAxis.value = o);
				let {
					_lodMax: x
				} = this;
				p.dTheta.value = b, p.mipInt.value = x - n;
				let M = this._sizeLods[r],
					T = 3 * M * (r > x - Mo ? r - x + Mo : 0),
					I = 4 * (this._cubeSize - M);
				cu(e, T, I, 3 * M, 2 * M), h.setRenderTarget(e), h.render(g, Hf)
			}
		};

	function EA(i) {
		let t = [],
			e = [],
			n = [],
			r = i,
			s = i - Mo + 1 + wy.length;
		for (let a = 0; a < s; a++) {
			let o = Math.pow(2, r);
			e.push(o);
			let h = 1 / o;
			a > i - Mo ? h = wy[a - i + Mo - 1] : a === 0 && (h = 0), n.push(h);
			let c = 1 / (o - 2),
				u = -c,
				g = 1 + c,
				p = [u, u, g, u, g, g, u, u, g, g, u, g],
				_ = 6,
				b = 6,
				y = 3,
				w = 2,
				f = 1,
				S = new Float32Array(y * b * _),
				x = new Float32Array(w * b * _),
				M = new Float32Array(f * b * _);
			for (let I = 0; I < _; I++) {
				let L = I % 3 * 2 / 3 - 1,
					F = I > 2 ? 0 : -1,
					k = [L, F, 0, L + 2 / 3, F, 0, L + 2 / 3, F + 1, 0, L, F, 0, L + 2 / 3, F + 1, 0, L, F + 1, 0];
				S.set(k, y * b * I), x.set(p, w * b * I);
				let G = [I, I, I, I, I, I];
				M.set(G, f * b * I)
			}
			let T = new tn;
			T.setAttribute("position", new Ji(S, y)), T.setAttribute("uv", new Ji(x, w)), T.setAttribute("faceIndex", new Ji(M, f)), t.push(T), r > Mo && r--
		}
		return {
			lodPlanes: t,
			sizeLods: e,
			sigmas: n
		}
	}

	function My(i, t, e) {
		let n = new zr(i, t, e);
		return n.texture.mapping = Ou, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
	}

	function cu(i, t, e, n, r) {
		i.viewport.set(t, e, n, r), i.scissor.set(t, e, n, r)
	}

	function MA(i, t, e) {
		let n = new Float32Array(ma),
			r = new ht(0, 1, 0);
		return new Bn({
			name: "SphericalGaussianBlur",
			defines: {
				n: ma,
				CUBEUV_TEXEL_WIDTH: 1 / t,
				CUBEUV_TEXEL_HEIGHT: 1 / e,
				CUBEUV_MAX_MIP: `${i}.0`
			},
			uniforms: {
				envMap: {
					value: null
				},
				samples: {
					value: 1
				},
				weights: {
					value: n
				},
				latitudinal: {
					value: !1
				},
				dTheta: {
					value: 0
				},
				mipInt: {
					value: 0
				},
				poleAxis: {
					value: r
				}
			},
			vertexShader: Cm(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
			blending: Ss,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Cy() {
		return new Bn({
			name: "EquirectangularToCubeUV",
			uniforms: {
				envMap: {
					value: null
				}
			},
			vertexShader: Cm(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
			blending: Ss,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Ty() {
		return new Bn({
			name: "CubemapToCubeUV",
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				}
			},
			vertexShader: Cm(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
			blending: Ss,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Cm() {
		return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
	}

	function CA(i) {
		let t = new WeakMap,
			e = null;

		function n(o) {
			if (o && o.isTexture) {
				let h = o.mapping,
					c = h === Yf || h === Kf,
					u = h === Do || h === Io;
				if (c || u)
					if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
						o.needsPMREMUpdate = !1;
						let g = t.get(o);
						return e === null && (e = new Iu(i)), g = c ? e.fromEquirectangular(o, g) : e.fromCubemap(o, g), t.set(o, g), g.texture
					} else {
						if (t.has(o)) return t.get(o).texture; {
							let g = o.image;
							if (c && g && g.height > 0 || u && g && r(g)) {
								e === null && (e = new Iu(i));
								let p = c ? e.fromEquirectangular(o) : e.fromCubemap(o);
								return t.set(o, p), o.addEventListener("dispose", s), p.texture
							} else return null
						}
					}
			}
			return o
		}

		function r(o) {
			let h = 0,
				c = 6;
			for (let u = 0; u < c; u++) o[u] !== void 0 && h++;
			return h === c
		}

		function s(o) {
			let h = o.target;
			h.removeEventListener("dispose", s);
			let c = t.get(h);
			c !== void 0 && (t.delete(h), c.dispose())
		}

		function a() {
			t = new WeakMap, e !== null && (e.dispose(), e = null)
		}
		return {
			get: n,
			dispose: a
		}
	}

	function TA(i) {
		let t = {};

		function e(n) {
			if (t[n] !== void 0) return t[n];
			let r;
			switch (n) {
				case "WEBGL_depth_texture":
					r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
					break;
				case "EXT_texture_filter_anisotropic":
					r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
					break;
				case "WEBGL_compressed_texture_s3tc":
					r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
					break;
				case "WEBGL_compressed_texture_pvrtc":
					r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
					break;
				default:
					r = i.getExtension(n)
			}
			return t[n] = r, r
		}
		return {
			has: function (n) {
				return e(n) !== null
			},
			init: function (n) {
				n.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture")
			},
			get: function (n) {
				let r = e(n);
				return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r
			}
		}
	}

	function PA(i, t, e, n) {
		let r = {},
			s = new WeakMap;

		function a(g) {
			let p = g.target;
			p.index !== null && t.remove(p.index);
			for (let b in p.attributes) t.remove(p.attributes[b]);
			p.removeEventListener("dispose", a), delete r[p.id];
			let _ = s.get(p);
			_ && (t.remove(_), s.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, e.memory.geometries--
		}

		function o(g, p) {
			return r[p.id] === !0 || (p.addEventListener("dispose", a), r[p.id] = !0, e.memory.geometries++), p
		}

		function h(g) {
			let p = g.attributes;
			for (let b in p) t.update(p[b], 34962);
			let _ = g.morphAttributes;
			for (let b in _) {
				let y = _[b];
				for (let w = 0, f = y.length; w < f; w++) t.update(y[w], 34962)
			}
		}

		function c(g) {
			let p = [],
				_ = g.index,
				b = g.attributes.position,
				y = 0;
			if (_ !== null) {
				let S = _.array;
				y = _.version;
				for (let x = 0, M = S.length; x < M; x += 3) {
					let T = S[x + 0],
						I = S[x + 1],
						L = S[x + 2];
					p.push(T, I, I, L, L, T)
				}
			} else {
				let S = b.array;
				y = b.version;
				for (let x = 0, M = S.length / 3 - 1; x < M; x += 3) {
					let T = x + 0,
						I = x + 1,
						L = x + 2;
					p.push(T, I, I, L, L, T)
				}
			}
			let w = new(ib(p) ? Tu : Cu)(p, 1);
			w.version = y;
			let f = s.get(g);
			f && t.remove(f), s.set(g, w)
		}

		function u(g) {
			let p = s.get(g);
			if (p) {
				let _ = g.index;
				_ !== null && p.version < _.version && c(g)
			} else c(g);
			return s.get(g)
		}
		return {
			get: o,
			update: h,
			getWireframeAttribute: u
		}
	}

	function AA(i, t, e, n) {
		let r = n.isWebGL2,
			s;

		function a(p) {
			s = p
		}
		let o, h;

		function c(p) {
			o = p.type, h = p.bytesPerElement
		}

		function u(p, _) {
			i.drawElements(s, _, o, p * h), e.update(_, s, 1)
		}

		function g(p, _, b) {
			if (b === 0) return;
			let y, w;
			if (r) y = i, w = "drawElementsInstanced";
			else if (y = t.get("ANGLE_instanced_arrays"), w = "drawElementsInstancedANGLE", y === null) {
				console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			y[w](s, _, o, p * h, b), e.update(_, s, b)
		}
		this.setMode = a, this.setIndex = c, this.render = u, this.renderInstances = g
	}

	function DA(i) {
		let t = {
				geometries: 0,
				textures: 0
			},
			e = {
				frame: 0,
				calls: 0,
				triangles: 0,
				points: 0,
				lines: 0
			};

		function n(s, a, o) {
			switch (e.calls++, a) {
				case 4:
					e.triangles += o * (s / 3);
					break;
				case 1:
					e.lines += o * (s / 2);
					break;
				case 3:
					e.lines += o * (s - 1);
					break;
				case 2:
					e.lines += o * s;
					break;
				case 0:
					e.points += o * s;
					break;
				default:
					console.error("THREE.WebGLInfo: Unknown draw mode:", a);
					break
			}
		}

		function r() {
			e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
		}
		return {
			memory: t,
			render: e,
			programs: null,
			autoReset: !0,
			reset: r,
			update: n
		}
	}

	function IA(i, t) {
		return i[0] - t[0]
	}

	function LA(i, t) {
		return Math.abs(t[1]) - Math.abs(i[1])
	}

	function kA(i, t, e) {
		let n = {},
			r = new Float32Array(8),
			s = new WeakMap,
			a = new ai,
			o = [];
		for (let c = 0; c < 8; c++) o[c] = [c, 0];

		function h(c, u, g) {
			let p = c.morphTargetInfluences;
			if (t.isWebGL2 === !0) {
				let _ = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
					b = _ !== void 0 ? _.length : 0,
					y = s.get(u);
				if (y === void 0 || y.count !== b) {
					let $ = function () {
						U.dispose(), s.delete(u), u.removeEventListener("dispose", $)
					};
					y !== void 0 && y.texture.dispose();
					let S = u.morphAttributes.position !== void 0,
						x = u.morphAttributes.normal !== void 0,
						M = u.morphAttributes.color !== void 0,
						T = u.morphAttributes.position || [],
						I = u.morphAttributes.normal || [],
						L = u.morphAttributes.color || [],
						F = 0;
					S === !0 && (F = 1), x === !0 && (F = 2), M === !0 && (F = 3);
					let k = u.attributes.position.count * F,
						G = 1;
					k > t.maxTextureSize && (G = Math.ceil(k / t.maxTextureSize), k = t.maxTextureSize);
					let j = new Float32Array(k * G * 4 * b),
						U = new wu(j, k, G, b);
					U.type = ga, U.needsUpdate = !0;
					let z = F * 4;
					for (let W = 0; W < b; W++) {
						let O = T[W],
							B = I[W],
							A = L[W],
							D = k * G * 4 * W;
						for (let H = 0; H < O.count; H++) {
							let q = H * z;
							S === !0 && (a.fromBufferAttribute(O, H), j[D + q + 0] = a.x, j[D + q + 1] = a.y, j[D + q + 2] = a.z, j[D + q + 3] = 0), x === !0 && (a.fromBufferAttribute(B, H), j[D + q + 4] = a.x, j[D + q + 5] = a.y, j[D + q + 6] = a.z, j[D + q + 7] = 0), M === !0 && (a.fromBufferAttribute(A, H), j[D + q + 8] = a.x, j[D + q + 9] = a.y, j[D + q + 10] = a.z, j[D + q + 11] = A.itemSize === 4 ? a.w : 1)
						}
					}
					y = {
						count: b,
						texture: U,
						size: new Oe(k, G)
					}, s.set(u, y), u.addEventListener("dispose", $)
				}
				let w = 0;
				for (let S = 0; S < p.length; S++) w += p[S];
				let f = u.morphTargetsRelative ? 1 : 1 - w;
				g.getUniforms().setValue(i, "morphTargetBaseInfluence", f), g.getUniforms().setValue(i, "morphTargetInfluences", p), g.getUniforms().setValue(i, "morphTargetsTexture", y.texture, e), g.getUniforms().setValue(i, "morphTargetsTextureSize", y.size)
			} else {
				let _ = p === void 0 ? 0 : p.length,
					b = n[u.id];
				if (b === void 0 || b.length !== _) {
					b = [];
					for (let x = 0; x < _; x++) b[x] = [x, 0];
					n[u.id] = b
				}
				for (let x = 0; x < _; x++) {
					let M = b[x];
					M[0] = x, M[1] = p[x]
				}
				b.sort(LA);
				for (let x = 0; x < 8; x++) x < _ && b[x][1] ? (o[x][0] = b[x][0], o[x][1] = b[x][1]) : (o[x][0] = Number.MAX_SAFE_INTEGER, o[x][1] = 0);
				o.sort(IA);
				let y = u.morphAttributes.position,
					w = u.morphAttributes.normal,
					f = 0;
				for (let x = 0; x < 8; x++) {
					let M = o[x],
						T = M[0],
						I = M[1];
					T !== Number.MAX_SAFE_INTEGER && I ? (y && u.getAttribute("morphTarget" + x) !== y[T] && u.setAttribute("morphTarget" + x, y[T]), w && u.getAttribute("morphNormal" + x) !== w[T] && u.setAttribute("morphNormal" + x, w[T]), r[x] = I, f += I) : (y && u.hasAttribute("morphTarget" + x) === !0 && u.deleteAttribute("morphTarget" + x), w && u.hasAttribute("morphNormal" + x) === !0 && u.deleteAttribute("morphNormal" + x), r[x] = 0)
				}
				let S = u.morphTargetsRelative ? 1 : 1 - f;
				g.getUniforms().setValue(i, "morphTargetBaseInfluence", S), g.getUniforms().setValue(i, "morphTargetInfluences", r)
			}
		}
		return {
			update: h
		}
	}

	function RA(i, t, e, n) {
		let r = new WeakMap;

		function s(h) {
			let c = n.render.frame,
				u = h.geometry,
				g = t.get(h, u);
			return r.get(g) !== c && (t.update(g), r.set(g, c)), h.isInstancedMesh && (h.hasEventListener("dispose", o) === !1 && h.addEventListener("dispose", o), e.update(h.instanceMatrix, 34962), h.instanceColor !== null && e.update(h.instanceColor, 34962)), g
		}

		function a() {
			r = new WeakMap
		}

		function o(h) {
			let c = h.target;
			c.removeEventListener("dispose", o), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor)
		}
		return {
			update: s,
			dispose: a
		}
	}
	var ab = new Ni,
		lb = new wu,
		hb = new em,
		cb = new Au,
		Py = [],
		Ay = [],
		Dy = new Float32Array(16),
		Iy = new Float32Array(9),
		Ly = new Float32Array(4);

	function zo(i, t, e) {
		let n = i[0];
		if (n <= 0 || n > 0) return i;
		let r = t * e,
			s = Py[r];
		if (s === void 0 && (s = new Float32Array(r), Py[r] = s), t !== 0) {
			n.toArray(s, 0);
			for (let a = 1, o = 0; a !== t; ++a) o += e, i[a].toArray(s, o)
		}
		return s
	}

	function oi(i, t) {
		if (i.length !== t.length) return !1;
		for (let e = 0, n = i.length; e < n; e++)
			if (i[e] !== t[e]) return !1;
		return !0
	}

	function li(i, t) {
		for (let e = 0, n = t.length; e < n; e++) i[e] = t[e]
	}

	function Nu(i, t) {
		let e = Ay[t];
		e === void 0 && (e = new Int32Array(t), Ay[t] = e);
		for (let n = 0; n !== t; ++n) e[n] = i.allocateTextureUnit();
		return e
	}

	function FA(i, t) {
		let e = this.cache;
		e[0] !== t && (i.uniform1f(this.addr, t), e[0] = t)
	}

	function OA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y) && (i.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
		else {
			if (oi(e, t)) return;
			i.uniform2fv(this.addr, t), li(e, t)
		}
	}

	function NA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
		else if (t.r !== void 0)(e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (i.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
		else {
			if (oi(e, t)) return;
			i.uniform3fv(this.addr, t), li(e, t)
		}
	}

	function VA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
		else {
			if (oi(e, t)) return;
			i.uniform4fv(this.addr, t), li(e, t)
		}
	}

	function zA(i, t) {
		let e = this.cache,
			n = t.elements;
		if (n === void 0) {
			if (oi(e, t)) return;
			i.uniformMatrix2fv(this.addr, !1, t), li(e, t)
		} else {
			if (oi(e, n)) return;
			Ly.set(n), i.uniformMatrix2fv(this.addr, !1, Ly), li(e, n)
		}
	}

	function BA(i, t) {
		let e = this.cache,
			n = t.elements;
		if (n === void 0) {
			if (oi(e, t)) return;
			i.uniformMatrix3fv(this.addr, !1, t), li(e, t)
		} else {
			if (oi(e, n)) return;
			Iy.set(n), i.uniformMatrix3fv(this.addr, !1, Iy), li(e, n)
		}
	}

	function UA(i, t) {
		let e = this.cache,
			n = t.elements;
		if (n === void 0) {
			if (oi(e, t)) return;
			i.uniformMatrix4fv(this.addr, !1, t), li(e, t)
		} else {
			if (oi(e, n)) return;
			Dy.set(n), i.uniformMatrix4fv(this.addr, !1, Dy), li(e, n)
		}
	}

	function GA(i, t) {
		let e = this.cache;
		e[0] !== t && (i.uniform1i(this.addr, t), e[0] = t)
	}

	function HA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y) && (i.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
		else {
			if (oi(e, t)) return;
			i.uniform2iv(this.addr, t), li(e, t)
		}
	}

	function WA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
		else {
			if (oi(e, t)) return;
			i.uniform3iv(this.addr, t), li(e, t)
		}
	}

	function $A(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
		else {
			if (oi(e, t)) return;
			i.uniform4iv(this.addr, t), li(e, t)
		}
	}

	function qA(i, t) {
		let e = this.cache;
		e[0] !== t && (i.uniform1ui(this.addr, t), e[0] = t)
	}

	function jA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y) && (i.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
		else {
			if (oi(e, t)) return;
			i.uniform2uiv(this.addr, t), li(e, t)
		}
	}

	function XA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
		else {
			if (oi(e, t)) return;
			i.uniform3uiv(this.addr, t), li(e, t)
		}
	}

	function YA(i, t) {
		let e = this.cache;
		if (t.x !== void 0)(e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
		else {
			if (oi(e, t)) return;
			i.uniform4uiv(this.addr, t), li(e, t)
		}
	}

	function KA(i, t, e) {
		let n = this.cache,
			r = e.allocateTextureUnit();
		n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2D(t || ab, r)
	}

	function ZA(i, t, e) {
		let n = this.cache,
			r = e.allocateTextureUnit();
		n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture3D(t || hb, r)
	}

	function JA(i, t, e) {
		let n = this.cache,
			r = e.allocateTextureUnit();
		n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTextureCube(t || cb, r)
	}

	function QA(i, t, e) {
		let n = this.cache,
			r = e.allocateTextureUnit();
		n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2DArray(t || lb, r)
	}

	function tD(i) {
		switch (i) {
			case 5126:
				return FA;
			case 35664:
				return OA;
			case 35665:
				return NA;
			case 35666:
				return VA;
			case 35674:
				return zA;
			case 35675:
				return BA;
			case 35676:
				return UA;
			case 5124:
			case 35670:
				return GA;
			case 35667:
			case 35671:
				return HA;
			case 35668:
			case 35672:
				return WA;
			case 35669:
			case 35673:
				return $A;
			case 5125:
				return qA;
			case 36294:
				return jA;
			case 36295:
				return XA;
			case 36296:
				return YA;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return KA;
			case 35679:
			case 36299:
			case 36307:
				return ZA;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return JA;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return QA
		}
	}

	function eD(i, t) {
		i.uniform1fv(this.addr, t)
	}

	function iD(i, t) {
		let e = zo(t, this.size, 2);
		i.uniform2fv(this.addr, e)
	}

	function nD(i, t) {
		let e = zo(t, this.size, 3);
		i.uniform3fv(this.addr, e)
	}

	function rD(i, t) {
		let e = zo(t, this.size, 4);
		i.uniform4fv(this.addr, e)
	}

	function sD(i, t) {
		let e = zo(t, this.size, 4);
		i.uniformMatrix2fv(this.addr, !1, e)
	}

	function aD(i, t) {
		let e = zo(t, this.size, 9);
		i.uniformMatrix3fv(this.addr, !1, e)
	}

	function oD(i, t) {
		let e = zo(t, this.size, 16);
		i.uniformMatrix4fv(this.addr, !1, e)
	}

	function lD(i, t) {
		i.uniform1iv(this.addr, t)
	}

	function hD(i, t) {
		i.uniform2iv(this.addr, t)
	}

	function cD(i, t) {
		i.uniform3iv(this.addr, t)
	}

	function uD(i, t) {
		i.uniform4iv(this.addr, t)
	}

	function dD(i, t) {
		i.uniform1uiv(this.addr, t)
	}

	function pD(i, t) {
		i.uniform2uiv(this.addr, t)
	}

	function fD(i, t) {
		i.uniform3uiv(this.addr, t)
	}

	function mD(i, t) {
		i.uniform4uiv(this.addr, t)
	}

	function vD(i, t, e) {
		let n = this.cache,
			r = t.length,
			s = Nu(e, r);
		oi(n, s) || (i.uniform1iv(this.addr, s), li(n, s));
		for (let a = 0; a !== r; ++a) e.setTexture2D(t[a] || ab, s[a])
	}

	function gD(i, t, e) {
		let n = this.cache,
			r = t.length,
			s = Nu(e, r);
		oi(n, s) || (i.uniform1iv(this.addr, s), li(n, s));
		for (let a = 0; a !== r; ++a) e.setTexture3D(t[a] || hb, s[a])
	}

	function _D(i, t, e) {
		let n = this.cache,
			r = t.length,
			s = Nu(e, r);
		oi(n, s) || (i.uniform1iv(this.addr, s), li(n, s));
		for (let a = 0; a !== r; ++a) e.setTextureCube(t[a] || cb, s[a])
	}

	function yD(i, t, e) {
		let n = this.cache,
			r = t.length,
			s = Nu(e, r);
		oi(n, s) || (i.uniform1iv(this.addr, s), li(n, s));
		for (let a = 0; a !== r; ++a) e.setTexture2DArray(t[a] || lb, s[a])
	}

	function bD(i) {
		switch (i) {
			case 5126:
				return eD;
			case 35664:
				return iD;
			case 35665:
				return nD;
			case 35666:
				return rD;
			case 35674:
				return sD;
			case 35675:
				return aD;
			case 35676:
				return oD;
			case 5124:
			case 35670:
				return lD;
			case 35667:
			case 35671:
				return hD;
			case 35668:
			case 35672:
				return cD;
			case 35669:
			case 35673:
				return uD;
			case 5125:
				return dD;
			case 36294:
				return pD;
			case 36295:
				return fD;
			case 36296:
				return mD;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return vD;
			case 35679:
			case 36299:
			case 36307:
				return gD;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return _D;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return yD
		}
	}
	var sm = class {
			constructor(t, e, n) {
				this.id = t, this.addr = n, this.cache = [], this.setValue = tD(e.type)
			}
		},
		am = class {
			constructor(t, e, n) {
				this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = bD(e.type)
			}
		},
		om = class {
			constructor(t) {
				this.id = t, this.seq = [], this.map = {}
			}
			setValue(t, e, n) {
				let r = this.seq;
				for (let s = 0, a = r.length; s !== a; ++s) {
					let o = r[s];
					o.setValue(t, e[o.id], n)
				}
			}
		},
		$f = /(\w+)(\])?(\[|\.)?/g;

	function ky(i, t) {
		i.seq.push(t), i.map[t.id] = t
	}

	function xD(i, t, e) {
		let n = i.name,
			r = n.length;
		for ($f.lastIndex = 0;;) {
			let s = $f.exec(n),
				a = $f.lastIndex,
				o = s[1],
				h = s[2] === "]",
				c = s[3];
			if (h && (o = o | 0), c === void 0 || c === "[" && a + 2 === r) {
				ky(e, c === void 0 ? new sm(o, i, t) : new am(o, i, t));
				break
			} else {
				let g = e.map[o];
				g === void 0 && (g = new om(o), ky(e, g)), e = g
			}
		}
	}
	var Ao = class {
		constructor(t, e) {
			this.seq = [], this.map = {};
			let n = t.getProgramParameter(e, 35718);
			for (let r = 0; r < n; ++r) {
				let s = t.getActiveUniform(e, r),
					a = t.getUniformLocation(e, s.name);
				xD(s, a, this)
			}
		}
		setValue(t, e, n, r) {
			let s = this.map[e];
			s !== void 0 && s.setValue(t, n, r)
		}
		setOptional(t, e, n) {
			let r = e[n];
			r !== void 0 && this.setValue(t, n, r)
		}
		static upload(t, e, n, r) {
			for (let s = 0, a = e.length; s !== a; ++s) {
				let o = e[s],
					h = n[o.id];
				h.needsUpdate !== !1 && o.setValue(t, h.value, r)
			}
		}
		static seqWithValue(t, e) {
			let n = [];
			for (let r = 0, s = t.length; r !== s; ++r) {
				let a = t[r];
				a.id in e && n.push(a)
			}
			return n
		}
	};

	function Ry(i, t, e) {
		let n = i.createShader(t);
		return i.shaderSource(n, e), i.compileShader(n), n
	}
	var wD = 0;

	function SD(i, t) {
		let e = i.split(`
`),
			n = [],
			r = Math.max(t - 6, 0),
			s = Math.min(t + 6, e.length);
		for (let a = r; a < s; a++) {
			let o = a + 1;
			n.push(`${o===t?">":" "} ${o}: ${e[a]}`)
		}
		return n.join(`
`)
	}

	function ED(i) {
		switch (i) {
			case ba:
				return ["Linear", "( value )"];
			case ze:
				return ["sRGB", "( value )"];
			default:
				return console.warn("THREE.WebGLProgram: Unsupported encoding:", i), ["Linear", "( value )"]
		}
	}

	function Fy(i, t, e) {
		let n = i.getShaderParameter(t, 35713),
			r = i.getShaderInfoLog(t).trim();
		if (n && r === "") return "";
		let s = /ERROR: 0:(\d+)/.exec(r);
		if (s) {
			let a = parseInt(s[1]);
			return e.toUpperCase() + `

` + r + `

` + SD(i.getShaderSource(t), a)
		} else return r
	}

	function MD(i, t) {
		let e = ED(t);
		return "vec4 " + i + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }"
	}

	function CD(i, t) {
		let e;
		switch (t) {
			case $M:
				e = "Linear";
				break;
			case qM:
				e = "Reinhard";
				break;
			case jM:
				e = "OptimizedCineon";
				break;
			case XM:
				e = "ACESFilmic";
				break;
			case YM:
				e = "Custom";
				break;
			default:
				console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear"
		}
		return "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
	}

	function TD(i) {
		return [i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.normalMapTangentSpace || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Jl).join(`
`)
	}

	function PD(i) {
		let t = [];
		for (let e in i) {
			let n = i[e];
			n !== !1 && t.push("#define " + e + " " + n)
		}
		return t.join(`
`)
	}

	function AD(i, t) {
		let e = {},
			n = i.getProgramParameter(t, 35721);
		for (let r = 0; r < n; r++) {
			let s = i.getActiveAttrib(t, r),
				a = s.name,
				o = 1;
			s.type === 35674 && (o = 2), s.type === 35675 && (o = 3), s.type === 35676 && (o = 4), e[a] = {
				type: s.type,
				location: i.getAttribLocation(t, a),
				locationSize: o
			}
		}
		return e
	}

	function Jl(i) {
		return i !== ""
	}

	function Oy(i, t) {
		let e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
		return i.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
	}

	function Ny(i, t) {
		return i.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
	}
	var DD = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function lm(i) {
		return i.replace(DD, ID)
	}

	function ID(i, t) {
		let e = he[t];
		if (e === void 0) throw new Error("Can not resolve #include <" + t + ">");
		return lm(e)
	}
	var LD = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function Vy(i) {
		return i.replace(LD, kD)
	}

	function kD(i, t, e, n) {
		let r = "";
		for (let s = parseInt(t); s < parseInt(e); s++) r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
		return r
	}

	function zy(i) {
		let t = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
		return i.precision === "highp" ? t += `
#define HIGH_PRECISION` : i.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (t += `
#define LOW_PRECISION`), t
	}

	function RD(i) {
		let t = "SHADOWMAP_TYPE_BASIC";
		return i.shadowMapType === Yy ? t = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === SM ? t = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === Zl && (t = "SHADOWMAP_TYPE_VSM"), t
	}

	function FD(i) {
		let t = "ENVMAP_TYPE_CUBE";
		if (i.envMap) switch (i.envMapMode) {
			case Do:
			case Io:
				t = "ENVMAP_TYPE_CUBE";
				break;
			case Ou:
				t = "ENVMAP_TYPE_CUBE_UV";
				break
		}
		return t
	}

	function OD(i) {
		let t = "ENVMAP_MODE_REFLECTION";
		if (i.envMap) switch (i.envMapMode) {
			case Io:
				t = "ENVMAP_MODE_REFRACTION";
				break
		}
		return t
	}

	function ND(i) {
		let t = "ENVMAP_BLENDING_NONE";
		if (i.envMap) switch (i.combine) {
			case Jy:
				t = "ENVMAP_BLENDING_MULTIPLY";
				break;
			case HM:
				t = "ENVMAP_BLENDING_MIX";
				break;
			case WM:
				t = "ENVMAP_BLENDING_ADD";
				break
		}
		return t
	}

	function VD(i) {
		let t = i.envMapCubeUVHeight;
		if (t === null) return null;
		let e = Math.log2(t) - 2,
			n = 1 / t;
		return {
			texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
			texelHeight: n,
			maxMip: e
		}
	}

	function zD(i, t, e, n) {
		let r = i.getContext(),
			s = e.defines,
			a = e.vertexShader,
			o = e.fragmentShader,
			h = RD(e),
			c = FD(e),
			u = OD(e),
			g = ND(e),
			p = VD(e),
			_ = e.isWebGL2 ? "" : TD(e),
			b = PD(s),
			y = r.createProgram(),
			w, f, S = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
		e.isRawShaderMaterial ? (w = [b].filter(Jl).join(`
`), w.length > 0 && (w += `
`), f = [_, b].filter(Jl).join(`
`), f.length > 0 && (f += `
`)) : (w = [zy(e), "#define SHADER_NAME " + e.shaderName, b, e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + u : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.mapUv ? "#define MAP_UV " + e.mapUv : "", e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "", e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "", e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "", e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "", e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "", e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "", e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "", e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "", e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "", e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "", e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "", e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "", e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "", e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "", e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "", e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "", e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "", e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "", e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "", e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "", e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs2 ? "#define USE_UV2" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + h : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Jl).join(`
`), f = [_, zy(e), "#define SHADER_NAME " + e.shaderName, b, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + u : "", e.envMap ? "#define " + g : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs2 ? "#define USE_UV2" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + h : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.useLegacyLights ? "#define LEGACY_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== Vr ? "#define TONE_MAPPING" : "", e.toneMapping !== Vr ? he.tonemapping_pars_fragment : "", e.toneMapping !== Vr ? CD("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", he.encodings_pars_fragment, MD("linearToOutputTexel", e.outputEncoding), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`].filter(Jl).join(`
`)), a = lm(a), a = Oy(a, e), a = Ny(a, e), o = lm(o), o = Oy(o, e), o = Ny(o, e), a = Vy(a), o = Vy(o), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (S = `#version 300 es
`, w = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + w, f = ["#define varying in", e.glslVersion === ay ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === ay ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + f);
		let x = S + w + a,
			M = S + f + o,
			T = Ry(r, 35633, x),
			I = Ry(r, 35632, M);
		if (r.attachShader(y, T), r.attachShader(y, I), e.index0AttributeName !== void 0 ? r.bindAttribLocation(y, 0, e.index0AttributeName) : e.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), i.debug.checkShaderErrors) {
			let k = r.getProgramInfoLog(y).trim(),
				G = r.getShaderInfoLog(T).trim(),
				j = r.getShaderInfoLog(I).trim(),
				U = !0,
				z = !0;
			if (r.getProgramParameter(y, 35714) === !1)
				if (U = !1, typeof i.debug.onShaderError == "function") i.debug.onShaderError(r, y, T, I);
				else {
					let $ = Fy(r, T, "vertex"),
						W = Fy(r, I, "fragment");
					console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + `

Program Info Log: ` + k + `
` + $ + `
` + W)
				}
			else k !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", k) : (G === "" || j === "") && (z = !1);
			z && (this.diagnostics = {
				runnable: U,
				programLog: k,
				vertexShader: {
					log: G,
					prefix: w
				},
				fragmentShader: {
					log: j,
					prefix: f
				}
			})
		}
		r.deleteShader(T), r.deleteShader(I);
		let L;
		this.getUniforms = function () {
			return L === void 0 && (L = new Ao(r, y)), L
		};
		let F;
		return this.getAttributes = function () {
			return F === void 0 && (F = AD(r, y)), F
		}, this.destroy = function () {
			n.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0
		}, this.name = e.shaderName, this.id = wD++, this.cacheKey = t, this.usedTimes = 1, this.program = y, this.vertexShader = T, this.fragmentShader = I, this
	}
	var BD = 0,
		hm = class {
			constructor() {
				this.shaderCache = new Map, this.materialCache = new Map
			}
			update(t) {
				let e = t.vertexShader,
					n = t.fragmentShader,
					r = this._getShaderStage(e),
					s = this._getShaderStage(n),
					a = this._getShaderCacheForMaterial(t);
				return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this
			}
			remove(t) {
				let e = this.materialCache.get(t);
				for (let n of e) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
				return this.materialCache.delete(t), this
			}
			getVertexShaderID(t) {
				return this._getShaderStage(t.vertexShader).id
			}
			getFragmentShaderID(t) {
				return this._getShaderStage(t.fragmentShader).id
			}
			dispose() {
				this.shaderCache.clear(), this.materialCache.clear()
			}
			_getShaderCacheForMaterial(t) {
				let e = this.materialCache,
					n = e.get(t);
				return n === void 0 && (n = new Set, e.set(t, n)), n
			}
			_getShaderStage(t) {
				let e = this.shaderCache,
					n = e.get(t);
				return n === void 0 && (n = new cm(t), e.set(t, n)), n
			}
		},
		cm = class {
			constructor(t) {
				this.id = BD++, this.code = t, this.usedTimes = 0
			}
		};

	function UD(i, t, e, n, r, s, a) {
		let o = new Eu,
			h = new hm,
			c = [],
			u = r.isWebGL2,
			g = r.logarithmicDepthBuffer,
			p = r.vertexTextures,
			_ = r.precision,
			b = {
				MeshDepthMaterial: "depth",
				MeshDistanceMaterial: "distanceRGBA",
				MeshNormalMaterial: "normal",
				MeshBasicMaterial: "basic",
				MeshLambertMaterial: "lambert",
				MeshPhongMaterial: "phong",
				MeshToonMaterial: "toon",
				MeshStandardMaterial: "physical",
				MeshPhysicalMaterial: "physical",
				MeshMatcapMaterial: "matcap",
				LineBasicMaterial: "basic",
				LineDashedMaterial: "dashed",
				PointsMaterial: "points",
				ShadowMaterial: "shadow",
				SpriteMaterial: "sprite"
			};

		function y(k) {
			return k === 1 ? "uv2" : "uv"
		}

		function w(k, G, j, U, z) {
			let $ = U.fog,
				W = z.geometry,
				O = k.isMeshStandardMaterial ? U.environment : null,
				B = (k.isMeshStandardMaterial ? e : t).get(k.envMap || O),
				A = B && B.mapping === Ou ? B.image.height : null,
				D = b[k.type];
			k.precision !== null && (_ = r.getMaxPrecision(k.precision), _ !== k.precision && console.warn("THREE.WebGLProgram.getParameters:", k.precision, "not supported, using", _, "instead."));
			let H = W.morphAttributes.position || W.morphAttributes.normal || W.morphAttributes.color,
				q = H !== void 0 ? H.length : 0,
				Q = 0;
			W.morphAttributes.position !== void 0 && (Q = 1), W.morphAttributes.normal !== void 0 && (Q = 2), W.morphAttributes.color !== void 0 && (Q = 3);
			let tt, nt, ut, et;
			if (D) {
				let kt = ar[D];
				tt = kt.vertexShader, nt = kt.fragmentShader
			} else tt = k.vertexShader, nt = k.fragmentShader, h.update(k), ut = h.getVertexShaderID(k), et = h.getFragmentShaderID(k);
			let it = i.getRenderTarget(),
				Et = z.isInstancedMesh === !0,
				wt = !!k.map,
				yt = !!k.matcap,
				At = !!B,
				Vt = !!k.aoMap,
				lt = !!k.lightMap,
				dt = !!k.bumpMap,
				qt = !!k.normalMap,
				Zt = !!k.displacementMap,
				re = !!k.emissiveMap,
				de = !!k.metalnessMap,
				Xt = !!k.roughnessMap,
				le = k.clearcoat > 0,
				ye = k.iridescence > 0,
				Z = k.sheen > 0,
				X = k.transmission > 0,
				pt = le && !!k.clearcoatMap,
				xt = le && !!k.clearcoatNormalMap,
				St = le && !!k.clearcoatRoughnessMap,
				Pt = ye && !!k.iridescenceMap,
				Bt = ye && !!k.iridescenceThicknessMap,
				It = Z && !!k.sheenColorMap,
				mt = Z && !!k.sheenRoughnessMap,
				Ot = !!k.specularMap,
				Gt = !!k.specularColorMap,
				Ut = !!k.specularIntensityMap,
				Lt = X && !!k.transmissionMap,
				Nt = X && !!k.thicknessMap,
				ce = !!k.gradientMap,
				be = !!k.alphaMap,
				Ie = k.alphaTest > 0,
				rt = !!k.extensions,
				gt = !!W.attributes.uv2;
			return {
				isWebGL2: u,
				shaderID: D,
				shaderName: k.type,
				vertexShader: tt,
				fragmentShader: nt,
				defines: k.defines,
				customVertexShaderID: ut,
				customFragmentShaderID: et,
				isRawShaderMaterial: k.isRawShaderMaterial === !0,
				glslVersion: k.glslVersion,
				precision: _,
				instancing: Et,
				instancingColor: Et && z.instanceColor !== null,
				supportsVertexTextures: p,
				outputEncoding: it === null ? i.outputEncoding : it.isXRRenderTarget === !0 ? it.texture.encoding : ba,
				map: wt,
				matcap: yt,
				envMap: At,
				envMapMode: At && B.mapping,
				envMapCubeUVHeight: A,
				aoMap: Vt,
				lightMap: lt,
				bumpMap: dt,
				normalMap: qt,
				displacementMap: p && Zt,
				emissiveMap: re,
				normalMapObjectSpace: qt && k.normalMapType === mC,
				normalMapTangentSpace: qt && k.normalMapType === fC,
				decodeVideoTexture: wt && k.map.isVideoTexture === !0 && k.map.encoding === ze,
				metalnessMap: de,
				roughnessMap: Xt,
				clearcoat: le,
				clearcoatMap: pt,
				clearcoatNormalMap: xt,
				clearcoatRoughnessMap: St,
				iridescence: ye,
				iridescenceMap: Pt,
				iridescenceThicknessMap: Bt,
				sheen: Z,
				sheenColorMap: It,
				sheenRoughnessMap: mt,
				specularMap: Ot,
				specularColorMap: Gt,
				specularIntensityMap: Ut,
				transmission: X,
				transmissionMap: Lt,
				thicknessMap: Nt,
				gradientMap: ce,
				opaque: k.transparent === !1 && k.blending === Co,
				alphaMap: be,
				alphaTest: Ie,
				combine: k.combine,
				mapUv: wt && y(k.map.channel),
				aoMapUv: Vt && y(k.aoMap.channel),
				lightMapUv: lt && y(k.lightMap.channel),
				bumpMapUv: dt && y(k.bumpMap.channel),
				normalMapUv: qt && y(k.normalMap.channel),
				displacementMapUv: Zt && y(k.displacementMap.channel),
				emissiveMapUv: re && y(k.emissiveMap.channel),
				metalnessMapUv: de && y(k.metalnessMap.channel),
				roughnessMapUv: Xt && y(k.roughnessMap.channel),
				clearcoatMapUv: pt && y(k.clearcoatMap.channel),
				clearcoatNormalMapUv: xt && y(k.clearcoatNormalMap.channel),
				clearcoatRoughnessMapUv: St && y(k.clearcoatRoughnessMap.channel),
				iridescenceMapUv: Pt && y(k.iridescenceMap.channel),
				iridescenceThicknessMapUv: Bt && y(k.iridescenceThicknessMap.channel),
				sheenColorMapUv: It && y(k.sheenColorMap.channel),
				sheenRoughnessMapUv: mt && y(k.sheenRoughnessMap.channel),
				specularMapUv: Ot && y(k.specularMap.channel),
				specularColorMapUv: Gt && y(k.specularColorMap.channel),
				specularIntensityMapUv: Ut && y(k.specularIntensityMap.channel),
				transmissionMapUv: Lt && y(k.transmissionMap.channel),
				thicknessMapUv: Nt && y(k.thicknessMap.channel),
				alphaMapUv: be && y(k.alphaMap.channel),
				vertexTangents: qt && !!W.attributes.tangent,
				vertexColors: k.vertexColors,
				vertexAlphas: k.vertexColors === !0 && !!W.attributes.color && W.attributes.color.itemSize === 4,
				vertexUvs2: gt,
				pointsUvs: z.isPoints === !0 && !!W.attributes.uv && (wt || be),
				fog: !!$,
				useFog: k.fog === !0,
				fogExp2: $ && $.isFogExp2,
				flatShading: k.flatShading === !0,
				sizeAttenuation: k.sizeAttenuation === !0,
				logarithmicDepthBuffer: g,
				skinning: z.isSkinnedMesh === !0,
				morphTargets: W.morphAttributes.position !== void 0,
				morphNormals: W.morphAttributes.normal !== void 0,
				morphColors: W.morphAttributes.color !== void 0,
				morphTargetsCount: q,
				morphTextureStride: Q,
				numDirLights: G.directional.length,
				numPointLights: G.point.length,
				numSpotLights: G.spot.length,
				numSpotLightMaps: G.spotLightMap.length,
				numRectAreaLights: G.rectArea.length,
				numHemiLights: G.hemi.length,
				numDirLightShadows: G.directionalShadowMap.length,
				numPointLightShadows: G.pointShadowMap.length,
				numSpotLightShadows: G.spotShadowMap.length,
				numSpotLightShadowsWithMaps: G.numSpotLightShadowsWithMaps,
				numClippingPlanes: a.numPlanes,
				numClipIntersection: a.numIntersection,
				dithering: k.dithering,
				shadowMapEnabled: i.shadowMap.enabled && j.length > 0,
				shadowMapType: i.shadowMap.type,
				toneMapping: k.toneMapped ? i.toneMapping : Vr,
				useLegacyLights: i.useLegacyLights,
				premultipliedAlpha: k.premultipliedAlpha,
				doubleSided: k.side === Or,
				flipSided: k.side === Zi,
				useDepthPacking: k.depthPacking >= 0,
				depthPacking: k.depthPacking || 0,
				index0AttributeName: k.index0AttributeName,
				extensionDerivatives: rt && k.extensions.derivatives === !0,
				extensionFragDepth: rt && k.extensions.fragDepth === !0,
				extensionDrawBuffers: rt && k.extensions.drawBuffers === !0,
				extensionShaderTextureLOD: rt && k.extensions.shaderTextureLOD === !0,
				rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
				rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
				rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
				customProgramCacheKey: k.customProgramCacheKey()
			}
		}

		function f(k) {
			let G = [];
			if (k.shaderID ? G.push(k.shaderID) : (G.push(k.customVertexShaderID), G.push(k.customFragmentShaderID)), k.defines !== void 0)
				for (let j in k.defines) G.push(j), G.push(k.defines[j]);
			return k.isRawShaderMaterial === !1 && (S(G, k), x(G, k), G.push(i.outputEncoding)), G.push(k.customProgramCacheKey), G.join()
		}

		function S(k, G) {
			k.push(G.precision), k.push(G.outputEncoding), k.push(G.envMapMode), k.push(G.envMapCubeUVHeight), k.push(G.mapUv), k.push(G.alphaMapUv), k.push(G.lightMapUv), k.push(G.aoMapUv), k.push(G.bumpMapUv), k.push(G.normalMapUv), k.push(G.displacementMapUv), k.push(G.emissiveMapUv), k.push(G.metalnessMapUv), k.push(G.roughnessMapUv), k.push(G.clearcoatMapUv), k.push(G.clearcoatNormalMapUv), k.push(G.clearcoatRoughnessMapUv), k.push(G.iridescenceMapUv), k.push(G.iridescenceThicknessMapUv), k.push(G.sheenColorMapUv), k.push(G.sheenRoughnessMapUv), k.push(G.specularMapUv), k.push(G.specularColorMapUv), k.push(G.specularIntensityMapUv), k.push(G.transmissionMapUv), k.push(G.thicknessMapUv), k.push(G.combine), k.push(G.fogExp2), k.push(G.sizeAttenuation), k.push(G.morphTargetsCount), k.push(G.morphAttributeCount), k.push(G.numDirLights), k.push(G.numPointLights), k.push(G.numSpotLights), k.push(G.numSpotLightMaps), k.push(G.numHemiLights), k.push(G.numRectAreaLights), k.push(G.numDirLightShadows), k.push(G.numPointLightShadows), k.push(G.numSpotLightShadows), k.push(G.numSpotLightShadowsWithMaps), k.push(G.shadowMapType), k.push(G.toneMapping), k.push(G.numClippingPlanes), k.push(G.numClipIntersection), k.push(G.depthPacking)
		}

		function x(k, G) {
			o.disableAll(), G.isWebGL2 && o.enable(0), G.supportsVertexTextures && o.enable(1), G.instancing && o.enable(2), G.instancingColor && o.enable(3), G.matcap && o.enable(4), G.envMap && o.enable(5), G.normalMapObjectSpace && o.enable(6), G.normalMapTangentSpace && o.enable(7), G.clearcoat && o.enable(8), G.iridescence && o.enable(9), G.alphaTest && o.enable(10), G.vertexColors && o.enable(11), G.vertexAlphas && o.enable(12), G.vertexUvs2 && o.enable(13), G.vertexTangents && o.enable(14), k.push(o.mask), o.disableAll(), G.fog && o.enable(0), G.useFog && o.enable(1), G.flatShading && o.enable(2), G.logarithmicDepthBuffer && o.enable(3), G.skinning && o.enable(4), G.morphTargets && o.enable(5), G.morphNormals && o.enable(6), G.morphColors && o.enable(7), G.premultipliedAlpha && o.enable(8), G.shadowMapEnabled && o.enable(9), G.useLegacyLights && o.enable(10), G.doubleSided && o.enable(11), G.flipSided && o.enable(12), G.useDepthPacking && o.enable(13), G.dithering && o.enable(14), G.transmission && o.enable(15), G.sheen && o.enable(16), G.decodeVideoTexture && o.enable(17), G.opaque && o.enable(18), G.pointsUvs && o.enable(19), k.push(o.mask)
		}

		function M(k) {
			let G = b[k.type],
				j;
			if (G) {
				let U = ar[G];
				j = NC.clone(U.uniforms)
			} else j = k.uniforms;
			return j
		}

		function T(k, G) {
			let j;
			for (let U = 0, z = c.length; U < z; U++) {
				let $ = c[U];
				if ($.cacheKey === G) {
					j = $, ++j.usedTimes;
					break
				}
			}
			return j === void 0 && (j = new zD(i, G, k, s), c.push(j)), j
		}

		function I(k) {
			if (--k.usedTimes === 0) {
				let G = c.indexOf(k);
				c[G] = c[c.length - 1], c.pop(), k.destroy()
			}
		}

		function L(k) {
			h.remove(k)
		}

		function F() {
			h.dispose()
		}
		return {
			getParameters: w,
			getProgramCacheKey: f,
			getUniforms: M,
			acquireProgram: T,
			releaseProgram: I,
			releaseShaderCache: L,
			programs: c,
			dispose: F
		}
	}

	function GD() {
		let i = new WeakMap;

		function t(s) {
			let a = i.get(s);
			return a === void 0 && (a = {}, i.set(s, a)), a
		}

		function e(s) {
			i.delete(s)
		}

		function n(s, a, o) {
			i.get(s)[a] = o
		}

		function r() {
			i = new WeakMap
		}
		return {
			get: t,
			remove: e,
			update: n,
			dispose: r
		}
	}

	function HD(i, t) {
		return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.material.id !== t.material.id ? i.material.id - t.material.id : i.z !== t.z ? i.z - t.z : i.id - t.id
	}

	function By(i, t) {
		return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.z !== t.z ? t.z - i.z : i.id - t.id
	}

	function Uy() {
		let i = [],
			t = 0,
			e = [],
			n = [],
			r = [];

		function s() {
			t = 0, e.length = 0, n.length = 0, r.length = 0
		}

		function a(g, p, _, b, y, w) {
			let f = i[t];
			return f === void 0 ? (f = {
				id: g.id,
				object: g,
				geometry: p,
				material: _,
				groupOrder: b,
				renderOrder: g.renderOrder,
				z: y,
				group: w
			}, i[t] = f) : (f.id = g.id, f.object = g, f.geometry = p, f.material = _, f.groupOrder = b, f.renderOrder = g.renderOrder, f.z = y, f.group = w), t++, f
		}

		function o(g, p, _, b, y, w) {
			let f = a(g, p, _, b, y, w);
			_.transmission > 0 ? n.push(f) : _.transparent === !0 ? r.push(f) : e.push(f)
		}

		function h(g, p, _, b, y, w) {
			let f = a(g, p, _, b, y, w);
			_.transmission > 0 ? n.unshift(f) : _.transparent === !0 ? r.unshift(f) : e.unshift(f)
		}

		function c(g, p) {
			e.length > 1 && e.sort(g || HD), n.length > 1 && n.sort(p || By), r.length > 1 && r.sort(p || By)
		}

		function u() {
			for (let g = t, p = i.length; g < p; g++) {
				let _ = i[g];
				if (_.id === null) break;
				_.id = null, _.object = null, _.geometry = null, _.material = null, _.group = null
			}
		}
		return {
			opaque: e,
			transmissive: n,
			transparent: r,
			init: s,
			push: o,
			unshift: h,
			finish: u,
			sort: c
		}
	}

	function WD() {
		let i = new WeakMap;

		function t(n, r) {
			let s = i.get(n),
				a;
			return s === void 0 ? (a = new Uy, i.set(n, [a])) : r >= s.length ? (a = new Uy, s.push(a)) : a = s[r], a
		}

		function e() {
			i = new WeakMap
		}
		return {
			get: t,
			dispose: e
		}
	}

	function $D() {
		let i = {};
		return {
			get: function (t) {
				if (i[t.id] !== void 0) return i[t.id];
				let e;
				switch (t.type) {
					case "DirectionalLight":
						e = {
							direction: new ht,
							color: new Pe
						};
						break;
					case "SpotLight":
						e = {
							position: new ht,
							direction: new ht,
							color: new Pe,
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;
					case "PointLight":
						e = {
							position: new ht,
							color: new Pe,
							distance: 0,
							decay: 0
						};
						break;
					case "HemisphereLight":
						e = {
							direction: new ht,
							skyColor: new Pe,
							groundColor: new Pe
						};
						break;
					case "RectAreaLight":
						e = {
							color: new Pe,
							position: new ht,
							halfWidth: new ht,
							halfHeight: new ht
						};
						break
				}
				return i[t.id] = e, e
			}
		}
	}

	function qD() {
		let i = {};
		return {
			get: function (t) {
				if (i[t.id] !== void 0) return i[t.id];
				let e;
				switch (t.type) {
					case "DirectionalLight":
						e = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Oe
						};
						break;
					case "SpotLight":
						e = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Oe
						};
						break;
					case "PointLight":
						e = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Oe,
							shadowCameraNear: 1,
							shadowCameraFar: 1e3
						};
						break
				}
				return i[t.id] = e, e
			}
		}
	}
	var jD = 0;

	function XD(i, t) {
		return (t.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (i.map ? 1 : 0)
	}

	function YD(i, t) {
		let e = new $D,
			n = qD(),
			r = {
				version: 0,
				hash: {
					directionalLength: -1,
					pointLength: -1,
					spotLength: -1,
					rectAreaLength: -1,
					hemiLength: -1,
					numDirectionalShadows: -1,
					numPointShadows: -1,
					numSpotShadows: -1,
					numSpotMaps: -1
				},
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadow: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotLightMap: [],
				spotShadow: [],
				spotShadowMap: [],
				spotLightMatrix: [],
				rectArea: [],
				rectAreaLTC1: null,
				rectAreaLTC2: null,
				point: [],
				pointShadow: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
				numSpotLightShadowsWithMaps: 0
			};
		for (let u = 0; u < 9; u++) r.probe.push(new ht);
		let s = new ht,
			a = new ii,
			o = new ii;

		function h(u, g) {
			let p = 0,
				_ = 0,
				b = 0;
			for (let j = 0; j < 9; j++) r.probe[j].set(0, 0, 0);
			let y = 0,
				w = 0,
				f = 0,
				S = 0,
				x = 0,
				M = 0,
				T = 0,
				I = 0,
				L = 0,
				F = 0;
			u.sort(XD);
			let k = g === !0 ? Math.PI : 1;
			for (let j = 0, U = u.length; j < U; j++) {
				let z = u[j],
					$ = z.color,
					W = z.intensity,
					O = z.distance,
					B = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
				if (z.isAmbientLight) p += $.r * W * k, _ += $.g * W * k, b += $.b * W * k;
				else if (z.isLightProbe)
					for (let A = 0; A < 9; A++) r.probe[A].addScaledVector(z.sh.coefficients[A], W);
				else if (z.isDirectionalLight) {
					let A = e.get(z);
					if (A.color.copy(z.color).multiplyScalar(z.intensity * k), z.castShadow) {
						let D = z.shadow,
							H = n.get(z);
						H.shadowBias = D.bias, H.shadowNormalBias = D.normalBias, H.shadowRadius = D.radius, H.shadowMapSize = D.mapSize, r.directionalShadow[y] = H, r.directionalShadowMap[y] = B, r.directionalShadowMatrix[y] = z.shadow.matrix, M++
					}
					r.directional[y] = A, y++
				} else if (z.isSpotLight) {
					let A = e.get(z);
					A.position.setFromMatrixPosition(z.matrixWorld), A.color.copy($).multiplyScalar(W * k), A.distance = O, A.coneCos = Math.cos(z.angle), A.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)), A.decay = z.decay, r.spot[f] = A;
					let D = z.shadow;
					if (z.map && (r.spotLightMap[L] = z.map, L++, D.updateMatrices(z), z.castShadow && F++), r.spotLightMatrix[f] = D.matrix, z.castShadow) {
						let H = n.get(z);
						H.shadowBias = D.bias, H.shadowNormalBias = D.normalBias, H.shadowRadius = D.radius, H.shadowMapSize = D.mapSize, r.spotShadow[f] = H, r.spotShadowMap[f] = B, I++
					}
					f++
				} else if (z.isRectAreaLight) {
					let A = e.get(z);
					A.color.copy($).multiplyScalar(W), A.halfWidth.set(z.width * .5, 0, 0), A.halfHeight.set(0, z.height * .5, 0), r.rectArea[S] = A, S++
				} else if (z.isPointLight) {
					let A = e.get(z);
					if (A.color.copy(z.color).multiplyScalar(z.intensity * k), A.distance = z.distance, A.decay = z.decay, z.castShadow) {
						let D = z.shadow,
							H = n.get(z);
						H.shadowBias = D.bias, H.shadowNormalBias = D.normalBias, H.shadowRadius = D.radius, H.shadowMapSize = D.mapSize, H.shadowCameraNear = D.camera.near, H.shadowCameraFar = D.camera.far, r.pointShadow[w] = H, r.pointShadowMap[w] = B, r.pointShadowMatrix[w] = z.shadow.matrix, T++
					}
					r.point[w] = A, w++
				} else if (z.isHemisphereLight) {
					let A = e.get(z);
					A.skyColor.copy(z.color).multiplyScalar(W * k), A.groundColor.copy(z.groundColor).multiplyScalar(W * k), r.hemi[x] = A, x++
				}
			}
			S > 0 && (t.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Dt.LTC_FLOAT_1, r.rectAreaLTC2 = Dt.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Dt.LTC_HALF_1, r.rectAreaLTC2 = Dt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = _, r.ambient[2] = b;
			let G = r.hash;
			(G.directionalLength !== y || G.pointLength !== w || G.spotLength !== f || G.rectAreaLength !== S || G.hemiLength !== x || G.numDirectionalShadows !== M || G.numPointShadows !== T || G.numSpotShadows !== I || G.numSpotMaps !== L) && (r.directional.length = y, r.spot.length = f, r.rectArea.length = S, r.point.length = w, r.hemi.length = x, r.directionalShadow.length = M, r.directionalShadowMap.length = M, r.pointShadow.length = T, r.pointShadowMap.length = T, r.spotShadow.length = I, r.spotShadowMap.length = I, r.directionalShadowMatrix.length = M, r.pointShadowMatrix.length = T, r.spotLightMatrix.length = I + L - F, r.spotLightMap.length = L, r.numSpotLightShadowsWithMaps = F, G.directionalLength = y, G.pointLength = w, G.spotLength = f, G.rectAreaLength = S, G.hemiLength = x, G.numDirectionalShadows = M, G.numPointShadows = T, G.numSpotShadows = I, G.numSpotMaps = L, r.version = jD++)
		}

		function c(u, g) {
			let p = 0,
				_ = 0,
				b = 0,
				y = 0,
				w = 0,
				f = g.matrixWorldInverse;
			for (let S = 0, x = u.length; S < x; S++) {
				let M = u[S];
				if (M.isDirectionalLight) {
					let T = r.directional[p];
					T.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(f), p++
				} else if (M.isSpotLight) {
					let T = r.spot[b];
					T.position.setFromMatrixPosition(M.matrixWorld), T.position.applyMatrix4(f), T.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(f), b++
				} else if (M.isRectAreaLight) {
					let T = r.rectArea[y];
					T.position.setFromMatrixPosition(M.matrixWorld), T.position.applyMatrix4(f), o.identity(), a.copy(M.matrixWorld), a.premultiply(f), o.extractRotation(a), T.halfWidth.set(M.width * .5, 0, 0), T.halfHeight.set(0, M.height * .5, 0), T.halfWidth.applyMatrix4(o), T.halfHeight.applyMatrix4(o), y++
				} else if (M.isPointLight) {
					let T = r.point[_];
					T.position.setFromMatrixPosition(M.matrixWorld), T.position.applyMatrix4(f), _++
				} else if (M.isHemisphereLight) {
					let T = r.hemi[w];
					T.direction.setFromMatrixPosition(M.matrixWorld), T.direction.transformDirection(f), w++
				}
			}
		}
		return {
			setup: h,
			setupView: c,
			state: r
		}
	}

	function Gy(i, t) {
		let e = new YD(i, t),
			n = [],
			r = [];

		function s() {
			n.length = 0, r.length = 0
		}

		function a(g) {
			n.push(g)
		}

		function o(g) {
			r.push(g)
		}

		function h(g) {
			e.setup(n, g)
		}

		function c(g) {
			e.setupView(n, g)
		}
		return {
			init: s,
			state: {
				lightsArray: n,
				shadowsArray: r,
				lights: e
			},
			setupLights: h,
			setupLightsView: c,
			pushLight: a,
			pushShadow: o
		}
	}

	function KD(i, t) {
		let e = new WeakMap;

		function n(s, a = 0) {
			let o = e.get(s),
				h;
			return o === void 0 ? (h = new Gy(i, t), e.set(s, [h])) : a >= o.length ? (h = new Gy(i, t), o.push(h)) : h = o[a], h
		}

		function r() {
			e = new WeakMap
		}
		return {
			get: n,
			dispose: r
		}
	}
	var um = class extends wa {
			constructor(t) {
				super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = dC, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
			}
			copy(t) {
				return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
			}
		},
		dm = class extends wa {
			constructor(t) {
				super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
			}
			copy(t) {
				return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
			}
		},
		ZD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
		JD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

	function QD(i, t, e) {
		let n = new Du,
			r = new Oe,
			s = new Oe,
			a = new ai,
			o = new um({
				depthPacking: pC
			}),
			h = new dm,
			c = {},
			u = e.maxTextureSize,
			g = {
				[Es]: Zi,
				[Zi]: Es,
				[Or]: Or
			},
			p = new Bn({
				defines: {
					VSM_SAMPLES: 8
				},
				uniforms: {
					shadow_pass: {
						value: null
					},
					resolution: {
						value: new Oe
					},
					radius: {
						value: 4
					}
				},
				vertexShader: ZD,
				fragmentShader: JD
			}),
			_ = p.clone();
		_.defines.HORIZONTAL_PASS = 1;
		let b = new tn;
		b.setAttribute("position", new Ji(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
		let y = new or(b, p),
			w = this;
		this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Yy, this.render = function (M, T, I) {
			if (w.enabled === !1 || w.autoUpdate === !1 && w.needsUpdate === !1 || M.length === 0) return;
			let L = i.getRenderTarget(),
				F = i.getActiveCubeFace(),
				k = i.getActiveMipmapLevel(),
				G = i.state;
			G.setBlending(Ss), G.buffers.color.setClear(1, 1, 1, 1), G.buffers.depth.setTest(!0), G.setScissorTest(!1);
			for (let j = 0, U = M.length; j < U; j++) {
				let z = M[j],
					$ = z.shadow;
				if ($ === void 0) {
					console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
					continue
				}
				if ($.autoUpdate === !1 && $.needsUpdate === !1) continue;
				r.copy($.mapSize);
				let W = $.getFrameExtents();
				if (r.multiply(W), s.copy($.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / W.x), r.x = s.x * W.x, $.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / W.y), r.y = s.y * W.y, $.mapSize.y = s.y)), $.map === null) {
					let B = this.type !== Zl ? {
						minFilter: Fi,
						magFilter: Fi
					} : {};
					$.map = new zr(r.x, r.y, B), $.map.texture.name = z.name + ".shadowMap", $.camera.updateProjectionMatrix()
				}
				i.setRenderTarget($.map), i.clear();
				let O = $.getViewportCount();
				for (let B = 0; B < O; B++) {
					let A = $.getViewport(B);
					a.set(s.x * A.x, s.y * A.y, s.x * A.z, s.y * A.w), G.viewport(a), $.updateMatrices(z, B), n = $.getFrustum(), x(T, I, $.camera, z, this.type)
				}
				$.isPointLightShadow !== !0 && this.type === Zl && f($, I), $.needsUpdate = !1
			}
			w.needsUpdate = !1, i.setRenderTarget(L, F, k)
		};

		function f(M, T) {
			let I = t.update(y);
			p.defines.VSM_SAMPLES !== M.blurSamples && (p.defines.VSM_SAMPLES = M.blurSamples, _.defines.VSM_SAMPLES = M.blurSamples, p.needsUpdate = !0, _.needsUpdate = !0), M.mapPass === null && (M.mapPass = new zr(r.x, r.y)), p.uniforms.shadow_pass.value = M.map.texture, p.uniforms.resolution.value = M.mapSize, p.uniforms.radius.value = M.radius, i.setRenderTarget(M.mapPass), i.clear(), i.renderBufferDirect(T, null, I, p, y, null), _.uniforms.shadow_pass.value = M.mapPass.texture, _.uniforms.resolution.value = M.mapSize, _.uniforms.radius.value = M.radius, i.setRenderTarget(M.map), i.clear(), i.renderBufferDirect(T, null, I, _, y, null)
		}

		function S(M, T, I, L) {
			let F = null,
				k = I.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
			if (k !== void 0) F = k;
			else if (F = I.isPointLight === !0 ? h : o, i.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
				let G = F.uuid,
					j = T.uuid,
					U = c[G];
				U === void 0 && (U = {}, c[G] = U);
				let z = U[j];
				z === void 0 && (z = F.clone(), U[j] = z), F = z
			}
			if (F.visible = T.visible, F.wireframe = T.wireframe, L === Zl ? F.side = T.shadowSide !== null ? T.shadowSide : T.side : F.side = T.shadowSide !== null ? T.shadowSide : g[T.side], F.alphaMap = T.alphaMap, F.alphaTest = T.alphaTest, F.map = T.map, F.clipShadows = T.clipShadows, F.clippingPlanes = T.clippingPlanes, F.clipIntersection = T.clipIntersection, F.displacementMap = T.displacementMap, F.displacementScale = T.displacementScale, F.displacementBias = T.displacementBias, F.wireframeLinewidth = T.wireframeLinewidth, F.linewidth = T.linewidth, I.isPointLight === !0 && F.isMeshDistanceMaterial === !0) {
				let G = i.properties.get(F);
				G.light = I
			}
			return F
		}

		function x(M, T, I, L, F) {
			if (M.visible === !1) return;
			if (M.layers.test(T.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && F === Zl) && (!M.frustumCulled || n.intersectsObject(M))) {
				M.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, M.matrixWorld);
				let j = t.update(M),
					U = M.material;
				if (Array.isArray(U)) {
					let z = j.groups;
					for (let $ = 0, W = z.length; $ < W; $++) {
						let O = z[$],
							B = U[O.materialIndex];
						if (B && B.visible) {
							let A = S(M, B, L, F);
							i.renderBufferDirect(I, null, j, A, M, O)
						}
					}
				} else if (U.visible) {
					let z = S(M, U, L, F);
					i.renderBufferDirect(I, null, j, z, M, null)
				}
			}
			let G = M.children;
			for (let j = 0, U = G.length; j < U; j++) x(G[j], T, I, L, F)
		}
	}

	function t2(i, t, e) {
		let n = e.isWebGL2;

		function r() {
			let rt = !1,
				gt = new ai,
				Mt = null,
				kt = new ai(0, 0, 0, 0);
			return {
				setMask: function (zt) {
					Mt !== zt && !rt && (i.colorMask(zt, zt, zt, zt), Mt = zt)
				},
				setLocked: function (zt) {
					rt = zt
				},
				setClear: function (zt, fe, Ae, xe, Vi) {
					Vi === !0 && (zt *= xe, fe *= xe, Ae *= xe), gt.set(zt, fe, Ae, xe), kt.equals(gt) === !1 && (i.clearColor(zt, fe, Ae, xe), kt.copy(gt))
				},
				reset: function () {
					rt = !1, Mt = null, kt.set(-1, 0, 0, 0)
				}
			}
		}

		function s() {
			let rt = !1,
				gt = null,
				Mt = null,
				kt = null;
			return {
				setTest: function (zt) {
					zt ? it(2929) : Et(2929)
				},
				setMask: function (zt) {
					gt !== zt && !rt && (i.depthMask(zt), gt = zt)
				},
				setFunc: function (zt) {
					if (Mt !== zt) {
						switch (zt) {
							case OM:
								i.depthFunc(512);
								break;
							case NM:
								i.depthFunc(519);
								break;
							case VM:
								i.depthFunc(513);
								break;
							case Xf:
								i.depthFunc(515);
								break;
							case zM:
								i.depthFunc(514);
								break;
							case BM:
								i.depthFunc(518);
								break;
							case UM:
								i.depthFunc(516);
								break;
							case GM:
								i.depthFunc(517);
								break;
							default:
								i.depthFunc(515)
						}
						Mt = zt
					}
				},
				setLocked: function (zt) {
					rt = zt
				},
				setClear: function (zt) {
					kt !== zt && (i.clearDepth(zt), kt = zt)
				},
				reset: function () {
					rt = !1, gt = null, Mt = null, kt = null
				}
			}
		}

		function a() {
			let rt = !1,
				gt = null,
				Mt = null,
				kt = null,
				zt = null,
				fe = null,
				Ae = null,
				xe = null,
				Vi = null;
			return {
				setTest: function (ge) {
					rt || (ge ? it(2960) : Et(2960))
				},
				setMask: function (ge) {
					gt !== ge && !rt && (i.stencilMask(ge), gt = ge)
				},
				setFunc: function (ge, vi, ci) {
					(Mt !== ge || kt !== vi || zt !== ci) && (i.stencilFunc(ge, vi, ci), Mt = ge, kt = vi, zt = ci)
				},
				setOp: function (ge, vi, ci) {
					(fe !== ge || Ae !== vi || xe !== ci) && (i.stencilOp(ge, vi, ci), fe = ge, Ae = vi, xe = ci)
				},
				setLocked: function (ge) {
					rt = ge
				},
				setClear: function (ge) {
					Vi !== ge && (i.clearStencil(ge), Vi = ge)
				},
				reset: function () {
					rt = !1, gt = null, Mt = null, kt = null, zt = null, fe = null, Ae = null, xe = null, Vi = null
				}
			}
		}
		let o = new r,
			h = new s,
			c = new a,
			u = new WeakMap,
			g = new WeakMap,
			p = {},
			_ = {},
			b = new WeakMap,
			y = [],
			w = null,
			f = !1,
			S = null,
			x = null,
			M = null,
			T = null,
			I = null,
			L = null,
			F = null,
			k = !1,
			G = null,
			j = null,
			U = null,
			z = null,
			$ = null,
			W = i.getParameter(35661),
			O = !1,
			B = 0,
			A = i.getParameter(7938);
		A.indexOf("WebGL") !== -1 ? (B = parseFloat(/^WebGL (\d)/.exec(A)[1]), O = B >= 1) : A.indexOf("OpenGL ES") !== -1 && (B = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), O = B >= 2);
		let D = null,
			H = {},
			q = i.getParameter(3088),
			Q = i.getParameter(2978),
			tt = new ai().fromArray(q),
			nt = new ai().fromArray(Q);

		function ut(rt, gt, Mt) {
			let kt = new Uint8Array(4),
				zt = i.createTexture();
			i.bindTexture(rt, zt), i.texParameteri(rt, 10241, 9728), i.texParameteri(rt, 10240, 9728);
			for (let fe = 0; fe < Mt; fe++) i.texImage2D(gt + fe, 0, 6408, 1, 1, 0, 6408, 5121, kt);
			return zt
		}
		let et = {};
		et[3553] = ut(3553, 3553, 1), et[34067] = ut(34067, 34069, 6), o.setClear(0, 0, 0, 1), h.setClear(1), c.setClear(0), it(2929), h.setFunc(Xf), Zt(!1), re(C_), it(2884), dt(Ss);

		function it(rt) {
			p[rt] !== !0 && (i.enable(rt), p[rt] = !0)
		}

		function Et(rt) {
			p[rt] !== !1 && (i.disable(rt), p[rt] = !1)
		}

		function wt(rt, gt) {
			return _[rt] !== gt ? (i.bindFramebuffer(rt, gt), _[rt] = gt, n && (rt === 36009 && (_[36160] = gt), rt === 36160 && (_[36009] = gt)), !0) : !1
		}

		function yt(rt, gt) {
			let Mt = y,
				kt = !1;
			if (rt)
				if (Mt = b.get(gt), Mt === void 0 && (Mt = [], b.set(gt, Mt)), rt.isWebGLMultipleRenderTargets) {
					let zt = rt.texture;
					if (Mt.length !== zt.length || Mt[0] !== 36064) {
						for (let fe = 0, Ae = zt.length; fe < Ae; fe++) Mt[fe] = 36064 + fe;
						Mt.length = zt.length, kt = !0
					}
				} else Mt[0] !== 36064 && (Mt[0] = 36064, kt = !0);
			else Mt[0] !== 1029 && (Mt[0] = 1029, kt = !0);
			kt && (e.isWebGL2 ? i.drawBuffers(Mt) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(Mt))
		}

		function At(rt) {
			return w !== rt ? (i.useProgram(rt), w = rt, !0) : !1
		}
		let Vt = {
			[Eo]: 32774,
			[MM]: 32778,
			[CM]: 32779
		};
		if (n) Vt[D_] = 32775, Vt[I_] = 32776;
		else {
			let rt = t.get("EXT_blend_minmax");
			rt !== null && (Vt[D_] = rt.MIN_EXT, Vt[I_] = rt.MAX_EXT)
		}
		let lt = {
			[TM]: 0,
			[PM]: 1,
			[AM]: 768,
			[Ky]: 770,
			[FM]: 776,
			[kM]: 774,
			[IM]: 772,
			[DM]: 769,
			[Zy]: 771,
			[RM]: 775,
			[LM]: 773
		};

		function dt(rt, gt, Mt, kt, zt, fe, Ae, xe) {
			if (rt === Ss) {
				f === !0 && (Et(3042), f = !1);
				return
			}
			if (f === !1 && (it(3042), f = !0), rt !== EM) {
				if (rt !== S || xe !== k) {
					if ((x !== Eo || I !== Eo) && (i.blendEquation(32774), x = Eo, I = Eo), xe) switch (rt) {
						case Co:
							i.blendFuncSeparate(1, 771, 1, 771);
							break;
						case T_:
							i.blendFunc(1, 1);
							break;
						case P_:
							i.blendFuncSeparate(0, 769, 0, 1);
							break;
						case A_:
							i.blendFuncSeparate(0, 768, 0, 770);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", rt);
							break
					} else switch (rt) {
						case Co:
							i.blendFuncSeparate(770, 771, 1, 771);
							break;
						case T_:
							i.blendFunc(770, 1);
							break;
						case P_:
							i.blendFuncSeparate(0, 769, 0, 1);
							break;
						case A_:
							i.blendFunc(0, 768);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", rt);
							break
					}
					M = null, T = null, L = null, F = null, S = rt, k = xe
				}
				return
			}
			zt = zt || gt, fe = fe || Mt, Ae = Ae || kt, (gt !== x || zt !== I) && (i.blendEquationSeparate(Vt[gt], Vt[zt]), x = gt, I = zt), (Mt !== M || kt !== T || fe !== L || Ae !== F) && (i.blendFuncSeparate(lt[Mt], lt[kt], lt[fe], lt[Ae]), M = Mt, T = kt, L = fe, F = Ae), S = rt, k = !1
		}

		function qt(rt, gt) {
			rt.side === Or ? Et(2884) : it(2884);
			let Mt = rt.side === Zi;
			gt && (Mt = !Mt), Zt(Mt), rt.blending === Co && rt.transparent === !1 ? dt(Ss) : dt(rt.blending, rt.blendEquation, rt.blendSrc, rt.blendDst, rt.blendEquationAlpha, rt.blendSrcAlpha, rt.blendDstAlpha, rt.premultipliedAlpha), h.setFunc(rt.depthFunc), h.setTest(rt.depthTest), h.setMask(rt.depthWrite), o.setMask(rt.colorWrite);
			let kt = rt.stencilWrite;
			c.setTest(kt), kt && (c.setMask(rt.stencilWriteMask), c.setFunc(rt.stencilFunc, rt.stencilRef, rt.stencilFuncMask), c.setOp(rt.stencilFail, rt.stencilZFail, rt.stencilZPass)), Xt(rt.polygonOffset, rt.polygonOffsetFactor, rt.polygonOffsetUnits), rt.alphaToCoverage === !0 ? it(32926) : Et(32926)
		}

		function Zt(rt) {
			G !== rt && (rt ? i.frontFace(2304) : i.frontFace(2305), G = rt)
		}

		function re(rt) {
			rt !== xM ? (it(2884), rt !== j && (rt === C_ ? i.cullFace(1029) : rt === wM ? i.cullFace(1028) : i.cullFace(1032))) : Et(2884), j = rt
		}

		function de(rt) {
			rt !== U && (O && i.lineWidth(rt), U = rt)
		}

		function Xt(rt, gt, Mt) {
			rt ? (it(32823), (z !== gt || $ !== Mt) && (i.polygonOffset(gt, Mt), z = gt, $ = Mt)) : Et(32823)
		}

		function le(rt) {
			rt ? it(3089) : Et(3089)
		}

		function ye(rt) {
			rt === void 0 && (rt = 33984 + W - 1), D !== rt && (i.activeTexture(rt), D = rt)
		}

		function Z(rt, gt, Mt) {
			Mt === void 0 && (D === null ? Mt = 33984 + W - 1 : Mt = D);
			let kt = H[Mt];
			kt === void 0 && (kt = {
				type: void 0,
				texture: void 0
			}, H[Mt] = kt), (kt.type !== rt || kt.texture !== gt) && (D !== Mt && (i.activeTexture(Mt), D = Mt), i.bindTexture(rt, gt || et[rt]), kt.type = rt, kt.texture = gt)
		}

		function X() {
			let rt = H[D];
			rt !== void 0 && rt.type !== void 0 && (i.bindTexture(rt.type, null), rt.type = void 0, rt.texture = void 0)
		}

		function pt() {
			try {
				i.compressedTexImage2D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function xt() {
			try {
				i.compressedTexImage3D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function St() {
			try {
				i.texSubImage2D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Pt() {
			try {
				i.texSubImage3D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Bt() {
			try {
				i.compressedTexSubImage2D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function It() {
			try {
				i.compressedTexSubImage3D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function mt() {
			try {
				i.texStorage2D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Ot() {
			try {
				i.texStorage3D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Gt() {
			try {
				i.texImage2D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Ut() {
			try {
				i.texImage3D.apply(i, arguments)
			} catch (rt) {
				console.error("THREE.WebGLState:", rt)
			}
		}

		function Lt(rt) {
			tt.equals(rt) === !1 && (i.scissor(rt.x, rt.y, rt.z, rt.w), tt.copy(rt))
		}

		function Nt(rt) {
			nt.equals(rt) === !1 && (i.viewport(rt.x, rt.y, rt.z, rt.w), nt.copy(rt))
		}

		function ce(rt, gt) {
			let Mt = g.get(gt);
			Mt === void 0 && (Mt = new WeakMap, g.set(gt, Mt));
			let kt = Mt.get(rt);
			kt === void 0 && (kt = i.getUniformBlockIndex(gt, rt.name), Mt.set(rt, kt))
		}

		function be(rt, gt) {
			let kt = g.get(gt).get(rt);
			u.get(gt) !== kt && (i.uniformBlockBinding(gt, kt, rt.__bindingPointIndex), u.set(gt, kt))
		}

		function Ie() {
			i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), n === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), p = {}, D = null, H = {}, _ = {}, b = new WeakMap, y = [], w = null, f = !1, S = null, x = null, M = null, T = null, I = null, L = null, F = null, k = !1, G = null, j = null, U = null, z = null, $ = null, tt.set(0, 0, i.canvas.width, i.canvas.height), nt.set(0, 0, i.canvas.width, i.canvas.height), o.reset(), h.reset(), c.reset()
		}
		return {
			buffers: {
				color: o,
				depth: h,
				stencil: c
			},
			enable: it,
			disable: Et,
			bindFramebuffer: wt,
			drawBuffers: yt,
			useProgram: At,
			setBlending: dt,
			setMaterial: qt,
			setFlipSided: Zt,
			setCullFace: re,
			setLineWidth: de,
			setPolygonOffset: Xt,
			setScissorTest: le,
			activeTexture: ye,
			bindTexture: Z,
			unbindTexture: X,
			compressedTexImage2D: pt,
			compressedTexImage3D: xt,
			texImage2D: Gt,
			texImage3D: Ut,
			updateUBOMapping: ce,
			uniformBlockBinding: be,
			texStorage2D: mt,
			texStorage3D: Ot,
			texSubImage2D: St,
			texSubImage3D: Pt,
			compressedTexSubImage2D: Bt,
			compressedTexSubImage3D: It,
			scissor: Lt,
			viewport: Nt,
			reset: Ie
		}
	}

	function e2(i, t, e, n, r, s, a) {
		let o = r.isWebGL2,
			h = r.maxTextures,
			c = r.maxCubemapSize,
			u = r.maxTextureSize,
			g = r.maxSamples,
			p = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
			_ = typeof navigator == "undefined" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
			b = new WeakMap,
			y, w = new WeakMap,
			f = !1;
		try {
			f = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null
		} catch (Z) {}

		function S(Z, X) {
			return f ? new OffscreenCanvas(Z, X) : yu("canvas")
		}

		function x(Z, X, pt, xt) {
			let St = 1;
			if ((Z.width > xt || Z.height > xt) && (St = xt / Math.max(Z.width, Z.height)), St < 1 || X === !0)
				if (typeof HTMLImageElement != "undefined" && Z instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && Z instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && Z instanceof ImageBitmap) {
					let Pt = X ? _C : Math.floor,
						Bt = Pt(St * Z.width),
						It = Pt(St * Z.height);
					y === void 0 && (y = S(Bt, It));
					let mt = pt ? S(Bt, It) : y;
					return mt.width = Bt, mt.height = It, mt.getContext("2d").drawImage(Z, 0, 0, Bt, It), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Z.width + "x" + Z.height + ") to (" + Bt + "x" + It + ")."), mt
				} else return "data" in Z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Z.width + "x" + Z.height + ")."), Z;
			return Z
		}

		function M(Z) {
			return oy(Z.width) && oy(Z.height)
		}

		function T(Z) {
			return o ? !1 : Z.wrapS !== Vn || Z.wrapT !== Vn || Z.minFilter !== Fi && Z.minFilter !== Mn
		}

		function I(Z, X) {
			return Z.generateMipmaps && X && Z.minFilter !== Fi && Z.minFilter !== Mn
		}

		function L(Z) {
			i.generateMipmap(Z)
		}

		function F(Z, X, pt, xt, St = !1) {
			if (o === !1) return X;
			if (Z !== null) {
				if (i[Z] !== void 0) return i[Z];
				console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Z + "'")
			}
			let Pt = X;
			return X === 6403 && (pt === 5126 && (Pt = 33326), pt === 5131 && (Pt = 33325), pt === 5121 && (Pt = 33321)), X === 33319 && (pt === 5126 && (Pt = 33328), pt === 5131 && (Pt = 33327), pt === 5121 && (Pt = 33323)), X === 6408 && (pt === 5126 && (Pt = 34836), pt === 5131 && (Pt = 34842), pt === 5121 && (Pt = xt === ze && St === !1 ? 35907 : 32856), pt === 32819 && (Pt = 32854), pt === 32820 && (Pt = 32855)), (Pt === 33325 || Pt === 33326 || Pt === 33327 || Pt === 33328 || Pt === 34842 || Pt === 34836) && t.get("EXT_color_buffer_float"), Pt
		}

		function k(Z, X, pt) {
			return I(Z, pt) === !0 || Z.isFramebufferTexture && Z.minFilter !== Fi && Z.minFilter !== Mn ? Math.log2(Math.max(X.width, X.height)) + 1 : Z.mipmaps !== void 0 && Z.mipmaps.length > 0 ? Z.mipmaps.length : Z.isCompressedTexture && Array.isArray(Z.image) ? X.mipmaps.length : 1
		}

		function G(Z) {
			return Z === Fi || Z === L_ || Z === gf ? 9728 : 9729
		}

		function j(Z) {
			let X = Z.target;
			X.removeEventListener("dispose", j), z(X), X.isVideoTexture && b.delete(X)
		}

		function U(Z) {
			let X = Z.target;
			X.removeEventListener("dispose", U), W(X)
		}

		function z(Z) {
			let X = n.get(Z);
			if (X.__webglInit === void 0) return;
			let pt = Z.source,
				xt = w.get(pt);
			if (xt) {
				let St = xt[X.__cacheKey];
				St.usedTimes--, St.usedTimes === 0 && $(Z), Object.keys(xt).length === 0 && w.delete(pt)
			}
			n.remove(Z)
		}

		function $(Z) {
			let X = n.get(Z);
			i.deleteTexture(X.__webglTexture);
			let pt = Z.source,
				xt = w.get(pt);
			delete xt[X.__cacheKey], a.memory.textures--
		}

		function W(Z) {
			let X = Z.texture,
				pt = n.get(Z),
				xt = n.get(X);
			if (xt.__webglTexture !== void 0 && (i.deleteTexture(xt.__webglTexture), a.memory.textures--), Z.depthTexture && Z.depthTexture.dispose(), Z.isWebGLCubeRenderTarget)
				for (let St = 0; St < 6; St++) i.deleteFramebuffer(pt.__webglFramebuffer[St]), pt.__webglDepthbuffer && i.deleteRenderbuffer(pt.__webglDepthbuffer[St]);
			else {
				if (i.deleteFramebuffer(pt.__webglFramebuffer), pt.__webglDepthbuffer && i.deleteRenderbuffer(pt.__webglDepthbuffer), pt.__webglMultisampledFramebuffer && i.deleteFramebuffer(pt.__webglMultisampledFramebuffer), pt.__webglColorRenderbuffer)
					for (let St = 0; St < pt.__webglColorRenderbuffer.length; St++) pt.__webglColorRenderbuffer[St] && i.deleteRenderbuffer(pt.__webglColorRenderbuffer[St]);
				pt.__webglDepthRenderbuffer && i.deleteRenderbuffer(pt.__webglDepthRenderbuffer)
			}
			if (Z.isWebGLMultipleRenderTargets)
				for (let St = 0, Pt = X.length; St < Pt; St++) {
					let Bt = n.get(X[St]);
					Bt.__webglTexture && (i.deleteTexture(Bt.__webglTexture), a.memory.textures--), n.remove(X[St])
				}
			n.remove(X), n.remove(Z)
		}
		let O = 0;

		function B() {
			O = 0
		}

		function A() {
			let Z = O;
			return Z >= h && console.warn("THREE.WebGLTextures: Trying to use " + Z + " texture units while this GPU supports only " + h), O += 1, Z
		}

		function D(Z) {
			let X = [];
			return X.push(Z.wrapS), X.push(Z.wrapT), X.push(Z.wrapR || 0), X.push(Z.magFilter), X.push(Z.minFilter), X.push(Z.anisotropy), X.push(Z.internalFormat), X.push(Z.format), X.push(Z.type), X.push(Z.generateMipmaps), X.push(Z.premultiplyAlpha), X.push(Z.flipY), X.push(Z.unpackAlignment), X.push(Z.encoding), X.join()
		}

		function H(Z, X) {
			let pt = n.get(Z);
			if (Z.isVideoTexture && le(Z), Z.isRenderTargetTexture === !1 && Z.version > 0 && pt.__version !== Z.version) {
				let xt = Z.image;
				if (xt === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
				else if (xt.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
				else {
					Et(pt, Z, X);
					return
				}
			}
			e.bindTexture(3553, pt.__webglTexture, 33984 + X)
		}

		function q(Z, X) {
			let pt = n.get(Z);
			if (Z.version > 0 && pt.__version !== Z.version) {
				Et(pt, Z, X);
				return
			}
			e.bindTexture(35866, pt.__webglTexture, 33984 + X)
		}

		function Q(Z, X) {
			let pt = n.get(Z);
			if (Z.version > 0 && pt.__version !== Z.version) {
				Et(pt, Z, X);
				return
			}
			e.bindTexture(32879, pt.__webglTexture, 33984 + X)
		}

		function tt(Z, X) {
			let pt = n.get(Z);
			if (Z.version > 0 && pt.__version !== Z.version) {
				wt(pt, Z, X);
				return
			}
			e.bindTexture(34067, pt.__webglTexture, 33984 + X)
		}
		let nt = {
				[Zf]: 10497,
				[Vn]: 33071,
				[Jf]: 33648
			},
			ut = {
				[Fi]: 9728,
				[L_]: 9984,
				[gf]: 9986,
				[Mn]: 9729,
				[KM]: 9985,
				[th]: 9987
			};

		function et(Z, X, pt) {
			if (pt ? (i.texParameteri(Z, 10242, nt[X.wrapS]), i.texParameteri(Z, 10243, nt[X.wrapT]), (Z === 32879 || Z === 35866) && i.texParameteri(Z, 32882, nt[X.wrapR]), i.texParameteri(Z, 10240, ut[X.magFilter]), i.texParameteri(Z, 10241, ut[X.minFilter])) : (i.texParameteri(Z, 10242, 33071), i.texParameteri(Z, 10243, 33071), (Z === 32879 || Z === 35866) && i.texParameteri(Z, 32882, 33071), (X.wrapS !== Vn || X.wrapT !== Vn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(Z, 10240, G(X.magFilter)), i.texParameteri(Z, 10241, G(X.minFilter)), X.minFilter !== Fi && X.minFilter !== Mn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), t.has("EXT_texture_filter_anisotropic") === !0) {
				let xt = t.get("EXT_texture_filter_anisotropic");
				if (X.magFilter === Fi || X.minFilter !== gf && X.minFilter !== th || X.type === ga && t.has("OES_texture_float_linear") === !1 || o === !1 && X.type === eh && t.has("OES_texture_half_float_linear") === !1) return;
				(X.anisotropy > 1 || n.get(X).__currentAnisotropy) && (i.texParameterf(Z, xt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(X.anisotropy, r.getMaxAnisotropy())), n.get(X).__currentAnisotropy = X.anisotropy)
			}
		}

		function it(Z, X) {
			let pt = !1;
			Z.__webglInit === void 0 && (Z.__webglInit = !0, X.addEventListener("dispose", j));
			let xt = X.source,
				St = w.get(xt);
			St === void 0 && (St = {}, w.set(xt, St));
			let Pt = D(X);
			if (Pt !== Z.__cacheKey) {
				St[Pt] === void 0 && (St[Pt] = {
					texture: i.createTexture(),
					usedTimes: 0
				}, a.memory.textures++, pt = !0), St[Pt].usedTimes++;
				let Bt = St[Z.__cacheKey];
				Bt !== void 0 && (St[Z.__cacheKey].usedTimes--, Bt.usedTimes === 0 && $(X)), Z.__cacheKey = Pt, Z.__webglTexture = St[Pt].texture
			}
			return pt
		}

		function Et(Z, X, pt) {
			let xt = 3553;
			(X.isDataArrayTexture || X.isCompressedArrayTexture) && (xt = 35866), X.isData3DTexture && (xt = 32879);
			let St = it(Z, X),
				Pt = X.source;
			e.bindTexture(xt, Z.__webglTexture, 33984 + pt);
			let Bt = n.get(Pt);
			if (Pt.version !== Bt.__version || St === !0) {
				e.activeTexture(33984 + pt), i.pixelStorei(37440, X.flipY), i.pixelStorei(37441, X.premultiplyAlpha), i.pixelStorei(3317, X.unpackAlignment), i.pixelStorei(37443, 0);
				let It = T(X) && M(X.image) === !1,
					mt = x(X.image, It, !1, u);
				mt = ye(X, mt);
				let Ot = M(mt) || o,
					Gt = s.convert(X.format, X.encoding),
					Ut = s.convert(X.type),
					Lt = F(X.internalFormat, Gt, Ut, X.encoding, X.isVideoTexture);
				et(xt, X, Ot);
				let Nt, ce = X.mipmaps,
					be = o && X.isVideoTexture !== !0,
					Ie = Bt.__version === void 0 || St === !0,
					rt = k(X, mt, Ot);
				if (X.isDepthTexture) Lt = 6402, o ? X.type === ga ? Lt = 36012 : X.type === va ? Lt = 33190 : X.type === To ? Lt = 35056 : Lt = 33189 : X.type === ga && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), X.format === _a && Lt === 6402 && X.type !== tb && X.type !== va && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), X.type = va, Ut = s.convert(X.type)), X.format === Lo && Lt === 6402 && (Lt = 34041, X.type !== To && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), X.type = To, Ut = s.convert(X.type))), Ie && (be ? e.texStorage2D(3553, 1, Lt, mt.width, mt.height) : e.texImage2D(3553, 0, Lt, mt.width, mt.height, 0, Gt, Ut, null));
				else if (X.isDataTexture)
					if (ce.length > 0 && Ot) {
						be && Ie && e.texStorage2D(3553, rt, Lt, ce[0].width, ce[0].height);
						for (let gt = 0, Mt = ce.length; gt < Mt; gt++) Nt = ce[gt], be ? e.texSubImage2D(3553, gt, 0, 0, Nt.width, Nt.height, Gt, Ut, Nt.data) : e.texImage2D(3553, gt, Lt, Nt.width, Nt.height, 0, Gt, Ut, Nt.data);
						X.generateMipmaps = !1
					} else be ? (Ie && e.texStorage2D(3553, rt, Lt, mt.width, mt.height), e.texSubImage2D(3553, 0, 0, 0, mt.width, mt.height, Gt, Ut, mt.data)) : e.texImage2D(3553, 0, Lt, mt.width, mt.height, 0, Gt, Ut, mt.data);
				else if (X.isCompressedTexture)
					if (X.isCompressedArrayTexture) {
						be && Ie && e.texStorage3D(35866, rt, Lt, ce[0].width, ce[0].height, mt.depth);
						for (let gt = 0, Mt = ce.length; gt < Mt; gt++) Nt = ce[gt], X.format !== zn ? Gt !== null ? be ? e.compressedTexSubImage3D(35866, gt, 0, 0, 0, Nt.width, Nt.height, mt.depth, Gt, Nt.data, 0, 0) : e.compressedTexImage3D(35866, gt, Lt, Nt.width, Nt.height, mt.depth, 0, Nt.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : be ? e.texSubImage3D(35866, gt, 0, 0, 0, Nt.width, Nt.height, mt.depth, Gt, Ut, Nt.data) : e.texImage3D(35866, gt, Lt, Nt.width, Nt.height, mt.depth, 0, Gt, Ut, Nt.data)
					} else {
						be && Ie && e.texStorage2D(3553, rt, Lt, ce[0].width, ce[0].height);
						for (let gt = 0, Mt = ce.length; gt < Mt; gt++) Nt = ce[gt], X.format !== zn ? Gt !== null ? be ? e.compressedTexSubImage2D(3553, gt, 0, 0, Nt.width, Nt.height, Gt, Nt.data) : e.compressedTexImage2D(3553, gt, Lt, Nt.width, Nt.height, 0, Nt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : be ? e.texSubImage2D(3553, gt, 0, 0, Nt.width, Nt.height, Gt, Ut, Nt.data) : e.texImage2D(3553, gt, Lt, Nt.width, Nt.height, 0, Gt, Ut, Nt.data)
					}
				else if (X.isDataArrayTexture) be ? (Ie && e.texStorage3D(35866, rt, Lt, mt.width, mt.height, mt.depth), e.texSubImage3D(35866, 0, 0, 0, 0, mt.width, mt.height, mt.depth, Gt, Ut, mt.data)) : e.texImage3D(35866, 0, Lt, mt.width, mt.height, mt.depth, 0, Gt, Ut, mt.data);
				else if (X.isData3DTexture) be ? (Ie && e.texStorage3D(32879, rt, Lt, mt.width, mt.height, mt.depth), e.texSubImage3D(32879, 0, 0, 0, 0, mt.width, mt.height, mt.depth, Gt, Ut, mt.data)) : e.texImage3D(32879, 0, Lt, mt.width, mt.height, mt.depth, 0, Gt, Ut, mt.data);
				else if (X.isFramebufferTexture) {
					if (Ie)
						if (be) e.texStorage2D(3553, rt, Lt, mt.width, mt.height);
						else {
							let gt = mt.width,
								Mt = mt.height;
							for (let kt = 0; kt < rt; kt++) e.texImage2D(3553, kt, Lt, gt, Mt, 0, Gt, Ut, null), gt >>= 1, Mt >>= 1
						}
				} else if (ce.length > 0 && Ot) {
					be && Ie && e.texStorage2D(3553, rt, Lt, ce[0].width, ce[0].height);
					for (let gt = 0, Mt = ce.length; gt < Mt; gt++) Nt = ce[gt], be ? e.texSubImage2D(3553, gt, 0, 0, Gt, Ut, Nt) : e.texImage2D(3553, gt, Lt, Gt, Ut, Nt);
					X.generateMipmaps = !1
				} else be ? (Ie && e.texStorage2D(3553, rt, Lt, mt.width, mt.height), e.texSubImage2D(3553, 0, 0, 0, Gt, Ut, mt)) : e.texImage2D(3553, 0, Lt, Gt, Ut, mt);
				I(X, Ot) && L(xt), Bt.__version = Pt.version, X.onUpdate && X.onUpdate(X)
			}
			Z.__version = X.version
		}

		function wt(Z, X, pt) {
			if (X.image.length !== 6) return;
			let xt = it(Z, X),
				St = X.source;
			e.bindTexture(34067, Z.__webglTexture, 33984 + pt);
			let Pt = n.get(St);
			if (St.version !== Pt.__version || xt === !0) {
				e.activeTexture(33984 + pt), i.pixelStorei(37440, X.flipY), i.pixelStorei(37441, X.premultiplyAlpha), i.pixelStorei(3317, X.unpackAlignment), i.pixelStorei(37443, 0);
				let Bt = X.isCompressedTexture || X.image[0].isCompressedTexture,
					It = X.image[0] && X.image[0].isDataTexture,
					mt = [];
				for (let gt = 0; gt < 6; gt++) !Bt && !It ? mt[gt] = x(X.image[gt], !1, !0, c) : mt[gt] = It ? X.image[gt].image : X.image[gt], mt[gt] = ye(X, mt[gt]);
				let Ot = mt[0],
					Gt = M(Ot) || o,
					Ut = s.convert(X.format, X.encoding),
					Lt = s.convert(X.type),
					Nt = F(X.internalFormat, Ut, Lt, X.encoding),
					ce = o && X.isVideoTexture !== !0,
					be = Pt.__version === void 0 || xt === !0,
					Ie = k(X, Ot, Gt);
				et(34067, X, Gt);
				let rt;
				if (Bt) {
					ce && be && e.texStorage2D(34067, Ie, Nt, Ot.width, Ot.height);
					for (let gt = 0; gt < 6; gt++) {
						rt = mt[gt].mipmaps;
						for (let Mt = 0; Mt < rt.length; Mt++) {
							let kt = rt[Mt];
							X.format !== zn ? Ut !== null ? ce ? e.compressedTexSubImage2D(34069 + gt, Mt, 0, 0, kt.width, kt.height, Ut, kt.data) : e.compressedTexImage2D(34069 + gt, Mt, Nt, kt.width, kt.height, 0, kt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ce ? e.texSubImage2D(34069 + gt, Mt, 0, 0, kt.width, kt.height, Ut, Lt, kt.data) : e.texImage2D(34069 + gt, Mt, Nt, kt.width, kt.height, 0, Ut, Lt, kt.data)
						}
					}
				} else {
					rt = X.mipmaps, ce && be && (rt.length > 0 && Ie++, e.texStorage2D(34067, Ie, Nt, mt[0].width, mt[0].height));
					for (let gt = 0; gt < 6; gt++)
						if (It) {
							ce ? e.texSubImage2D(34069 + gt, 0, 0, 0, mt[gt].width, mt[gt].height, Ut, Lt, mt[gt].data) : e.texImage2D(34069 + gt, 0, Nt, mt[gt].width, mt[gt].height, 0, Ut, Lt, mt[gt].data);
							for (let Mt = 0; Mt < rt.length; Mt++) {
								let zt = rt[Mt].image[gt].image;
								ce ? e.texSubImage2D(34069 + gt, Mt + 1, 0, 0, zt.width, zt.height, Ut, Lt, zt.data) : e.texImage2D(34069 + gt, Mt + 1, Nt, zt.width, zt.height, 0, Ut, Lt, zt.data)
							}
						} else {
							ce ? e.texSubImage2D(34069 + gt, 0, 0, 0, Ut, Lt, mt[gt]) : e.texImage2D(34069 + gt, 0, Nt, Ut, Lt, mt[gt]);
							for (let Mt = 0; Mt < rt.length; Mt++) {
								let kt = rt[Mt];
								ce ? e.texSubImage2D(34069 + gt, Mt + 1, 0, 0, Ut, Lt, kt.image[gt]) : e.texImage2D(34069 + gt, Mt + 1, Nt, Ut, Lt, kt.image[gt])
							}
						}
				}
				I(X, Gt) && L(34067), Pt.__version = St.version, X.onUpdate && X.onUpdate(X)
			}
			Z.__version = X.version
		}

		function yt(Z, X, pt, xt, St) {
			let Pt = s.convert(pt.format, pt.encoding),
				Bt = s.convert(pt.type),
				It = F(pt.internalFormat, Pt, Bt, pt.encoding);
			n.get(X).__hasExternalTextures || (St === 32879 || St === 35866 ? e.texImage3D(St, 0, It, X.width, X.height, X.depth, 0, Pt, Bt, null) : e.texImage2D(St, 0, It, X.width, X.height, 0, Pt, Bt, null)), e.bindFramebuffer(36160, Z), Xt(X) ? p.framebufferTexture2DMultisampleEXT(36160, xt, St, n.get(pt).__webglTexture, 0, de(X)) : (St === 3553 || St >= 34069 && St <= 34074) && i.framebufferTexture2D(36160, xt, St, n.get(pt).__webglTexture, 0), e.bindFramebuffer(36160, null)
		}

		function At(Z, X, pt) {
			if (i.bindRenderbuffer(36161, Z), X.depthBuffer && !X.stencilBuffer) {
				let xt = 33189;
				if (pt || Xt(X)) {
					let St = X.depthTexture;
					St && St.isDepthTexture && (St.type === ga ? xt = 36012 : St.type === va && (xt = 33190));
					let Pt = de(X);
					Xt(X) ? p.renderbufferStorageMultisampleEXT(36161, Pt, xt, X.width, X.height) : i.renderbufferStorageMultisample(36161, Pt, xt, X.width, X.height)
				} else i.renderbufferStorage(36161, xt, X.width, X.height);
				i.framebufferRenderbuffer(36160, 36096, 36161, Z)
			} else if (X.depthBuffer && X.stencilBuffer) {
				let xt = de(X);
				pt && Xt(X) === !1 ? i.renderbufferStorageMultisample(36161, xt, 35056, X.width, X.height) : Xt(X) ? p.renderbufferStorageMultisampleEXT(36161, xt, 35056, X.width, X.height) : i.renderbufferStorage(36161, 34041, X.width, X.height), i.framebufferRenderbuffer(36160, 33306, 36161, Z)
			} else {
				let xt = X.isWebGLMultipleRenderTargets === !0 ? X.texture : [X.texture];
				for (let St = 0; St < xt.length; St++) {
					let Pt = xt[St],
						Bt = s.convert(Pt.format, Pt.encoding),
						It = s.convert(Pt.type),
						mt = F(Pt.internalFormat, Bt, It, Pt.encoding),
						Ot = de(X);
					pt && Xt(X) === !1 ? i.renderbufferStorageMultisample(36161, Ot, mt, X.width, X.height) : Xt(X) ? p.renderbufferStorageMultisampleEXT(36161, Ot, mt, X.width, X.height) : i.renderbufferStorage(36161, mt, X.width, X.height)
				}
			}
			i.bindRenderbuffer(36161, null)
		}

		function Vt(Z, X) {
			if (X && X.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
			if (e.bindFramebuffer(36160, Z), !(X.depthTexture && X.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
			(!n.get(X.depthTexture).__webglTexture || X.depthTexture.image.width !== X.width || X.depthTexture.image.height !== X.height) && (X.depthTexture.image.width = X.width, X.depthTexture.image.height = X.height, X.depthTexture.needsUpdate = !0), H(X.depthTexture, 0);
			let xt = n.get(X.depthTexture).__webglTexture,
				St = de(X);
			if (X.depthTexture.format === _a) Xt(X) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, xt, 0, St) : i.framebufferTexture2D(36160, 36096, 3553, xt, 0);
			else if (X.depthTexture.format === Lo) Xt(X) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, xt, 0, St) : i.framebufferTexture2D(36160, 33306, 3553, xt, 0);
			else throw new Error("Unknown depthTexture format")
		}

		function lt(Z) {
			let X = n.get(Z),
				pt = Z.isWebGLCubeRenderTarget === !0;
			if (Z.depthTexture && !X.__autoAllocateDepthBuffer) {
				if (pt) throw new Error("target.depthTexture not supported in Cube render targets");
				Vt(X.__webglFramebuffer, Z)
			} else if (pt) {
				X.__webglDepthbuffer = [];
				for (let xt = 0; xt < 6; xt++) e.bindFramebuffer(36160, X.__webglFramebuffer[xt]), X.__webglDepthbuffer[xt] = i.createRenderbuffer(), At(X.__webglDepthbuffer[xt], Z, !1)
			} else e.bindFramebuffer(36160, X.__webglFramebuffer), X.__webglDepthbuffer = i.createRenderbuffer(), At(X.__webglDepthbuffer, Z, !1);
			e.bindFramebuffer(36160, null)
		}

		function dt(Z, X, pt) {
			let xt = n.get(Z);
			X !== void 0 && yt(xt.__webglFramebuffer, Z, Z.texture, 36064, 3553), pt !== void 0 && lt(Z)
		}

		function qt(Z) {
			let X = Z.texture,
				pt = n.get(Z),
				xt = n.get(X);
			Z.addEventListener("dispose", U), Z.isWebGLMultipleRenderTargets !== !0 && (xt.__webglTexture === void 0 && (xt.__webglTexture = i.createTexture()), xt.__version = X.version, a.memory.textures++);
			let St = Z.isWebGLCubeRenderTarget === !0,
				Pt = Z.isWebGLMultipleRenderTargets === !0,
				Bt = M(Z) || o;
			if (St) {
				pt.__webglFramebuffer = [];
				for (let It = 0; It < 6; It++) pt.__webglFramebuffer[It] = i.createFramebuffer()
			} else {
				if (pt.__webglFramebuffer = i.createFramebuffer(), Pt)
					if (r.drawBuffers) {
						let It = Z.texture;
						for (let mt = 0, Ot = It.length; mt < Ot; mt++) {
							let Gt = n.get(It[mt]);
							Gt.__webglTexture === void 0 && (Gt.__webglTexture = i.createTexture(), a.memory.textures++)
						}
					} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
				if (o && Z.samples > 0 && Xt(Z) === !1) {
					let It = Pt ? X : [X];
					pt.__webglMultisampledFramebuffer = i.createFramebuffer(), pt.__webglColorRenderbuffer = [], e.bindFramebuffer(36160, pt.__webglMultisampledFramebuffer);
					for (let mt = 0; mt < It.length; mt++) {
						let Ot = It[mt];
						pt.__webglColorRenderbuffer[mt] = i.createRenderbuffer(), i.bindRenderbuffer(36161, pt.__webglColorRenderbuffer[mt]);
						let Gt = s.convert(Ot.format, Ot.encoding),
							Ut = s.convert(Ot.type),
							Lt = F(Ot.internalFormat, Gt, Ut, Ot.encoding, Z.isXRRenderTarget === !0),
							Nt = de(Z);
						i.renderbufferStorageMultisample(36161, Nt, Lt, Z.width, Z.height), i.framebufferRenderbuffer(36160, 36064 + mt, 36161, pt.__webglColorRenderbuffer[mt])
					}
					i.bindRenderbuffer(36161, null), Z.depthBuffer && (pt.__webglDepthRenderbuffer = i.createRenderbuffer(), At(pt.__webglDepthRenderbuffer, Z, !0)), e.bindFramebuffer(36160, null)
				}
			}
			if (St) {
				e.bindTexture(34067, xt.__webglTexture), et(34067, X, Bt);
				for (let It = 0; It < 6; It++) yt(pt.__webglFramebuffer[It], Z, X, 36064, 34069 + It);
				I(X, Bt) && L(34067), e.unbindTexture()
			} else if (Pt) {
				let It = Z.texture;
				for (let mt = 0, Ot = It.length; mt < Ot; mt++) {
					let Gt = It[mt],
						Ut = n.get(Gt);
					e.bindTexture(3553, Ut.__webglTexture), et(3553, Gt, Bt), yt(pt.__webglFramebuffer, Z, Gt, 36064 + mt, 3553), I(Gt, Bt) && L(3553)
				}
				e.unbindTexture()
			} else {
				let It = 3553;
				(Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) && (o ? It = Z.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(It, xt.__webglTexture), et(It, X, Bt), yt(pt.__webglFramebuffer, Z, X, 36064, It), I(X, Bt) && L(It), e.unbindTexture()
			}
			Z.depthBuffer && lt(Z)
		}

		function Zt(Z) {
			let X = M(Z) || o,
				pt = Z.isWebGLMultipleRenderTargets === !0 ? Z.texture : [Z.texture];
			for (let xt = 0, St = pt.length; xt < St; xt++) {
				let Pt = pt[xt];
				if (I(Pt, X)) {
					let Bt = Z.isWebGLCubeRenderTarget ? 34067 : 3553,
						It = n.get(Pt).__webglTexture;
					e.bindTexture(Bt, It), L(Bt), e.unbindTexture()
				}
			}
		}

		function re(Z) {
			if (o && Z.samples > 0 && Xt(Z) === !1) {
				let X = Z.isWebGLMultipleRenderTargets ? Z.texture : [Z.texture],
					pt = Z.width,
					xt = Z.height,
					St = 16384,
					Pt = [],
					Bt = Z.stencilBuffer ? 33306 : 36096,
					It = n.get(Z),
					mt = Z.isWebGLMultipleRenderTargets === !0;
				if (mt)
					for (let Ot = 0; Ot < X.length; Ot++) e.bindFramebuffer(36160, It.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Ot, 36161, null), e.bindFramebuffer(36160, It.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Ot, 3553, null, 0);
				e.bindFramebuffer(36008, It.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, It.__webglFramebuffer);
				for (let Ot = 0; Ot < X.length; Ot++) {
					Pt.push(36064 + Ot), Z.depthBuffer && Pt.push(Bt);
					let Gt = It.__ignoreDepthValues !== void 0 ? It.__ignoreDepthValues : !1;
					if (Gt === !1 && (Z.depthBuffer && (St |= 256), Z.stencilBuffer && (St |= 1024)), mt && i.framebufferRenderbuffer(36008, 36064, 36161, It.__webglColorRenderbuffer[Ot]), Gt === !0 && (i.invalidateFramebuffer(36008, [Bt]), i.invalidateFramebuffer(36009, [Bt])), mt) {
						let Ut = n.get(X[Ot]).__webglTexture;
						i.framebufferTexture2D(36009, 36064, 3553, Ut, 0)
					}
					i.blitFramebuffer(0, 0, pt, xt, 0, 0, pt, xt, St, 9728), _ && i.invalidateFramebuffer(36008, Pt)
				}
				if (e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, null), mt)
					for (let Ot = 0; Ot < X.length; Ot++) {
						e.bindFramebuffer(36160, It.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Ot, 36161, It.__webglColorRenderbuffer[Ot]);
						let Gt = n.get(X[Ot]).__webglTexture;
						e.bindFramebuffer(36160, It.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Ot, 3553, Gt, 0)
					}
				e.bindFramebuffer(36009, It.__webglMultisampledFramebuffer)
			}
		}

		function de(Z) {
			return Math.min(g, Z.samples)
		}

		function Xt(Z) {
			let X = n.get(Z);
			return o && Z.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && X.__useRenderToTexture !== !1
		}

		function le(Z) {
			let X = a.render.frame;
			b.get(Z) !== X && (b.set(Z, X), Z.update())
		}

		function ye(Z, X) {
			let pt = Z.encoding,
				xt = Z.format,
				St = Z.type;
			return Z.isCompressedTexture === !0 || Z.isVideoTexture === !0 || Z.format === Qf || pt !== ba && (pt === ze ? o === !1 ? t.has("EXT_sRGB") === !0 && xt === zn ? (Z.format = Qf, Z.minFilter = Mn, Z.generateMipmaps = !1) : X = bu.sRGBToLinear(X) : (xt !== zn || St !== ya) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", pt)), X
		}
		this.allocateTextureUnit = A, this.resetTextureUnits = B, this.setTexture2D = H, this.setTexture2DArray = q, this.setTexture3D = Q, this.setTextureCube = tt, this.rebindTextures = dt, this.setupRenderTarget = qt, this.updateRenderTargetMipmap = Zt, this.updateMultisampleRenderTarget = re, this.setupDepthRenderbuffer = lt, this.setupFrameBufferTexture = yt, this.useMultisampledRTT = Xt
	}

	function i2(i, t, e) {
		let n = e.isWebGL2;

		function r(s, a = null) {
			let o;
			if (s === ya) return 5121;
			if (s === tC) return 32819;
			if (s === eC) return 32820;
			if (s === ZM) return 5120;
			if (s === JM) return 5122;
			if (s === tb) return 5123;
			if (s === QM) return 5124;
			if (s === va) return 5125;
			if (s === ga) return 5126;
			if (s === eh) return n ? 5131 : (o = t.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
			if (s === iC) return 6406;
			if (s === zn) return 6408;
			if (s === nC) return 6409;
			if (s === rC) return 6410;
			if (s === _a) return 6402;
			if (s === Lo) return 34041;
			if (s === Qf) return o = t.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
			if (s === sC) return 6403;
			if (s === aC) return 36244;
			if (s === oC) return 33319;
			if (s === lC) return 33320;
			if (s === hC) return 36249;
			if (s === _f || s === yf || s === bf || s === xf)
				if (a === ze)
					if (o = t.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
						if (s === _f) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if (s === yf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if (s === bf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if (s === xf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
					} else return null;
			else if (o = t.get("WEBGL_compressed_texture_s3tc"), o !== null) {
				if (s === _f) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (s === yf) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (s === bf) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (s === xf) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
			} else return null;
			if (s === k_ || s === R_ || s === F_ || s === O_)
				if (o = t.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
					if (s === k_) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (s === R_) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (s === F_) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (s === O_) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				} else return null;
			if (s === cC) return o = t.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
			if (s === N_ || s === V_)
				if (o = t.get("WEBGL_compressed_texture_etc"), o !== null) {
					if (s === N_) return a === ze ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
					if (s === V_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC
				} else return null;
			if (s === z_ || s === B_ || s === U_ || s === G_ || s === H_ || s === W_ || s === $_ || s === q_ || s === j_ || s === X_ || s === Y_ || s === K_ || s === Z_ || s === J_)
				if (o = t.get("WEBGL_compressed_texture_astc"), o !== null) {
					if (s === z_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if (s === B_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if (s === U_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if (s === G_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if (s === H_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if (s === W_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if (s === $_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if (s === q_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if (s === j_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if (s === X_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if (s === Y_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if (s === K_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if (s === Z_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if (s === J_) return a === ze ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
				} else return null;
			if (s === wf)
				if (o = t.get("EXT_texture_compression_bptc"), o !== null) {
					if (s === wf) return a === ze ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT
				} else return null;
			if (s === uC || s === Q_ || s === ty || s === ey)
				if (o = t.get("EXT_texture_compression_rgtc"), o !== null) {
					if (s === wf) return o.COMPRESSED_RED_RGTC1_EXT;
					if (s === Q_) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if (s === ty) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if (s === ey) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
				} else return null;
			return s === To ? n ? 34042 : (o = t.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : i[s] !== void 0 ? i[s] : null
		}
		return {
			convert: r
		}
	}
	var pm = class extends Oi {
			constructor(t = []) {
				super(), this.isArrayCamera = !0, this.cameras = t
			}
		},
		Nr = class extends fi {
			constructor() {
				super(), this.isGroup = !0, this.type = "Group"
			}
		},
		n2 = {
			type: "move"
		},
		Ql = class {
			constructor() {
				this._targetRay = null, this._grip = null, this._hand = null
			}
			getHandSpace() {
				return this._hand === null && (this._hand = new Nr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
					pinching: !1
				}), this._hand
			}
			getTargetRaySpace() {
				return this._targetRay === null && (this._targetRay = new Nr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ht, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ht), this._targetRay
			}
			getGripSpace() {
				return this._grip === null && (this._grip = new Nr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ht, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ht), this._grip
			}
			dispatchEvent(t) {
				return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this
			}
			connect(t) {
				if (t && t.hand) {
					let e = this._hand;
					if (e)
						for (let n of t.hand.values()) this._getHandJoint(e, n)
				}
				return this.dispatchEvent({
					type: "connected",
					data: t
				}), this
			}
			disconnect(t) {
				return this.dispatchEvent({
					type: "disconnected",
					data: t
				}), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
			}
			update(t, e, n) {
				let r = null,
					s = null,
					a = null,
					o = this._targetRay,
					h = this._grip,
					c = this._hand;
				if (t && e.session.visibilityState !== "visible-blurred") {
					if (c && t.hand) {
						a = !0;
						for (let y of t.hand.values()) {
							let w = e.getJointPose(y, n),
								f = this._getHandJoint(c, y);
							w !== null && (f.matrix.fromArray(w.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), f.jointRadius = w.radius), f.visible = w !== null
						}
						let u = c.joints["index-finger-tip"],
							g = c.joints["thumb-tip"],
							p = u.position.distanceTo(g.position),
							_ = .02,
							b = .005;
						c.inputState.pinching && p > _ + b ? (c.inputState.pinching = !1, this.dispatchEvent({
							type: "pinchend",
							handedness: t.handedness,
							target: this
						})) : !c.inputState.pinching && p <= _ - b && (c.inputState.pinching = !0, this.dispatchEvent({
							type: "pinchstart",
							handedness: t.handedness,
							target: this
						}))
					} else h !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (h.matrix.fromArray(s.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), s.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(s.linearVelocity)) : h.hasLinearVelocity = !1, s.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(s.angularVelocity)) : h.hasAngularVelocity = !1));
					o !== null && (r = e.getPose(t.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(n2)))
				}
				return o !== null && (o.visible = r !== null), h !== null && (h.visible = s !== null), c !== null && (c.visible = a !== null), this
			}
			_getHandJoint(t, e) {
				if (t.joints[e.jointName] === void 0) {
					let n = new Nr;
					n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
				}
				return t.joints[e.jointName]
			}
		},
		fm = class extends Ni {
			constructor(t, e, n, r, s, a, o, h, c, u) {
				if (u = u !== void 0 ? u : _a, u !== _a && u !== Lo) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
				n === void 0 && u === _a && (n = va), n === void 0 && u === Lo && (n = To), super(null, r, s, a, o, h, u, n, c), this.isDepthTexture = !0, this.image = {
					width: t,
					height: e
				}, this.magFilter = o !== void 0 ? o : Fi, this.minFilter = h !== void 0 ? h : Fi, this.flipY = !1, this.generateMipmaps = !1
			}
		},
		mm = class extends Ms {
			constructor(t, e) {
				super();
				let n = this,
					r = null,
					s = 1,
					a = null,
					o = "local-floor",
					h = 1,
					c = null,
					u = null,
					g = null,
					p = null,
					_ = null,
					b = null,
					y = e.getContextAttributes(),
					w = null,
					f = null,
					S = [],
					x = [],
					M = new Set,
					T = new Map,
					I = new Oi;
				I.layers.enable(1), I.viewport = new ai;
				let L = new Oi;
				L.layers.enable(2), L.viewport = new ai;
				let F = [I, L],
					k = new pm;
				k.layers.enable(1), k.layers.enable(2);
				let G = null,
					j = null;
				this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (tt) {
					let nt = S[tt];
					return nt === void 0 && (nt = new Ql, S[tt] = nt), nt.getTargetRaySpace()
				}, this.getControllerGrip = function (tt) {
					let nt = S[tt];
					return nt === void 0 && (nt = new Ql, S[tt] = nt), nt.getGripSpace()
				}, this.getHand = function (tt) {
					let nt = S[tt];
					return nt === void 0 && (nt = new Ql, S[tt] = nt), nt.getHandSpace()
				};

				function U(tt) {
					let nt = x.indexOf(tt.inputSource);
					if (nt === -1) return;
					let ut = S[nt];
					ut !== void 0 && ut.dispatchEvent({
						type: tt.type,
						data: tt.inputSource
					})
				}

				function z() {
					r.removeEventListener("select", U), r.removeEventListener("selectstart", U), r.removeEventListener("selectend", U), r.removeEventListener("squeeze", U), r.removeEventListener("squeezestart", U), r.removeEventListener("squeezeend", U), r.removeEventListener("end", z), r.removeEventListener("inputsourceschange", $);
					for (let tt = 0; tt < S.length; tt++) {
						let nt = x[tt];
						nt !== null && (x[tt] = null, S[tt].disconnect(nt))
					}
					G = null, j = null, t.setRenderTarget(w), _ = null, p = null, g = null, r = null, f = null, Q.stop(), n.isPresenting = !1, n.dispatchEvent({
						type: "sessionend"
					})
				}
				this.setFramebufferScaleFactor = function (tt) {
					s = tt, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
				}, this.setReferenceSpaceType = function (tt) {
					o = tt, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
				}, this.getReferenceSpace = function () {
					return c || a
				}, this.setReferenceSpace = function (tt) {
					c = tt
				}, this.getBaseLayer = function () {
					return p !== null ? p : _
				}, this.getBinding = function () {
					return g
				}, this.getFrame = function () {
					return b
				}, this.getSession = function () {
					return r
				}, this.setSession = function (tt) {
					return Di(this, null, function* () {
						if (r = tt, r !== null) {
							if (w = t.getRenderTarget(), r.addEventListener("select", U), r.addEventListener("selectstart", U), r.addEventListener("selectend", U), r.addEventListener("squeeze", U), r.addEventListener("squeezestart", U), r.addEventListener("squeezeend", U), r.addEventListener("end", z), r.addEventListener("inputsourceschange", $), y.xrCompatible !== !0 && (yield e.makeXRCompatible()), r.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1) {
								let nt = {
									antialias: r.renderState.layers === void 0 ? y.antialias : !0,
									alpha: y.alpha,
									depth: y.depth,
									stencil: y.stencil,
									framebufferScaleFactor: s
								};
								_ = new XRWebGLLayer(r, e, nt), r.updateRenderState({
									baseLayer: _
								}), f = new zr(_.framebufferWidth, _.framebufferHeight, {
									format: zn,
									type: ya,
									encoding: t.outputEncoding,
									stencilBuffer: y.stencil
								})
							} else {
								let nt = null,
									ut = null,
									et = null;
								y.depth && (et = y.stencil ? 35056 : 33190, nt = y.stencil ? Lo : _a, ut = y.stencil ? To : va);
								let it = {
									colorFormat: 32856,
									depthFormat: et,
									scaleFactor: s
								};
								g = new XRWebGLBinding(r, e), p = g.createProjectionLayer(it), r.updateRenderState({
									layers: [p]
								}), f = new zr(p.textureWidth, p.textureHeight, {
									format: zn,
									type: ya,
									depthTexture: new fm(p.textureWidth, p.textureHeight, ut, void 0, void 0, void 0, void 0, void 0, void 0, nt),
									stencilBuffer: y.stencil,
									encoding: t.outputEncoding,
									samples: y.antialias ? 4 : 0
								});
								let Et = t.properties.get(f);
								Et.__ignoreDepthValues = p.ignoreDepthValues
							}
							f.isXRRenderTarget = !0, this.setFoveation(h), c = null, a = yield r.requestReferenceSpace(o), Q.setContext(r), Q.start(), n.isPresenting = !0, n.dispatchEvent({
								type: "sessionstart"
							})
						}
					})
				};

				function $(tt) {
					for (let nt = 0; nt < tt.removed.length; nt++) {
						let ut = tt.removed[nt],
							et = x.indexOf(ut);
						et >= 0 && (x[et] = null, S[et].disconnect(ut))
					}
					for (let nt = 0; nt < tt.added.length; nt++) {
						let ut = tt.added[nt],
							et = x.indexOf(ut);
						if (et === -1) {
							for (let Et = 0; Et < S.length; Et++)
								if (Et >= x.length) {
									x.push(ut), et = Et;
									break
								} else if (x[Et] === null) {
								x[Et] = ut, et = Et;
								break
							}
							if (et === -1) break
						}
						let it = S[et];
						it && it.connect(ut)
					}
				}
				let W = new ht,
					O = new ht;

				function B(tt, nt, ut) {
					W.setFromMatrixPosition(nt.matrixWorld), O.setFromMatrixPosition(ut.matrixWorld);
					let et = W.distanceTo(O),
						it = nt.projectionMatrix.elements,
						Et = ut.projectionMatrix.elements,
						wt = it[14] / (it[10] - 1),
						yt = it[14] / (it[10] + 1),
						At = (it[9] + 1) / it[5],
						Vt = (it[9] - 1) / it[5],
						lt = (it[8] - 1) / it[0],
						dt = (Et[8] + 1) / Et[0],
						qt = wt * lt,
						Zt = wt * dt,
						re = et / (-lt + dt),
						de = re * -lt;
					nt.matrixWorld.decompose(tt.position, tt.quaternion, tt.scale), tt.translateX(de), tt.translateZ(re), tt.matrixWorld.compose(tt.position, tt.quaternion, tt.scale), tt.matrixWorldInverse.copy(tt.matrixWorld).invert();
					let Xt = wt + re,
						le = yt + re,
						ye = qt - de,
						Z = Zt + (et - de),
						X = At * yt / le * Xt,
						pt = Vt * yt / le * Xt;
					tt.projectionMatrix.makePerspective(ye, Z, X, pt, Xt, le), tt.projectionMatrixInverse.copy(tt.projectionMatrix).invert()
				}

				function A(tt, nt) {
					nt === null ? tt.matrixWorld.copy(tt.matrix) : tt.matrixWorld.multiplyMatrices(nt.matrixWorld, tt.matrix), tt.matrixWorldInverse.copy(tt.matrixWorld).invert()
				}
				this.updateCamera = function (tt) {
					if (r === null) return;
					k.near = L.near = I.near = tt.near, k.far = L.far = I.far = tt.far, (G !== k.near || j !== k.far) && (r.updateRenderState({
						depthNear: k.near,
						depthFar: k.far
					}), G = k.near, j = k.far);
					let nt = tt.parent,
						ut = k.cameras;
					A(k, nt);
					for (let et = 0; et < ut.length; et++) A(ut[et], nt);
					ut.length === 2 ? B(k, I, L) : k.projectionMatrix.copy(I.projectionMatrix), D(tt, k, nt)
				};

				function D(tt, nt, ut) {
					ut === null ? tt.matrix.copy(nt.matrixWorld) : (tt.matrix.copy(ut.matrixWorld), tt.matrix.invert(), tt.matrix.multiply(nt.matrixWorld)), tt.matrix.decompose(tt.position, tt.quaternion, tt.scale), tt.updateMatrixWorld(!0);
					let et = tt.children;
					for (let it = 0, Et = et.length; it < Et; it++) et[it].updateMatrixWorld(!0);
					tt.projectionMatrix.copy(nt.projectionMatrix), tt.projectionMatrixInverse.copy(nt.projectionMatrixInverse), tt.isPerspectiveCamera && (tt.fov = tm * 2 * Math.atan(1 / tt.projectionMatrix.elements[5]), tt.zoom = 1)
				}
				this.getCamera = function () {
					return k
				}, this.getFoveation = function () {
					if (!(p === null && _ === null)) return h
				}, this.setFoveation = function (tt) {
					h = tt, p !== null && (p.fixedFoveation = tt), _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = tt)
				}, this.getPlanes = function () {
					return M
				};
				let H = null;

				function q(tt, nt) {
					if (u = nt.getViewerPose(c || a), b = nt, u !== null) {
						let ut = u.views;
						_ !== null && (t.setRenderTargetFramebuffer(f, _.framebuffer), t.setRenderTarget(f));
						let et = !1;
						ut.length !== k.cameras.length && (k.cameras.length = 0, et = !0);
						for (let it = 0; it < ut.length; it++) {
							let Et = ut[it],
								wt = null;
							if (_ !== null) wt = _.getViewport(Et);
							else {
								let At = g.getViewSubImage(p, Et);
								wt = At.viewport, it === 0 && (t.setRenderTargetTextures(f, At.colorTexture, p.ignoreDepthValues ? void 0 : At.depthStencilTexture), t.setRenderTarget(f))
							}
							let yt = F[it];
							yt === void 0 && (yt = new Oi, yt.layers.enable(it), yt.viewport = new ai, F[it] = yt), yt.matrix.fromArray(Et.transform.matrix), yt.matrix.decompose(yt.position, yt.quaternion, yt.scale), yt.projectionMatrix.fromArray(Et.projectionMatrix), yt.projectionMatrixInverse.copy(yt.projectionMatrix).invert(), yt.viewport.set(wt.x, wt.y, wt.width, wt.height), it === 0 && (k.matrix.copy(yt.matrix), k.matrix.decompose(k.position, k.quaternion, k.scale)), et === !0 && k.cameras.push(yt)
						}
					}
					for (let ut = 0; ut < S.length; ut++) {
						let et = x[ut],
							it = S[ut];
						et !== null && it !== void 0 && it.update(et, nt, c || a)
					}
					if (H && H(tt, nt), nt.detectedPlanes) {
						n.dispatchEvent({
							type: "planesdetected",
							data: nt.detectedPlanes
						});
						let ut = null;
						for (let et of M) nt.detectedPlanes.has(et) || (ut === null && (ut = []), ut.push(et));
						if (ut !== null)
							for (let et of ut) M.delete(et), T.delete(et), n.dispatchEvent({
								type: "planeremoved",
								data: et
							});
						for (let et of nt.detectedPlanes)
							if (!M.has(et)) M.add(et), T.set(et, nt.lastChangedTime), n.dispatchEvent({
								type: "planeadded",
								data: et
							});
							else {
								let it = T.get(et);
								et.lastChangedTime > it && (T.set(et, et.lastChangedTime), n.dispatchEvent({
									type: "planechanged",
									data: et
								}))
							}
					}
					b = null
				}
				let Q = new sb;
				Q.setAnimationLoop(q), this.setAnimationLoop = function (tt) {
					H = tt
				}, this.dispose = function () {}
			}
		};

	function r2(i, t) {
		function e(w, f) {
			w.matrixAutoUpdate === !0 && w.updateMatrix(), f.value.copy(w.matrix)
		}

		function n(w, f) {
			f.color.getRGB(w.fogColor.value, rb(i)), f.isFog ? (w.fogNear.value = f.near, w.fogFar.value = f.far) : f.isFogExp2 && (w.fogDensity.value = f.density)
		}

		function r(w, f, S, x, M) {
			f.isMeshBasicMaterial || f.isMeshLambertMaterial ? s(w, f) : f.isMeshToonMaterial ? (s(w, f), g(w, f)) : f.isMeshPhongMaterial ? (s(w, f), u(w, f)) : f.isMeshStandardMaterial ? (s(w, f), p(w, f), f.isMeshPhysicalMaterial && _(w, f, M)) : f.isMeshMatcapMaterial ? (s(w, f), b(w, f)) : f.isMeshDepthMaterial ? s(w, f) : f.isMeshDistanceMaterial ? (s(w, f), y(w, f)) : f.isMeshNormalMaterial ? s(w, f) : f.isLineBasicMaterial ? (a(w, f), f.isLineDashedMaterial && o(w, f)) : f.isPointsMaterial ? h(w, f, S, x) : f.isSpriteMaterial ? c(w, f) : f.isShadowMaterial ? (w.color.value.copy(f.color), w.opacity.value = f.opacity) : f.isShaderMaterial && (f.uniformsNeedUpdate = !1)
		}

		function s(w, f) {
			w.opacity.value = f.opacity, f.color && w.diffuse.value.copy(f.color), f.emissive && w.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity), f.map && (w.map.value = f.map, e(f.map, w.mapTransform)), f.alphaMap && (w.alphaMap.value = f.alphaMap, e(f.alphaMap, w.alphaMapTransform)), f.bumpMap && (w.bumpMap.value = f.bumpMap, e(f.bumpMap, w.bumpMapTransform), w.bumpScale.value = f.bumpScale, f.side === Zi && (w.bumpScale.value *= -1)), f.normalMap && (w.normalMap.value = f.normalMap, e(f.normalMap, w.normalMapTransform), w.normalScale.value.copy(f.normalScale), f.side === Zi && w.normalScale.value.negate()), f.displacementMap && (w.displacementMap.value = f.displacementMap, e(f.displacementMap, w.displacementMapTransform), w.displacementScale.value = f.displacementScale, w.displacementBias.value = f.displacementBias), f.emissiveMap && (w.emissiveMap.value = f.emissiveMap, e(f.emissiveMap, w.emissiveMapTransform)), f.specularMap && (w.specularMap.value = f.specularMap, e(f.specularMap, w.specularMapTransform)), f.alphaTest > 0 && (w.alphaTest.value = f.alphaTest);
			let S = t.get(f).envMap;
			if (S && (w.envMap.value = S, w.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, w.reflectivity.value = f.reflectivity, w.ior.value = f.ior, w.refractionRatio.value = f.refractionRatio), f.lightMap) {
				w.lightMap.value = f.lightMap;
				let x = i.useLegacyLights === !0 ? Math.PI : 1;
				w.lightMapIntensity.value = f.lightMapIntensity * x, e(f.lightMap, w.lightMapTransform)
			}
			f.aoMap && (w.aoMap.value = f.aoMap, w.aoMapIntensity.value = f.aoMapIntensity, e(f.aoMap, w.aoMapTransform))
		}

		function a(w, f) {
			w.diffuse.value.copy(f.color), w.opacity.value = f.opacity, f.map && (w.map.value = f.map, e(f.map, w.mapTransform))
		}

		function o(w, f) {
			w.dashSize.value = f.dashSize, w.totalSize.value = f.dashSize + f.gapSize, w.scale.value = f.scale
		}

		function h(w, f, S, x) {
			w.diffuse.value.copy(f.color), w.opacity.value = f.opacity, w.size.value = f.size * S, w.scale.value = x * .5, f.map && (w.map.value = f.map, e(f.map, w.uvTransform)), f.alphaMap && (w.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (w.alphaTest.value = f.alphaTest)
		}

		function c(w, f) {
			w.diffuse.value.copy(f.color), w.opacity.value = f.opacity, w.rotation.value = f.rotation, f.map && (w.map.value = f.map, e(f.map, w.mapTransform)), f.alphaMap && (w.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (w.alphaTest.value = f.alphaTest)
		}

		function u(w, f) {
			w.specular.value.copy(f.specular), w.shininess.value = Math.max(f.shininess, 1e-4)
		}

		function g(w, f) {
			f.gradientMap && (w.gradientMap.value = f.gradientMap)
		}

		function p(w, f) {
			w.metalness.value = f.metalness, f.metalnessMap && (w.metalnessMap.value = f.metalnessMap, e(f.metalnessMap, w.metalnessMapTransform)), w.roughness.value = f.roughness, f.roughnessMap && (w.roughnessMap.value = f.roughnessMap, e(f.roughnessMap, w.roughnessMapTransform)), t.get(f).envMap && (w.envMapIntensity.value = f.envMapIntensity)
		}

		function _(w, f, S) {
			w.ior.value = f.ior, f.sheen > 0 && (w.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen), w.sheenRoughness.value = f.sheenRoughness, f.sheenColorMap && (w.sheenColorMap.value = f.sheenColorMap, e(f.sheenColorMap, w.sheenColorMapTransform)), f.sheenRoughnessMap && (w.sheenRoughnessMap.value = f.sheenRoughnessMap, e(f.sheenRoughnessMap, w.sheenRoughnessMapTransform))), f.clearcoat > 0 && (w.clearcoat.value = f.clearcoat, w.clearcoatRoughness.value = f.clearcoatRoughness, f.clearcoatMap && (w.clearcoatMap.value = f.clearcoatMap, e(f.clearcoatMap, w.clearcoatMapTransform)), f.clearcoatRoughnessMap && (w.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap, e(f.clearcoatRoughnessMap, w.clearcoatRoughnessMapTransform)), f.clearcoatNormalMap && (w.clearcoatNormalMap.value = f.clearcoatNormalMap, e(f.clearcoatNormalMap, w.clearcoatNormalMapTransform), w.clearcoatNormalScale.value.copy(f.clearcoatNormalScale), f.side === Zi && w.clearcoatNormalScale.value.negate())), f.iridescence > 0 && (w.iridescence.value = f.iridescence, w.iridescenceIOR.value = f.iridescenceIOR, w.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0], w.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1], f.iridescenceMap && (w.iridescenceMap.value = f.iridescenceMap, e(f.iridescenceMap, w.iridescenceMapTransform)), f.iridescenceThicknessMap && (w.iridescenceThicknessMap.value = f.iridescenceThicknessMap, e(f.iridescenceThicknessMap, w.iridescenceThicknessMapTransform))), f.transmission > 0 && (w.transmission.value = f.transmission, w.transmissionSamplerMap.value = S.texture, w.transmissionSamplerSize.value.set(S.width, S.height), f.transmissionMap && (w.transmissionMap.value = f.transmissionMap, e(f.transmissionMap, w.transmissionMapTransform)), w.thickness.value = f.thickness, f.thicknessMap && (w.thicknessMap.value = f.thicknessMap, e(f.thicknessMap, w.thicknessMapTransform)), w.attenuationDistance.value = f.attenuationDistance, w.attenuationColor.value.copy(f.attenuationColor)), w.specularIntensity.value = f.specularIntensity, w.specularColor.value.copy(f.specularColor), f.specularColorMap && (w.specularColorMap.value = f.specularColorMap, e(f.specularColorMap, w.specularColorMapTransform)), f.specularIntensityMap && (w.specularIntensityMap.value = f.specularIntensityMap, e(f.specularIntensityMap, w.specularIntensityMapTransform))
		}

		function b(w, f) {
			f.matcap && (w.matcap.value = f.matcap)
		}

		function y(w, f) {
			let S = t.get(f).light;
			w.referencePosition.value.setFromMatrixPosition(S.matrixWorld), w.nearDistance.value = S.shadow.camera.near, w.farDistance.value = S.shadow.camera.far
		}
		return {
			refreshFogUniforms: n,
			refreshMaterialUniforms: r
		}
	}

	function s2(i, t, e, n) {
		let r = {},
			s = {},
			a = [],
			o = e.isWebGL2 ? i.getParameter(35375) : 0;

		function h(S, x) {
			let M = x.program;
			n.uniformBlockBinding(S, M)
		}

		function c(S, x) {
			let M = r[S.id];
			M === void 0 && (b(S), M = u(S), r[S.id] = M, S.addEventListener("dispose", w));
			let T = x.program;
			n.updateUBOMapping(S, T);
			let I = t.render.frame;
			s[S.id] !== I && (p(S), s[S.id] = I)
		}

		function u(S) {
			let x = g();
			S.__bindingPointIndex = x;
			let M = i.createBuffer(),
				T = S.__size,
				I = S.usage;
			return i.bindBuffer(35345, M), i.bufferData(35345, T, I), i.bindBuffer(35345, null), i.bindBufferBase(35345, x, M), M
		}

		function g() {
			for (let S = 0; S < o; S++)
				if (a.indexOf(S) === -1) return a.push(S), S;
			return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
		}

		function p(S) {
			let x = r[S.id],
				M = S.uniforms,
				T = S.__cache;
			i.bindBuffer(35345, x);
			for (let I = 0, L = M.length; I < L; I++) {
				let F = M[I];
				if (_(F, I, T) === !0) {
					let k = F.__offset,
						G = Array.isArray(F.value) ? F.value : [F.value],
						j = 0;
					for (let U = 0; U < G.length; U++) {
						let z = G[U],
							$ = y(z);
						typeof z == "number" ? (F.__data[0] = z, i.bufferSubData(35345, k + j, F.__data)) : z.isMatrix3 ? (F.__data[0] = z.elements[0], F.__data[1] = z.elements[1], F.__data[2] = z.elements[2], F.__data[3] = z.elements[0], F.__data[4] = z.elements[3], F.__data[5] = z.elements[4], F.__data[6] = z.elements[5], F.__data[7] = z.elements[0], F.__data[8] = z.elements[6], F.__data[9] = z.elements[7], F.__data[10] = z.elements[8], F.__data[11] = z.elements[0]) : (z.toArray(F.__data, j), j += $.storage / Float32Array.BYTES_PER_ELEMENT)
					}
					i.bufferSubData(35345, k, F.__data)
				}
			}
			i.bindBuffer(35345, null)
		}

		function _(S, x, M) {
			let T = S.value;
			if (M[x] === void 0) {
				if (typeof T == "number") M[x] = T;
				else {
					let I = Array.isArray(T) ? T : [T],
						L = [];
					for (let F = 0; F < I.length; F++) L.push(I[F].clone());
					M[x] = L
				}
				return !0
			} else if (typeof T == "number") {
				if (M[x] !== T) return M[x] = T, !0
			} else {
				let I = Array.isArray(M[x]) ? M[x] : [M[x]],
					L = Array.isArray(T) ? T : [T];
				for (let F = 0; F < I.length; F++) {
					let k = I[F];
					if (k.equals(L[F]) === !1) return k.copy(L[F]), !0
				}
			}
			return !1
		}

		function b(S) {
			let x = S.uniforms,
				M = 0,
				T = 16,
				I = 0;
			for (let L = 0, F = x.length; L < F; L++) {
				let k = x[L],
					G = {
						boundary: 0,
						storage: 0
					},
					j = Array.isArray(k.value) ? k.value : [k.value];
				for (let U = 0, z = j.length; U < z; U++) {
					let $ = j[U],
						W = y($);
					G.boundary += W.boundary, G.storage += W.storage
				}
				if (k.__data = new Float32Array(G.storage / Float32Array.BYTES_PER_ELEMENT), k.__offset = M, L > 0) {
					I = M % T;
					let U = T - I;
					I !== 0 && U - G.boundary < 0 && (M += T - I, k.__offset = M)
				}
				M += G.storage
			}
			return I = M % T, I > 0 && (M += T - I), S.__size = M, S.__cache = {}, this
		}

		function y(S) {
			let x = {
				boundary: 0,
				storage: 0
			};
			return typeof S == "number" ? (x.boundary = 4, x.storage = 4) : S.isVector2 ? (x.boundary = 8, x.storage = 8) : S.isVector3 || S.isColor ? (x.boundary = 16, x.storage = 12) : S.isVector4 ? (x.boundary = 16, x.storage = 16) : S.isMatrix3 ? (x.boundary = 48, x.storage = 48) : S.isMatrix4 ? (x.boundary = 64, x.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), x
		}

		function w(S) {
			let x = S.target;
			x.removeEventListener("dispose", w);
			let M = a.indexOf(x.__bindingPointIndex);
			a.splice(M, 1), i.deleteBuffer(r[x.id]), delete r[x.id], delete s[x.id]
		}

		function f() {
			for (let S in r) i.deleteBuffer(r[S]);
			a = [], r = {}, s = {}
		}
		return {
			bind: h,
			update: c,
			dispose: f
		}
	}

	function a2() {
		let i = yu("canvas");
		return i.style.display = "block", i
	}
	var nh = class {
			constructor(t = {}) {
				let {
					canvas: e = a2(),
					context: n = null,
					depth: r = !0,
					stencil: s = !0,
					alpha: a = !1,
					antialias: o = !1,
					premultipliedAlpha: h = !0,
					preserveDrawingBuffer: c = !1,
					powerPreference: u = "default",
					failIfMajorPerformanceCaveat: g = !1
				} = t;
				this.isWebGLRenderer = !0;
				let p;
				n !== null ? p = n.getContextAttributes().alpha : p = a;
				let _ = null,
					b = null,
					y = [],
					w = [];
				this.domElement = e, this.debug = {
					checkShaderErrors: !0,
					onShaderError: null
				}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = ba, this.useLegacyLights = !0, this.toneMapping = Vr, this.toneMappingExposure = 1;
				let f = this,
					S = !1,
					x = 0,
					M = 0,
					T = null,
					I = -1,
					L = null,
					F = new ai,
					k = new ai,
					G = null,
					j = e.width,
					U = e.height,
					z = 1,
					$ = null,
					W = null,
					O = new ai(0, 0, j, U),
					B = new ai(0, 0, j, U),
					A = !1,
					D = new Du,
					H = !1,
					q = !1,
					Q = null,
					tt = new ii,
					nt = new ht,
					ut = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: !0
					};

				function et() {
					return T === null ? z : 1
				}
				let it = n;

				function Et(K, ct) {
					for (let vt = 0; vt < K.length; vt++) {
						let ot = K[vt],
							_t = e.getContext(ot, ct);
						if (_t !== null) return _t
					}
					return null
				}
				try {
					let K = {
						alpha: !0,
						depth: r,
						stencil: s,
						antialias: o,
						premultipliedAlpha: h,
						preserveDrawingBuffer: c,
						powerPreference: u,
						failIfMajorPerformanceCaveat: g
					};
					if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Mm}`), e.addEventListener("webglcontextlost", Nt, !1), e.addEventListener("webglcontextrestored", ce, !1), e.addEventListener("webglcontextcreationerror", be, !1), it === null) {
						let ct = ["webgl2", "webgl", "experimental-webgl"];
						if (f.isWebGL1Renderer === !0 && ct.shift(), it = Et(ct, K), it === null) throw Et(ct) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
					}
					it.getShaderPrecisionFormat === void 0 && (it.getShaderPrecisionFormat = function () {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					})
				} catch (K) {
					throw console.error("THREE.WebGLRenderer: " + K.message), K
				}
				let wt, yt, At, Vt, lt, dt, qt, Zt, re, de, Xt, le, ye, Z, X, pt, xt, St, Pt, Bt, It, mt, Ot, Gt;

				function Ut() {
					wt = new TA(it), yt = new xA(it, wt, t), wt.init(yt), mt = new i2(it, wt, yt), At = new t2(it, wt, yt), Vt = new DA, lt = new GD, dt = new e2(it, wt, At, lt, yt, mt, Vt), qt = new SA(f), Zt = new CA(f), re = new GC(it, yt), Ot = new yA(it, wt, re, yt), de = new PA(it, re, Vt, Ot), Xt = new RA(it, de, re, Vt), Pt = new kA(it, yt, dt), pt = new wA(lt), le = new UD(f, qt, Zt, wt, yt, Ot, pt), ye = new r2(f, lt), Z = new WD, X = new KD(wt, yt), St = new _A(f, qt, Zt, At, Xt, p, h), xt = new QD(f, Xt, yt), Gt = new s2(it, Vt, yt, At), Bt = new bA(it, wt, Vt, yt), It = new AA(it, wt, Vt, yt), Vt.programs = le.programs, f.capabilities = yt, f.extensions = wt, f.properties = lt, f.renderLists = Z, f.shadowMap = xt, f.state = At, f.info = Vt
				}
				Ut();
				let Lt = new mm(f, it);
				this.xr = Lt, this.getContext = function () {
					return it
				}, this.getContextAttributes = function () {
					return it.getContextAttributes()
				}, this.forceContextLoss = function () {
					let K = wt.get("WEBGL_lose_context");
					K && K.loseContext()
				}, this.forceContextRestore = function () {
					let K = wt.get("WEBGL_lose_context");
					K && K.restoreContext()
				}, this.getPixelRatio = function () {
					return z
				}, this.setPixelRatio = function (K) {
					K !== void 0 && (z = K, this.setSize(j, U, !1))
				}, this.getSize = function (K) {
					return K.set(j, U)
				}, this.setSize = function (K, ct, vt = !0) {
					if (Lt.isPresenting) {
						console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
						return
					}
					j = K, U = ct, e.width = Math.floor(K * z), e.height = Math.floor(ct * z), vt === !0 && (e.style.width = K + "px", e.style.height = ct + "px"), this.setViewport(0, 0, K, ct)
				}, this.getDrawingBufferSize = function (K) {
					return K.set(j * z, U * z).floor()
				}, this.setDrawingBufferSize = function (K, ct, vt) {
					j = K, U = ct, z = vt, e.width = Math.floor(K * vt), e.height = Math.floor(ct * vt), this.setViewport(0, 0, K, ct)
				}, this.getCurrentViewport = function (K) {
					return K.copy(F)
				}, this.getViewport = function (K) {
					return K.copy(O)
				}, this.setViewport = function (K, ct, vt, ot) {
					K.isVector4 ? O.set(K.x, K.y, K.z, K.w) : O.set(K, ct, vt, ot), At.viewport(F.copy(O).multiplyScalar(z).floor())
				}, this.getScissor = function (K) {
					return K.copy(B)
				}, this.setScissor = function (K, ct, vt, ot) {
					K.isVector4 ? B.set(K.x, K.y, K.z, K.w) : B.set(K, ct, vt, ot), At.scissor(k.copy(B).multiplyScalar(z).floor())
				}, this.getScissorTest = function () {
					return A
				}, this.setScissorTest = function (K) {
					At.setScissorTest(A = K)
				}, this.setOpaqueSort = function (K) {
					$ = K
				}, this.setTransparentSort = function (K) {
					W = K
				}, this.getClearColor = function (K) {
					return K.copy(St.getClearColor())
				}, this.setClearColor = function () {
					St.setClearColor.apply(St, arguments)
				}, this.getClearAlpha = function () {
					return St.getClearAlpha()
				}, this.setClearAlpha = function () {
					St.setClearAlpha.apply(St, arguments)
				}, this.clear = function (K = !0, ct = !0, vt = !0) {
					let ot = 0;
					K && (ot |= 16384), ct && (ot |= 256), vt && (ot |= 1024), it.clear(ot)
				}, this.clearColor = function () {
					this.clear(!0, !1, !1)
				}, this.clearDepth = function () {
					this.clear(!1, !0, !1)
				}, this.clearStencil = function () {
					this.clear(!1, !1, !0)
				}, this.dispose = function () {
					e.removeEventListener("webglcontextlost", Nt, !1), e.removeEventListener("webglcontextrestored", ce, !1), e.removeEventListener("webglcontextcreationerror", be, !1), Z.dispose(), X.dispose(), lt.dispose(), qt.dispose(), Zt.dispose(), Xt.dispose(), Ot.dispose(), Gt.dispose(), le.dispose(), Lt.dispose(), Lt.removeEventListener("sessionstart", zt), Lt.removeEventListener("sessionend", fe), Q && (Q.dispose(), Q = null), Ae.stop()
				};

				function Nt(K) {
					K.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0
				}

				function ce() {
					console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
					let K = Vt.autoReset,
						ct = xt.enabled,
						vt = xt.autoUpdate,
						ot = xt.needsUpdate,
						_t = xt.type;
					Ut(), Vt.autoReset = K, xt.enabled = ct, xt.autoUpdate = vt, xt.needsUpdate = ot, xt.type = _t
				}

				function be(K) {
					console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", K.statusMessage)
				}

				function Ie(K) {
					let ct = K.target;
					ct.removeEventListener("dispose", Ie), rt(ct)
				}

				function rt(K) {
					gt(K), lt.remove(K)
				}

				function gt(K) {
					let ct = lt.get(K).programs;
					ct !== void 0 && (ct.forEach(function (vt) {
						le.releaseProgram(vt)
					}), K.isShaderMaterial && le.releaseShaderCache(K))
				}
				this.renderBufferDirect = function (K, ct, vt, ot, _t, Ht) {
					ct === null && (ct = ut);
					let $t = _t.isMesh && _t.matrixWorld.determinant() < 0,
						Yt = Ls(K, ct, vt, ot, _t);
					At.setMaterial(ot, $t);
					let ee = vt.index,
						te = 1;
					ot.wireframe === !0 && (ee = de.getWireframeAttribute(vt), te = 2);
					let se = vt.drawRange,
						Jt = vt.attributes.position,
						we = se.start * te,
						Ke = (se.start + se.count) * te;
					Ht !== null && (we = Math.max(we, Ht.start * te), Ke = Math.min(Ke, (Ht.start + Ht.count) * te)), ee !== null ? (we = Math.max(we, 0), Ke = Math.min(Ke, ee.count)) : Jt != null && (we = Math.max(we, 0), Ke = Math.min(Ke, Jt.count));
					let Ci = Ke - we;
					if (Ci < 0 || Ci === 1 / 0) return;
					Ot.setup(_t, ot, Yt, vt, ee);
					let Ti, Be = Bt;
					if (ee !== null && (Ti = re.get(ee), Be = It, Be.setIndex(Ti)), _t.isMesh) ot.wireframe === !0 ? (At.setLineWidth(ot.wireframeLinewidth * et()), Be.setMode(1)) : Be.setMode(4);
					else if (_t.isLine) {
						let Wt = ot.linewidth;
						Wt === void 0 && (Wt = 1), At.setLineWidth(Wt * et()), _t.isLineSegments ? Be.setMode(1) : _t.isLineLoop ? Be.setMode(2) : Be.setMode(3)
					} else _t.isPoints ? Be.setMode(0) : _t.isSprite && Be.setMode(4);
					if (_t.isInstancedMesh) Be.renderInstances(we, Ci, _t.count);
					else if (vt.isInstancedBufferGeometry) {
						let Wt = vt._maxInstanceCount !== void 0 ? vt._maxInstanceCount : 1 / 0,
							Rs = Math.min(vt.instanceCount, Wt);
						Be.renderInstances(we, Ci, Rs)
					} else Be.render(we, Ci)
				}, this.compile = function (K, ct) {
					function vt(ot, _t, Ht) {
						ot.transparent === !0 && ot.side === Or && ot.forceSinglePass === !1 ? (ot.side = Zi, ot.needsUpdate = !0, pr(ot, _t, Ht), ot.side = Es, ot.needsUpdate = !0, pr(ot, _t, Ht), ot.side = Or) : pr(ot, _t, Ht)
					}
					b = X.get(K), b.init(), w.push(b), K.traverseVisible(function (ot) {
						ot.isLight && ot.layers.test(ct.layers) && (b.pushLight(ot), ot.castShadow && b.pushShadow(ot))
					}), b.setupLights(f.useLegacyLights), K.traverse(function (ot) {
						let _t = ot.material;
						if (_t)
							if (Array.isArray(_t))
								for (let Ht = 0; Ht < _t.length; Ht++) {
									let $t = _t[Ht];
									vt($t, K, ot)
								} else vt(_t, K, ot)
					}), w.pop(), b = null
				};
				let Mt = null;

				function kt(K) {
					Mt && Mt(K)
				}

				function zt() {
					Ae.stop()
				}

				function fe() {
					Ae.start()
				}
				let Ae = new sb;
				Ae.setAnimationLoop(kt), typeof self != "undefined" && Ae.setContext(self), this.setAnimationLoop = function (K) {
					Mt = K, Lt.setAnimationLoop(K), K === null ? Ae.stop() : Ae.start()
				}, Lt.addEventListener("sessionstart", zt), Lt.addEventListener("sessionend", fe), this.render = function (K, ct) {
					if (ct !== void 0 && ct.isCamera !== !0) {
						console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
						return
					}
					if (S === !0) return;
					K.matrixWorldAutoUpdate === !0 && K.updateMatrixWorld(), ct.parent === null && ct.matrixWorldAutoUpdate === !0 && ct.updateMatrixWorld(), Lt.enabled === !0 && Lt.isPresenting === !0 && (Lt.cameraAutoUpdate === !0 && Lt.updateCamera(ct), ct = Lt.getCamera()), K.isScene === !0 && K.onBeforeRender(f, K, ct, T), b = X.get(K, w.length), b.init(), w.push(b), tt.multiplyMatrices(ct.projectionMatrix, ct.matrixWorldInverse), D.setFromProjectionMatrix(tt), q = this.localClippingEnabled, H = pt.init(this.clippingPlanes, q), _ = Z.get(K, y.length), _.init(), y.push(_), xe(K, ct, 0, f.sortObjects), _.finish(), f.sortObjects === !0 && _.sort($, W), H === !0 && pt.beginShadows();
					let vt = b.state.shadowsArray;
					if (xt.render(vt, K, ct), H === !0 && pt.endShadows(), this.info.autoReset === !0 && this.info.reset(), St.render(_, K), b.setupLights(f.useLegacyLights), ct.isArrayCamera) {
						let ot = ct.cameras;
						for (let _t = 0, Ht = ot.length; _t < Ht; _t++) {
							let $t = ot[_t];
							Vi(_, K, $t, $t.viewport)
						}
					} else Vi(_, K, ct);
					T !== null && (dt.updateMultisampleRenderTarget(T), dt.updateRenderTargetMipmap(T)), K.isScene === !0 && K.onAfterRender(f, K, ct), Ot.resetDefaultState(), I = -1, L = null, w.pop(), w.length > 0 ? b = w[w.length - 1] : b = null, y.pop(), y.length > 0 ? _ = y[y.length - 1] : _ = null
				};

				function xe(K, ct, vt, ot) {
					if (K.visible === !1) return;
					if (K.layers.test(ct.layers)) {
						if (K.isGroup) vt = K.renderOrder;
						else if (K.isLOD) K.autoUpdate === !0 && K.update(ct);
						else if (K.isLight) b.pushLight(K), K.castShadow && b.pushShadow(K);
						else if (K.isSprite) {
							if (!K.frustumCulled || D.intersectsSprite(K)) {
								ot && nt.setFromMatrixPosition(K.matrixWorld).applyMatrix4(tt);
								let $t = Xt.update(K),
									Yt = K.material;
								Yt.visible && _.push(K, $t, Yt, vt, nt.z, null)
							}
						} else if ((K.isMesh || K.isLine || K.isPoints) && (K.isSkinnedMesh && K.skeleton.frame !== Vt.render.frame && (K.skeleton.update(), K.skeleton.frame = Vt.render.frame), !K.frustumCulled || D.intersectsObject(K))) {
							ot && nt.setFromMatrixPosition(K.matrixWorld).applyMatrix4(tt);
							let $t = Xt.update(K),
								Yt = K.material;
							if (Array.isArray(Yt)) {
								let ee = $t.groups;
								for (let te = 0, se = ee.length; te < se; te++) {
									let Jt = ee[te],
										we = Yt[Jt.materialIndex];
									we && we.visible && _.push(K, $t, we, vt, nt.z, Jt)
								}
							} else Yt.visible && _.push(K, $t, Yt, vt, nt.z, null)
						}
					}
					let Ht = K.children;
					for (let $t = 0, Yt = Ht.length; $t < Yt; $t++) xe(Ht[$t], ct, vt, ot)
				}

				function Vi(K, ct, vt, ot) {
					let _t = K.opaque,
						Ht = K.transmissive,
						$t = K.transparent;
					b.setupLightsView(vt), H === !0 && pt.setGlobalState(f.clippingPlanes, vt), Ht.length > 0 && ge(_t, Ht, ct, vt), ot && At.viewport(F.copy(ot)), _t.length > 0 && vi(_t, ct, vt), Ht.length > 0 && vi(Ht, ct, vt), $t.length > 0 && vi($t, ct, vt), At.buffers.depth.setTest(!0), At.buffers.depth.setMask(!0), At.buffers.color.setMask(!0), At.setPolygonOffset(!1)
				}

				function ge(K, ct, vt, ot) {
					if (Q === null) {
						let Yt = yt.isWebGL2;
						Q = new zr(1024, 1024, {
							generateMipmaps: !0,
							type: wt.has("EXT_color_buffer_half_float") ? eh : ya,
							minFilter: th,
							samples: Yt && o === !0 ? 4 : 0
						})
					}
					let _t = f.getRenderTarget();
					f.setRenderTarget(Q), f.clear();
					let Ht = f.toneMapping;
					f.toneMapping = Vr, vi(K, vt, ot), dt.updateMultisampleRenderTarget(Q), dt.updateRenderTargetMipmap(Q);
					let $t = !1;
					for (let Yt = 0, ee = ct.length; Yt < ee; Yt++) {
						let te = ct[Yt],
							se = te.object,
							Jt = te.geometry,
							we = te.material,
							Ke = te.group;
						if (we.side === Or && se.layers.test(ot.layers)) {
							let Ci = we.side;
							we.side = Zi, we.needsUpdate = !0, ci(se, vt, ot, Jt, we, Ke), we.side = Ci, we.needsUpdate = !0, $t = !0
						}
					}
					$t === !0 && (dt.updateMultisampleRenderTarget(Q), dt.updateRenderTargetMipmap(Q)), f.setRenderTarget(_t), f.toneMapping = Ht
				}

				function vi(K, ct, vt) {
					let ot = ct.isScene === !0 ? ct.overrideMaterial : null;
					for (let _t = 0, Ht = K.length; _t < Ht; _t++) {
						let $t = K[_t],
							Yt = $t.object,
							ee = $t.geometry,
							te = ot === null ? $t.material : ot,
							se = $t.group;
						Yt.layers.test(vt.layers) && ci(Yt, ct, vt, ee, te, se)
					}
				}

				function ci(K, ct, vt, ot, _t, Ht) {
					K.onBeforeRender(f, ct, vt, ot, _t, Ht), K.modelViewMatrix.multiplyMatrices(vt.matrixWorldInverse, K.matrixWorld), K.normalMatrix.getNormalMatrix(K.modelViewMatrix), _t.onBeforeRender(f, ct, vt, ot, K, Ht), _t.transparent === !0 && _t.side === Or && _t.forceSinglePass === !1 ? (_t.side = Zi, _t.needsUpdate = !0, f.renderBufferDirect(vt, ct, ot, _t, K, Ht), _t.side = Es, _t.needsUpdate = !0, f.renderBufferDirect(vt, ct, ot, _t, K, Ht), _t.side = Or) : f.renderBufferDirect(vt, ct, ot, _t, K, Ht), K.onAfterRender(f, ct, vt, ot, _t, Ht)
				}

				function pr(K, ct, vt) {
					ct.isScene !== !0 && (ct = ut);
					let ot = lt.get(K),
						_t = b.state.lights,
						Ht = b.state.shadowsArray,
						$t = _t.state.version,
						Yt = le.getParameters(K, _t.state, Ht, ct, vt),
						ee = le.getProgramCacheKey(Yt),
						te = ot.programs;
					ot.environment = K.isMeshStandardMaterial ? ct.environment : null, ot.fog = ct.fog, ot.envMap = (K.isMeshStandardMaterial ? Zt : qt).get(K.envMap || ot.environment), te === void 0 && (K.addEventListener("dispose", Ie), te = new Map, ot.programs = te);
					let se = te.get(ee);
					if (se !== void 0) {
						if (ot.currentProgram === se && ot.lightsStateVersion === $t) return fr(K, Yt), se
					} else Yt.uniforms = le.getUniforms(K), K.onBuild(vt, Yt, f), K.onBeforeCompile(Yt, f), se = le.acquireProgram(Yt, ee), te.set(ee, se), ot.uniforms = Yt.uniforms;
					let Jt = ot.uniforms;
					(!K.isShaderMaterial && !K.isRawShaderMaterial || K.clipping === !0) && (Jt.clippingPlanes = pt.uniform), fr(K, Yt), ot.needsLights = Ko(K), ot.lightsStateVersion = $t, ot.needsLights && (Jt.ambientLightColor.value = _t.state.ambient, Jt.lightProbe.value = _t.state.probe, Jt.directionalLights.value = _t.state.directional, Jt.directionalLightShadows.value = _t.state.directionalShadow, Jt.spotLights.value = _t.state.spot, Jt.spotLightShadows.value = _t.state.spotShadow, Jt.rectAreaLights.value = _t.state.rectArea, Jt.ltc_1.value = _t.state.rectAreaLTC1, Jt.ltc_2.value = _t.state.rectAreaLTC2, Jt.pointLights.value = _t.state.point, Jt.pointLightShadows.value = _t.state.pointShadow, Jt.hemisphereLights.value = _t.state.hemi, Jt.directionalShadowMap.value = _t.state.directionalShadowMap, Jt.directionalShadowMatrix.value = _t.state.directionalShadowMatrix, Jt.spotShadowMap.value = _t.state.spotShadowMap, Jt.spotLightMatrix.value = _t.state.spotLightMatrix, Jt.spotLightMap.value = _t.state.spotLightMap, Jt.pointShadowMap.value = _t.state.pointShadowMap, Jt.pointShadowMatrix.value = _t.state.pointShadowMatrix);
					let we = se.getUniforms(),
						Ke = Ao.seqWithValue(we.seq, Jt);
					return ot.currentProgram = se, ot.uniformsList = Ke, se
				}

				function fr(K, ct) {
					let vt = lt.get(K);
					vt.outputEncoding = ct.outputEncoding, vt.instancing = ct.instancing, vt.skinning = ct.skinning, vt.morphTargets = ct.morphTargets, vt.morphNormals = ct.morphNormals, vt.morphColors = ct.morphColors, vt.morphTargetsCount = ct.morphTargetsCount, vt.numClippingPlanes = ct.numClippingPlanes, vt.numIntersection = ct.numClipIntersection, vt.vertexAlphas = ct.vertexAlphas, vt.vertexTangents = ct.vertexTangents, vt.toneMapping = ct.toneMapping
				}

				function Ls(K, ct, vt, ot, _t) {
					ct.isScene !== !0 && (ct = ut), dt.resetTextureUnits();
					let Ht = ct.fog,
						$t = ot.isMeshStandardMaterial ? ct.environment : null,
						Yt = T === null ? f.outputEncoding : T.isXRRenderTarget === !0 ? T.texture.encoding : ba,
						ee = (ot.isMeshStandardMaterial ? Zt : qt).get(ot.envMap || $t),
						te = ot.vertexColors === !0 && !!vt.attributes.color && vt.attributes.color.itemSize === 4,
						se = !!ot.normalMap && !!vt.attributes.tangent,
						Jt = !!vt.morphAttributes.position,
						we = !!vt.morphAttributes.normal,
						Ke = !!vt.morphAttributes.color,
						Ci = ot.toneMapped ? f.toneMapping : Vr,
						Ti = vt.morphAttributes.position || vt.morphAttributes.normal || vt.morphAttributes.color,
						Be = Ti !== void 0 ? Ti.length : 0,
						Wt = lt.get(ot),
						Rs = b.state.lights;
					if (H === !0 && (q === !0 || K !== L)) {
						let Ze = K === L && ot.id === I;
						pt.setState(ot, K, Ze)
					}
					let Ve = !1;
					ot.version === Wt.__version ? (Wt.needsLights && Wt.lightsStateVersion !== Rs.state.version || Wt.outputEncoding !== Yt || _t.isInstancedMesh && Wt.instancing === !1 || !_t.isInstancedMesh && Wt.instancing === !0 || _t.isSkinnedMesh && Wt.skinning === !1 || !_t.isSkinnedMesh && Wt.skinning === !0 || Wt.envMap !== ee || ot.fog === !0 && Wt.fog !== Ht || Wt.numClippingPlanes !== void 0 && (Wt.numClippingPlanes !== pt.numPlanes || Wt.numIntersection !== pt.numIntersection) || Wt.vertexAlphas !== te || Wt.vertexTangents !== se || Wt.morphTargets !== Jt || Wt.morphNormals !== we || Wt.morphColors !== Ke || Wt.toneMapping !== Ci || yt.isWebGL2 === !0 && Wt.morphTargetsCount !== Be) && (Ve = !0) : (Ve = !0, Wt.__version = ot.version);
					let un = Wt.currentProgram;
					Ve === !0 && (un = pr(ot, ct, _t));
					let qr = !1,
						$n = !1,
						jr = !1,
						ni = un.getUniforms(),
						yi = Wt.uniforms;
					if (At.useProgram(un.program) && (qr = !0, $n = !0, jr = !0), ot.id !== I && (I = ot.id, $n = !0), qr || L !== K) {
						if (ni.setValue(it, "projectionMatrix", K.projectionMatrix), yt.logarithmicDepthBuffer && ni.setValue(it, "logDepthBufFC", 2 / (Math.log(K.far + 1) / Math.LN2)), L !== K && (L = K, $n = !0, jr = !0), ot.isShaderMaterial || ot.isMeshPhongMaterial || ot.isMeshToonMaterial || ot.isMeshStandardMaterial || ot.envMap) {
							let Ze = ni.map.cameraPosition;
							Ze !== void 0 && Ze.setValue(it, nt.setFromMatrixPosition(K.matrixWorld))
						}(ot.isMeshPhongMaterial || ot.isMeshToonMaterial || ot.isMeshLambertMaterial || ot.isMeshBasicMaterial || ot.isMeshStandardMaterial || ot.isShaderMaterial) && ni.setValue(it, "isOrthographic", K.isOrthographicCamera === !0), (ot.isMeshPhongMaterial || ot.isMeshToonMaterial || ot.isMeshLambertMaterial || ot.isMeshBasicMaterial || ot.isMeshStandardMaterial || ot.isShaderMaterial || ot.isShadowMaterial || _t.isSkinnedMesh) && ni.setValue(it, "viewMatrix", K.matrixWorldInverse)
					}
					if (_t.isSkinnedMesh) {
						ni.setOptional(it, _t, "bindMatrix"), ni.setOptional(it, _t, "bindMatrixInverse");
						let Ze = _t.skeleton;
						Ze && (yt.floatVertexTextures ? (Ze.boneTexture === null && Ze.computeBoneTexture(), ni.setValue(it, "boneTexture", Ze.boneTexture, dt), ni.setValue(it, "boneTextureSize", Ze.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
					}
					let dn = vt.morphAttributes;
					if ((dn.position !== void 0 || dn.normal !== void 0 || dn.color !== void 0 && yt.isWebGL2 === !0) && Pt.update(_t, vt, un), ($n || Wt.receiveShadow !== _t.receiveShadow) && (Wt.receiveShadow = _t.receiveShadow, ni.setValue(it, "receiveShadow", _t.receiveShadow)), ot.isMeshGouraudMaterial && ot.envMap !== null && (yi.envMap.value = ee, yi.flipEnvMap.value = ee.isCubeTexture && ee.isRenderTargetTexture === !1 ? -1 : 1), $n && (ni.setValue(it, "toneMappingExposure", f.toneMappingExposure), Wt.needsLights && ks(yi, jr), Ht && ot.fog === !0 && ye.refreshFogUniforms(yi, Ht), ye.refreshMaterialUniforms(yi, ot, z, U, Q), Ao.upload(it, Wt.uniformsList, yi, dt)), ot.isShaderMaterial && ot.uniformsNeedUpdate === !0 && (Ao.upload(it, Wt.uniformsList, yi, dt), ot.uniformsNeedUpdate = !1), ot.isSpriteMaterial && ni.setValue(it, "center", _t.center), ni.setValue(it, "modelViewMatrix", _t.modelViewMatrix), ni.setValue(it, "normalMatrix", _t.normalMatrix), ni.setValue(it, "modelMatrix", _t.matrixWorld), ot.isShaderMaterial || ot.isRawShaderMaterial) {
						let Ze = ot.uniformsGroups;
						for (let mr = 0, Zo = Ze.length; mr < Zo; mr++)
							if (yt.isWebGL2) {
								let Fs = Ze[mr];
								Gt.update(Fs, un), Gt.bind(Fs, un)
							} else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
					}
					return un
				}

				function ks(K, ct) {
					K.ambientLightColor.needsUpdate = ct, K.lightProbe.needsUpdate = ct, K.directionalLights.needsUpdate = ct, K.directionalLightShadows.needsUpdate = ct, K.pointLights.needsUpdate = ct, K.pointLightShadows.needsUpdate = ct, K.spotLights.needsUpdate = ct, K.spotLightShadows.needsUpdate = ct, K.rectAreaLights.needsUpdate = ct, K.hemisphereLights.needsUpdate = ct
				}

				function Ko(K) {
					return K.isMeshLambertMaterial || K.isMeshToonMaterial || K.isMeshPhongMaterial || K.isMeshStandardMaterial || K.isShadowMaterial || K.isShaderMaterial && K.lights === !0
				}
				this.getActiveCubeFace = function () {
					return x
				}, this.getActiveMipmapLevel = function () {
					return M
				}, this.getRenderTarget = function () {
					return T
				}, this.setRenderTargetTextures = function (K, ct, vt) {
					lt.get(K.texture).__webglTexture = ct, lt.get(K.depthTexture).__webglTexture = vt;
					let ot = lt.get(K);
					ot.__hasExternalTextures = !0, ot.__hasExternalTextures && (ot.__autoAllocateDepthBuffer = vt === void 0, ot.__autoAllocateDepthBuffer || wt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ot.__useRenderToTexture = !1))
				}, this.setRenderTargetFramebuffer = function (K, ct) {
					let vt = lt.get(K);
					vt.__webglFramebuffer = ct, vt.__useDefaultFramebuffer = ct === void 0
				}, this.setRenderTarget = function (K, ct = 0, vt = 0) {
					T = K, x = ct, M = vt;
					let ot = !0,
						_t = null,
						Ht = !1,
						$t = !1;
					if (K) {
						let ee = lt.get(K);
						ee.__useDefaultFramebuffer !== void 0 ? (At.bindFramebuffer(36160, null), ot = !1) : ee.__webglFramebuffer === void 0 ? dt.setupRenderTarget(K) : ee.__hasExternalTextures && dt.rebindTextures(K, lt.get(K.texture).__webglTexture, lt.get(K.depthTexture).__webglTexture);
						let te = K.texture;
						(te.isData3DTexture || te.isDataArrayTexture || te.isCompressedArrayTexture) && ($t = !0);
						let se = lt.get(K).__webglFramebuffer;
						K.isWebGLCubeRenderTarget ? (_t = se[ct], Ht = !0) : yt.isWebGL2 && K.samples > 0 && dt.useMultisampledRTT(K) === !1 ? _t = lt.get(K).__webglMultisampledFramebuffer : _t = se, F.copy(K.viewport), k.copy(K.scissor), G = K.scissorTest
					} else F.copy(O).multiplyScalar(z).floor(), k.copy(B).multiplyScalar(z).floor(), G = A;
					if (At.bindFramebuffer(36160, _t) && yt.drawBuffers && ot && At.drawBuffers(K, _t), At.viewport(F), At.scissor(k), At.setScissorTest(G), Ht) {
						let ee = lt.get(K.texture);
						it.framebufferTexture2D(36160, 36064, 34069 + ct, ee.__webglTexture, vt)
					} else if ($t) {
						let ee = lt.get(K.texture),
							te = ct || 0;
						it.framebufferTextureLayer(36160, 36064, ee.__webglTexture, vt || 0, te)
					}
					I = -1
				}, this.readRenderTargetPixels = function (K, ct, vt, ot, _t, Ht, $t) {
					if (!(K && K.isWebGLRenderTarget)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
						return
					}
					let Yt = lt.get(K).__webglFramebuffer;
					if (K.isWebGLCubeRenderTarget && $t !== void 0 && (Yt = Yt[$t]), Yt) {
						At.bindFramebuffer(36160, Yt);
						try {
							let ee = K.texture,
								te = ee.format,
								se = ee.type;
							if (te !== zn && mt.convert(te) !== it.getParameter(35739)) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
								return
							}
							let Jt = se === eh && (wt.has("EXT_color_buffer_half_float") || yt.isWebGL2 && wt.has("EXT_color_buffer_float"));
							if (se !== ya && mt.convert(se) !== it.getParameter(35738) && !(se === ga && (yt.isWebGL2 || wt.has("OES_texture_float") || wt.has("WEBGL_color_buffer_float"))) && !Jt) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
								return
							}
							ct >= 0 && ct <= K.width - ot && vt >= 0 && vt <= K.height - _t && it.readPixels(ct, vt, ot, _t, mt.convert(te), mt.convert(se), Ht)
						} finally {
							let ee = T !== null ? lt.get(T).__webglFramebuffer : null;
							At.bindFramebuffer(36160, ee)
						}
					}
				}, this.copyFramebufferToTexture = function (K, ct, vt = 0) {
					let ot = Math.pow(2, -vt),
						_t = Math.floor(ct.image.width * ot),
						Ht = Math.floor(ct.image.height * ot);
					dt.setTexture2D(ct, 0), it.copyTexSubImage2D(3553, vt, 0, 0, K.x, K.y, _t, Ht), At.unbindTexture()
				}, this.copyTextureToTexture = function (K, ct, vt, ot = 0) {
					let _t = ct.image.width,
						Ht = ct.image.height,
						$t = mt.convert(vt.format),
						Yt = mt.convert(vt.type);
					dt.setTexture2D(vt, 0), it.pixelStorei(37440, vt.flipY), it.pixelStorei(37441, vt.premultiplyAlpha), it.pixelStorei(3317, vt.unpackAlignment), ct.isDataTexture ? it.texSubImage2D(3553, ot, K.x, K.y, _t, Ht, $t, Yt, ct.image.data) : ct.isCompressedTexture ? it.compressedTexSubImage2D(3553, ot, K.x, K.y, ct.mipmaps[0].width, ct.mipmaps[0].height, $t, ct.mipmaps[0].data) : it.texSubImage2D(3553, ot, K.x, K.y, $t, Yt, ct.image), ot === 0 && vt.generateMipmaps && it.generateMipmap(3553), At.unbindTexture()
				}, this.copyTextureToTexture3D = function (K, ct, vt, ot, _t = 0) {
					if (f.isWebGL1Renderer) {
						console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
						return
					}
					let Ht = K.max.x - K.min.x + 1,
						$t = K.max.y - K.min.y + 1,
						Yt = K.max.z - K.min.z + 1,
						ee = mt.convert(ot.format),
						te = mt.convert(ot.type),
						se;
					if (ot.isData3DTexture) dt.setTexture3D(ot, 0), se = 32879;
					else if (ot.isDataArrayTexture) dt.setTexture2DArray(ot, 0), se = 35866;
					else {
						console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
						return
					}
					it.pixelStorei(37440, ot.flipY), it.pixelStorei(37441, ot.premultiplyAlpha), it.pixelStorei(3317, ot.unpackAlignment);
					let Jt = it.getParameter(3314),
						we = it.getParameter(32878),
						Ke = it.getParameter(3316),
						Ci = it.getParameter(3315),
						Ti = it.getParameter(32877),
						Be = vt.isCompressedTexture ? vt.mipmaps[0] : vt.image;
					it.pixelStorei(3314, Be.width), it.pixelStorei(32878, Be.height), it.pixelStorei(3316, K.min.x), it.pixelStorei(3315, K.min.y), it.pixelStorei(32877, K.min.z), vt.isDataTexture || vt.isData3DTexture ? it.texSubImage3D(se, _t, ct.x, ct.y, ct.z, Ht, $t, Yt, ee, te, Be.data) : vt.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), it.compressedTexSubImage3D(se, _t, ct.x, ct.y, ct.z, Ht, $t, Yt, ee, Be.data)) : it.texSubImage3D(se, _t, ct.x, ct.y, ct.z, Ht, $t, Yt, ee, te, Be), it.pixelStorei(3314, Jt), it.pixelStorei(32878, we), it.pixelStorei(3316, Ke), it.pixelStorei(3315, Ci), it.pixelStorei(32877, Ti), _t === 0 && ot.generateMipmaps && it.generateMipmap(se), At.unbindTexture()
				}, this.initTexture = function (K) {
					K.isCubeTexture ? dt.setTextureCube(K, 0) : K.isData3DTexture ? dt.setTexture3D(K, 0) : K.isDataArrayTexture || K.isCompressedArrayTexture ? dt.setTexture2DArray(K, 0) : dt.setTexture2D(K, 0), At.unbindTexture()
				}, this.resetState = function () {
					x = 0, M = 0, T = null, At.reset(), Ot.reset()
				}, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
					detail: this
				}))
			}
			get physicallyCorrectLights() {
				return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
			}
			set physicallyCorrectLights(t) {
				console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !t
			}
		},
		vm = class extends nh {};
	vm.prototype.isWebGL1Renderer = !0;
	var Lu = class extends fi {
		constructor() {
			super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
				detail: this
			}))
		}
		copy(t, e) {
			return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
		}
		toJSON(t) {
			let e = super.toJSON(t);
			return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e
		}
		get autoUpdate() {
			return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
		}
		set autoUpdate(t) {
			console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t
		}
	};
	var Oo = class extends wa {
			constructor(t) {
				super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Pe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
			}
			copy(t) {
				return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
			}
		},
		Hy = new ht,
		Wy = new ht,
		$y = new ii,
		qf = new Su,
		uu = new ko,
		rh = class extends fi {
			constructor(t = new tn, e = new Oo) {
				super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
			}
			copy(t, e) {
				return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
			}
			computeLineDistances() {
				let t = this.geometry;
				if (t.index === null) {
					let e = t.attributes.position,
						n = [0];
					for (let r = 1, s = e.count; r < s; r++) Hy.fromBufferAttribute(e, r - 1), Wy.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += Hy.distanceTo(Wy);
					t.setAttribute("lineDistance", new Qi(n, 1))
				} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
			raycast(t, e) {
				let n = this.geometry,
					r = this.matrixWorld,
					s = t.params.Line.threshold,
					a = n.drawRange;
				if (n.boundingSphere === null && n.computeBoundingSphere(), uu.copy(n.boundingSphere), uu.applyMatrix4(r), uu.radius += s, t.ray.intersectsSphere(uu) === !1) return;
				$y.copy(r).invert(), qf.copy(t.ray).applyMatrix4($y);
				let o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					h = o * o,
					c = new ht,
					u = new ht,
					g = new ht,
					p = new ht,
					_ = this.isLineSegments ? 2 : 1,
					b = n.index,
					w = n.attributes.position;
				if (b !== null) {
					let f = Math.max(0, a.start),
						S = Math.min(b.count, a.start + a.count);
					for (let x = f, M = S - 1; x < M; x += _) {
						let T = b.getX(x),
							I = b.getX(x + 1);
						if (c.fromBufferAttribute(w, T), u.fromBufferAttribute(w, I), qf.distanceSqToSegment(c, u, p, g) > h) continue;
						p.applyMatrix4(this.matrixWorld);
						let F = t.ray.origin.distanceTo(p);
						F < t.near || F > t.far || e.push({
							distance: F,
							point: g.clone().applyMatrix4(this.matrixWorld),
							index: x,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				} else {
					let f = Math.max(0, a.start),
						S = Math.min(w.count, a.start + a.count);
					for (let x = f, M = S - 1; x < M; x += _) {
						if (c.fromBufferAttribute(w, x), u.fromBufferAttribute(w, x + 1), qf.distanceSqToSegment(c, u, p, g) > h) continue;
						p.applyMatrix4(this.matrixWorld);
						let I = t.ray.origin.distanceTo(p);
						I < t.near || I > t.far || e.push({
							distance: I,
							point: g.clone().applyMatrix4(this.matrixWorld),
							index: x,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				}
			}
			updateMorphTargets() {
				let e = this.geometry.morphAttributes,
					n = Object.keys(e);
				if (n.length > 0) {
					let r = e[n[0]];
					if (r !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, a = r.length; s < a; s++) {
							let o = r[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s
						}
					}
				}
			}
		},
		qy = new ht,
		jy = new ht,
		sh = class extends rh {
			constructor(t, e) {
				super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
			}
			computeLineDistances() {
				let t = this.geometry;
				if (t.index === null) {
					let e = t.attributes.position,
						n = [];
					for (let r = 0, s = e.count; r < s; r += 2) qy.fromBufferAttribute(e, r), jy.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + qy.distanceTo(jy);
					t.setAttribute("lineDistance", new Qi(n, 1))
				} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
		};
	var du = new ht,
		pu = new ht,
		jf = new ht,
		fu = new Ki,
		ku = class extends tn {
			constructor(t = null, e = 1) {
				if (super(), this.type = "EdgesGeometry", this.parameters = {
						geometry: t,
						thresholdAngle: e
					}, t !== null) {
					let r = Math.pow(10, 4),
						s = Math.cos(vu * e),
						a = t.getIndex(),
						o = t.getAttribute("position"),
						h = a ? a.count : o.count,
						c = [0, 0, 0],
						u = ["a", "b", "c"],
						g = new Array(3),
						p = {},
						_ = [];
					for (let b = 0; b < h; b += 3) {
						a ? (c[0] = a.getX(b), c[1] = a.getX(b + 1), c[2] = a.getX(b + 2)) : (c[0] = b, c[1] = b + 1, c[2] = b + 2);
						let {
							a: y,
							b: w,
							c: f
						} = fu;
						if (y.fromBufferAttribute(o, c[0]), w.fromBufferAttribute(o, c[1]), f.fromBufferAttribute(o, c[2]), fu.getNormal(jf), g[0] = `${Math.round(y.x*r)},${Math.round(y.y*r)},${Math.round(y.z*r)}`, g[1] = `${Math.round(w.x*r)},${Math.round(w.y*r)},${Math.round(w.z*r)}`, g[2] = `${Math.round(f.x*r)},${Math.round(f.y*r)},${Math.round(f.z*r)}`, !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
							for (let S = 0; S < 3; S++) {
								let x = (S + 1) % 3,
									M = g[S],
									T = g[x],
									I = fu[u[S]],
									L = fu[u[x]],
									F = `${M}_${T}`,
									k = `${T}_${M}`;
								k in p && p[k] ? (jf.dot(p[k].normal) <= s && (_.push(I.x, I.y, I.z), _.push(L.x, L.y, L.z)), p[k] = null) : F in p || (p[F] = {
									index0: c[S],
									index1: c[x],
									normal: jf.clone()
								})
							}
					}
					for (let b in p)
						if (p[b]) {
							let {
								index0: y,
								index1: w
							} = p[b];
							du.fromBufferAttribute(o, y), pu.fromBufferAttribute(o, w), _.push(du.x, du.y, du.z), _.push(pu.x, pu.y, pu.z)
						} this.setAttribute("position", new Qi(_, 3))
				}
			}
			copy(t) {
				return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
			}
		};

	function ws(i, t, e) {
		return ub(i) ? new i.constructor(i.subarray(t, e !== void 0 ? e : i.length)) : i.slice(t, e)
	}

	function mu(i, t, e) {
		return !i || !e && i.constructor === t ? i : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i) : Array.prototype.slice.call(i)
	}

	function ub(i) {
		return ArrayBuffer.isView(i) && !(i instanceof DataView)
	}
	var No = class {
			constructor(t, e, n, r) {
				this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
			}
			evaluate(t) {
				let e = this.parameterPositions,
					n = this._cachedIndex,
					r = e[n],
					s = e[n - 1];
				i: {
					t: {
						let a;e: {
							n: if (!(t < r)) {
								for (let o = n + 2;;) {
									if (r === void 0) {
										if (t < s) break n;
										return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
									}
									if (n === o) break;
									if (s = r, r = e[++n], t < r) break t
								}
								a = e.length;
								break e
							}if (!(t >= s)) {
								let o = e[1];
								t < o && (n = 2, s = o);
								for (let h = n - 2;;) {
									if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
									if (n === h) break;
									if (r = s, s = e[--n - 1], t >= s) break t
								}
								a = n, n = 0;
								break e
							}
							break i
						}
						for (; n < a;) {
							let o = n + a >>> 1;
							t < e[o] ? a = o : n = o + 1
						}
						if (r = e[n], s = e[n - 1], s === void 0) return this._cachedIndex = 0,
						this.copySampleValue_(0);
						if (r === void 0) return n = e.length,
						this._cachedIndex = n,
						this.copySampleValue_(n - 1)
					}
					this._cachedIndex = n,
					this.intervalChanged_(n, s, r)
				}
				return this.interpolate_(n, s, t, r)
			}
			getSettings_() {
				return this.settings || this.DefaultSettings_
			}
			copySampleValue_(t) {
				let e = this.resultBuffer,
					n = this.sampleValues,
					r = this.valueSize,
					s = t * r;
				for (let a = 0; a !== r; ++a) e[a] = n[s + a];
				return e
			}
			interpolate_() {
				throw new Error("call to abstract method")
			}
			intervalChanged_() {}
		},
		gm = class extends No {
			constructor(t, e, n, r) {
				super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
					endingStart: iy,
					endingEnd: iy
				}
			}
			intervalChanged_(t, e, n) {
				let r = this.parameterPositions,
					s = t - 2,
					a = t + 1,
					o = r[s],
					h = r[a];
				if (o === void 0) switch (this.getSettings_().endingStart) {
					case ny:
						s = t, o = 2 * e - n;
						break;
					case ry:
						s = r.length - 2, o = e + r[s] - r[s + 1];
						break;
					default:
						s = t, o = n
				}
				if (h === void 0) switch (this.getSettings_().endingEnd) {
					case ny:
						a = t, h = 2 * n - e;
						break;
					case ry:
						a = 1, h = n + r[1] - r[0];
						break;
					default:
						a = t - 1, h = e
				}
				let c = (n - e) * .5,
					u = this.valueSize;
				this._weightPrev = c / (e - o), this._weightNext = c / (h - n), this._offsetPrev = s * u, this._offsetNext = a * u
			}
			interpolate_(t, e, n, r) {
				let s = this.resultBuffer,
					a = this.sampleValues,
					o = this.valueSize,
					h = t * o,
					c = h - o,
					u = this._offsetPrev,
					g = this._offsetNext,
					p = this._weightPrev,
					_ = this._weightNext,
					b = (n - e) / (r - e),
					y = b * b,
					w = y * b,
					f = -p * w + 2 * p * y - p * b,
					S = (1 + p) * w + (-1.5 - 2 * p) * y + (-.5 + p) * b + 1,
					x = (-1 - _) * w + (1.5 + _) * y + .5 * b,
					M = _ * w - _ * y;
				for (let T = 0; T !== o; ++T) s[T] = f * a[u + T] + S * a[c + T] + x * a[h + T] + M * a[g + T];
				return s
			}
		},
		_m = class extends No {
			constructor(t, e, n, r) {
				super(t, e, n, r)
			}
			interpolate_(t, e, n, r) {
				let s = this.resultBuffer,
					a = this.sampleValues,
					o = this.valueSize,
					h = t * o,
					c = h - o,
					u = (n - e) / (r - e),
					g = 1 - u;
				for (let p = 0; p !== o; ++p) s[p] = a[c + p] * g + a[h + p] * u;
				return s
			}
		},
		ym = class extends No {
			constructor(t, e, n, r) {
				super(t, e, n, r)
			}
			interpolate_(t) {
				return this.copySampleValue_(t - 1)
			}
		},
		Un = class {
			constructor(t, e, n, r) {
				if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
				if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
				this.name = t, this.times = mu(e, this.TimeBufferType), this.values = mu(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
			}
			static toJSON(t) {
				let e = t.constructor,
					n;
				if (e.toJSON !== this.toJSON) n = e.toJSON(t);
				else {
					n = {
						name: t.name,
						times: mu(t.times, Array),
						values: mu(t.values, Array)
					};
					let r = t.getInterpolation();
					r !== t.DefaultInterpolation && (n.interpolation = r)
				}
				return n.type = t.ValueTypeName, n
			}
			InterpolantFactoryMethodDiscrete(t) {
				return new ym(this.times, this.values, this.getValueSize(), t)
			}
			InterpolantFactoryMethodLinear(t) {
				return new _m(this.times, this.values, this.getValueSize(), t)
			}
			InterpolantFactoryMethodSmooth(t) {
				return new gm(this.times, this.values, this.getValueSize(), t)
			}
			setInterpolation(t) {
				let e;
				switch (t) {
					case gu:
						e = this.InterpolantFactoryMethodDiscrete;
						break;
					case _u:
						e = this.InterpolantFactoryMethodLinear;
						break;
					case Sf:
						e = this.InterpolantFactoryMethodSmooth;
						break
				}
				if (e === void 0) {
					let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
					if (this.createInterpolant === void 0)
						if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
						else throw new Error(n);
					return console.warn("THREE.KeyframeTrack:", n), this
				}
				return this.createInterpolant = e, this
			}
			getInterpolation() {
				switch (this.createInterpolant) {
					case this.InterpolantFactoryMethodDiscrete:
						return gu;
					case this.InterpolantFactoryMethodLinear:
						return _u;
					case this.InterpolantFactoryMethodSmooth:
						return Sf
				}
			}
			getValueSize() {
				return this.values.length / this.times.length
			}
			shift(t) {
				if (t !== 0) {
					let e = this.times;
					for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
				}
				return this
			}
			scale(t) {
				if (t !== 1) {
					let e = this.times;
					for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
				}
				return this
			}
			trim(t, e) {
				let n = this.times,
					r = n.length,
					s = 0,
					a = r - 1;
				for (; s !== r && n[s] < t;) ++s;
				for (; a !== -1 && n[a] > e;) --a;
				if (++a, s !== 0 || a !== r) {
					s >= a && (a = Math.max(a, 1), s = a - 1);
					let o = this.getValueSize();
					this.times = ws(n, s, a), this.values = ws(this.values, s * o, a * o)
				}
				return this
			}
			validate() {
				let t = !0,
					e = this.getValueSize();
				e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
				let n = this.times,
					r = this.values,
					s = n.length;
				s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
				let a = null;
				for (let o = 0; o !== s; o++) {
					let h = n[o];
					if (typeof h == "number" && isNaN(h)) {
						console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, h), t = !1;
						break
					}
					if (a !== null && a > h) {
						console.error("THREE.KeyframeTrack: Out of order keys.", this, o, h, a), t = !1;
						break
					}
					a = h
				}
				if (r !== void 0 && ub(r))
					for (let o = 0, h = r.length; o !== h; ++o) {
						let c = r[o];
						if (isNaN(c)) {
							console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), t = !1;
							break
						}
					}
				return t
			}
			optimize() {
				let t = ws(this.times),
					e = ws(this.values),
					n = this.getValueSize(),
					r = this.getInterpolation() === Sf,
					s = t.length - 1,
					a = 1;
				for (let o = 1; o < s; ++o) {
					let h = !1,
						c = t[o],
						u = t[o + 1];
					if (c !== u && (o !== 1 || c !== t[0]))
						if (r) h = !0;
						else {
							let g = o * n,
								p = g - n,
								_ = g + n;
							for (let b = 0; b !== n; ++b) {
								let y = e[g + b];
								if (y !== e[p + b] || y !== e[_ + b]) {
									h = !0;
									break
								}
							}
						} if (h) {
						if (o !== a) {
							t[a] = t[o];
							let g = o * n,
								p = a * n;
							for (let _ = 0; _ !== n; ++_) e[p + _] = e[g + _]
						}++a
					}
				}
				if (s > 0) {
					t[a] = t[s];
					for (let o = s * n, h = a * n, c = 0; c !== n; ++c) e[h + c] = e[o + c];
					++a
				}
				return a !== t.length ? (this.times = ws(t, 0, a), this.values = ws(e, 0, a * n)) : (this.times = t, this.values = e), this
			}
			clone() {
				let t = ws(this.times, 0),
					e = ws(this.values, 0),
					n = this.constructor,
					r = new n(this.name, t, e);
				return r.createInterpolant = this.createInterpolant, r
			}
		};
	Un.prototype.TimeBufferType = Float32Array;
	Un.prototype.ValueBufferType = Float32Array;
	Un.prototype.DefaultInterpolation = _u;
	var Ma = class extends Un {};
	Ma.prototype.ValueTypeName = "bool";
	Ma.prototype.ValueBufferType = Array;
	Ma.prototype.DefaultInterpolation = gu;
	Ma.prototype.InterpolantFactoryMethodLinear = void 0;
	Ma.prototype.InterpolantFactoryMethodSmooth = void 0;
	var bm = class extends Un {};
	bm.prototype.ValueTypeName = "color";
	var xm = class extends Un {};
	xm.prototype.ValueTypeName = "number";
	var wm = class extends No {
			constructor(t, e, n, r) {
				super(t, e, n, r)
			}
			interpolate_(t, e, n, r) {
				let s = this.resultBuffer,
					a = this.sampleValues,
					o = this.valueSize,
					h = (n - e) / (r - e),
					c = t * o;
				for (let u = c + o; c !== u; c += 4) lr.slerpFlat(s, 0, a, c - o, a, c, h);
				return s
			}
		},
		ah = class extends Un {
			InterpolantFactoryMethodLinear(t) {
				return new wm(this.times, this.values, this.getValueSize(), t)
			}
		};
	ah.prototype.ValueTypeName = "quaternion";
	ah.prototype.DefaultInterpolation = _u;
	ah.prototype.InterpolantFactoryMethodSmooth = void 0;
	var Ca = class extends Un {};
	Ca.prototype.ValueTypeName = "string";
	Ca.prototype.ValueBufferType = Array;
	Ca.prototype.DefaultInterpolation = gu;
	Ca.prototype.InterpolantFactoryMethodLinear = void 0;
	Ca.prototype.InterpolantFactoryMethodSmooth = void 0;
	var Sm = class extends Un {};
	Sm.prototype.ValueTypeName = "vector";
	var Ru = class {
		constructor(t = !0) {
			this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
		}
		start() {
			this.startTime = Xy(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
		}
		stop() {
			this.getElapsedTime(), this.running = !1, this.autoStart = !1
		}
		getElapsedTime() {
			return this.getDelta(), this.elapsedTime
		}
		getDelta() {
			let t = 0;
			if (this.autoStart && !this.running) return this.start(), 0;
			if (this.running) {
				let e = Xy();
				t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
			}
			return t
		}
	};

	function Xy() {
		return (typeof performance == "undefined" ? Date : performance).now()
	}
	var Tm = "\\[\\]\\.:\\/",
		o2 = new RegExp("[" + Tm + "]", "g"),
		Pm = "[^" + Tm + "]",
		l2 = "[^" + Tm.replace("\\.", "") + "]",
		h2 = /((?:WC+[\/:])*)/.source.replace("WC", Pm),
		c2 = /(WCOD+)?/.source.replace("WCOD", l2),
		u2 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Pm),
		d2 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Pm),
		p2 = new RegExp("^" + h2 + c2 + u2 + d2 + "$"),
		f2 = ["material", "materials", "bones", "map"],
		Em = class {
			constructor(t, e, n) {
				let r = n || Te.parseTrackName(e);
				this._targetGroup = t, this._bindings = t.subscribe_(e, r)
			}
			getValue(t, e) {
				this.bind();
				let n = this._targetGroup.nCachedObjects_,
					r = this._bindings[n];
				r !== void 0 && r.getValue(t, e)
			}
			setValue(t, e) {
				let n = this._bindings;
				for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r) n[r].setValue(t, e)
			}
			bind() {
				let t = this._bindings;
				for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
			}
			unbind() {
				let t = this._bindings;
				for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
			}
		},
		Te = class {
			constructor(t, e, n) {
				this.path = e, this.parsedPath = n || Te.parseTrackName(e), this.node = Te.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
			static create(t, e, n) {
				return t && t.isAnimationObjectGroup ? new Te.Composite(t, e, n) : new Te(t, e, n)
			}
			static sanitizeNodeName(t) {
				return t.replace(/\s/g, "_").replace(o2, "")
			}
			static parseTrackName(t) {
				let e = p2.exec(t);
				if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
				let n = {
						nodeName: e[2],
						objectName: e[3],
						objectIndex: e[4],
						propertyName: e[5],
						propertyIndex: e[6]
					},
					r = n.nodeName && n.nodeName.lastIndexOf(".");
				if (r !== void 0 && r !== -1) {
					let s = n.nodeName.substring(r + 1);
					f2.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s)
				}
				if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
				return n
			}
			static findNode(t, e) {
				if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
				if (t.skeleton) {
					let n = t.skeleton.getBoneByName(e);
					if (n !== void 0) return n
				}
				if (t.children) {
					let n = function (s) {
							for (let a = 0; a < s.length; a++) {
								let o = s[a];
								if (o.name === e || o.uuid === e) return o;
								let h = n(o.children);
								if (h) return h
							}
							return null
						},
						r = n(t.children);
					if (r) return r
				}
				return null
			}
			_getValue_unavailable() {}
			_setValue_unavailable() {}
			_getValue_direct(t, e) {
				t[e] = this.targetObject[this.propertyName]
			}
			_getValue_array(t, e) {
				let n = this.resolvedProperty;
				for (let r = 0, s = n.length; r !== s; ++r) t[e++] = n[r]
			}
			_getValue_arrayElement(t, e) {
				t[e] = this.resolvedProperty[this.propertyIndex]
			}
			_getValue_toArray(t, e) {
				this.resolvedProperty.toArray(t, e)
			}
			_setValue_direct(t, e) {
				this.targetObject[this.propertyName] = t[e]
			}
			_setValue_direct_setNeedsUpdate(t, e) {
				this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
			}
			_setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
				this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_array(t, e) {
				let n = this.resolvedProperty;
				for (let r = 0, s = n.length; r !== s; ++r) n[r] = t[e++]
			}
			_setValue_array_setNeedsUpdate(t, e) {
				let n = this.resolvedProperty;
				for (let r = 0, s = n.length; r !== s; ++r) n[r] = t[e++];
				this.targetObject.needsUpdate = !0
			}
			_setValue_array_setMatrixWorldNeedsUpdate(t, e) {
				let n = this.resolvedProperty;
				for (let r = 0, s = n.length; r !== s; ++r) n[r] = t[e++];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_arrayElement(t, e) {
				this.resolvedProperty[this.propertyIndex] = t[e]
			}
			_setValue_arrayElement_setNeedsUpdate(t, e) {
				this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
			}
			_setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
				this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_fromArray(t, e) {
				this.resolvedProperty.fromArray(t, e)
			}
			_setValue_fromArray_setNeedsUpdate(t, e) {
				this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
			}
			_setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
				this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_getValue_unbound(t, e) {
				this.bind(), this.getValue(t, e)
			}
			_setValue_unbound(t, e) {
				this.bind(), this.setValue(t, e)
			}
			bind() {
				let t = this.node,
					e = this.parsedPath,
					n = e.objectName,
					r = e.propertyName,
					s = e.propertyIndex;
				if (t || (t = Te.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
					console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
					return
				}
				if (n) {
					let c = e.objectIndex;
					switch (n) {
						case "materials":
							if (!t.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!t.material.materials) {
								console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
								return
							}
							t = t.material.materials;
							break;
						case "bones":
							if (!t.skeleton) {
								console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								return
							}
							t = t.skeleton.bones;
							for (let u = 0; u < t.length; u++)
								if (t[u].name === c) {
									c = u;
									break
								} break;
						case "map":
							if ("map" in t) {
								t = t.map;
								break
							}
							if (!t.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!t.material.map) {
								console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
								return
							}
							t = t.material.map;
							break;
						default:
							if (t[n] === void 0) {
								console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								return
							}
							t = t[n]
					}
					if (c !== void 0) {
						if (t[c] === void 0) {
							console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
							return
						}
						t = t[c]
					}
				}
				let a = t[r];
				if (a === void 0) {
					let c = e.nodeName;
					console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", t);
					return
				}
				let o = this.Versioning.None;
				this.targetObject = t, t.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
				let h = this.BindingType.Direct;
				if (s !== void 0) {
					if (r === "morphTargetInfluences") {
						if (!t.geometry) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							return
						}
						if (!t.geometry.morphAttributes) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
							return
						}
						t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s])
					}
					h = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s
				} else a.fromArray !== void 0 && a.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (h = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
				this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][o]
			}
			unbind() {
				this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
		};
	Te.Composite = Em;
	Te.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	Te.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	Te.prototype.GetterByBindingType = [Te.prototype._getValue_direct, Te.prototype._getValue_array, Te.prototype._getValue_arrayElement, Te.prototype._getValue_toArray];
	Te.prototype.SetterByBindingTypeAndVersioning = [
		[Te.prototype._setValue_direct, Te.prototype._setValue_direct_setNeedsUpdate, Te.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
		[Te.prototype._setValue_array, Te.prototype._setValue_array_setNeedsUpdate, Te.prototype._setValue_array_setMatrixWorldNeedsUpdate],
		[Te.prototype._setValue_arrayElement, Te.prototype._setValue_arrayElement_setNeedsUpdate, Te.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
		[Te.prototype._setValue_fromArray, Te.prototype._setValue_fromArray_setNeedsUpdate, Te.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
	];
	var uR = new Float32Array(1);
	var Vo = class {
		constructor(t) {
			this.value = t
		}
		clone() {
			return new Vo(this.value.clone === void 0 ? this.value : this.value.clone())
		}
	};
	var Fu = class extends sh {
		constructor(t = 1) {
			let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
				n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
				r = new tn;
			r.setAttribute("position", new Qi(e, 3)), r.setAttribute("color", new Qi(n, 3));
			let s = new Oo({
				vertexColors: !0,
				toneMapped: !1
			});
			super(r, s), this.type = "AxesHelper"
		}
		setColors(t, e, n) {
			let r = new Pe,
				s = this.geometry.attributes.color.array;
			return r.set(t), r.toArray(s, 0), r.toArray(s, 3), r.set(e), r.toArray(s, 6), r.toArray(s, 9), r.set(n), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this
		}
		dispose() {
			this.geometry.dispose(), this.material.dispose()
		}
	};
	typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
		detail: {
			revision: Mm
		}
	}));
	typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Mm);
	var Ta = class extends pe {
		constructor(t) {
			super(t), this.isDisabled = !1
		}
		init() {
			var t, e, n;
			ie.REDUCED_MOTION || (window.addEventListener(Ce.RESIZE_END, this.resizeBind = () => this.resize()), this.$el = this.el, this.sizes = {}, this.scene = new Lu, this.camera = new Oi(75, 1), this.renderer = new nh({
				antialias: !0,
				alpha: !0
			}), (e = (t = this.renderer.domElement) == null ? void 0 : t.setAttribute) == null || e.call(t, "aria-hidden", !0), this.resize(!1), (n = this.onInit) == null || n.call(this), this.clock = new Ru, this.$el.appendChild(this.renderer.domElement), this.render())
		}
		start() {
			var t;
			this.isDisabled || this.isTicking || ie.REDUCED_MOTION || (this.isTicking = !0, this.tickerBind = this.render.bind(this), ne.ticker.add(this.tickerBind), (t = this.onStart) == null || t.call(this))
		}
		stop() {
			var t;
			this.isDisabled || !this.isTicking || ie.REDUCED_MOTION || (this.isTicking = !1, ne.ticker.remove(this.tickerBind), (t = this.onStop) == null || t.call(this))
		}
		toggle(t) {
			var e;
			this.isDisabled || ie.REDUCED_MOTION || (t.way === "enter" || typeof t.way == "undefined" && !this.isTicking ? this.start() : this.stop(), (e = this.onToggle) == null || e.call(this))
		}
		resize(t = !0) {
			var e;
			(e = this.onResize) == null || e.call(this), !this.isDisabled && (typeof this.sizes.width == "undefined" && (this.sizes.width = di.window.width, this.sizes.height = di.window.height), this.camera.aspect = this.sizes.width / this.sizes.height, this.renderer.setSize(this.sizes.width, this.sizes.height), this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), !this.isTicking && t && this.render())
		}
		render() {
			var n, r, s, a, o;
			if (this.isDisabled) return;
			let t = (n = this.clock) == null ? void 0 : n.getDelta(),
				e = (r = this.clock) == null ? void 0 : r.getElapsedTime();
			(s = this.renderer) == null || s.render(this.scene, this.camera), (a = this.camera) == null || a.updateProjectionMatrix(), (o = this.onRender) == null || o.call(this, t, e)
		}
		destroy() {
			var t, e, n, r, s, a;
			ie.REDUCED_MOTION || (this.stop(), (e = (t = this.geometry) == null ? void 0 : t.dispose) == null || e.call(t), (r = (n = this.material) == null ? void 0 : n.dispose) == null || r.call(n), (a = (s = this.renderer) == null ? void 0 : s.dispose) == null || a.call(s), window.removeEventListener(Ce.RESIZE_END, this.resizeBind))
		}
	};
	var db = "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";
	var pb = "float random(in vec2 st){return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}float noise(in vec2 st){vec2 i=floor(st);vec2 f=fract(st);float a=random(i);float b=random(i+vec2(1.0,0.0));float c=random(i+vec2(0.0,1.0));float d=random(i+vec2(1.0,1.0));vec2 u=f*f*(3.0-2.0*f);return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;}";
	var fb = "uniform float uIntensity;uniform float uTime;uniform vec3 uColor;varying vec2 vUv;varying float vDisplacement;void main(){float distort=2.0*vDisplacement*uIntensity*sin(vUv.y*10.0+uTime);gl_FragColor=vec4(uColor,1.0);}";
	var mb = `uniform float uIntensity;uniform float uTime;varying vec2 vUv;varying float vDisplacement;
#include <noise3d>
void main(){vUv=uv;vDisplacement=cnoise(position+vec3(2.0*uTime));vec3 newPosition=position+normal*(uIntensity*vDisplacement);vec4 modelPosition=modelMatrix*vec4(newPosition,1.0);vec4 viewPosition=viewMatrix*modelPosition;vec4 projectedPosition=projectionMatrix*viewPosition;gl_Position=projectedPosition;}`;
	var vb = `#ifdef GL_ES
precision mediump float;
#endif
#define PI 3.14159265359
#define TWO_PI 6.28318530718
uniform vec2 u_resolution;uniform float u_opacity;uniform vec3 u_color;void main(){vec2 st=gl_FragCoord.xy/u_resolution.xy;gl_FragColor=vec4(u_color,u_opacity);}`;
	var gb = `#define PI 3.14159265359
uniform float u_time;uniform float u_pointsize;uniform float u_noise_master_amp;uniform float u_noise_amp_1;uniform float u_noise_freq_1;uniform float u_spd_modifier_1;uniform float u_noise_amp_2;uniform float u_noise_freq_2;uniform float u_spd_modifier_2;
#include <noise2d>
mat2 rotate2d(float angle){return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));}void main(){gl_PointSize=u_pointsize;vec3 pos=position;pos.z+=noise(pos.xy*u_noise_freq_1+u_time*u_spd_modifier_1)*u_noise_amp_1*u_noise_master_amp;pos.x+=noise(rotate2d(PI/4.)*pos.yx*u_noise_freq_2-u_time*u_spd_modifier_2*0.6)*u_noise_amp_2*u_noise_master_amp;pos.y-=noise(rotate2d(PI/4.)*pos.yx*u_noise_freq_2-u_time*u_spd_modifier_2*0.6)*u_noise_amp_2*u_noise_master_amp;vec4 mvm=modelViewMatrix*vec4(pos,1.0);gl_Position=projectionMatrix*mvm;}`;
	var x2 = {
			blobFragment: fb,
			blobVertex: mb,
			hypermeshFragment: vb,
			hypermeshVertex: gb
		},
		w2 = {
			noise3d: db,
			noise2d: pb
		},
		S2 = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function _b(i) {
		return i.replace(S2, (t, e) => {
			let n = w2[e];
			if (n === void 0) throw new Error(`Can not resolve #include <${e}>`);
			return _b(n)
		})
	}

	function Dm(i) {
		return _b(x2[i])
	}
	var Im, Sb;
	Di(void 0, null, function* () {
		ie.IS_DEV && (Im = yield Promise.resolve().then(() => yl(bb(), 1)), Sb = yield Promise.resolve().then(() => yl(wb(), 1)))
	});
	var E2 = Dm("hypermeshVertex"),
		M2 = Dm("hypermeshFragment"),
		lh = class extends Ta {
			constructor(t) {
				super(t), this.SIZE = this.getData("size") || 1.3, this.DPR = Math.max(window.devicePixelRatio, 2), this.settings = {
					meshQty: 48,
					meshSpacing: .02,
					meshSpin: .02,
					meshScrollSpin: -Math.PI,
					meshAutoRotate: {
						x: .001,
						y: .001,
						z: 0
					},
					camera: {
						origin: {
							x: 0,
							y: 0,
							z: 2
						},
						target: {
							x: .8,
							y: 1,
							z: 0
						},
						mouseSensitivity: {
							x: -1e-4,
							y: -1e-4
						}
					},
					color: Xi.dataset.theme === "light" ? "#FF8500" : "#ffffff",
					opacity: Xi.dataset.theme === "dark" ? .5 : .2
				}
			}
			onInit() {
				this.uniforms = {
					u_time: {
						value: 0
					},
					u_resolution: {
						value: {
							x: this.sizes.width * this.DPR,
							y: this.sizes.height * this.DPR
						}
					},
					u_color: new Vo(new Pe(this.settings.color)),
					u_noise_master_amp: {
						value: 0
					},
					u_noise_freq_1: {
						value: 1.17
					},
					u_noise_amp_1: {
						value: .09
					},
					u_spd_modifier_1: {
						value: .22
					},
					u_noise_freq_2: {
						value: .87
					},
					u_noise_amp_2: {
						value: .22
					},
					u_spd_modifier_2: {
						value: .43
					},
					u_opacity: {
						value: this.settings.opacity
					}
				}, this.initCamera(), this.initObjects(), this.initScrollTimeline(), this.handleEvents(), ie.IS_DEV && this.initTweakpane()
			}
			initObjects() {
				this.axesHelper = new Fu(1), this.axesHelper.visible = !1, this.scene.add(this.axesHelper), this.geometry = new ku(new Ea(this.SIZE, this.SIZE, this.SIZE, this.SIZE)), this.material = new Bn({
					uniforms: this.uniforms,
					vertexShader: E2,
					fragmentShader: M2,
					transparent: !0
				}), this.meshesOuter = new Nr, this.meshesInner = new Nr, this.populate(), this.meshesOuter.add(this.meshesInner), this.scene.add(this.meshesOuter)
			}
			populate() {
				this.meshesInner.clear(), this.meshes = [];
				for (let t = 0; t < this.settings.meshQty; t++) {
					let e = new sh(this.geometry, this.material);
					this.meshes.push(e), this.meshesInner.add(e)
				}
				this.meshesInner.position.z = this.meshes.length * -this.settings.meshSpacing / 2
			}
			initIntroTimeline() {
				var t, e;
				(e = (t = this.introTl) == null ? void 0 : t.kill) == null || e.call(t), this.introTl = ne.timeline({
					defaults: {
						duration: 2,
						ease: "power3.inOut"
					}
				});
				for (let n = 0; n < this.meshes.length; n++) {
					let r = this.meshes[n];
					this.introTl.set(r, {
						visible: !0
					}, 0).to(r.position, {
						z: `${n*this.settings.meshSpacing}`
					}, 0).to(r.rotation, {
						z: `${n*this.settings.meshSpin}`
					}, 0)
				}
				this.introTl.to(this.uniforms.u_noise_master_amp, {
					value: 1,
					ease: "power4.inOut",
					duration: 4
				}, 0)
			}
			initScrollTimeline() {
				var t, e, n, r;
				(e = (t = this.scrollTl) == null ? void 0 : t.progress) == null || e.call(t, 0), (r = (n = this.scrollTl) == null ? void 0 : n.kill) == null || r.call(n), this.scrollTl = ne.timeline({
					defaults: {
						duration: 2,
						ease: "power2.out"
					},
					paused: !0,
					onUpdate: () => {
						var s, a;
						(a = (s = this.camera) == null ? void 0 : s.lookAt) == null || a.call(s, 0, 0, 0)
					}
				}).fromTo(this.camera.position, this.settings.camera.origin, this.settings.camera.target, 0).to(this.meshesInner.rotation, {
					z: this.settings.meshScrollSpin
				}, 0)
			}
			initCamera() {
				let {
					x: t,
					y: e,
					z: n
				} = this.settings.camera.origin;
				this.camera.position.set(t, e, n), this.orbit = new fi, this.orbit.rotation.order = "YXZ", this.orbit.position.set(0, 0, 0), this.scene.add(this.orbit), this.orbit.add(this.camera)
			}
			initTweakpane() {
				if (!Im) throw "Tweakpane not defined";
				this.pane = new Im.Pane, this.pane.registerPlugin(Sb), this.pane.hidden = !0, this.pane.containerElem_.style.position = "fixed", this.pane.containerElem_.style.zIndex = 9999, document.addEventListener("keyup", h => {
					h.key === "Escape" && (this.pane.hidden = !this.pane.hidden, this.axesHelper.visible = !this.pane.hidden)
				});
				let t = this.pane.addFolder({
					title: "Debug"
				});
				this.fpsGraph = t.addBlade({
					view: "fpsgraph",
					label: "fpsgraph",
					lineCount: 2
				}), t.addInput(this.axesHelper, "visible", {
					label: "Axes Helper"
				});
				let e = this.pane.addFolder({
					title: "Meshes"
				});
				e.addInput(this.settings, "meshQty", {
					label: "Qty",
					min: 0,
					max: 400,
					step: 1
				}).on("change", this.reset.bind(this)), e.addInput(this.settings, "meshSpacing", {
					label: "Spacing",
					min: 0,
					max: .04,
					step: 1e-4
				}).on("change", this.reset.bind(this)), e.addInput(this.settings, "meshSpin", {
					label: "Spin",
					min: -.04,
					max: .04,
					step: 1e-4
				}).on("change", this.reset.bind(this)), e.addInput(this.settings, "meshScrollSpin", {
					label: "Scroll Spin",
					min: -Math.PI * 2,
					max: Math.PI * 2
				}).on("change", this.reset.bind(this)), e.addInput(this.settings, "meshAutoRotate", {
					label: "Auto Rotate",
					z: {
						step: .001
					}
				});
				let n = this.pane.addFolder({
					title: "Camera"
				});
				n.addInput(this.camera, "position", {
					disabled: !0
				}), n.addInput(this.settings.camera, "origin").on("change", this.reset.bind(this)), n.addInput(this.settings.camera, "target").on("change", this.reset.bind(this)), n.addInput(this.settings.camera, "mouseSensitivity", {
					x: {
						min: -.001,
						max: 0
					},
					y: {
						min: -.001,
						max: 0
					}
				}).on("change", this.reset.bind(this));
				let r = this.pane.addFolder({
					title: "Uniforms"
				});
				r.addInput(this.uniforms.u_color, "value", {
					label: "Col",
					color: {
						type: "float"
					}
				}), r.addInput(this.uniforms.u_opacity, "value", {
					label: "Opacity",
					min: 0,
					max: 1
				}), r.addInput(this.uniforms.u_noise_master_amp, "value", {
					label: "Noise master",
					min: 0,
					max: 1
				});
				let s = r.addFolder({
					title: "Noise 1",
					expanded: !1
				});
				s.addInput(this.uniforms.u_noise_freq_1, "value", {
					label: "Freq",
					min: 0,
					max: 4
				}), s.addInput(this.uniforms.u_noise_amp_1, "value", {
					label: "Amp",
					min: 0,
					max: 4
				}), s.addInput(this.uniforms.u_spd_modifier_1, "value", {
					label: "Speed",
					min: 0,
					max: 2
				});
				let a = r.addFolder({
					title: "Noise 2",
					expanded: !1
				});
				a.addInput(this.uniforms.u_noise_freq_2, "value", {
					label: "Freq",
					min: 0,
					max: 4
				}), a.addInput(this.uniforms.u_noise_amp_2, "value", {
					label: "Amp",
					min: 0,
					max: 4
				}), a.addInput(this.uniforms.u_spd_modifier_2, "value", {
					label: "Speed",
					min: 0,
					max: 2
				});
				let o = this.pane.addFolder({
					title: "Actions"
				});
				o.addButton({
					title: "Reset"
				}).on("click", this.reset.bind(this)), o.addButton({
					title: "Toggle Noise"
				}).on("click", () => {
					ne.to(this.uniforms.u_noise_master_amp, {
						value: Math.floor(1 - this.uniforms.u_noise_master_amp.value)
					})
				})
			}
			updateTweakPane() {
				var t, e;
				(e = (t = this.pane) == null ? void 0 : t.refresh) == null || e.call(t)
			}
			reset() {
				this.call("scrollTo", {
					target: 0
				}, "Scroll");
				let {
					x: t,
					y: e,
					z: n
				} = this.settings.camera.origin;
				this.camera.position.set(t, e, n), this.camera.lookAt(0, 0, 0), this.meshesInner.rotation.set(0, 0, 0), this.meshesOuter.rotation.set(0, 0, 0), this.populate();
				for (let r of this.meshes) ne.set([r.position, r.rotation], {
					x: 0,
					y: 0,
					z: 0
				}, 0);
				ne.set(this.uniforms.u_noise_master_amp, {
					value: 0
				}), this.initIntroTimeline(), this.initScrollTimeline()
			}
			handleEvents() {
				window.addEventListener(Ce.READY, this.onReady = () => this.initIntroTimeline()), ie.IS_DESKTOP && window.addEventListener("mousemove", this.onMouseMove = t => this.mouseMove(t))
			}
			onResize() {
				this.sizes.width = this.$el.offsetWidth, this.sizes.height = this.$el.offsetHeight, this.uniforms && (this.uniforms.u_resolution.value.x = this.sizes.width * this.DPR, this.uniforms.u_resolution.value.y = this.sizes.height * this.DPR), this.settings.camera.origin.z = ne.utils.mapRange(500, 1500, 2 + .5 * this.SIZE, 2, this.sizes.width)
			}
			onRender(t) {
				var e, n, r, s;
				(n = (e = this.fpsGraph) == null ? void 0 : e.end) == null || n.call(e), this.uniforms.u_time.value += t, this.meshesOuter.rotation.x += this.settings.meshAutoRotate.x, this.meshesOuter.rotation.y += this.settings.meshAutoRotate.y, this.meshesOuter.rotation.z += this.settings.meshAutoRotate.z, ie.IS_DEV && this.updateTweakPane(), (s = (r = this.fpsGraph) == null ? void 0 : r.begin) == null || s.call(r)
			}
			mouseMove(t) {
				this.orbit.rotateY(t.movementX * this.settings.camera.mouseSensitivity.y), this.orbit.rotateX(t.movementY * this.settings.camera.mouseSensitivity.x), this.orbit.rotation.z = 0
			}
			onScrollProgress(t = 0) {
				var e, n;
				(n = (e = this.scrollTl) == null ? void 0 : e.progress) == null || n.call(e, t)
			}
			hide() {
				ne.set(this.$el, {
					opacity: 0
				})
			}
			show() {
				ne.to(this.$el, {
					opacity: 1,
					duration: 1,
					ease: "power2.out"
				})
			}
			destroy(t) {
				super.destroy(), window.removeEventListener(Ce.READY, this.onReady), ie.IS_DESKTOP && window.removeEventListener("mousemove", this.onMouseMove)
			}
		};
	var mi = class extends Ta {
		static get settings() {
			return {
				CLASS_DISABLED: "is-disabled",
				animationDuration: .8,
				cubePoints: new Float32Array([-1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, 1, -1, -1, 1]),
				states: [{
					rotation: {
						x: -1,
						y: 1,
						z: 0
					},
					twist: Math.PI / 2
				}, {
					rotation: {
						x: 0,
						y: -1,
						z: -1
					},
					twist: -Math.PI / 4
				}, {
					rotation: {
						x: 1,
						y: 0,
						z: 1
					},
					twist: Math.PI / 4
				}, {
					rotation: {
						x: -1,
						y: 1,
						z: 0
					},
					twist: Math.PI / 2
				}, {
					rotation: {
						x: 0,
						y: -1,
						z: 1
					},
					twist: -Math.PI / 4
				}, {
					rotation: {
						x: 1,
						y: 1,
						z: -1
					},
					twist: Math.PI / 4
				}, {
					rotation: {
						x: 1,
						y: 0,
						z: 1
					},
					twist: -Math.PI / 2
				}]
			}
		}
		constructor(t) {
			super(t), this.$el = this.el, this.$points = Array.from(this.$("point")), this.$images = Array.from(this.$("image")), this.currentIndex = -1, this.$el.removeAttribute("data-images")
		}
		onInit() {
			if (this.isDisabled = di.window.width < 1e3 || ie.REDUCED_MOTION, this.isDisabled) {
				this.$el.classList.add(mi.settings.CLASS_DISABLED);
				return
			}
			ne.set(this.$images, {
				rotationX: -90,
				yPercent: 100,
				z: -100
			}), this.camera.position.z = di.window.width > di.window.height ? 3 : 5;
			let t = new Oo({
				color: 1464296
			});
			this.geometry = new tn, this.geometry.setAttribute("position", new Ji(mi.settings.cubePoints, 3)), this.geometry.computeVertexNormals(), this.mesh = new rh(this.geometry, t), this.twist(-Math.PI / 8), this.scene.add(this.mesh), this.stop()
		}
		onResize() {
			this.sizes.width = this.$el.offsetWidth, this.sizes.height = this.$el.offsetHeight, this.isDisabled && di.window.width >= 1e3 ? (this.isDisabled = !1, this.$el.classList.remove(mi.settings.CLASS_DISABLED), this.init()) : !this.isDisabled && di.window.width < 1e3 && (this.isDisabled = !0, this.$el.classList.add(mi.settings.CLASS_DISABLED), this.renderer.domElement.remove())
		}
		animate(t) {
			if (!this.isDisabled && (this.start(), !!this.mesh))
				if (clearTimeout(this.onAnimationComplete), this.onAnimationComplete = setTimeout(() => {
						this.stop()
					}, 1e3 * mi.settings.animationDuration), this.currentIndex > -1 && (ne.to(this.$images[this.currentIndex], {
						rotationX: 45,
						yPercent: -100,
						z: -100,
						scale: .9,
						duration: .5 * mi.settings.animationDuration,
						ease: "power2.out",
						overwrite: !0
					}), ne.to(this.mesh.scale, {
						x: .8,
						y: .8,
						z: .8,
						duration: .25 * mi.settings.animationDuration,
						ease: "power2.in"
					})), t < 0) ne.set(this.mesh.rotation, {
					x: 0,
					y: 0,
					z: 0
				});
				else {
					let e = mi.settings.states[t];
					ne.to(this.mesh.rotation, {
						x: e.rotation.x,
						y: e.rotation.y,
						z: e.rotation.z,
						duration: mi.settings.animationDuration,
						ease: "power2.out"
					}), ne.to(this.mesh.scale, {
						x: 1,
						y: 1,
						z: 1,
						duration: .75 * mi.settings.animationDuration,
						delay: .25 * mi.settings.animationDuration,
						ease: "power2.out"
					}), ne.fromTo(this.$images[t], {
						rotationX: -90,
						yPercent: 100,
						z: -100,
						scale: .9
					}, {
						rotationX: 0,
						yPercent: 0,
						z: 0,
						scale: 1,
						duration: .75 * mi.settings.animationDuration,
						ease: "power2.out"
					}), this.currentIndex = t
				}
		}
		twist(t) {
			let e = new lr,
				n = new ht(0, 1, 0),
				r = this.geometry.attributes.position.array;
			for (let s = 0; s < r.length; s += 3) {
				e.setFromAxisAngle(n, r[s + 1] * t);
				let a = new ht(r[s], r[s + 1], r[s + 2]);
				a.applyQuaternion(e), r[s] = a.x, r[s + 2] = a.z
			}
			this.mesh.geometry.computeVertexNormals(), this.mesh.geometry.attributes.position.needsUpdate = !0
		}
		destroy() {}
	};

	function Lm() {
		return Lm = Object.assign ? Object.assign.bind() : function (i) {
			for (var t = 1; t < arguments.length; t++) {
				var e = arguments[t];
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (i[n] = e[n])
			}
			return i
		}, Lm.apply(this, arguments)
	}

	function Bu(i, t, e) {
		return Math.max(i, Math.min(t, e))
	}
	var km = class {
			advance(t) {
				var e;
				if (!this.isRunning) return;
				let n = !1;
				if (this.lerp) this.value = (r = this.value, s = this.to, (1 - (a = 1 - Math.exp(-60 * this.lerp * t))) * r + a * s), Math.round(this.value) === this.to && (this.value = this.to, n = !0);
				else {
					this.currentTime += t;
					let o = Bu(0, this.currentTime / this.duration, 1);
					n = o >= 1;
					let h = n ? 1 : this.easing(o);
					this.value = this.from + (this.to - this.from) * h
				}
				var r, s, a;
				(e = this.onUpdate) == null || e.call(this, this.value, n), n && this.stop()
			}
			stop() {
				this.isRunning = !1
			}
			fromTo(t, e, {
				lerp: n = .1,
				duration: r = 1,
				easing: s = h => h,
				onStart: a,
				onUpdate: o
			}) {
				this.from = this.value = t, this.to = e, this.lerp = n, this.duration = r, this.easing = s, this.currentTime = 0, this.isRunning = !0, a == null || a(), this.onUpdate = o
			}
		},
		Rm = class {
			constructor({
				wrapper: t,
				content: e,
				autoResize: n = !0
			} = {}) {
				if (this.resize = () => {
						this.onWrapperResize(), this.onContentResize()
					}, this.onWrapperResize = () => {
						this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
					}, this.onContentResize = () => {
						this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth
					}, this.wrapper = t, this.content = e, n) {
					let r = function (s, a) {
						let o;
						return function () {
							let h = arguments,
								c = this;
							clearTimeout(o), o = setTimeout(function () {
								s.apply(c, h)
							}, 250)
						}
					}(this.resize);
					this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(r), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(r), this.contentResizeObserver.observe(this.content)
				}
				this.resize()
			}
			destroy() {
				var t, e;
				(t = this.wrapperResizeObserver) == null || t.disconnect(), (e = this.contentResizeObserver) == null || e.disconnect()
			}
			get limit() {
				return {
					x: this.scrollWidth - this.width,
					y: this.scrollHeight - this.height
				}
			}
		},
		Uu = class {
			constructor() {
				this.events = {}
			}
			emit(t, ...e) {
				let n = this.events[t] || [];
				for (let r = 0, s = n.length; r < s; r++) n[r](...e)
			}
			on(t, e) {
				var n;
				return (n = this.events[t]) != null && n.push(e) || (this.events[t] = [e]), () => {
					var r;
					this.events[t] = (r = this.events[t]) == null ? void 0 : r.filter(s => e !== s)
				}
			}
			off(t, e) {
				var n;
				this.events[t] = (n = this.events[t]) == null ? void 0 : n.filter(r => e !== r)
			}
			destroy() {
				this.events = {}
			}
		},
		Fm = class {
			constructor(t, {
				wheelMultiplier: e = 1,
				touchMultiplier: n = 2,
				normalizeWheel: r = !1
			}) {
				this.onTouchStart = s => {
					let {
						clientX: a,
						clientY: o
					} = s.targetTouches ? s.targetTouches[0] : s;
					this.touchStart.x = a, this.touchStart.y = o, this.lastDelta = {
						x: 0,
						y: 0
					}
				}, this.onTouchMove = s => {
					let {
						clientX: a,
						clientY: o
					} = s.targetTouches ? s.targetTouches[0] : s, h = -(a - this.touchStart.x) * this.touchMultiplier, c = -(o - this.touchStart.y) * this.touchMultiplier;
					this.touchStart.x = a, this.touchStart.y = o, this.lastDelta = {
						x: h,
						y: c
					}, this.emitter.emit("scroll", {
						deltaX: h,
						deltaY: c,
						event: s
					})
				}, this.onTouchEnd = s => {
					this.emitter.emit("scroll", {
						deltaX: this.lastDelta.x,
						deltaY: this.lastDelta.y,
						event: s
					})
				}, this.onWheel = s => {
					let {
						deltaX: a,
						deltaY: o
					} = s;
					this.normalizeWheel && (a = Bu(-100, a, 100), o = Bu(-100, o, 100)), a *= this.wheelMultiplier, o *= this.wheelMultiplier, this.emitter.emit("scroll", {
						deltaX: a,
						deltaY: o,
						event: s
					})
				}, this.element = t, this.wheelMultiplier = e, this.touchMultiplier = n, this.normalizeWheel = r, this.touchStart = {
					x: null,
					y: null
				}, this.emitter = new Uu, this.element.addEventListener("wheel", this.onWheel, {
					passive: !1
				}), this.element.addEventListener("touchstart", this.onTouchStart, {
					passive: !1
				}), this.element.addEventListener("touchmove", this.onTouchMove, {
					passive: !1
				}), this.element.addEventListener("touchend", this.onTouchEnd, {
					passive: !1
				})
			}
			on(t, e) {
				return this.emitter.on(t, e)
			}
			destroy() {
				this.emitter.destroy(), this.element.removeEventListener("wheel", this.onWheel, {
					passive: !1
				}), this.element.removeEventListener("touchstart", this.onTouchStart, {
					passive: !1
				}), this.element.removeEventListener("touchmove", this.onTouchMove, {
					passive: !1
				}), this.element.removeEventListener("touchend", this.onTouchEnd, {
					passive: !1
				})
			}
		},
		Gu = class {
			constructor({
				wrapper: t = window,
				content: e = document.documentElement,
				wheelEventsTarget: n = t,
				eventsTarget: r = n,
				smoothWheel: s = !0,
				smoothTouch: a = !1,
				syncTouch: o = !1,
				syncTouchLerp: h = .1,
				__iosNoInertiaSyncTouchLerp: c = .4,
				touchInertiaMultiplier: u = 35,
				duration: g,
				easing: p = T => Math.min(1, 1.001 - Math.pow(2, -10 * T)),
				lerp: _ = !g && .1,
				infinite: b = !1,
				orientation: y = "vertical",
				gestureOrientation: w = "vertical",
				touchMultiplier: f = 1,
				wheelMultiplier: S = 1,
				normalizeWheel: x = !1,
				autoResize: M = !0
			} = {}) {
				this.onVirtualScroll = ({
					deltaX: T,
					deltaY: I,
					event: L
				}) => {
					if (L.ctrlKey) return;
					let F = L.type.includes("touch"),
						k = L.type.includes("wheel");
					if (this.options.gestureOrientation === "both" && T === 0 && I === 0 || this.options.gestureOrientation === "vertical" && I === 0 || this.options.gestureOrientation === "horizontal" && T === 0 || F && this.options.gestureOrientation === "vertical" && this.scroll === 0 && !this.options.infinite && I <= 0) return;
					let G = L.composedPath();
					if (G = G.slice(0, G.indexOf(this.rootElement)), G.find($ => {
							var W;
							return ($.hasAttribute == null ? void 0 : $.hasAttribute("data-lenis-prevent")) || F && ($.hasAttribute == null ? void 0 : $.hasAttribute("data-lenis-prevent-touch")) || k && ($.hasAttribute == null ? void 0 : $.hasAttribute("data-lenis-prevent-wheel")) || ((W = $.classList) == null ? void 0 : W.contains("lenis"))
						})) return;
					if (this.isStopped || this.isLocked) return void L.preventDefault();
					if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && F || this.options.smoothWheel && k, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
					L.preventDefault();
					let j = I;
					this.options.gestureOrientation === "both" ? j = Math.abs(I) > Math.abs(T) ? I : T : this.options.gestureOrientation === "horizontal" && (j = T);
					let U = F && this.options.syncTouch,
						z = F && L.type === "touchend" && Math.abs(j) > 1;
					z && (j = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + j, Lm({
						programmatic: !1
					}, U && {
						lerp: z ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp
					}))
				}, this.onNativeScroll = () => {
					if (!this.__preventNextScrollEvent && !this.isScrolling) {
						let T = this.animatedScroll;
						this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - T), this.emit()
					}
				}, window.lenisVersion = "1.0.29", t !== document.documentElement && t !== document.body || (t = window), this.options = {
					wrapper: t,
					content: e,
					wheelEventsTarget: n,
					eventsTarget: r,
					smoothWheel: s,
					smoothTouch: a,
					syncTouch: o,
					syncTouchLerp: h,
					__iosNoInertiaSyncTouchLerp: c,
					touchInertiaMultiplier: u,
					duration: g,
					easing: p,
					lerp: _,
					infinite: b,
					gestureOrientation: w,
					orientation: y,
					touchMultiplier: f,
					wheelMultiplier: S,
					normalizeWheel: x,
					autoResize: M
				}, this.animate = new km, this.emitter = new Uu, this.dimensions = new Rm({
					wrapper: t,
					content: e,
					autoResize: M
				}), this.toggleClass("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = o || s || a, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, {
					passive: !1
				}), this.virtualScroll = new Fm(r, {
					touchMultiplier: f,
					wheelMultiplier: S,
					normalizeWheel: x
				}), this.virtualScroll.on("scroll", this.onVirtualScroll)
			}
			destroy() {
				this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, {
					passive: !1
				}), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass("lenis", !1), this.toggleClass("lenis-smooth", !1), this.toggleClass("lenis-scrolling", !1), this.toggleClass("lenis-stopped", !1), this.toggleClass("lenis-locked", !1)
			}
			on(t, e) {
				return this.emitter.on(t, e)
			}
			off(t, e) {
				return this.emitter.off(t, e)
			}
			setScroll(t) {
				this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
			}
			resize() {
				this.dimensions.resize()
			}
			emit() {
				this.emitter.emit("scroll", this)
			}
			reset() {
				this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
			}
			start() {
				this.isStopped = !1, this.reset()
			}
			stop() {
				this.isStopped = !0, this.animate.stop(), this.reset()
			}
			raf(t) {
				let e = t - (this.time || t);
				this.time = t, this.animate.advance(.001 * e)
			}
			scrollTo(t, {
				offset: e = 0,
				immediate: n = !1,
				lock: r = !1,
				duration: s = this.options.duration,
				easing: a = this.options.easing,
				lerp: o = !s && this.options.lerp,
				onComplete: h = null,
				force: c = !1,
				programmatic: u = !0
			} = {}) {
				if (!this.isStopped && !this.isLocked || c) {
					if (["top", "left", "start"].includes(t)) t = 0;
					else if (["bottom", "right", "end"].includes(t)) t = this.limit;
					else {
						var g;
						let p;
						if (typeof t == "string" ? p = document.querySelector(t) : (g = t) != null && g.nodeType && (p = t), p) {
							if (this.options.wrapper !== window) {
								let b = this.options.wrapper.getBoundingClientRect();
								e -= this.isHorizontal ? b.left : b.top
							}
							let _ = p.getBoundingClientRect();
							t = (this.isHorizontal ? _.left : _.top) + this.animatedScroll
						}
					}
					if (typeof t == "number") {
						if (t += e, t = Math.round(t), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : t = Bu(0, t, this.limit), n) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), void(h == null || h(this));
						if (!u) {
							if (t === this.targetScroll) return;
							this.targetScroll = t
						}
						this.animate.fromTo(this.animatedScroll, t, {
							duration: s,
							easing: a,
							lerp: o,
							onStart: () => {
								r && (this.isLocked = !0), this.isScrolling = !0
							},
							onUpdate: (p, _) => {
								this.isScrolling = !0, this.velocity = p - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = p, this.setScroll(this.scroll), u && (this.targetScroll = p), _ || this.emit(), _ && (this.reset(), this.emit(), h == null || h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {
									delete this.__preventNextScrollEvent
								}))
							}
						})
					}
				}
			}
			get rootElement() {
				return this.options.wrapper === window ? document.documentElement : this.options.wrapper
			}
			get limit() {
				return this.dimensions.limit[this.isHorizontal ? "x" : "y"]
			}
			get isHorizontal() {
				return this.options.orientation === "horizontal"
			}
			get actualScroll() {
				return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
			}
			get scroll() {
				return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;
				var t
			}
			get progress() {
				return this.limit === 0 ? 1 : this.scroll / this.limit
			}
			get isSmooth() {
				return this.__isSmooth
			}
			set isSmooth(t) {
				this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClass("lenis-smooth", t))
			}
			get isScrolling() {
				return this.__isScrolling
			}
			set isScrolling(t) {
				this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClass("lenis-scrolling", t))
			}
			get isStopped() {
				return this.__isStopped
			}
			set isStopped(t) {
				this.__isStopped !== t && (this.__isStopped = t, this.toggleClass("lenis-stopped", t))
			}
			get isLocked() {
				return this.__isLocked
			}
			set isLocked(t) {
				this.__isLocked !== t && (this.__isLocked = t, this.toggleClass("lenis-locked", t))
			}
			get className() {
				let t = "lenis";
				return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), this.isSmooth && (t += " lenis-smooth"), t
			}
			toggleClass(t, e) {
				this.rootElement.classList.toggle(t, e), this.emitter.emit("className change", this)
			}
		};

	function Om() {
		return Om = Object.assign ? Object.assign.bind() : function (i) {
			for (var t = 1; t < arguments.length; t++) {
				var e = arguments[t];
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (i[n] = e[n])
			}
			return i
		}, Om.apply(this, arguments)
	}
	var Hu = class {
		constructor({
			scrollElements: t,
			rootMargin: e = "-1px -1px -1px -1px",
			IORaf: n
		}) {
			this.scrollElements = void 0, this.rootMargin = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = t, this.rootMargin = e, this.IORaf = n, this._init()
		}
		_init() {
			this.observer = new IntersectionObserver(t => {
				t.forEach(e => {
					let n = this.scrollElements.find(r => r.$el === e.target);
					e.isIntersecting ? (n && (n.isAlreadyIntersected = !0), this._setInview(e)) : n && n.isAlreadyIntersected && this._setOutOfView(e)
				})
			}, {
				rootMargin: this.rootMargin
			});
			for (let t of this.scrollElements) this.observe(t.$el)
		}
		destroy() {
			this.observer.disconnect()
		}
		observe(t) {
			t && this.observer.observe(t)
		}
		unobserve(t) {
			t && this.observer.unobserve(t)
		}
		_setInview(t) {
			let e = this.scrollElements.find(n => n.$el === t.target);
			this.IORaf && (e == null || e.setInteractivityOn()), !this.IORaf && (e == null || e.setInview())
		}
		_setOutOfView(t) {
			let e = this.scrollElements.find(n => n.$el === t.target);
			this.IORaf && (e == null || e.setInteractivityOff()), !this.IORaf && (e == null || e.setOutOfView()), e != null && e.attributes.scrollRepeat || this.IORaf || this.unobserve(t.target)
		}
	};

	function Eb(i, t, e, n, r) {
		return e + ((r - i) / (t - i) * (n - e) || 0)
	}

	function Mb(i, t) {
		return i.reduce((e, n) => Math.abs(n - t) < Math.abs(e - t) ? n : e)
	}
	var Nm = class {
			constructor({
				$el: t,
				id: e,
				modularInstance: n,
				subscribeElementUpdateFn: r,
				unsubscribeElementUpdateFn: s,
				needRaf: a,
				scrollOrientation: o
			}) {
				var h, c, u, g, p;
				this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.modularInstance = void 0, this.progressModularModules = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.$el = t, this.id = e, this.needRaf = a, this.scrollOrientation = o, this.modularInstance = n, this.subscribeElementUpdateFn = r, this.unsubscribeElementUpdateFn = s, this.attributes = {
					scrollClass: (h = this.$el.dataset.scrollClass) != null ? h : "is-inview",
					scrollOffset: (c = this.$el.dataset.scrollOffset) != null ? c : "0,0",
					scrollPosition: (u = this.$el.dataset.scrollPosition) != null ? u : "start,end",
					scrollModuleProgress: this.$el.dataset.scrollModuleProgress != null,
					scrollCssProgress: this.$el.dataset.scrollCssProgress != null,
					scrollEventProgress: (g = this.$el.dataset.scrollEventProgress) != null ? g : null,
					scrollSpeed: this.$el.dataset.scrollSpeed != null ? parseFloat(this.$el.dataset.scrollSpeed) : null,
					scrollRepeat: this.$el.dataset.scrollRepeat != null,
					scrollCall: (p = this.$el.dataset.scrollCall) != null ? p : null,
					scrollCallSelf: this.$el.dataset.scrollCallSelf != null,
					scrollIgnoreFold: this.$el.dataset.scrollIgnoreFold != null,
					scrollEnableTouchSpeed: this.$el.dataset.scrollEnableTouchSpeed != null
				}, this.intersection = {
					start: 0,
					end: 0
				}, this.metrics = {
					offsetStart: 0,
					offsetEnd: 0,
					bcr: {}
				}, this.currentScroll = this.scrollOrientation === "vertical" ? window.scrollY : window.scrollX, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.progressModularModules = [], this.isInview = !1, this.isInteractive = !1, this.isAlreadyIntersected = !1, this.isInFold = !1, this.isFirstResize = !0, this._init()
			}
			_init() {
				this.needRaf && (this.modularInstance && this.attributes.scrollModuleProgress && this._getProgressModularModules(), this._resize())
			}
			onResize({
				currentScroll: t
			}) {
				this.currentScroll = t, this._resize()
			}
			onRender({
				currentScroll: t,
				smooth: e
			}) {
				let n = this.scrollOrientation === "vertical" ? window.innerHeight : window.innerWidth;
				if (this.currentScroll = t, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed))
					if (this.attributes.scrollEnableTouchSpeed || e) {
						if (this.isInFold) {
							let r = Math.max(0, this.progress);
							this.translateValue = r * n * this.attributes.scrollSpeed * -1
						} else {
							let r = Eb(0, 1, -1, 1, this.progress);
							this.translateValue = r * n * this.attributes.scrollSpeed * -1
						}
						this.$el.style.transform = this.scrollOrientation === "vertical" ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`
					} else this.translateValue && (this.$el.style.transform = "translate3d(0, 0, 0)"), this.translateValue = 0
			}
			setInview() {
				if (this.isInview) return;
				this.isInview = !0, this.$el.classList.add(this.attributes.scrollClass);
				let t = this._getScrollCallFrom();
				this.attributes.scrollCall && this._dispatchCall("enter", t)
			}
			setOutOfView() {
				if (!this.isInview || !this.attributes.scrollRepeat) return;
				this.isInview = !1, this.$el.classList.remove(this.attributes.scrollClass);
				let t = this._getScrollCallFrom();
				this.attributes.scrollCall && this._dispatchCall("leave", t)
			}
			setInteractivityOn() {
				this.isInteractive || (this.isInteractive = !0, this.subscribeElementUpdateFn(this))
			}
			setInteractivityOff() {
				this.isInteractive && (this.isInteractive = !1, this.unsubscribeElementUpdateFn(this), this.lastProgress != null && this._computeProgress(Mb([0, 1], this.lastProgress)))
			}
			_resize() {
				this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = !1, this.isInFold && this.setInview())
			}
			_computeMetrics() {
				let {
					top: t,
					left: e,
					height: n,
					width: r
				} = this.metrics.bcr, s = this.scrollOrientation === "vertical" ? window.innerHeight : window.innerWidth, a = this.scrollOrientation === "vertical" ? n : r;
				this.metrics.offsetStart = this.currentScroll + (this.scrollOrientation === "vertical" ? t : e) - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + a, this.isInFold = this.metrics.offsetStart < s && !this.attributes.scrollIgnoreFold
			}
			_computeIntersection() {
				let t = this.scrollOrientation === "vertical" ? window.innerHeight : window.innerWidth,
					e = this.scrollOrientation === "vertical" ? this.metrics.bcr.height : this.metrics.bcr.width,
					n = this.attributes.scrollOffset.split(","),
					r = n[0] != null ? n[0].trim() : "0",
					s = n[1] != null ? n[1].trim() : "0",
					a = this.attributes.scrollPosition.split(","),
					o = a[0] != null ? a[0].trim() : "start",
					h = a[1] != null ? a[1].trim() : "end",
					c = r.includes("%") ? t * parseInt(r.replace("%", "").trim()) * .01 : parseInt(r),
					u = s.includes("%") ? t * parseInt(s.replace("%", "").trim()) * .01 : parseInt(s);
				switch (this.isInFold && (o = "fold"), o) {
					case "start":
					default:
						this.intersection.start = this.metrics.offsetStart - t + c;
						break;
					case "middle":
						this.intersection.start = this.metrics.offsetStart - t + c + .5 * e;
						break;
					case "end":
						this.intersection.start = this.metrics.offsetStart - t + c + e;
						break;
					case "fold":
						this.intersection.start = 0
				}
				switch (h) {
					case "start":
						this.intersection.end = this.metrics.offsetStart - u;
						break;
					case "middle":
						this.intersection.end = this.metrics.offsetStart - u + .5 * e;
						break;
					default:
						this.intersection.end = this.metrics.offsetStart - u + e
				}
				if (this.intersection.end <= this.intersection.start) switch (h) {
					case "start":
					default:
						this.intersection.end = this.intersection.start + 1;
						break;
					case "middle":
						this.intersection.end = this.intersection.start + .5 * e;
						break;
					case "end":
						this.intersection.end = this.intersection.start + e
				}
			}
			_computeProgress(t) {
				let e = t != null ? t : (n = Eb(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : n > 1 ? 1 : n;
				var n;
				if (this.progress = e, e != this.lastProgress) {
					if (this.lastProgress = e, this.attributes.scrollCssProgress && this._setCssProgress(e), this.attributes.scrollEventProgress && this._setCustomEventProgress(e), this.attributes.scrollModuleProgress)
						for (let r of this.progressModularModules) this.modularInstance && this.modularInstance.call("onScrollProgress", e, r.moduleName, r.moduleId);
					e > 0 && e < 1 && this.setInview(), e === 0 && this.setOutOfView(), e === 1 && this.setOutOfView()
				}
			}
			_setCssProgress(t = 0) {
				this.$el.style.setProperty("--progress", t.toString())
			}
			_setCustomEventProgress(t = 0) {
				let e = this.attributes.scrollEventProgress;
				if (!e) return;
				let n = new CustomEvent(e, {
					detail: {
						target: this.$el,
						progress: t
					}
				});
				window.dispatchEvent(n)
			}
			_getProgressModularModules() {
				if (!this.modularInstance) return;
				let t = Object.keys(this.$el.dataset).filter(n => n.includes("module")),
					e = Object.entries(this.modularInstance.modules);
				if (t.length)
					for (let n of t) {
						let r = this.$el.dataset[n];
						if (!r) return;
						for (let s of e) {
							let [a, o] = s;
							r in o && this.progressModularModules.push({
								moduleName: a,
								moduleId: r
							})
						}
					}
			}
			_getScrollCallFrom() {
				let t = Mb([this.intersection.start, this.intersection.end], this.currentScroll);
				return this.intersection.start === t ? "start" : "end"
			}
			_dispatchCall(t, e) {
				var n, r;
				let s = (n = this.attributes.scrollCall) == null ? void 0 : n.split(","),
					a = (r = this.attributes) == null ? void 0 : r.scrollCallSelf;
				if (s && s.length > 1) {
					var o;
					let [h, c, u] = s, g;
					g = a ? this.$el.dataset[`module${c.trim()}`] : u, this.modularInstance && this.modularInstance.call(h.trim(), {
						target: this.$el,
						way: t,
						from: e
					}, c.trim(), (o = g) == null ? void 0 : o.trim())
				} else if (s) {
					let [h] = s, c = new CustomEvent(h, {
						detail: {
							target: this.$el,
							way: t,
							from: e
						}
					});
					window.dispatchEvent(c)
				}
			}
		},
		C2 = ["scrollOffset", "scrollPosition", "scrollModuleProgress", "scrollCssProgress", "scrollEventProgress", "scrollSpeed"],
		Vm = class {
			constructor({
				$el: t,
				modularInstance: e,
				triggerRootMargin: n,
				rafRootMargin: r,
				scrollOrientation: s
			}) {
				this.$scrollContainer = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, t ? (this.$scrollContainer = t, this.modularInstance = e, this.scrollOrientation = s, this.triggerRootMargin = n != null ? n : "-1px -1px -1px -1px", this.rafRootMargin = r != null ? r : "100% 100% 100% 100%", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error("Please provide a DOM Element as scrollContainer")
			}
			_init() {
				let t = this.$scrollContainer.querySelectorAll("[data-scroll]"),
					e = Array.from(t);
				this._subscribeScrollElements(e), this.IOTriggerInstance = new Hu({
					scrollElements: [...this.triggeredScrollElements],
					rootMargin: this.triggerRootMargin,
					IORaf: !1
				}), this.IORafInstance = new Hu({
					scrollElements: [...this.RAFScrollElements],
					rootMargin: this.rafRootMargin,
					IORaf: !0
				})
			}
			destroy() {
				this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements()
			}
			onResize({
				currentScroll: t
			}) {
				for (let e of this.RAFScrollElements) e.onResize({
					currentScroll: t
				})
			}
			onRender({
				currentScroll: t,
				smooth: e
			}) {
				for (let n of this.scrollElementsToUpdate) n.onRender({
					currentScroll: t,
					smooth: e
				})
			}
			removeScrollElements(t) {
				let e = t.querySelectorAll("[data-scroll]");
				if (e.length) {
					for (let n = 0; n < this.triggeredScrollElements.length; n++) {
						let r = this.triggeredScrollElements[n];
						Array.from(e).indexOf(r.$el) > -1 && (this.IOTriggerInstance.unobserve(r.$el), this.triggeredScrollElements.splice(n, 1))
					}
					for (let n = 0; n < this.RAFScrollElements.length; n++) {
						let r = this.RAFScrollElements[n];
						Array.from(e).indexOf(r.$el) > -1 && (this.IORafInstance.unobserve(r.$el), this.RAFScrollElements.splice(n, 1))
					}
					e.forEach(n => {
						let r = this.scrollElementsToUpdate.find(a => a.$el === n),
							s = this.scrollElements.find(a => a.$el === n);
						r && this._unsubscribeElementUpdate(r), s && (this.scrollElements = this.scrollElements.filter(a => a.id != s.id))
					})
				}
			}
			addScrollElements(t) {
				let e = t.querySelectorAll("[data-scroll]"),
					n = [];
				this.scrollElements.forEach(a => {
					n.push(a.id)
				});
				let r = Math.max(...n) + 1,
					s = Array.from(e);
				this._subscribeScrollElements(s, r, !0)
			}
			_subscribeScrollElements(t, e = 0, n = !1) {
				for (let r = 0; r < t.length; r++) {
					let s = t[r],
						a = this._checkRafNeeded(s),
						o = new Nm({
							$el: s,
							id: e + r,
							scrollOrientation: this.scrollOrientation,
							modularInstance: this.modularInstance,
							subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),
							unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),
							needRaf: a
						});
					this.scrollElements.push(o), a ? (this.RAFScrollElements.push(o), n && (this.IORafInstance.scrollElements.push(o), this.IORafInstance.observe(o.$el))) : (this.triggeredScrollElements.push(o), n && (this.IOTriggerInstance.scrollElements.push(o), this.IOTriggerInstance.observe(o.$el)))
				}
			}
			_unsubscribeAllScrollElements() {
				this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = []
			}
			_subscribeElementUpdate(t) {
				this.scrollElementsToUpdate.push(t)
			}
			_unsubscribeElementUpdate(t) {
				this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(e => e.id != t.id)
			}
			_checkRafNeeded(t) {
				let e = [...C2],
					n = r => {
						e = e.filter(s => s != r)
					};
				if (t.dataset.scrollOffset) {
					if (t.dataset.scrollOffset.split(",").map(r => r.replace("%", "").trim()).join(",") != "0,0") return !0;
					n("scrollOffset")
				} else n("scrollOffset");
				if (t.dataset.scrollPosition) {
					if (t.dataset.scrollPosition.trim() != "top,bottom") return !0;
					n("scrollPosition")
				} else n("scrollPosition");
				if (t.dataset.scrollSpeed && !isNaN(parseFloat(t.dataset.scrollSpeed))) return !0;
				n("scrollSpeed");
				for (let r of e)
					if (r in t.dataset) return !0;
				return !1
			}
		},
		zm = class {
			constructor({
				resizeElements: t,
				resizeCallback: e = () => {}
			}) {
				this.$resizeElements = void 0, this.isFirstObserve = void 0, this.observer = void 0, this.resizeCallback = void 0, this.$resizeElements = t, this.resizeCallback = e, this.isFirstObserve = !0, this._init()
			}
			_init() {
				this.observer = new ResizeObserver(t => {
					var e;
					!this.isFirstObserve && ((e = this.resizeCallback) == null || e.call(this)), this.isFirstObserve = !1
				});
				for (let t of this.$resizeElements) this.observer.observe(t)
			}
			destroy() {
				this.observer.disconnect()
			}
		},
		Cb = {
			wrapper: window,
			content: document.documentElement,
			eventsTarget: window,
			lerp: .1,
			duration: .75,
			orientation: "vertical",
			gestureOrientation: "vertical",
			smoothWheel: !0,
			smoothTouch: !1,
			syncTouch: !1,
			syncTouchLerp: .1,
			touchInertiaMultiplier: 35,
			wheelMultiplier: 1,
			touchMultiplier: 2,
			normalizeWheel: !1,
			autoResize: !0,
			easing: i => Math.min(1, 1.001 - Math.pow(2, -10 * i))
		},
		Wu = class {
			constructor({
				lenisOptions: t = {},
				modularInstance: e,
				triggerRootMargin: n,
				rafRootMargin: r,
				autoResize: s = !0,
				autoStart: a = !0,
				scrollCallback: o = () => {},
				initCustomTicker: h,
				destroyCustomTicker: c
			} = {}) {
				this.rafPlaying = void 0, this.lenisInstance = void 0, this.coreInstance = void 0, this.lenisOptions = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoResize = void 0, this.autoStart = void 0, this.ROInstance = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0, this.lenisOptions = Om({}, Cb, t), Object.assign(this, {
					lenisOptions: t,
					modularInstance: e,
					triggerRootMargin: n,
					rafRootMargin: r,
					autoResize: s,
					autoStart: a,
					scrollCallback: o,
					initCustomTicker: h,
					destroyCustomTicker: c
				}), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = !1, this._init()
			}
			_init() {
				var t;
				this.lenisInstance = new Gu({
					wrapper: this.lenisOptions.wrapper,
					content: this.lenisOptions.content,
					eventsTarget: this.lenisOptions.eventsTarget,
					lerp: this.lenisOptions.lerp,
					duration: this.lenisOptions.duration,
					orientation: this.lenisOptions.orientation,
					gestureOrientation: this.lenisOptions.gestureOrientation,
					smoothWheel: this.lenisOptions.smoothWheel,
					smoothTouch: this.lenisOptions.smoothTouch,
					syncTouch: this.lenisOptions.syncTouch,
					syncTouchLerp: this.lenisOptions.syncTouchLerp,
					touchInertiaMultiplier: this.lenisOptions.touchInertiaMultiplier,
					wheelMultiplier: this.lenisOptions.wheelMultiplier,
					touchMultiplier: this.lenisOptions.touchMultiplier,
					normalizeWheel: this.lenisOptions.normalizeWheel,
					easing: this.lenisOptions.easing
				}), (t = this.lenisInstance) == null || t.on("scroll", this.scrollCallback), document.documentElement.setAttribute("data-scroll-orientation", this.lenisInstance.options.orientation), requestAnimationFrame(() => {
					this.coreInstance = new Vm({
						$el: this.lenisInstance.rootElement,
						modularInstance: this.modularInstance,
						triggerRootMargin: this.triggerRootMargin,
						rafRootMargin: this.rafRootMargin,
						scrollOrientation: this.lenisInstance.options.orientation
					}), this._bindEvents(), this.initCustomTicker && !this.destroyCustomTicker ? console.warn("initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.") : !this.initCustomTicker && this.destroyCustomTicker && console.warn("destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."), this.autoStart && this.start()
				})
			}
			destroy() {
				var t;
				this.stop(), this._unbindEvents(), this.lenisInstance.destroy(), (t = this.coreInstance) == null || t.destroy(), requestAnimationFrame(() => {
					var e;
					(e = this.coreInstance) == null || e.destroy()
				})
			}
			_bindEvents() {
				this._bindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance = new zm({
					resizeElements: [document.body],
					resizeCallback: this._onResizeBind
				}) : window.addEventListener("resize", this._onResizeBind))
			}
			_unbindEvents() {
				this._unbindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance && this.ROInstance.destroy() : window.removeEventListener("resize", this._onResizeBind))
			}
			_bindScrollToEvents(t) {
				let e = t || this.lenisInstance.rootElement,
					n = e == null ? void 0 : e.querySelectorAll("[data-scroll-to]");
				n != null && n.length && n.forEach(r => {
					r.addEventListener("click", this._onScrollToBind, !1)
				})
			}
			_unbindScrollToEvents(t) {
				let e = t || this.lenisInstance.rootElement,
					n = e == null ? void 0 : e.querySelectorAll("[data-scroll-to]");
				n != null && n.length && n.forEach(r => {
					r.removeEventListener("click", this._onScrollToBind, !1)
				})
			}
			_onResize() {
				requestAnimationFrame(() => {
					var t;
					(t = this.coreInstance) == null || t.onResize({
						currentScroll: this.lenisInstance.scroll
					})
				})
			}
			_onRender() {
				var t, e;
				(t = this.lenisInstance) == null || t.raf(Date.now()), (e = this.coreInstance) == null || e.onRender({
					currentScroll: this.lenisInstance.scroll,
					smooth: this.lenisInstance.isSmooth
				})
			}
			_onScrollTo(t) {
				var e;
				t.preventDefault();
				let n = (e = t.currentTarget) != null ? e : null;
				if (!n) return;
				let r = n.getAttribute("data-scroll-to-href") || n.getAttribute("href"),
					s = n.getAttribute("data-scroll-to-offset") || 0,
					a = n.getAttribute("data-scroll-to-duration") || this.lenisOptions.duration || Cb.duration;
				r && this.scrollTo(r, {
					offset: typeof s == "string" ? parseInt(s) : s,
					duration: typeof a == "string" ? parseInt(a) : a
				})
			}
			start() {
				var t;
				this.rafPlaying || ((t = this.lenisInstance) == null || t.start(), this.rafPlaying = !0, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf())
			}
			stop() {
				var t;
				this.rafPlaying && ((t = this.lenisInstance) == null || t.stop(), this.rafPlaying = !1, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance))
			}
			removeScrollElements(t) {
				var e;
				t ? (this._unbindScrollToEvents(t), (e = this.coreInstance) == null || e.removeScrollElements(t)) : console.error("Please provide a DOM Element as $oldContainer")
			}
			addScrollElements(t) {
				var e;
				t ? ((e = this.coreInstance) == null || e.addScrollElements(t), requestAnimationFrame(() => {
					this._bindScrollToEvents(t)
				})) : console.error("Please provide a DOM Element as $newContainer")
			}
			resize() {
				this._onResizeBind()
			}
			scrollTo(t, e) {
				var n;
				(n = this.lenisInstance) == null || n.scrollTo(t, {
					offset: e == null ? void 0 : e.offset,
					lerp: e == null ? void 0 : e.lerp,
					duration: e == null ? void 0 : e.duration,
					immediate: e == null ? void 0 : e.immediate,
					lock: e == null ? void 0 : e.lock,
					force: e == null ? void 0 : e.force,
					easing: e == null ? void 0 : e.easing,
					onComplete: e == null ? void 0 : e.onComplete
				})
			}
			_raf() {
				this._onRenderBind(), this.rafInstance = requestAnimationFrame(() => this._raf())
			}
		};
	var $u = class extends pe {
		constructor(i) {
			super(i)
		}
		init() {
			history.scrollRestoration && (history.scrollRestoration = "manual", window.scrollTo(0, 0)), this.scroll = new Wu({
				modularInstance: this,
				scrollCallback: this.onScroll.bind(this),
				initCustomTicker: t => ne.ticker.add(t),
				destroyCustomTicker: t => ne.ticker.remove(t)
			}), this.scroll.lenisInstance.on("scroll", t => {
				this.call("updateVelocity", t.velocity, "Rail")
			}), this.scroll.lenisInstance.options.content.addEventListener("wheel", t => {
				t.composedPath().some(r => r.id === "cc-main") && t.stopPropagation()
			}), this.$anchors = document.querySelectorAll('a[href^="#"]'), this.anchorEventListeners = [], this.$anchors.forEach((t, e) => {
				this.anchorEventListeners.push(n => {
					n.preventDefault(), this.scrollTo({
						target: t.getAttribute("href")
					})
				}), t.addEventListener("click", this.anchorEventListeners[e])
			});
			let i = window.location.hash;
			i && (this.scrollTo({
				target: i,
				immediate: !0
			}), this.call("setReduced", !0, "Header"))
		}
		onScroll(i) {
			let t = i.direction;
			t !== 0 && this.call("setReduced", i.scroll > 120 && t > 0, "Header")
		}
		scrollTo(i) {
			var s;
			let r = i,
				{
					target: t
				} = r,
				e = Jv(r, ["target"]),
				n = Object.assign({
					duration: 1,
					ease: zp.easeInOut,
					offset: -di.headerHeight
				}, e);
			(s = this.scroll) == null || s.scrollTo(t, n)
		}
		lock(i = !0) {
			var t, e;
			i ? (t = this.scroll) == null || t.lenisInstance.stop() : (e = this.scroll) == null || e.lenisInstance.start()
		}
		removeScrollElements(i) {
			var t;
			(t = this.scroll) == null || t.removeScrollElements(i)
		}
		addScrollElements(i) {
			var t;
			(t = this.scroll) == null || t.addScrollElements(i)
		}
		update() {
			var i, t;
			(t = (i = this.scroll) == null ? void 0 : i.lenisInstance) == null || t.resize()
		}
		destroy() {
			var i;
			(i = this.scroll) == null || i.destroy(), this.$anchors.forEach((t, e) => {
				t.removeEventListener("click", this.anchorEventListeners[e])
			})
		}
	};
	var qu = class extends pe {
		constructor(i) {
			super(i), this.$button = this.$("button")[0], this.events = {
				click: {
					button: "onClick"
				}
			}
		}
		onClick(i) {
			i.preventDefault();
			let t = document.querySelector("#page[tabindex]"),
				e = t.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'),
				n = e.length > 0 ? e[0] : t;
			n && (this.call("scrollTo", {
				target: n
			}, "Scroll"), n.focus())
		}
		setFocusable(i = !0) {
			i ? this.$button.removeAttribute("tabindex") : this.$button.setAttribute("tabindex", "-1")
		}
	};

	function Tb(i, t) {
		for (var e = 0; e < t.length; e++) {
			var n = t[e];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n)
		}
	}

	function T2(i, t, e) {
		return t && Tb(i.prototype, t), e && Tb(i, e), Object.defineProperty(i, "prototype", {
			writable: !1
		}), i
	}
	var Pb = "(prefers-reduced-motion: reduce)",
		Go = 1,
		P2 = 2,
		$o = 3,
		jo = 4,
		yh = 5,
		Xu = 6,
		Ju = 7,
		A2 = {
			CREATED: Go,
			MOUNTED: P2,
			IDLE: $o,
			MOVING: jo,
			SCROLLING: yh,
			DRAGGING: Xu,
			DESTROYED: Ju
		};

	function Wr(i) {
		i.length = 0
	}

	function Ds(i, t, e) {
		return Array.prototype.slice.call(i, t, e)
	}

	function Ne(i) {
		return i.bind.apply(i, [null].concat(Ds(arguments, 1)))
	}
	var Gb = setTimeout,
		Wm = function () {};

	function Ab(i) {
		return requestAnimationFrame(i)
	}

	function id(i, t) {
		return typeof t === i
	}

	function uh(i) {
		return !Zm(i) && id("object", i)
	}
	var Km = Array.isArray,
		Hb = Ne(id, "function"),
		Ts = Ne(id, "string"),
		bh = Ne(id, "undefined");

	function Zm(i) {
		return i === null
	}

	function Wb(i) {
		try {
			return i instanceof(i.ownerDocument.defaultView || window).HTMLElement
		} catch (t) {
			return !1
		}
	}

	function xh(i) {
		return Km(i) ? i : [i]
	}

	function Pn(i, t) {
		xh(i).forEach(t)
	}

	function Jm(i, t) {
		return i.indexOf(t) > -1
	}

	function Yu(i, t) {
		return i.push.apply(i, xh(t)), i
	}

	function Ur(i, t, e) {
		i && Pn(t, function (n) {
			n && i.classList[e ? "add" : "remove"](n)
		})
	}

	function hr(i, t) {
		Ur(i, Ts(t) ? t.split(" ") : t, !0)
	}

	function wh(i, t) {
		Pn(t, i.appendChild.bind(i))
	}

	function Qm(i, t) {
		Pn(i, function (e) {
			var n = (t || e).parentNode;
			n && n.insertBefore(e, t)
		})
	}

	function dh(i, t) {
		return Wb(i) && (i.msMatchesSelector || i.matches).call(i, t)
	}

	function $b(i, t) {
		var e = i ? Ds(i.children) : [];
		return t ? e.filter(function (n) {
			return dh(n, t)
		}) : e
	}

	function Sh(i, t) {
		return t ? $b(i, t)[0] : i.firstElementChild
	}
	var ph = Object.keys;

	function Aa(i, t, e) {
		return i && (e ? ph(i).reverse() : ph(i)).forEach(function (n) {
			n !== "__proto__" && t(i[n], n)
		}), i
	}

	function fh(i) {
		return Ds(arguments, 1).forEach(function (t) {
			Aa(t, function (e, n) {
				i[n] = t[n]
			})
		}), i
	}

	function Cs(i) {
		return Ds(arguments, 1).forEach(function (t) {
			Aa(t, function (e, n) {
				Km(e) ? i[n] = e.slice() : uh(e) ? i[n] = Cs({}, uh(i[n]) ? i[n] : {}, e) : i[n] = e
			})
		}), i
	}

	function Db(i, t) {
		Pn(t || ph(i), function (e) {
			delete i[e]
		})
	}

	function cr(i, t) {
		Pn(i, function (e) {
			Pn(t, function (n) {
				e && e.removeAttribute(n)
			})
		})
	}

	function oe(i, t, e) {
		uh(t) ? Aa(t, function (n, r) {
			oe(i, r, n)
		}) : Pn(i, function (n) {
			Zm(e) || e === "" ? cr(n, t) : n.setAttribute(t, String(e))
		})
	}

	function Ho(i, t, e) {
		var n = document.createElement(i);
		return t && (Ts(t) ? hr(n, t) : oe(n, t)), e && wh(e, n), n
	}

	function Gn(i, t, e) {
		if (bh(e)) return getComputedStyle(i)[t];
		Zm(e) || (i.style[t] = "" + e)
	}

	function mh(i, t) {
		Gn(i, "display", t)
	}

	function qb(i) {
		i.setActive && i.setActive() || i.focus({
			preventScroll: !0
		})
	}

	function Hn(i, t) {
		return i.getAttribute(t)
	}

	function Ib(i, t) {
		return i && i.classList.contains(t)
	}

	function Cn(i) {
		return i.getBoundingClientRect()
	}

	function Da(i) {
		Pn(i, function (t) {
			t && t.parentNode && t.parentNode.removeChild(t)
		})
	}

	function jb(i) {
		return Sh(new DOMParser().parseFromString(i, "text/html").body)
	}

	function Br(i, t) {
		i.preventDefault(), t && (i.stopPropagation(), i.stopImmediatePropagation())
	}

	function Xb(i, t) {
		return i && i.querySelector(t)
	}

	function tv(i, t) {
		return t ? Ds(i.querySelectorAll(t)) : []
	}

	function Gr(i, t) {
		Ur(i, t, !1)
	}

	function $m(i) {
		return i.timeStamp
	}

	function Pa(i) {
		return Ts(i) ? i : i ? i + "px" : ""
	}
	var Eh = "splide",
		ev = "data-" + Eh;

	function hh(i, t) {
		if (!i) throw new Error("[" + Eh + "] " + (t || ""))
	}
	var Ps = Math.min,
		Qu = Math.max,
		td = Math.floor,
		vh = Math.ceil,
		en = Math.abs;

	function Yb(i, t, e) {
		return en(i - t) < e
	}

	function Ku(i, t, e, n) {
		var r = Ps(t, e),
			s = Qu(t, e);
		return n ? r < i && i < s : r <= i && i <= s
	}

	function Bo(i, t, e) {
		var n = Ps(t, e),
			r = Qu(t, e);
		return Ps(Qu(n, i), r)
	}

	function qm(i) {
		return +(i > 0) - +(i < 0)
	}

	function jm(i, t) {
		return Pn(t, function (e) {
			i = i.replace("%s", "" + e)
		}), i
	}

	function iv(i) {
		return i < 10 ? "0" + i : "" + i
	}
	var Lb = {};

	function D2(i) {
		return "" + i + iv(Lb[i] = (Lb[i] || 0) + 1)
	}

	function Kb() {
		var i = [];

		function t(a, o, h, c) {
			r(a, o, function (u, g, p) {
				var _ = "addEventListener" in u,
					b = _ ? u.removeEventListener.bind(u, g, h, c) : u.removeListener.bind(u, h);
				_ ? u.addEventListener(g, h, c) : u.addListener(h), i.push([u, g, p, h, b])
			})
		}

		function e(a, o, h) {
			r(a, o, function (c, u, g) {
				i = i.filter(function (p) {
					return p[0] === c && p[1] === u && p[2] === g && (!h || p[3] === h) ? (p[4](), !1) : !0
				})
			})
		}

		function n(a, o, h) {
			var c, u = !0;
			return typeof CustomEvent == "function" ? c = new CustomEvent(o, {
				bubbles: u,
				detail: h
			}) : (c = document.createEvent("CustomEvent"), c.initCustomEvent(o, u, !1, h)), a.dispatchEvent(c), c
		}

		function r(a, o, h) {
			Pn(a, function (c) {
				c && Pn(o, function (u) {
					u.split(" ").forEach(function (g) {
						var p = g.split(".");
						h(c, p[0], p[1])
					})
				})
			})
		}

		function s() {
			i.forEach(function (a) {
				a[4]()
			}), Wr(i)
		}
		return {
			bind: t,
			unbind: e,
			dispatch: n,
			destroy: s
		}
	}
	var La = "mounted",
		kb = "ready",
		As = "move",
		Mh = "moved",
		Zb = "click",
		I2 = "active",
		L2 = "inactive",
		k2 = "visible",
		R2 = "hidden",
		hi = "refresh",
		nn = "updated",
		gh = "resize",
		nv = "resized",
		F2 = "drag",
		O2 = "dragging",
		N2 = "dragged",
		rv = "scroll",
		Xo = "scrolled",
		V2 = "overflow",
		Jb = "destroy",
		z2 = "arrows:mounted",
		B2 = "arrows:updated",
		U2 = "pagination:mounted",
		G2 = "pagination:updated",
		Qb = "navigation:mounted",
		tx = "autoplay:play",
		H2 = "autoplay:playing",
		ex = "autoplay:pause",
		ix = "lazyload:loaded",
		nx = "sk",
		rx = "sh",
		ed = "ei";

	function We(i) {
		var t = i ? i.event.bus : document.createDocumentFragment(),
			e = Kb();

		function n(s, a) {
			e.bind(t, xh(s).join(" "), function (o) {
				a.apply(a, Km(o.detail) ? o.detail : [])
			})
		}

		function r(s) {
			e.dispatch(t, s, Ds(arguments, 1))
		}
		return i && i.event.on(Jb, e.destroy), fh(e, {
			bus: t,
			on: n,
			off: Ne(e.unbind, t),
			emit: r
		})
	}

	function nd(i, t, e, n) {
		var r = Date.now,
			s, a = 0,
			o, h = !0,
			c = 0;

		function u() {
			if (!h) {
				if (a = i ? Ps((r() - s) / i, 1) : 1, e && e(a), a >= 1 && (t(), s = r(), n && ++c >= n)) return p();
				o = Ab(u)
			}
		}

		function g(f) {
			f || b(), s = r() - (f ? a * i : 0), h = !1, o = Ab(u)
		}

		function p() {
			h = !0
		}

		function _() {
			s = r(), a = 0, e && e(a)
		}

		function b() {
			o && cancelAnimationFrame(o), a = 0, o = 0, h = !0
		}

		function y(f) {
			i = f
		}

		function w() {
			return h
		}
		return {
			start: g,
			rewind: _,
			pause: p,
			cancel: b,
			set: y,
			isPaused: w
		}
	}

	function W2(i) {
		var t = i;

		function e(r) {
			t = r
		}

		function n(r) {
			return Jm(xh(r), t)
		}
		return {
			set: e,
			is: n
		}
	}

	function $2(i, t) {
		var e = nd(t || 0, i, null, 1);
		return function () {
			e.isPaused() && e.start()
		}
	}

	function q2(i, t, e) {
		var n = i.state,
			r = e.breakpoints || {},
			s = e.reducedMotion || {},
			a = Kb(),
			o = [];

		function h() {
			var b = e.mediaQuery === "min";
			ph(r).sort(function (y, w) {
				return b ? +y - +w : +w - +y
			}).forEach(function (y) {
				u(r[y], "(" + (b ? "min" : "max") + "-width:" + y + "px)")
			}), u(s, Pb), g()
		}

		function c(b) {
			b && a.destroy()
		}

		function u(b, y) {
			var w = matchMedia(y);
			a.bind(w, "change", g), o.push([b, w])
		}

		function g() {
			var b = n.is(Ju),
				y = e.direction,
				w = o.reduce(function (f, S) {
					return Cs(f, S[1].matches ? S[0] : {})
				}, {});
			Db(e), _(w), e.destroy ? i.destroy(e.destroy === "completely") : b ? (c(!0), i.mount()) : y !== e.direction && i.refresh()
		}

		function p(b) {
			matchMedia(Pb).matches && (b ? Cs(e, s) : Db(e, ph(s)))
		}

		function _(b, y, w) {
			Cs(e, b), y && Cs(Object.getPrototypeOf(e), b), (w || !n.is(Go)) && i.emit(nn, e)
		}
		return {
			setup: h,
			destroy: c,
			reduce: p,
			set: _
		}
	}
	var rd = "Arrow",
		sd = rd + "Left",
		ad = rd + "Right",
		sx = rd + "Up",
		ax = rd + "Down";
	var Rb = "rtl",
		od = "ttb",
		Bm = {
			width: ["height"],
			left: ["top", "right"],
			right: ["bottom", "left"],
			x: ["y"],
			X: ["Y"],
			Y: ["X"],
			ArrowLeft: [sx, ad],
			ArrowRight: [ax, sd]
		};

	function j2(i, t, e) {
		function n(s, a, o) {
			o = o || e.direction;
			var h = o === Rb && !a ? 1 : o === od ? 0 : -1;
			return Bm[s] && Bm[s][h] || s.replace(/width|left|right/i, function (c, u) {
				var g = Bm[c.toLowerCase()][h] || c;
				return u > 0 ? g.charAt(0).toUpperCase() + g.slice(1) : g
			})
		}

		function r(s) {
			return s * (e.direction === Rb ? 1 : -1)
		}
		return {
			resolve: n,
			orient: r
		}
	}
	var Hr = "role",
		Wo = "tabindex",
		X2 = "disabled",
		Wn = "aria-",
		Ch = Wn + "controls",
		ox = Wn + "current",
		Fb = Wn + "selected",
		Tn = Wn + "label",
		sv = Wn + "labelledby",
		lx = Wn + "hidden",
		av = Wn + "orientation",
		_h = Wn + "roledescription",
		Ob = Wn + "live",
		Nb = Wn + "busy",
		Vb = Wn + "atomic",
		ov = [Hr, Wo, X2, Ch, ox, Tn, sv, lx, av, _h],
		ur = Eh + "__",
		Is = "is-",
		Um = Eh,
		zb = ur + "track",
		Y2 = ur + "list",
		ld = ur + "slide",
		hx = ld + "--clone",
		K2 = ld + "__container",
		lv = ur + "arrows",
		hd = ur + "arrow",
		cx = hd + "--prev",
		ux = hd + "--next",
		cd = ur + "pagination",
		dx = cd + "__page",
		Z2 = ur + "progress",
		J2 = Z2 + "__bar",
		hv = ur + "toggle",
		n3 = hv + "__play",
		r3 = hv + "__pause",
		Q2 = ur + "spinner",
		tI = ur + "sr",
		eI = Is + "initialized",
		Ia = Is + "active",
		px = Is + "prev",
		fx = Is + "next",
		Xm = Is + "visible",
		Ym = Is + "loading",
		mx = Is + "focus-in",
		vx = Is + "overflow",
		iI = [Ia, Xm, px, fx, Ym, mx, vx],
		nI = {
			slide: ld,
			clone: hx,
			arrows: lv,
			arrow: hd,
			prev: cx,
			next: ux,
			pagination: cd,
			page: dx,
			spinner: Q2
		};

	function rI(i, t) {
		if (Hb(i.closest)) return i.closest(t);
		for (var e = i; e && e.nodeType === 1 && !dh(e, t);) e = e.parentElement;
		return e
	}
	var sI = 5,
		Bb = 200,
		gx = "touchstart mousedown",
		Gm = "touchmove mousemove",
		Hm = "touchend touchcancel mouseup click";

	function aI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.bind,
			a = i.root,
			o = e.i18n,
			h = {},
			c = [],
			u = [],
			g = [],
			p, _, b;

		function y() {
			x(), M(), S()
		}

		function w() {
			r(hi, f), r(hi, y), r(nn, S), s(document, gx + " keydown", function (L) {
				b = L.type === "keydown"
			}, {
				capture: !0
			}), s(a, "focusin", function () {
				Ur(a, mx, !!b)
			})
		}

		function f(L) {
			var F = ov.concat("style");
			Wr(c), Gr(a, u), Gr(p, g), cr([p, _], F), cr(a, L ? F : ["style", _h])
		}

		function S() {
			Gr(a, u), Gr(p, g), u = I(Um), g = I(zb), hr(a, u), hr(p, g), oe(a, Tn, e.label), oe(a, sv, e.labelledby)
		}

		function x() {
			p = T("." + zb), _ = Sh(p, "." + Y2), hh(p && _, "A track/list element is missing."), Yu(c, $b(_, "." + ld + ":not(." + hx + ")")), Aa({
				arrows: lv,
				pagination: cd,
				prev: cx,
				next: ux,
				bar: J2,
				toggle: hv
			}, function (L, F) {
				h[F] = T("." + L)
			}), fh(h, {
				root: a,
				track: p,
				list: _,
				slides: c
			})
		}

		function M() {
			var L = a.id || D2(Eh),
				F = e.role;
			a.id = L, p.id = p.id || L + "-track", _.id = _.id || L + "-list", !Hn(a, Hr) && a.tagName !== "SECTION" && F && oe(a, Hr, F), oe(a, _h, o.carousel), oe(_, Hr, "presentation")
		}

		function T(L) {
			var F = Xb(a, L);
			return F && rI(F, "." + Um) === a ? F : void 0
		}

		function I(L) {
			return [L + "--" + e.type, L + "--" + e.direction, e.drag && L + "--draggable", e.isNavigation && L + "--nav", L === Um && Ia]
		}
		return fh(h, {
			setup: y,
			mount: w,
			destroy: f
		})
	}
	var qo = "slide",
		Yo = "loop",
		Th = "fade";

	function oI(i, t, e, n) {
		var r = We(i),
			s = r.on,
			a = r.emit,
			o = r.bind,
			h = i.Components,
			c = i.root,
			u = i.options,
			g = u.isNavigation,
			p = u.updateOnMove,
			_ = u.i18n,
			b = u.pagination,
			y = u.slideFocus,
			w = h.Direction.resolve,
			f = Hn(n, "style"),
			S = Hn(n, Tn),
			x = e > -1,
			M = Sh(n, "." + K2),
			T;

		function I() {
			x || (n.id = c.id + "-slide" + iv(t + 1), oe(n, Hr, b ? "tabpanel" : "group"), oe(n, _h, _.slide), oe(n, Tn, S || jm(_.slideLabel, [t + 1, i.length]))), L()
		}

		function L() {
			o(n, "click", Ne(a, Zb, A)), o(n, "keydown", Ne(a, nx, A)), s([Mh, rx, Xo], j), s(Qb, k), p && s(As, G)
		}

		function F() {
			T = !0, r.destroy(), Gr(n, iI), cr(n, ov), oe(n, "style", f), oe(n, Tn, S || "")
		}

		function k() {
			var D = i.splides.map(function (H) {
				var q = H.splide.Components.Slides.getAt(t);
				return q ? q.slide.id : ""
			}).join(" ");
			oe(n, Tn, jm(_.slideX, (x ? e : t) + 1)), oe(n, Ch, D), oe(n, Hr, y ? "button" : ""), y && cr(n, _h)
		}

		function G() {
			T || j()
		}

		function j() {
			if (!T) {
				var D = i.index;
				U(), z(), Ur(n, px, t === D - 1), Ur(n, fx, t === D + 1)
			}
		}

		function U() {
			var D = W();
			D !== Ib(n, Ia) && (Ur(n, Ia, D), oe(n, ox, g && D || ""), a(D ? I2 : L2, A))
		}

		function z() {
			var D = O(),
				H = !D && (!W() || x);
			if (i.state.is([jo, yh]) || oe(n, lx, H || ""), oe(tv(n, u.focusableNodes || ""), Wo, H ? -1 : ""), y && oe(n, Wo, H ? -1 : 0), D !== Ib(n, Xm) && (Ur(n, Xm, D), a(D ? k2 : R2, A)), !D && document.activeElement === n) {
				var q = h.Slides.getAt(i.index);
				q && qb(q.slide)
			}
		}

		function $(D, H, q) {
			Gn(q && M || n, D, H)
		}

		function W() {
			var D = i.index;
			return D === t || u.cloneStatus && D === e
		}

		function O() {
			if (i.is(Th)) return W();
			var D = Cn(h.Elements.track),
				H = Cn(n),
				q = w("left", !0),
				Q = w("right", !0);
			return td(D[q]) <= vh(H[q]) && td(H[Q]) <= vh(D[Q])
		}

		function B(D, H) {
			var q = en(D - t);
			return !x && (u.rewind || i.is(Yo)) && (q = Ps(q, i.length - q)), q <= H
		}
		var A = {
			index: t,
			slideIndex: e,
			slide: n,
			container: M,
			isClone: x,
			mount: I,
			destroy: F,
			update: j,
			style: $,
			isWithin: B
		};
		return A
	}

	function lI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = n.bind,
			o = t.Elements,
			h = o.slides,
			c = o.list,
			u = [];

		function g() {
			p(), r(hi, _), r(hi, p)
		}

		function p() {
			h.forEach(function (j, U) {
				y(j, U, -1)
			})
		}

		function _() {
			T(function (j) {
				j.destroy()
			}), Wr(u)
		}

		function b() {
			T(function (j) {
				j.update()
			})
		}

		function y(j, U, z) {
			var $ = oI(i, U, z, j);
			$.mount(), u.push($), u.sort(function (W, O) {
				return W.index - O.index
			})
		}

		function w(j) {
			return j ? I(function (U) {
				return !U.isClone
			}) : u
		}

		function f(j) {
			var U = t.Controller,
				z = U.toIndex(j),
				$ = U.hasFocus() ? 1 : e.perPage;
			return I(function (W) {
				return Ku(W.index, z, z + $ - 1)
			})
		}

		function S(j) {
			return I(j)[0]
		}

		function x(j, U) {
			Pn(j, function (z) {
				if (Ts(z) && (z = jb(z)), Wb(z)) {
					var $ = h[U];
					$ ? Qm(z, $) : wh(c, z), hr(z, e.classes.slide), F(z, Ne(s, gh))
				}
			}), s(hi)
		}

		function M(j) {
			Da(I(j).map(function (U) {
				return U.slide
			})), s(hi)
		}

		function T(j, U) {
			w(U).forEach(j)
		}

		function I(j) {
			return u.filter(Hb(j) ? j : function (U) {
				return Ts(j) ? dh(U.slide, j) : Jm(xh(j), U.index)
			})
		}

		function L(j, U, z) {
			T(function ($) {
				$.style(j, U, z)
			})
		}

		function F(j, U) {
			var z = tv(j, "img"),
				$ = z.length;
			$ ? z.forEach(function (W) {
				a(W, "load error", function () {
					--$ || U()
				})
			}) : U()
		}

		function k(j) {
			return j ? h.length : u.length
		}

		function G() {
			return u.length > e.perPage
		}
		return {
			mount: g,
			destroy: _,
			update: b,
			register: y,
			get: w,
			getIn: f,
			getAt: S,
			add: x,
			remove: M,
			forEach: T,
			filter: I,
			style: L,
			getLength: k,
			isEnough: G
		}
	}

	function hI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.bind,
			a = n.emit,
			o = t.Slides,
			h = t.Direction.resolve,
			c = t.Elements,
			u = c.root,
			g = c.track,
			p = c.list,
			_ = o.getAt,
			b = o.style,
			y, w, f;

		function S() {
			x(), s(window, "resize load", $2(Ne(a, gh))), r([nn, hi], x), r(gh, M)
		}

		function x() {
			y = e.direction === od, Gn(u, "maxWidth", Pa(e.width)), Gn(g, h("paddingLeft"), T(!1)), Gn(g, h("paddingRight"), T(!0)), M(!0)
		}

		function M(A) {
			var D = Cn(u);
			(A || w.width !== D.width || w.height !== D.height) && (Gn(g, "height", I()), b(h("marginRight"), Pa(e.gap)), b("width", F()), b("height", k(), !0), w = D, a(nv), f !== (f = B()) && (Ur(u, vx, f), a(V2, f)))
		}

		function T(A) {
			var D = e.padding,
				H = h(A ? "right" : "left");
			return D && Pa(D[H] || (uh(D) ? 0 : D)) || "0px"
		}

		function I() {
			var A = "";
			return y && (A = L(), hh(A, "height or heightRatio is missing."), A = "calc(" + A + " - " + T(!1) + " - " + T(!0) + ")"), A
		}

		function L() {
			return Pa(e.height || Cn(p).width * e.heightRatio)
		}

		function F() {
			return e.autoWidth ? null : Pa(e.fixedWidth) || (y ? "" : G())
		}

		function k() {
			return Pa(e.fixedHeight) || (y ? e.autoHeight ? null : G() : L())
		}

		function G() {
			var A = Pa(e.gap);
			return "calc((100%" + (A && " + " + A) + ")/" + (e.perPage || 1) + (A && " - " + A) + ")"
		}

		function j() {
			return Cn(p)[h("width")]
		}

		function U(A, D) {
			var H = _(A || 0);
			return H ? Cn(H.slide)[h("width")] + (D ? 0 : W()) : 0
		}

		function z(A, D) {
			var H = _(A);
			if (H) {
				var q = Cn(H.slide)[h("right")],
					Q = Cn(p)[h("left")];
				return en(q - Q) + (D ? 0 : W())
			}
			return 0
		}

		function $(A) {
			return z(i.length - 1) - z(0) + U(0, A)
		}

		function W() {
			var A = _(0);
			return A && parseFloat(Gn(A.slide, h("marginRight"))) || 0
		}

		function O(A) {
			return parseFloat(Gn(g, h("padding" + (A ? "Right" : "Left")))) || 0
		}

		function B() {
			return i.is(Th) || $(!0) > j()
		}
		return {
			mount: S,
			resize: M,
			listSize: j,
			slideSize: U,
			sliderSize: $,
			totalSize: z,
			getPadding: O,
			isOverflow: B
		}
	}
	var cI = 2;

	function uI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = t.Elements,
			a = t.Slides,
			o = t.Direction.resolve,
			h = [],
			c;

		function u() {
			r(hi, g), r([nn, gh], _), (c = w()) && (b(c), t.Layout.resize(!0))
		}

		function g() {
			p(), u()
		}

		function p() {
			Da(h), Wr(h), n.destroy()
		}

		function _() {
			var f = w();
			c !== f && (c < f || !f) && n.emit(hi)
		}

		function b(f) {
			var S = a.get().slice(),
				x = S.length;
			if (x) {
				for (; S.length < f;) Yu(S, S);
				Yu(S.slice(-f), S.slice(0, f)).forEach(function (M, T) {
					var I = T < f,
						L = y(M.slide, T);
					I ? Qm(L, S[0].slide) : wh(s.list, L), Yu(h, L), a.register(L, T - f + (I ? 0 : x), M.index)
				})
			}
		}

		function y(f, S) {
			var x = f.cloneNode(!0);
			return hr(x, e.classes.clone), x.id = i.root.id + "-clone" + iv(S + 1), x
		}

		function w() {
			var f = e.clones;
			if (!i.is(Yo)) f = 0;
			else if (bh(f)) {
				var S = e[o("fixedWidth")] && t.Layout.slideSize(0),
					x = S && vh(Cn(s.track)[o("width")] / S);
				f = x || e[o("autoWidth")] && i.length || e.perPage * cI
			}
			return f
		}
		return {
			mount: u,
			destroy: p
		}
	}

	function dI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = i.state.set,
			o = t.Layout,
			h = o.slideSize,
			c = o.getPadding,
			u = o.totalSize,
			g = o.listSize,
			p = o.sliderSize,
			_ = t.Direction,
			b = _.resolve,
			y = _.orient,
			w = t.Elements,
			f = w.list,
			S = w.track,
			x;

		function M() {
			x = t.Transition, r([La, nv, nn, hi], T)
		}

		function T() {
			t.Controller.isBusy() || (t.Scroll.cancel(), L(i.index), t.Slides.update())
		}

		function I(H, q, Q, tt) {
			H !== q && A(H > Q) && (j(), F(G($(), H > Q), !0)), a(jo), s(As, q, Q, H), x.start(q, function () {
				a($o), s(Mh, q, Q, H), tt && tt()
			})
		}

		function L(H) {
			F(z(H, !0))
		}

		function F(H, q) {
			if (!i.is(Th)) {
				var Q = q ? H : k(H);
				Gn(f, "transform", "translate" + b("X") + "(" + Q + "px)"), H !== Q && s(rx)
			}
		}

		function k(H) {
			if (i.is(Yo)) {
				var q = U(H),
					Q = q > t.Controller.getEnd(),
					tt = q < 0;
				(tt || Q) && (H = G(H, Q))
			}
			return H
		}

		function G(H, q) {
			var Q = H - B(q),
				tt = p();
			return H -= y(tt * (vh(en(Q) / tt) || 1)) * (q ? 1 : -1), H
		}

		function j() {
			F($(), !0), x.cancel()
		}

		function U(H) {
			for (var q = t.Slides.get(), Q = 0, tt = 1 / 0, nt = 0; nt < q.length; nt++) {
				var ut = q[nt].index,
					et = en(z(ut, !0) - H);
				if (et <= tt) tt = et, Q = ut;
				else break
			}
			return Q
		}

		function z(H, q) {
			var Q = y(u(H - 1) - O(H));
			return q ? W(Q) : Q
		}

		function $() {
			var H = b("left");
			return Cn(f)[H] - Cn(S)[H] + y(c(!1))
		}

		function W(H) {
			return e.trimSpace && i.is(qo) && (H = Bo(H, 0, y(p(!0) - g()))), H
		}

		function O(H) {
			var q = e.focus;
			return q === "center" ? (g() - h(H, !0)) / 2 : +q * h(H) || 0
		}

		function B(H) {
			return z(H ? t.Controller.getEnd() : 0, !!e.trimSpace)
		}

		function A(H) {
			var q = y(G($(), H));
			return H ? q >= 0 : q <= f[b("scrollWidth")] - Cn(S)[b("width")]
		}

		function D(H, q) {
			q = bh(q) ? $() : q;
			var Q = H !== !0 && y(q) < y(B(!1)),
				tt = H !== !1 && y(q) > y(B(!0));
			return Q || tt
		}
		return {
			mount: M,
			move: I,
			jump: L,
			translate: F,
			shift: G,
			cancel: j,
			toIndex: U,
			toPosition: z,
			getPosition: $,
			getLimit: B,
			exceededLimit: D,
			reposition: T
		}
	}

	function pI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = t.Move,
			o = a.getPosition,
			h = a.getLimit,
			c = a.toPosition,
			u = t.Slides,
			g = u.isEnough,
			p = u.getLength,
			_ = e.omitEnd,
			b = i.is(Yo),
			y = i.is(qo),
			w = Ne($, !1),
			f = Ne($, !0),
			S = e.start || 0,
			x, M = S,
			T, I, L;

		function F() {
			k(), r([nn, hi, ed], k), r(nv, G)
		}

		function k() {
			T = p(!0), I = e.perMove, L = e.perPage, x = A();
			var et = Bo(S, 0, _ ? x : T - 1);
			et !== S && (S = et, a.reposition())
		}

		function G() {
			x !== A() && s(ed)
		}

		function j(et, it, Et) {
			if (!ut()) {
				var wt = z(et),
					yt = B(wt);
				yt > -1 && (it || yt !== S) && (Q(yt), a.move(wt, yt, M, Et))
			}
		}

		function U(et, it, Et, wt) {
			t.Scroll.scroll(et, it, Et, function () {
				var yt = B(a.toIndex(o()));
				Q(_ ? Ps(yt, x) : yt), wt && wt()
			})
		}

		function z(et) {
			var it = S;
			if (Ts(et)) {
				var Et = et.match(/([+\-<>])(\d+)?/) || [],
					wt = Et[1],
					yt = Et[2];
				wt === "+" || wt === "-" ? it = W(S + +("" + wt + (+yt || 1)), S) : wt === ">" ? it = yt ? D(+yt) : w(!0) : wt === "<" && (it = f(!0))
			} else it = b ? et : Bo(et, 0, x);
			return it
		}

		function $(et, it) {
			var Et = I || (nt() ? 1 : L),
				wt = W(S + Et * (et ? -1 : 1), S, !(I || nt()));
			return wt === -1 && y && !Yb(o(), h(!et), 1) ? et ? 0 : x : it ? wt : B(wt)
		}

		function W(et, it, Et) {
			if (g() || nt()) {
				var wt = O(et);
				wt !== et && (it = et, et = wt, Et = !1), et < 0 || et > x ? !I && (Ku(0, et, it, !0) || Ku(x, it, et, !0)) ? et = D(H(et)) : b ? et = Et ? et < 0 ? -(T % L || L) : T : et : e.rewind ? et = et < 0 ? x : 0 : et = -1 : Et && et !== it && (et = D(H(it) + (et < it ? -1 : 1)))
			} else et = -1;
			return et
		}

		function O(et) {
			if (y && e.trimSpace === "move" && et !== S)
				for (var it = o(); it === c(et, !0) && Ku(et, 0, i.length - 1, !e.rewind);) et < S ? --et : ++et;
			return et
		}

		function B(et) {
			return b ? (et + T) % T || 0 : et
		}

		function A() {
			for (var et = T - (nt() || b && I ? 1 : L); _ && et-- > 0;)
				if (c(T - 1, !0) !== c(et, !0)) {
					et++;
					break
				} return Bo(et, 0, T - 1)
		}

		function D(et) {
			return Bo(nt() ? et : L * et, 0, x)
		}

		function H(et) {
			return nt() ? Ps(et, x) : td((et >= x ? T - 1 : et) / L)
		}

		function q(et) {
			var it = a.toIndex(et);
			return y ? Bo(it, 0, x) : it
		}

		function Q(et) {
			et !== S && (M = S, S = et)
		}

		function tt(et) {
			return et ? M : S
		}

		function nt() {
			return !bh(e.focus) || e.isNavigation
		}

		function ut() {
			return i.state.is([jo, yh]) && !!e.waitForTransition
		}
		return {
			mount: F,
			go: j,
			scroll: U,
			getNext: w,
			getPrev: f,
			getAdjacent: $,
			getEnd: A,
			setIndex: Q,
			getIndex: tt,
			toIndex: D,
			toPage: H,
			toDest: q,
			hasFocus: nt,
			isBusy: ut
		}
	}
	var fI = "http://www.w3.org/2000/svg",
		mI = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z",
		ju = 40;

	function vI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.bind,
			a = n.emit,
			o = e.classes,
			h = e.i18n,
			c = t.Elements,
			u = t.Controller,
			g = c.arrows,
			p = c.track,
			_ = g,
			b = c.prev,
			y = c.next,
			w, f, S = {};

		function x() {
			T(), r(nn, M)
		}

		function M() {
			I(), x()
		}

		function T() {
			var U = e.arrows;
			U && !(b && y) && k(), b && y && (fh(S, {
				prev: b,
				next: y
			}), mh(_, U ? "" : "none"), hr(_, f = lv + "--" + e.direction), U && (L(), j(), oe([b, y], Ch, p.id), a(z2, b, y)))
		}

		function I() {
			n.destroy(), Gr(_, f), w ? (Da(g ? [b, y] : _), b = y = null) : cr([b, y], ov)
		}

		function L() {
			r([La, Mh, hi, Xo, ed], j), s(y, "click", Ne(F, ">")), s(b, "click", Ne(F, "<"))
		}

		function F(U) {
			u.go(U, !0)
		}

		function k() {
			_ = g || Ho("div", o.arrows), b = G(!0), y = G(!1), w = !0, wh(_, [b, y]), !g && Qm(_, p)
		}

		function G(U) {
			var z = '<button class="' + o.arrow + " " + (U ? o.prev : o.next) + '" type="button"><svg xmlns="' + fI + '" viewBox="0 0 ' + ju + " " + ju + '" width="' + ju + '" height="' + ju + '" focusable="false"><path d="' + (e.arrowPath || mI) + '" />';
			return jb(z)
		}

		function j() {
			if (b && y) {
				var U = i.index,
					z = u.getPrev(),
					$ = u.getNext(),
					W = z > -1 && U < z ? h.last : h.prev,
					O = $ > -1 && U > $ ? h.first : h.next;
				b.disabled = z < 0, y.disabled = $ < 0, oe(b, Tn, W), oe(y, Tn, O), a(B2, b, y, z, $)
			}
		}
		return {
			arrows: S,
			mount: x,
			destroy: I,
			update: j
		}
	}
	var gI = ev + "-interval";

	function _I(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.bind,
			a = n.emit,
			o = nd(e.interval, i.go.bind(i, ">"), L),
			h = o.isPaused,
			c = t.Elements,
			u = t.Elements,
			g = u.root,
			p = u.toggle,
			_ = e.autoplay,
			b, y, w = _ === "pause";

		function f() {
			_ && (S(), p && oe(p, Ch, c.track.id), w || x(), I())
		}

		function S() {
			e.pauseOnHover && s(g, "mouseenter mouseleave", function (k) {
				b = k.type === "mouseenter", T()
			}), e.pauseOnFocus && s(g, "focusin focusout", function (k) {
				y = k.type === "focusin", T()
			}), p && s(p, "click", function () {
				w ? x() : M(!0)
			}), r([As, rv, hi], o.rewind), r(As, F)
		}

		function x() {
			h() && t.Slides.isEnough() && (o.start(!e.resetProgress), y = b = w = !1, I(), a(tx))
		}

		function M(k) {
			k === void 0 && (k = !0), w = !!k, I(), h() || (o.pause(), a(ex))
		}

		function T() {
			w || (b || y ? M(!1) : x())
		}

		function I() {
			p && (Ur(p, Ia, !w), oe(p, Tn, e.i18n[w ? "play" : "pause"]))
		}

		function L(k) {
			var G = c.bar;
			G && Gn(G, "width", k * 100 + "%"), a(H2, k)
		}

		function F(k) {
			var G = t.Slides.getAt(k);
			o.set(G && +Hn(G.slide, gI) || e.interval)
		}
		return {
			mount: f,
			destroy: o.cancel,
			play: x,
			pause: M,
			isPaused: h
		}
	}

	function yI(i, t, e) {
		var n = We(i),
			r = n.on;

		function s() {
			e.cover && (r(ix, Ne(o, !0)), r([La, nn, hi], Ne(a, !0)))
		}

		function a(h) {
			t.Slides.forEach(function (c) {
				var u = Sh(c.container || c.slide, "img");
				u && u.src && o(h, u, c)
			})
		}

		function o(h, c, u) {
			u.style("background", h ? 'center/cover no-repeat url("' + c.src + '")' : "", !0), mh(c, h ? "none" : "")
		}
		return {
			mount: s,
			destroy: Ne(a, !1)
		}
	}
	var bI = 10,
		xI = 600,
		wI = .6,
		SI = 1.5,
		EI = 800;

	function MI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = i.state.set,
			o = t.Move,
			h = o.getPosition,
			c = o.getLimit,
			u = o.exceededLimit,
			g = o.translate,
			p = i.is(qo),
			_, b, y = 1;

		function w() {
			r(As, M), r([nn, hi], T)
		}

		function f(L, F, k, G, j) {
			var U = h();
			if (M(), k && (!p || !u())) {
				var z = t.Layout.sliderSize(),
					$ = qm(L) * z * td(en(L) / z) || 0;
				L = o.toPosition(t.Controller.toDest(L % z)) + $
			}
			var W = Yb(U, L, 1);
			y = 1, F = W ? 0 : F || Qu(en(L - U) / SI, EI), b = G, _ = nd(F, S, Ne(x, U, L, j), 1), a(yh), s(rv), _.start()
		}

		function S() {
			a($o), b && b(), s(Xo)
		}

		function x(L, F, k, G) {
			var j = h(),
				U = L + (F - L) * I(G),
				z = (U - j) * y;
			g(j + z), p && !k && u() && (y *= wI, en(z) < bI && f(c(u(!0)), xI, !1, b, !0))
		}

		function M() {
			_ && _.cancel()
		}

		function T() {
			_ && !_.isPaused() && (M(), S())
		}

		function I(L) {
			var F = e.easingFunc;
			return F ? F(L) : 1 - Math.pow(1 - L, 4)
		}
		return {
			mount: w,
			destroy: M,
			scroll: f,
			cancel: T
		}
	}
	var Uo = {
		passive: !1,
		capture: !0
	};

	function CI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = n.bind,
			o = n.unbind,
			h = i.state,
			c = t.Move,
			u = t.Scroll,
			g = t.Controller,
			p = t.Elements.track,
			_ = t.Media.reduce,
			b = t.Direction,
			y = b.resolve,
			w = b.orient,
			f = c.getPosition,
			S = c.exceededLimit,
			x, M, T, I, L, F = !1,
			k, G, j;

		function U() {
			a(p, Gm, Wm, Uo), a(p, Hm, Wm, Uo), a(p, gx, $, Uo), a(p, "click", B, {
				capture: !0
			}), a(p, "dragstart", Br), r([La, nn], z)
		}

		function z() {
			var lt = e.drag;
			Vt(!lt), I = lt === "free"
		}

		function $(lt) {
			if (k = !1, !G) {
				var dt = yt(lt);
				wt(lt.target) && (dt || !lt.button) && (g.isBusy() ? Br(lt, !0) : (j = dt ? p : window, L = h.is([jo, yh]), T = null, a(j, Gm, W, Uo), a(j, Hm, O, Uo), c.cancel(), u.cancel(), A(lt)))
			}
		}

		function W(lt) {
			if (h.is(Xu) || (h.set(Xu), s(F2)), lt.cancelable)
				if (L) {
					c.translate(x + Et(nt(lt)));
					var dt = ut(lt) > Bb,
						qt = F !== (F = S());
					(dt || qt) && A(lt), k = !0, s(O2), Br(lt)
				} else q(lt) && (L = H(lt), Br(lt))
		}

		function O(lt) {
			h.is(Xu) && (h.set($o), s(N2)), L && (D(lt), Br(lt)), o(j, Gm, W), o(j, Hm, O), L = !1
		}

		function B(lt) {
			!G && k && Br(lt, !0)
		}

		function A(lt) {
			T = M, M = lt, x = f()
		}

		function D(lt) {
			var dt = Q(lt),
				qt = tt(dt),
				Zt = e.rewind && e.rewindByDrag;
			_(!1), I ? g.scroll(qt, 0, e.snap) : i.is(Th) ? g.go(w(qm(dt)) < 0 ? Zt ? "<" : "-" : Zt ? ">" : "+") : i.is(qo) && F && Zt ? g.go(S(!0) ? ">" : "<") : g.go(g.toDest(qt), !0), _(!0)
		}

		function H(lt) {
			var dt = e.dragMinThreshold,
				qt = uh(dt),
				Zt = qt && dt.mouse || 0,
				re = (qt ? dt.touch : +dt) || 10;
			return en(nt(lt)) > (yt(lt) ? re : Zt)
		}

		function q(lt) {
			return en(nt(lt)) > en(nt(lt, !0))
		}

		function Q(lt) {
			if (i.is(Yo) || !F) {
				var dt = ut(lt);
				if (dt && dt < Bb) return nt(lt) / dt
			}
			return 0
		}

		function tt(lt) {
			return f() + qm(lt) * Ps(en(lt) * (e.flickPower || 600), I ? 1 / 0 : t.Layout.listSize() * (e.flickMaxPages || 1))
		}

		function nt(lt, dt) {
			return it(lt, dt) - it(et(lt), dt)
		}

		function ut(lt) {
			return $m(lt) - $m(et(lt))
		}

		function et(lt) {
			return M === lt && T || M
		}

		function it(lt, dt) {
			return (yt(lt) ? lt.changedTouches[0] : lt)["page" + y(dt ? "Y" : "X")]
		}

		function Et(lt) {
			return lt / (F && i.is(qo) ? sI : 1)
		}

		function wt(lt) {
			var dt = e.noDrag;
			return !dh(lt, "." + dx + ", ." + hd) && (!dt || !dh(lt, dt))
		}

		function yt(lt) {
			return typeof TouchEvent != "undefined" && lt instanceof TouchEvent
		}

		function At() {
			return L
		}

		function Vt(lt) {
			G = lt
		}
		return {
			mount: U,
			disable: Vt,
			isDragging: At
		}
	}
	var TI = {
		Spacebar: " ",
		Right: ad,
		Left: sd,
		Up: sx,
		Down: ax
	};

	function cv(i) {
		return i = Ts(i) ? i : i.key, TI[i] || i
	}
	var Ub = "keydown";

	function PI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.bind,
			a = n.unbind,
			o = i.root,
			h = t.Direction.resolve,
			c, u;

		function g() {
			p(), r(nn, _), r(nn, p), r(As, y)
		}

		function p() {
			var f = e.keyboard;
			f && (c = f === "global" ? window : o, s(c, Ub, w))
		}

		function _() {
			a(c, Ub)
		}

		function b(f) {
			u = f
		}

		function y() {
			var f = u;
			u = !0, Gb(function () {
				u = f
			})
		}

		function w(f) {
			if (!u) {
				var S = cv(f);
				S === h(sd) ? i.go("<") : S === h(ad) && i.go(">")
			}
		}
		return {
			mount: g,
			destroy: _,
			disable: b
		}
	}
	var ch = ev + "-lazy",
		Zu = ch + "-srcset",
		AI = "[" + ch + "], [" + Zu + "]";

	function DI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.off,
			a = n.bind,
			o = n.emit,
			h = e.lazyLoad === "sequential",
			c = [Mh, Xo],
			u = [];

		function g() {
			e.lazyLoad && (p(), r(hi, p))
		}

		function p() {
			Wr(u), _(), h ? f() : (s(c), r(c, b), b())
		}

		function _() {
			t.Slides.forEach(function (S) {
				tv(S.slide, AI).forEach(function (x) {
					var M = Hn(x, ch),
						T = Hn(x, Zu);
					if (M !== x.src || T !== x.srcset) {
						var I = e.classes.spinner,
							L = x.parentElement,
							F = Sh(L, "." + I) || Ho("span", I, L);
						u.push([x, S, F]), x.src || mh(x, "none")
					}
				})
			})
		}

		function b() {
			u = u.filter(function (S) {
				var x = e.perPage * ((e.preloadPages || 1) + 1) - 1;
				return S[1].isWithin(i.index, x) ? y(S) : !0
			}), u.length || s(c)
		}

		function y(S) {
			var x = S[0];
			hr(S[1].slide, Ym), a(x, "load error", Ne(w, S)), oe(x, "src", Hn(x, ch)), oe(x, "srcset", Hn(x, Zu)), cr(x, ch), cr(x, Zu)
		}

		function w(S, x) {
			var M = S[0],
				T = S[1];
			Gr(T.slide, Ym), x.type !== "error" && (Da(S[2]), mh(M, ""), o(ix, M, T), o(gh)), h && f()
		}

		function f() {
			u.length && y(u.shift())
		}
		return {
			mount: g,
			destroy: Ne(Wr, u),
			check: b
		}
	}

	function II(i, t, e) {
		var n = We(i),
			r = n.on,
			s = n.emit,
			a = n.bind,
			o = t.Slides,
			h = t.Elements,
			c = t.Controller,
			u = c.hasFocus,
			g = c.getIndex,
			p = c.go,
			_ = t.Direction.resolve,
			b = h.pagination,
			y = [],
			w, f;

		function S() {
			x(), r([nn, hi, ed], S);
			var G = e.pagination;
			b && mh(b, G ? "" : "none"), G && (r([As, rv, Xo], k), M(), k(), s(U2, {
				list: w,
				items: y
			}, F(i.index)))
		}

		function x() {
			w && (Da(b ? Ds(w.children) : w), Gr(w, f), Wr(y), w = null), n.destroy()
		}

		function M() {
			var G = i.length,
				j = e.classes,
				U = e.i18n,
				z = e.perPage,
				$ = u() ? c.getEnd() + 1 : vh(G / z);
			w = b || Ho("ul", j.pagination, h.track.parentElement), hr(w, f = cd + "--" + L()), oe(w, Hr, "tablist"), oe(w, Tn, U.select), oe(w, av, L() === od ? "vertical" : "");
			for (var W = 0; W < $; W++) {
				var O = Ho("li", null, w),
					B = Ho("button", {
						class: j.page,
						type: "button"
					}, O),
					A = o.getIn(W).map(function (H) {
						return H.slide.id
					}),
					D = !u() && z > 1 ? U.pageX : U.slideX;
				a(B, "click", Ne(T, W)), e.paginationKeyboard && a(B, "keydown", Ne(I, W)), oe(O, Hr, "presentation"), oe(B, Hr, "tab"), oe(B, Ch, A.join(" ")), oe(B, Tn, jm(D, W + 1)), oe(B, Wo, -1), y.push({
					li: O,
					button: B,
					page: W
				})
			}
		}

		function T(G) {
			p(">" + G, !0)
		}

		function I(G, j) {
			var U = y.length,
				z = cv(j),
				$ = L(),
				W = -1;
			z === _(ad, !1, $) ? W = ++G % U : z === _(sd, !1, $) ? W = (--G + U) % U : z === "Home" ? W = 0 : z === "End" && (W = U - 1);
			var O = y[W];
			O && (qb(O.button), p(">" + W), Br(j, !0))
		}

		function L() {
			return e.paginationDirection || e.direction
		}

		function F(G) {
			return y[c.toPage(G)]
		}

		function k() {
			var G = F(g(!0)),
				j = F(g());
			if (G) {
				var U = G.button;
				Gr(U, Ia), cr(U, Fb), oe(U, Wo, -1)
			}
			if (j) {
				var z = j.button;
				hr(z, Ia), oe(z, Fb, !0), oe(z, Wo, "")
			}
			s(G2, {
				list: w,
				items: y
			}, G, j)
		}
		return {
			items: y,
			mount: S,
			destroy: x,
			getAt: F,
			update: k
		}
	}
	var LI = [" ", "Enter"];

	function kI(i, t, e) {
		var n = e.isNavigation,
			r = e.slideFocus,
			s = [];

		function a() {
			i.splides.forEach(function (b) {
				b.isParent || (c(i, b.splide), c(b.splide, i))
			}), n && u()
		}

		function o() {
			s.forEach(function (b) {
				b.destroy()
			}), Wr(s)
		}

		function h() {
			o(), a()
		}

		function c(b, y) {
			var w = We(b);
			w.on(As, function (f, S, x) {
				y.go(y.is(Yo) ? x : f)
			}), s.push(w)
		}

		function u() {
			var b = We(i),
				y = b.on;
			y(Zb, p), y(nx, _), y([La, nn], g), s.push(b), b.emit(Qb, i.splides)
		}

		function g() {
			oe(t.Elements.list, av, e.direction === od ? "vertical" : "")
		}

		function p(b) {
			i.go(b.index)
		}

		function _(b, y) {
			Jm(LI, cv(y)) && (p(b), Br(y))
		}
		return {
			setup: Ne(t.Media.set, {
				slideFocus: bh(r) ? n : r
			}, !0),
			mount: a,
			destroy: o,
			remount: h
		}
	}

	function RI(i, t, e) {
		var n = We(i),
			r = n.bind,
			s = 0;

		function a() {
			e.wheel && r(t.Elements.track, "wheel", o, Uo)
		}

		function o(c) {
			if (c.cancelable) {
				var u = c.deltaY,
					g = u < 0,
					p = $m(c),
					_ = e.wheelMinThreshold || 0,
					b = e.wheelSleep || 0;
				en(u) > _ && p - s > b && (i.go(g ? "<" : ">"), s = p), h(g) && Br(c)
			}
		}

		function h(c) {
			return !e.releaseWheel || i.state.is(jo) || t.Controller.getAdjacent(c) !== -1
		}
		return {
			mount: a
		}
	}
	var FI = 90;

	function OI(i, t, e) {
		var n = We(i),
			r = n.on,
			s = t.Elements.track,
			a = e.live && !e.isNavigation,
			o = Ho("span", tI),
			h = nd(FI, Ne(u, !1));

		function c() {
			a && (p(!t.Autoplay.isPaused()), oe(s, Vb, !0), o.textContent = "\u2026", r(tx, Ne(p, !0)), r(ex, Ne(p, !1)), r([Mh, Xo], Ne(u, !0)))
		}

		function u(_) {
			oe(s, Nb, _), _ ? (wh(s, o), h.start()) : (Da(o), h.cancel())
		}

		function g() {
			cr(s, [Ob, Vb, Nb]), Da(o)
		}

		function p(_) {
			a && oe(s, Ob, _ ? "off" : "polite")
		}
		return {
			mount: c,
			disable: p,
			destroy: g
		}
	}
	var NI = Object.freeze({
			__proto__: null,
			Media: q2,
			Direction: j2,
			Elements: aI,
			Slides: lI,
			Layout: hI,
			Clones: uI,
			Move: dI,
			Controller: pI,
			Arrows: vI,
			Autoplay: _I,
			Cover: yI,
			Scroll: MI,
			Drag: CI,
			Keyboard: PI,
			LazyLoad: DI,
			Pagination: II,
			Sync: kI,
			Wheel: RI,
			Live: OI
		}),
		VI = {
			prev: "Previous slide",
			next: "Next slide",
			first: "Go to first slide",
			last: "Go to last slide",
			slideX: "Go to slide %s",
			pageX: "Go to page %s",
			play: "Start autoplay",
			pause: "Pause autoplay",
			carousel: "carousel",
			slide: "slide",
			select: "Select a slide to show",
			slideLabel: "%s of %s"
		},
		zI = {
			type: "slide",
			role: "region",
			speed: 400,
			perPage: 1,
			cloneStatus: !0,
			arrows: !0,
			pagination: !0,
			paginationKeyboard: !0,
			interval: 5e3,
			pauseOnHover: !0,
			pauseOnFocus: !0,
			resetProgress: !0,
			easing: "cubic-bezier(0.25, 1, 0.5, 1)",
			drag: !0,
			direction: "ltr",
			trimSpace: !0,
			focusableNodes: "a, button, textarea, input, select, iframe",
			live: !0,
			classes: nI,
			i18n: VI,
			reducedMotion: {
				speed: 0,
				rewindSpeed: 0,
				autoplay: "pause"
			}
		};

	function BI(i, t, e) {
		var n = t.Slides;

		function r() {
			We(i).on([La, hi], s)
		}

		function s() {
			n.forEach(function (o) {
				o.style("transform", "translateX(-" + 100 * o.index + "%)")
			})
		}

		function a(o, h) {
			n.style("transition", "opacity " + e.speed + "ms " + e.easing), Gb(h)
		}
		return {
			mount: r,
			start: a,
			cancel: Wm
		}
	}

	function UI(i, t, e) {
		var n = t.Move,
			r = t.Controller,
			s = t.Scroll,
			a = t.Elements.list,
			o = Ne(Gn, a, "transition"),
			h;

		function c() {
			We(i).bind(a, "transitionend", function (_) {
				_.target === a && h && (g(), h())
			})
		}

		function u(_, b) {
			var y = n.toPosition(_, !0),
				w = n.getPosition(),
				f = p(_);
			en(y - w) >= 1 && f >= 1 ? e.useScroll ? s.scroll(y, f, !1, b) : (o("transform " + f + "ms " + e.easing), n.translate(y, !0), h = b) : (n.jump(_), b())
		}

		function g() {
			o(""), s.cancel()
		}

		function p(_) {
			var b = e.rewindSpeed;
			if (i.is(qo) && b) {
				var y = r.getIndex(!0),
					w = r.getEnd();
				if (y === 0 && _ >= w || y >= w && _ === 0) return b
			}
			return e.speed
		}
		return {
			mount: c,
			start: u,
			cancel: g
		}
	}
	var GI = function () {
			function i(e, n) {
				this.event = We(), this.Components = {}, this.state = W2(Go), this.splides = [], this._o = {}, this._E = {};
				var r = Ts(e) ? Xb(document, e) : e;
				hh(r, r + " is invalid."), this.root = r, n = Cs({
					label: Hn(r, Tn) || "",
					labelledby: Hn(r, sv) || ""
				}, zI, i.defaults, n || {});
				try {
					Cs(n, JSON.parse(Hn(r, ev)))
				} catch (s) {
					hh(!1, "Invalid JSON")
				}
				this._o = Object.create(Cs({}, n))
			}
			var t = i.prototype;
			return t.mount = function (n, r) {
				var s = this,
					a = this.state,
					o = this.Components;
				hh(a.is([Go, Ju]), "Already mounted!"), a.set(Go), this._C = o, this._T = r || this._T || (this.is(Th) ? BI : UI), this._E = n || this._E;
				var h = fh({}, NI, this._E, {
					Transition: this._T
				});
				return Aa(h, function (c, u) {
					var g = c(s, o, s._o);
					o[u] = g, g.setup && g.setup()
				}), Aa(o, function (c) {
					c.mount && c.mount()
				}), this.emit(La), hr(this.root, eI), a.set($o), this.emit(kb), this
			}, t.sync = function (n) {
				return this.splides.push({
					splide: n
				}), n.splides.push({
					splide: this,
					isParent: !0
				}), this.state.is($o) && (this._C.Sync.remount(), n.Components.Sync.remount()), this
			}, t.go = function (n) {
				return this._C.Controller.go(n), this
			}, t.on = function (n, r) {
				return this.event.on(n, r), this
			}, t.off = function (n) {
				return this.event.off(n), this
			}, t.emit = function (n) {
				var r;
				return (r = this.event).emit.apply(r, [n].concat(Ds(arguments, 1))), this
			}, t.add = function (n, r) {
				return this._C.Slides.add(n, r), this
			}, t.remove = function (n) {
				return this._C.Slides.remove(n), this
			}, t.is = function (n) {
				return this._o.type === n
			}, t.refresh = function () {
				return this.emit(hi), this
			}, t.destroy = function (n) {
				n === void 0 && (n = !0);
				var r = this.event,
					s = this.state;
				return s.is(Go) ? We(this).on(kb, this.destroy.bind(this, n)) : (Aa(this._C, function (a) {
					a.destroy && a.destroy(n)
				}, !0), r.emit(Jb), r.destroy(), n && Wr(this.splides), s.set(Ju)), this
			}, T2(i, [{
				key: "options",
				get: function () {
					return this._o
				},
				set: function (n) {
					this._C.Media.set(n, !0, !0)
				}
			}, {
				key: "length",
				get: function () {
					return this._C.Slides.getLength(!0)
				}
			}, {
				key: "index",
				get: function () {
					return this._C.Controller.getIndex()
				}
			}]), i
		}(),
		$r = GI;
	$r.defaults = {};
	$r.STATES = A2;
	var ka = class extends pe {
		static get settings() {
			return {
				MOBILE_BREAKPOINT: 700
			}
		}
		constructor(t) {
			var e, n;
			super(t), this.$el = this.el, this.$prev = this.$("prev")[0], this.$next = this.$("next")[0], this.$sliderMain = this.$("sliderMain")[0], this.$sliderPrev = (e = this.$("sliderPrev")) == null ? void 0 : e[0], this.$sliderNext = (n = this.$("sliderNext")) == null ? void 0 : n[0], this.breakpoint = window.matchMedia(`(min-width: ${ka.settings.MOBILE_BREAKPOINT}px)`), this.TOTAL_SLIDES = this.getData("slides-count"), this.options = {
				arrows: !1,
				autoWidth: !0,
				drag: !1,
				pagination: !1,
				speed: ie.REDUCED_MOTION ? 0 : 700,
				type: "loop"
			}, this.onBreakPointChangeBind = this.onBreakPointChange.bind(this), this.events = {
				click: {
					prev: "prev",
					next: "next",
					sliderPrev: "prev",
					sliderNext: "next"
				}
			}
		}
		init() {
			this.bindEvents(), this.onBreakPointChange()
		}
		onBreakPointChange() {
			var t, e, n;
			(t = this.swiper) == null || t.destroy(), (e = this.swiperPrev) == null || e.destroy(), (n = this.swiperNext) == null || n.destroy(), this.breakpoint.matches === !0 && this.$sliderPrev && this.$sliderNext ? (this.splidePrev = new $r(this.$sliderPrev, qa(gn({}, this.options), {
				start: this.TOTAL_SLIDES - 1
			})).mount(), this.splide = new $r(this.$sliderMain, qa(gn({}, this.options), {
				start: 0
			})).mount(), this.splideNext = new $r(this.$sliderNext, qa(gn({}, this.options), {
				start: 1
			})).mount()) : this.breakpoint.matches === !1 && (this.splide = new $r(this.$sliderMain, qa(gn({}, this.options), {
				gap: "var(--grid-gutter)",
				padding: "var(--grid-margin)"
			})).mount())
		}
		prev() {
			var t, e, n;
			(t = this.splide) == null || t.go("<"), (e = this.splidePrev) == null || e.go("<"), (n = this.splideNext) == null || n.go("<")
		}
		next() {
			var t, e, n;
			(t = this.splide) == null || t.go(">"), (e = this.splidePrev) == null || e.go(">"), (n = this.splideNext) == null || n.go(">")
		}
		bindEvents() {
			"addEventListener" in this.breakpoint ? this.breakpoint.addEventListener("change", this.onBreakPointChangeBind) : "addListener" in this.breakpoint && this.breakpoint.addListener(this.onBreakPointChangeBind)
		}
		unbindEvents() {
			"removeEventListener" in this.breakpoint ? this.breakpoint.removeEventListener("change", this.onBreakPointChangeBind) : "removeListener" in this.breakpoint && this.breakpoint.removeListener(this.onBreakPointChangeBind)
		}
		destroy() {
			var t, e, n;
			this.unbindEvents(), (t = this.splide) == null || t.destroy(), (e = this.splidePrev) == null || e.destroy(), (n = this.splideNext) == null || n.destroy(), super.destroy()
		}
	};
	var _x = (i, t) => String(i).padStart(t, "0");
	var Ph = class extends pe {
		constructor(t) {
			super(t), this.$el = this.el, this.$slider = this.$("slider")[0], this.$activeIndex = this.$("activeIndex")[0]
		}
		init() {
			this.splide = new $r(this.$el, {
				autoWidth: !0,
				drag: !1,
				pagination: !1,
				speed: 0,
				type: "loop"
			}), this.splide.mount(), this.splide.on("move", t => {
				let e = t + 1;
				this.$activeIndex.innerHTML = _x(e, 2)
			})
		}
		destroy() {
			var t;
			super.destroy(), (t = this.splide) == null || t.destroy()
		}
	};
	var dr = class extends pe {
		static get settings() {
			return {
				PAGINATION: 12
			}
		}
		constructor(t) {
			super(t), this.$el = this.el, this.$loadMore = Array.from(this.$("loadMore")), this.$list = this.$("list")[0], this.$members = Array.from(this.$("member")), this.membersCount = this.$members.length, this.paginationIndex = 0, ne.set(this.$members, {
				display: "none"
			}), this.events = {
				click: {
					loadMore: "show"
				},
				change: {
					order: "sort"
				}
			}
		}
		init() {
			this.show(!1)
		}
		show(t = !0) {
			this.paginationIndex++;
			let e = this.$members.slice((this.paginationIndex - 1) * dr.settings.PAGINATION, this.paginationIndex * dr.settings.PAGINATION);
			this.paginationIndex * dr.settings.PAGINATION >= this.membersCount ? ne.set(this.$loadMore, {
				opacity: 0
			}) : ne.set(this.$loadMore, {
				opacity: 1
			}), ne.set(e, {
				clearProps: "all"
			}), ne.from(e, {
				opacity: 0,
				yPercent: 10,
				stagger: .1,
				ease: "power2.out",
				duration: .5,
				onStart: () => {
					var n, r, s;
					t !== !1 && ((s = (r = (n = Array.from(this.$list.children)[(this.paginationIndex - 1) * dr.settings.PAGINATION]) == null ? void 0 : n.querySelector("button")) == null ? void 0 : r.focus) == null || s.call(r, {
						focusVisible: !0
					}))
				}
			})
		}
		sort(t) {
			let e = t.curTarget.value;
			this.call("scrollTo", {
				target: this.$el
			}, "Scroll"), ne.to(this.$members, {
				opacity: 0,
				yPercent: 10,
				stagger: .02,
				ease: "power2.in",
				duration: .25,
				onComplete: () => {
					ne.set(this.$members, {
						display: "none"
					}), e === "ASC" ? this.$members.sort((n, r) => n.dataset.name < r.dataset.name ? -1 : n.dataset.name > r.dataset.name ? 1 : 0) : e === "DESC" && this.$members.sort((n, r) => r.dataset.name < n.dataset.name ? -1 : r.dataset.name > n.dataset.name ? 1 : 0);
					for (let n of this.$members) this.$list.appendChild(n);
					this.paginationIndex = 0, this.show()
				}
			})
		}
		destroy() {}
	};
	var Ex = yl(bx(), 1);
	var dd;
	Di(void 0, null, function* () {
		if (ie.IS_DEV) {
			let i = yield Promise.resolve().then(() => (Sx(), wx));
			dd = i == null ? void 0 : i.gridHelper
		}
	});

	function Mx() {
		(0, Ex.default)(), dd == null || dd(), kc()
	}
	var Cx = (i, t, e = !1) => {
		let n = null;
		return (...r) => {
			clearTimeout(n);
			let s = () => {
				n = null, e || i(...r)
			};
			e && !n && i(...r), n = setTimeout(s, t)
		}
	};
	var Tx = new sg({
		modules: uv
	});
	window.onload = () => {
		let i = document.getElementById("main-css");
		i ? i.isLoaded ? Px() : i.addEventListener("load", () => {
			Px()
		}) : console.warn('The "main-css" stylesheet not found')
	};

	function Px() {
		Mx(), Tx.init(Tx);
		let i = () => {
			Xi.style.setProperty("--vw", `${di.window.width*.01}px`)
		};
		i();
		let t = () => {
			Xi.style.setProperty("--vh", `${di.window.height*.01}px`)
		};
		ie.IS_MOBILE && t(), ie.REDUCED_MOTION && Xi.classList.add(ti.REDUCED_MOTION), window.addEventListener("resize", () => {
			di.window.width = window.innerWidth, i(), ie.IS_DESKTOP && (di.window.height = window.innerHeight)
		});
		let e = new CustomEvent(Ce.RESIZE_END);
		window.addEventListener("resize", Cx(() => {
			window.dispatchEvent(e)
		}, 200, !1));
		let n = new Promise(s => {
				setTimeout(() => {
					s()
				}, 3e3)
			}),
			r = new Promise(s => {
				lg ? cg(Yn.EAGER, ie.IS_DEV).then(a => {
					Xi.classList.add(ti.FONTS_LOADED), ie.IS_DEV && (console.group("Eager fonts loaded!", a.length, "/", document.fonts.size), console.group("State of eager fonts:"), a.forEach(o => console.log(o == null ? void 0 : o.family, o == null ? void 0 : o.style, o == null ? void 0 : o.weight, o == null ? void 0 : o.status)), console.groupEnd(), console.group("State of all fonts:"), document.fonts.forEach(o => console.log(o == null ? void 0 : o.family, o == null ? void 0 : o.style, o == null ? void 0 : o.weight, o == null ? void 0 : o.status)), console.groupEnd()), s()
				}) : s()
			});
		Promise.all([n, r]).then(() => {
			Xi.classList.add(ti.LOADED), Xi.classList.add(ti.READY), Xi.classList.remove(ti.LOADING), window.dispatchEvent(new CustomEvent(Ce.READY))
		})
	}
})();
/*! Bundled license information:

lottie-web/build/player/lottie.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)

tweakpane/dist/tweakpane.js:
  (*! Tweakpane 3.1.10 (c) 2016 cocopon, licensed under the MIT license. *)

svg4everybody/dist/svg4everybody.js:
  (*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.2
   * https://greensock.com
   *
   * @license Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.2
   * https://greensock.com
   *
   * Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/utils/strings.js:
  (*!
   * strings: 3.12.2
   * https://greensock.com
   *
   * Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/SplitText.js:
  (*!
   * SplitText: 3.12.2
   * https://greensock.com
   *
   * @license Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

vanilla-cookieconsent/dist/cookieconsent.esm.js:
  (*!
  * CookieConsent 3.0.0
  * https://github.com/orestbida/cookieconsent/tree/v3
  * Author Orest Bida
  * Released under the MIT License
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

@splidejs/splide/dist/js/splide.esm.js:
  (*!
   * Splide.js
   * Version  : 4.1.4
   * License  : MIT
   * Copyright: 2022 Naotoshi Fujita
   *)
*/
//# sourceMappingURL=app.js.map